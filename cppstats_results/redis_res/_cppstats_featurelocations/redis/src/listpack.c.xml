<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/results/redis_res/_cppstats_featurelocations/redis/src/listpack.c">


































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"listpack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"listpack_malloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"redisassert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_HDR_SIZE</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_HDR_NUMELE_UNKNOWN</name></cpp:macro> <cpp:value>UINT16_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_MAX_INT_ENCODING_LEN</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_MAX_BACKLEN_SIZE</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_MAX_ENTRY_BACKLEN</name></cpp:macro> <cpp:value>34359738367ULL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_INT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_STRING</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_7BIT_UINT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_7BIT_UINT_MASK</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_7BIT_UINT</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_7BIT_UINT_MASK)==LP_ENCODING_7BIT_UINT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_7BIT_UINT_ENTRY_SIZE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_6BIT_STR</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_6BIT_STR_MASK</name></cpp:macro> <cpp:value>0xC0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_6BIT_STR</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_6BIT_STR_MASK)==LP_ENCODING_6BIT_STR)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_13BIT_INT</name></cpp:macro> <cpp:value>0xC0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_13BIT_INT_MASK</name></cpp:macro> <cpp:value>0xE0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_13BIT_INT</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_13BIT_INT_MASK)==LP_ENCODING_13BIT_INT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_13BIT_INT_ENTRY_SIZE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_12BIT_STR</name></cpp:macro> <cpp:value>0xE0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_12BIT_STR_MASK</name></cpp:macro> <cpp:value>0xF0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_12BIT_STR</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_12BIT_STR_MASK)==LP_ENCODING_12BIT_STR)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_16BIT_INT</name></cpp:macro> <cpp:value>0xF1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_16BIT_INT_MASK</name></cpp:macro> <cpp:value>0xFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_16BIT_INT</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_16BIT_INT_MASK)==LP_ENCODING_16BIT_INT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_16BIT_INT_ENTRY_SIZE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_24BIT_INT</name></cpp:macro> <cpp:value>0xF2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_24BIT_INT_MASK</name></cpp:macro> <cpp:value>0xFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_24BIT_INT</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_24BIT_INT_MASK)==LP_ENCODING_24BIT_INT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_24BIT_INT_ENTRY_SIZE</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_32BIT_INT</name></cpp:macro> <cpp:value>0xF3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_32BIT_INT_MASK</name></cpp:macro> <cpp:value>0xFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_32BIT_INT</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_32BIT_INT_MASK)==LP_ENCODING_32BIT_INT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_32BIT_INT_ENTRY_SIZE</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_64BIT_INT</name></cpp:macro> <cpp:value>0xF4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_64BIT_INT_MASK</name></cpp:macro> <cpp:value>0xFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_64BIT_INT</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_64BIT_INT_MASK)==LP_ENCODING_64BIT_INT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_64BIT_INT_ENTRY_SIZE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_32BIT_STR</name></cpp:macro> <cpp:value>0xF0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_32BIT_STR_MASK</name></cpp:macro> <cpp:value>0xFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_IS_32BIT_STR</name><parameter_list>(<parameter><type><name>byte</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((byte)&amp;LP_ENCODING_32BIT_STR_MASK)==LP_ENCODING_32BIT_STR)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_EOF</name></cpp:macro> <cpp:value>0xFF</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_6BIT_STR_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((p)[0] &amp; 0x3F)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_12BIT_STR_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((p)[0] &amp; 0xF) &lt;&lt; 8) | (p)[1])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LP_ENCODING_32BIT_STR_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((uint32_t)(p)[1]&lt;&lt;0) | ((uint32_t)(p)[2]&lt;&lt;8) | ((uint32_t)(p)[3]&lt;&lt;16) | ((uint32_t)(p)[4]&lt;&lt;24))</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lpGetTotalBytes</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((uint32_t)(p)[0]&lt;&lt;0) | ((uint32_t)(p)[1]&lt;&lt;8) | ((uint32_t)(p)[2]&lt;&lt;16) | ((uint32_t)(p)[3]&lt;&lt;24))</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lpGetNumElements</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((uint32_t)(p)[4]&lt;&lt;0) | ((uint32_t)(p)[5]&lt;&lt;8))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lpSetTotalBytes</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (p)[0] = (v)&amp;0xff; (p)[1] = ((v)&gt;&gt;8)&amp;0xff; (p)[2] = ((v)&gt;&gt;16)&amp;0xff; (p)[3] = ((v)&gt;&gt;24)&amp;0xff; } while(0)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lpSetNumElements</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (p)[4] = (v)&amp;0xff; (p)[5] = ((v)&gt;&gt;8)&amp;0xff; } while(0)</cpp:value></cpp:define>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_INTEGRITY</name><parameter_list>(<parameter><type><name>lp</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert((p) &gt;= (lp)+LP_HDR_SIZE &amp;&amp; (p) &lt; (lp)+lpGetTotalBytes((lp))); } while (0)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT_INTEGRITY_LEN</name><parameter_list>(<parameter><type><name>lp</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert((p) &gt;= (lp)+LP_HDR_SIZE &amp;&amp; (p)+(len) &lt; (lp)+lpGetTotalBytes((lp))); } while (0)</cpp:value></cpp:define>



<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>lpAssertValidEntry</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>lp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>lpbytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LISTPACK_MAX_SAFETY_SIZE</name></cpp:macro> <cpp:value>(1&lt;&lt;30)</cpp:value></cpp:define>
<function><type><name>int</name></type> <name>lpSafeToAdd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>lp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>add</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><ternary><condition><expr><name>lp</name></expr>?</condition><then> <expr><call><name>lpGetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <name>add</name> <operator>&gt;</operator> <name>LISTPACK_MAX_SAFETY_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

























<function><type><name>int</name></type> <name>lpStringToInt64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>slen</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>plen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>negative</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>plen</name> <operator>==</operator> <name>slen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>negative</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>plen</name><operator>++</operator></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>plen</name> <operator>==</operator> <name>slen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>plen</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>

<while>while <condition>(<expr><name>plen</name> <operator>&lt;</operator> <name>slen</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <operator>(</operator><name>UINT64_MAX</name> <operator>/</operator> <literal type="number">10</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>v</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <operator>(</operator><name>UINT64_MAX</name> <operator>-</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>v</name> <operator>+=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-</operator><literal type="char">'0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>plen</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name>plen</name> <operator>&lt;</operator> <name>slen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>negative</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><operator>-</operator><operator>(</operator><name>INT64_MIN</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>-</operator><name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <name>INT64_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>






<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpNew</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>capacity</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><call><name>lp_malloc</name><argument_list>(<argument><expr><ternary><condition><expr><name>capacity</name> <operator>&gt;</operator> <name>LP_HDR_SIZE</name><operator>+</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><name>capacity</name></expr> </then><else>: <expr><name>LP_HDR_SIZE</name><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lpSetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>LP_HDR_SIZE</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpSetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><index>[<expr><name>LP_HDR_SIZE</name></expr>]</index></name> <operator>=</operator> <name>LP_EOF</name></expr>;</expr_stmt>
<return>return <expr><name>lp</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>lpFree</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>lp_free</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>lpShrinkToFit</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>lpGetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <call><name>lp_malloc_size</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>lp_realloc</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><name>lp</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>lpEncodeIntegerGetType</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>intenc</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>enclen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;=</operator> <literal type="number">127</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">4096</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;=</operator> <literal type="number">4095</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">13</literal><operator>)</operator><operator>+</operator><name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>|</operator><name>LP_ENCODING_13BIT_INT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">32768</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;=</operator> <literal type="number">32767</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">16</literal><operator>)</operator><operator>+</operator><name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>LP_ENCODING_16BIT_INT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">8388608</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;=</operator> <literal type="number">8388607</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">24</literal><operator>)</operator><operator>+</operator><name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>LP_ENCODING_24BIT_INT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&gt;&gt;</operator><literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">2147483648</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;=</operator> <literal type="number">2147483647</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator><operator>+</operator><name>v</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>LP_ENCODING_32BIT_INT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>v</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>v</name><operator>&gt;&gt;</operator><literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>uv</name> <init>= <expr><name>v</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>LP_ENCODING_64BIT_INT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>uv</name><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uv</name><operator>&gt;&gt;</operator><literal type="number">8</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uv</name><operator>&gt;&gt;</operator><literal type="number">16</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uv</name><operator>&gt;&gt;</operator><literal type="number">24</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uv</name><operator>&gt;&gt;</operator><literal type="number">32</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uv</name><operator>&gt;&gt;</operator><literal type="number">40</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uv</name><operator>&gt;&gt;</operator><literal type="number">48</literal><operator>)</operator><operator>&amp;</operator><literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>intenc</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name>uv</name><operator>&gt;&gt;</operator><literal type="number">56</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>












<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>lpEncodeGetType</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>intenc</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>enclen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>v</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>lpStringToInt64</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>ele</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lpEncodeIntegerGetType</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>intenc</name></expr></argument>, <argument><expr><name>enclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>LP_ENCODING_INT</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">1</literal><operator>+</operator><name>size</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">4096</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">2</literal><operator>+</operator><name>size</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>enclen</name> <operator>=</operator> <literal type="number">5</literal><operator>+</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name>size</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>LP_ENCODING_STRING</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>long</name></type> <name>lpEncodeBacklen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;=</operator> <literal type="number">127</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>l</name> <operator>&lt;</operator> <literal type="number">16383</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l</name><operator>&gt;&gt;</operator><literal type="number">7</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>l</name><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>l</name> <operator>&lt;</operator> <literal type="number">2097151</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l</name><operator>&gt;&gt;</operator><literal type="number">14</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">7</literal><operator>)</operator><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>l</name><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">3</literal></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>l</name> <operator>&lt;</operator> <literal type="number">268435455</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l</name><operator>&gt;&gt;</operator><literal type="number">21</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">14</literal><operator>)</operator><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">7</literal><operator>)</operator><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>l</name><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">4</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>buf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>l</name><operator>&gt;&gt;</operator><literal type="number">28</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">21</literal><operator>)</operator><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">14</literal><operator>)</operator><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>l</name><operator>&gt;&gt;</operator><literal type="number">7</literal><operator>)</operator><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>l</name><operator>&amp;</operator><literal type="number">127</literal><operator>)</operator><operator>|</operator><literal type="number">128</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">5</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64_t</name></type> <name>lpDecodeBacklen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>shift</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">127</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name>shift</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">128</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>shift</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>shift</name> <operator>&gt;</operator> <literal type="number">28</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>UINT64_MAX</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block> while<condition>(<expr><literal type="number">1</literal></expr>)</condition>;</do>
<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>lpEncodeString</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>len</name> <operator>|</operator> <name>LP_ENCODING_6BIT_STR</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">4096</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name>LP_ENCODING_12BIT_STR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>len</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>LP_ENCODING_32BIT_STR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>len</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">5</literal></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32_t</name></type> <name>lpCurrentEncodedSizeUnsafe</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_7BIT_UINT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_6BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal><operator>+</operator><call><name>LP_ENCODING_6BIT_STR_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_13BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_16BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">3</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_24BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">4</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_32BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">5</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_64BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">9</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_12BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal><operator>+</operator><call><name>LP_ENCODING_12BIT_STR_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_32BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">5</literal><operator>+</operator><call><name>LP_ENCODING_32BIT_STR_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32_t</name></type> <name>lpCurrentEncodedSizeBytes</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_7BIT_UINT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_6BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_13BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_16BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_24BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_32BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_64BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_12BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_32BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">5</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpSkip</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>entrylen</name> <init>= <expr><call><name>lpCurrentEncodedSizeUnsafe</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>entrylen</name> <operator>+=</operator> <call><name>lpEncodeBacklen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>entrylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>entrylen</name></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpNext</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSkip</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lpAssertValidEntry</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpPrev</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name><operator>-</operator><name>lp</name> <operator>==</operator> <name>LP_HDR_SIZE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>prevlen</name> <init>= <expr><call><name>lpDecodeBacklen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>prevlen</name> <operator>+=</operator> <call><name>lpEncodeBacklen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>-=</operator> <name>prevlen</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpAssertValidEntry</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpFirst</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>lp</name> <operator>+</operator> <name>LP_HDR_SIZE</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lpAssertValidEntry</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpLast</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>lp</name><operator>+</operator><call><name>lpGetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>lpPrev</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>unsigned</name> <name>long</name></type> <name>lpLength</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>numele</name> <init>= <expr><call><name>lpGetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>numele</name> <operator>!=</operator> <name>LP_HDR_NUMELE_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>numele</name></expr>;</return></block_content></block></if></if_stmt>



<decl_stmt><decl><type><name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>



<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>LP_HDR_NUMELE_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>lpSetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>







































<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpGetWithSize</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>count</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>intbuf</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>entry_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>uval</name></decl>, <decl><type ref="prev"/><name>negstart</name></decl>, <decl><type ref="prev"/><name>negmax</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>LP_ENCODING_IS_7BIT_UINT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>negstart</name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name>negmax</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>uval</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry_size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>entry_size</name> <operator>=</operator> <name>LP_ENCODING_7BIT_UINT_ENTRY_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_6BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <call><name>LP_ENCODING_6BIT_STR_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry_size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>entry_size</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>*</operator><name>count</name> <operator>+</operator> <call><name>lpEncodeBacklen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>*</operator><name>count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_13BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uval</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>&amp;</operator><literal type="number">0x1f</literal><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>negstart</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">12</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>negmax</name> <operator>=</operator> <literal type="number">8191</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry_size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>entry_size</name> <operator>=</operator> <name>LP_ENCODING_13BIT_INT_ENTRY_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_16BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uval</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator>
<operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>negstart</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">15</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>negmax</name> <operator>=</operator> <name>UINT16_MAX</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry_size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>entry_size</name> <operator>=</operator> <name>LP_ENCODING_16BIT_INT_ENTRY_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_24BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uval</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator>
<operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal> <operator>|</operator>
<operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>negstart</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">23</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>negmax</name> <operator>=</operator> <name>UINT32_MAX</name><operator>&gt;&gt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry_size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>entry_size</name> <operator>=</operator> <name>LP_ENCODING_24BIT_INT_ENTRY_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_32BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uval</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator>
<operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal> <operator>|</operator>
<operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal> <operator>|</operator>
<operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>negstart</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">31</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>negmax</name> <operator>=</operator> <name>UINT32_MAX</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry_size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>entry_size</name> <operator>=</operator> <name>LP_ENCODING_32BIT_INT_ENTRY_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_64BIT_INT</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uval</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator>
<operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">8</literal> <operator>|</operator>
<operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">16</literal> <operator>|</operator>
<operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">24</literal> <operator>|</operator>
<operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">32</literal> <operator>|</operator>
<operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">6</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">40</literal> <operator>|</operator>
<operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">7</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">48</literal> <operator>|</operator>
<operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>p</name><index>[<expr><literal type="number">8</literal></expr>]</index></name><operator>&lt;&lt;</operator><literal type="number">56</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>negstart</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>negmax</name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry_size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>entry_size</name> <operator>=</operator> <name>LP_ENCODING_64BIT_INT_ENTRY_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_12BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <call><name>LP_ENCODING_12BIT_STR_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry_size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>entry_size</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <operator>*</operator><name>count</name> <operator>+</operator> <call><name>lpEncodeBacklen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>*</operator><name>count</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>p</name><operator>+</operator><literal type="number">2</literal></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>LP_ENCODING_IS_32BIT_STR</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <call><name>LP_ENCODING_32BIT_STR_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry_size</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>entry_size</name> <operator>=</operator> <literal type="number">5</literal> <operator>+</operator> <operator>*</operator><name>count</name> <operator>+</operator> <call><name>lpEncodeBacklen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>*</operator><name>count</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>p</name><operator>+</operator><literal type="number">5</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>uval</name> <operator>=</operator> <literal type="number">12345678900000000ULL</literal> <operator>+</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>negstart</name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name>negmax</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<if_stmt><if>if <condition>(<expr><name>uval</name> <operator>&gt;=</operator> <name>negstart</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>uval</name> <operator>=</operator> <name>negmax</name><operator>-</operator><name>uval</name></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>uval</name></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><name>val</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>uval</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<if_stmt><if>if <condition>(<expr><name>intbuf</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>intbuf</name></expr></argument>,<argument><expr><name>LP_INTBUF_SIZE</name></expr></argument>,<argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>intbuf</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpGet</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>count</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>intbuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>lpGetWithSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>intbuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpGetValue</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>slen</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name> <modifier>*</modifier></type><name>lval</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>ele_len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ele_len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vstr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>slen</name> <operator>=</operator> <name>ele_len</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>lval</name> <operator>=</operator> <name>ele_len</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>vstr</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpFind</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name></type> <name>slen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>skip</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>skipcnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>vencoding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>ll</name></decl>, <decl><type ref="prev"/><name>vll</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>entry_size</name> <init>= <expr><literal type="number">123456789</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>lp_bytes</name> <init>= <expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>skipcnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>lpGetWithSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ll</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>&gt;=</operator> <name>lp</name> <operator>+</operator> <name>LP_HDR_SIZE</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>+</operator> <name>entry_size</name> <operator>&lt;</operator> <name>lp</name> <operator>+</operator> <name>lp_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>==</operator> <name>ll</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>vencoding</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;=</operator> <literal type="number">32</literal> <operator>||</operator> <name>slen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>lpStringToInt64</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>s</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vll</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vencoding</name> <operator>=</operator> <name>UCHAR_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>vencoding</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>vencoding</name> <operator>!=</operator> <name>UCHAR_MAX</name> <operator>&amp;&amp;</operator> <name>ll</name> <operator>==</operator> <name>vll</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>skipcnt</name> <operator>=</operator> <name>skip</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>entry_size</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>skipcnt</name><operator>--</operator></expr>;</expr_stmt>



<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSkip</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <literal type="number">8</literal> <operator>&gt;=</operator> <name>lp</name> <operator>+</operator> <name>lp_bytes</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lpAssertValidEntry</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lp_bytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>&gt;=</operator> <name>lp</name> <operator>+</operator> <name>LP_HDR_SIZE</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&lt;</operator> <name>lp</name> <operator>+</operator> <name>lp_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>





























<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpInsert</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>elestr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eleint</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>intenc</name><index>[<expr><name>LP_MAX_INT_ENCODING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>backlen</name><index>[<expr><name>LP_MAX_BACKLEN_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>enclen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>delete</name> <init>= <expr><operator>(</operator><name>elestr</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>eleint</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name>delete</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>where</name> <operator>=</operator> <name>LP_REPLACE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name>LP_AFTER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSkip</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>where</name> <operator>=</operator> <name>LP_BEFORE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASSERT_INTEGRITY</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>poff</name> <init>= <expr><name>p</name><operator>-</operator><name>lp</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>enctype</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>elestr</name></expr>)</condition> <block>{<block_content>








<expr_stmt><expr><name>enctype</name> <operator>=</operator> <call><name>lpEncodeGetType</name><argument_list>(<argument><expr><name>elestr</name></expr></argument>,<argument><expr><name>size</name></expr></argument>,<argument><expr><name>intenc</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>enclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>enctype</name> <operator>==</operator> <name>LP_ENCODING_INT</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>eleint</name> <operator>=</operator> <name>intenc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>eleint</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>enctype</name> <operator>=</operator> <name>LP_ENCODING_INT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>enclen</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>enctype</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>enclen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>backlen_size</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>!</operator><name>delete</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>lpEncodeBacklen</name><argument_list>(<argument><expr><name>backlen</name></expr></argument>,<argument><expr><name>enclen</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>old_listpack_bytes</name> <init>= <expr><call><name>lpGetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>replaced_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name>LP_REPLACE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>replaced_len</name> <operator>=</operator> <call><name>lpCurrentEncodedSizeUnsafe</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>replaced_len</name> <operator>+=</operator> <call><name>lpEncodeBacklen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>replaced_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ASSERT_INTEGRITY_LEN</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>replaced_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>new_listpack_bytes</name> <init>= <expr><name>old_listpack_bytes</name> <operator>+</operator> <name>enclen</name> <operator>+</operator> <name>backlen_size</name>
<operator>-</operator> <name>replaced_len</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>new_listpack_bytes</name> <operator>&gt;</operator> <name>UINT32_MAX</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>







<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name>lp</name> <operator>+</operator> <name>poff</name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>new_listpack_bytes</name> <operator>&gt;</operator> <name>old_listpack_bytes</name> <operator>&amp;&amp;</operator>
<name>new_listpack_bytes</name> <operator>&gt;</operator> <call><name>lp_malloc_size</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp</name> <operator>=</operator> <call><name>lp_realloc</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>new_listpack_bytes</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <name>lp</name> <operator>+</operator> <name>poff</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name>LP_BEFORE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dst</name><operator>+</operator><name>enclen</name><operator>+</operator><name>backlen_size</name></expr></argument>,<argument><expr><name>dst</name></expr></argument>,<argument><expr><name>old_listpack_bytes</name><operator>-</operator><name>poff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>lendiff</name> <init>= <expr><operator>(</operator><name>enclen</name><operator>+</operator><name>backlen_size</name><operator>)</operator><operator>-</operator><name>replaced_len</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>dst</name><operator>+</operator><name>replaced_len</name><operator>+</operator><name>lendiff</name></expr></argument>,
<argument><expr><name>dst</name><operator>+</operator><name>replaced_len</name></expr></argument>,
<argument><expr><name>old_listpack_bytes</name><operator>-</operator><name>poff</name><operator>-</operator><name>replaced_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>new_listpack_bytes</name> <operator>&lt;</operator> <name>old_listpack_bytes</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp</name> <operator>=</operator> <call><name>lp_realloc</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>new_listpack_bytes</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dst</name> <operator>=</operator> <name>lp</name> <operator>+</operator> <name>poff</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>newp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>newp</name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>delete</name> <operator>&amp;&amp;</operator> <name><name>dst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>newp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>delete</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>enctype</name> <operator>==</operator> <name>LP_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name>eleint</name></expr></argument>,<argument><expr><name>enclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>lpEncodeString</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name>elestr</name></expr></argument>,<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>dst</name> <operator>+=</operator> <name>enclen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,<argument><expr><name>backlen</name></expr></argument>,<argument><expr><name>backlen_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dst</name> <operator>+=</operator> <name>backlen_size</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>where</name> <operator>!=</operator> <name>LP_REPLACE</name> <operator>||</operator> <name>delete</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>num_elements</name> <init>= <expr><call><name>lpGetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>num_elements</name> <operator>!=</operator> <name>LP_HDR_NUMELE_UNKNOWN</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>delete</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lpSetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>num_elements</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lpSetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>num_elements</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>lpSetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>new_listpack_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>






unsigned char *oldlp = lp;
lp = lp_malloc(new_listpack_bytes);
memcpy(lp,oldlp,new_listpack_bytes);
if (newp) {
unsigned long offset = (*newp)-oldlp;
*newp = lp + offset;
}

memset(oldlp,'A',new_listpack_bytes);
lp_free(oldlp);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>lp</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpInsertString</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>slen</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>lpInsert</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpInsertInteger</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name></type> <name>lval</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>enclen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>intenc</name><index>[<expr><name>LP_MAX_INT_ENCODING_LEN</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>lpEncodeIntegerGetType</name><argument_list>(<argument><expr><name>lval</name></expr></argument>, <argument><expr><name>intenc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>enclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>lpInsert</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>intenc</name></expr></argument>, <argument><expr><name>enclen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><name>newp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpPrepend</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>slen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>lpInsert</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>LP_BEFORE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpPrependInteger</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name></type> <name>lval</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>lpInsertInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>LP_BEFORE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpAppend</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>listpack_bytes</name> <init>= <expr><call><name>lpGetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eofptr</name> <init>= <expr><name>lp</name> <operator>+</operator> <name>listpack_bytes</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>lpInsert</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>size</name></expr></argument>,<argument><expr><name>eofptr</name></expr></argument>,<argument><expr><name>LP_BEFORE</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpAppendInteger</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name></type> <name>lval</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>listpack_bytes</name> <init>= <expr><call><name>lpGetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eofptr</name> <init>= <expr><name>lp</name> <operator>+</operator> <name>listpack_bytes</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>lpInsertInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><name>eofptr</name></expr></argument>, <argument><expr><name>LP_BEFORE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpReplace</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>slen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>lpInsert</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>LP_REPLACE</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpReplaceInteger</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name></type> <name>lval</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>lpInsertInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lval</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>LP_REPLACE</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpDelete</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>lpInsert</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>LP_REPLACE</name></expr></argument>,<argument><expr><name>newp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpDeleteRangeWithEntry</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>bytes</name> <init>= <expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eofptr</name> <init>= <expr><name>lp</name> <operator>+</operator> <name>bytes</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>first</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <name>tail</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>lp</name></expr>;</return></block_content></block></if></if_stmt>




<while>while <condition>(<expr><name>num</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>deleted</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>tail</name> <operator>=</operator> <call><name>lpSkip</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tail</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lpAssertValidEntry</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>



<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>poff</name> <init>= <expr><name>first</name><operator>-</operator><name>lp</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>, <argument><expr><name>eofptr</name> <operator>-</operator> <name>tail</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpSetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>bytes</name> <operator>-</operator> <operator>(</operator><name>tail</name> <operator>-</operator> <name>first</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>numele</name> <init>= <expr><call><name>lpGetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>numele</name> <operator>!=</operator> <name>LP_HDR_NUMELE_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lpSetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>numele</name><operator>-</operator><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpShrinkToFit</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>lp</name><operator>+</operator><name>poff</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>lp</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpDeleteRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>numele</name> <init>= <expr><call><name>lpGetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>lp</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>lp</name></expr>;</return></block_content></block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><name>numele</name> <operator>!=</operator> <name>LP_HDR_NUMELE_UNKNOWN</name> <operator>&amp;&amp;</operator> <name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>numele</name> <operator>+</operator> <name>index</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>numele</name> <operator>!=</operator> <name>LP_HDR_NUMELE_UNKNOWN</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>numele</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>index</name><operator>)</operator> <operator>&lt;=</operator> <name>num</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>LP_EOF</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpSetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>lp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpSetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpShrinkToFit</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRangeWithEntry</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>lp</name></expr>;</return>
</block_content>}</block></function>
















<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpMerge</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>first</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>second</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>first</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>first</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>second</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>second</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>first</name> <operator>==</operator> <operator>*</operator><name>second</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>first_bytes</name> <init>= <expr><call><name>lpBytes</name><argument_list>(<argument><expr><operator>*</operator><name>first</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>first_len</name> <init>= <expr><call><name>lpLength</name><argument_list>(<argument><expr><operator>*</operator><name>first</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>second_bytes</name> <init>= <expr><call><name>lpBytes</name><argument_list>(<argument><expr><operator>*</operator><name>second</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>second_len</name> <init>= <expr><call><name>lpLength</name><argument_list>(<argument><expr><operator>*</operator><name>second</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>append</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>source</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>target_bytes</name></decl>, <decl><type ref="prev"/><name>source_bytes</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>first_bytes</name> <operator>&gt;=</operator> <name>second_bytes</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>*</operator><name>first</name></expr>;</expr_stmt>
<expr_stmt><expr><name>target_bytes</name> <operator>=</operator> <name>first_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>source</name> <operator>=</operator> <operator>*</operator><name>second</name></expr>;</expr_stmt>
<expr_stmt><expr><name>source_bytes</name> <operator>=</operator> <name>second_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>append</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>*</operator><name>second</name></expr>;</expr_stmt>
<expr_stmt><expr><name>target_bytes</name> <operator>=</operator> <name>second_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>source</name> <operator>=</operator> <operator>*</operator><name>first</name></expr>;</expr_stmt>
<expr_stmt><expr><name>source_bytes</name> <operator>=</operator> <name>first_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>append</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>lpbytes</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name>first_bytes</name> <operator>+</operator> <name>second_bytes</name> <operator>-</operator> <name>LP_HDR_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lpbytes</name> <operator>&lt;</operator> <name>UINT32_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>lplength</name> <init>= <expr><name>first_len</name> <operator>+</operator> <name>second_len</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>lplength</name> <operator>=</operator> <ternary><condition><expr><name>lplength</name> <operator>&lt;</operator> <name>UINT16_MAX</name></expr> ?</condition><then> <expr><name>lplength</name></expr> </then><else>: <expr><name>UINT16_MAX</name></expr></else></ternary></expr>;</expr_stmt>


<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>lpbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>append</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>target</name> <operator>+</operator> <name>target_bytes</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>source</name> <operator>+</operator> <name>LP_HDR_SIZE</name></expr></argument>,
<argument><expr><name>source_bytes</name> <operator>-</operator> <name>LP_HDR_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>target</name> <operator>+</operator> <name>source_bytes</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>target</name> <operator>+</operator> <name>LP_HDR_SIZE</name></expr></argument>,
<argument><expr><name>target_bytes</name> <operator>-</operator> <name>LP_HDR_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>source_bytes</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>lpSetNumElements</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>lplength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpSetTotalBytes</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>lpbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>append</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><operator>*</operator><name>second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>second</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>first</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><operator>*</operator><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>first</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>second</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>target</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>lpBytes</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>lpGetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpSeek</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>forward</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><name>uint32_t</name></type> <name>numele</name> <init>= <expr><call><name>lpGetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>numele</name> <operator>!=</operator> <name>LP_HDR_NUMELE_UNKNOWN</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>numele</name><operator>+</operator><name>index</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>numele</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;</operator> <operator>(</operator><name>long</name><operator>)</operator><name>numele</name><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>forward</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>index</name> <operator>-=</operator> <name>numele</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>forward</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>forward</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>index</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ele</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>ele</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name> <init>= <expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>index</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>ele</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>ele</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lpValidateFirst</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>lp</name> <operator>+</operator> <name>LP_HDR_SIZE</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>lpValidateNext</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>lpbytes</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUT_OF_RANGE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>( (p) &lt; lp + LP_HDR_SIZE || (p) &gt; lp + lpbytes - 1)</cpp:value></cpp:define>


<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>OUT_OF_RANGE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name>uint32_t</name></type> <name>lenbytes</name> <init>= <expr><call><name>lpCurrentEncodedSizeBytes</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lenbytes</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>OUT_OF_RANGE</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>lenbytes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>entrylen</name> <init>= <expr><call><name>lpCurrentEncodedSizeUnsafe</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>encodedBacklen</name> <init>= <expr><call><name>lpEncodeBacklen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>entrylen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>entrylen</name> <operator>+=</operator> <name>encodedBacklen</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>OUT_OF_RANGE</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>entrylen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>entrylen</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>prevlen</name> <init>= <expr><call><name>lpDecodeBacklen</name><argument_list>(<argument><expr><name>p</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>prevlen</name> <operator>+</operator> <name>encodedBacklen</name> <operator>!=</operator> <name>entrylen</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OUT_OF_RANGE</name></cpp:undef>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>lpAssertValidEntry</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>lp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>lpbytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>lpbytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>lpValidateIntegrity</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deep</name></decl></parameter>,
<parameter><decl><type><name>listpackValidateEntryCB</name></type> <name>entry_cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_userdata</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>LP_HDR_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>bytes</name> <init>= <expr><call><name>lpGetTotalBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>!=</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>lp</name><index>[<expr><name>size</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>deep</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>numele</name> <init>= <expr><call><name>lpGetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>lp</name> <operator>+</operator> <name>LP_HDR_SIZE</name></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>LP_EOF</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>entry_cb</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>entry_cb</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>numele</name></expr></argument>, <argument><expr><name>cb_userdata</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>lp</name> <operator>+</operator> <name>size</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>numele</name> <operator>!=</operator> <name>LP_HDR_NUMELE_UNKNOWN</name> <operator>&amp;&amp;</operator> <name>numele</name> <operator>!=</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>



<function><type><name>unsigned</name> <name>int</name></type> <name>lpCompare</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>slen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>sz</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><name>slen</name> <operator>==</operator> <name>sz</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>



<decl_stmt><decl><type><name>int64_t</name></type> <name>sval</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>lpStringToInt64</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator><name>s</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>sz</name> <operator>==</operator> <name>sval</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>uintCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>unsigned</name> <name>int</name> <operator>*</operator><operator>)</operator> <name>a</name> <operator>-</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>int</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>lpSaveValue</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>lval</name></decl></parameter>, <parameter><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>sval</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>slen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>lval</name></name> <operator>=</operator> <name>lval</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>lpRandomPair</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>total_count</name></decl></parameter>, <parameter><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>total_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><operator>(</operator><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <name>total_count</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>sval</name></name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>slen</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>key</name><operator>-&gt;</operator><name>lval</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>sval</name></name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>slen</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>lval</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>lpRandomPairs</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>klen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>vlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>klval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>vlval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>order</name></decl>;</decl_stmt>
}</block></struct></type> <name>rand_pick</name>;</typedef>
<decl_stmt><decl><type><name>rand_pick</name> <modifier>*</modifier></type><name>picks</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rand_pick</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>total_size</name> <init>= <expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>picks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name> <operator>=</operator> <operator>(</operator><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <name>total_size</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>picks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>order</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>picks</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rand_pick</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>uintCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>lpindex</name> <init>= <expr><name><name>picks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>index</name></expr></init></decl>, <decl><type ref="prev"/><name>pickindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lpindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&amp;&amp;</operator> <name>pickindex</name> <operator>&lt;</operator> <name>count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>pickindex</name> <operator>&lt;</operator> <name>count</name> <operator>&amp;&amp;</operator> <name>lpindex</name> <operator>==</operator> <name><name>picks</name><index>[<expr><name>pickindex</name></expr>]</index></name><operator>.</operator><name>index</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>storeorder</name> <init>= <expr><name><name>picks</name><index>[<expr><name>pickindex</name></expr>]</index></name><operator>.</operator><name>order</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lpSaveValue</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>klval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>keys</name><index>[<expr><name>storeorder</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vals</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>lpSaveValue</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>vlval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vals</name><index>[<expr><name>storeorder</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pickindex</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>lpindex</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>picks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>unsigned</name> <name>int</name></type> <name>lpRandomPairsUnique</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>klen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>klval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>total_size</name> <init>= <expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name>total_size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>count</name> <operator>=</operator> <name>total_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>





<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>picked</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>remaining</name> <init>= <expr><name>count</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>picked</name> <operator>&lt;</operator> <name>count</name> <operator>&amp;&amp;</operator> <name>p</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>randomDouble</name> <init>= <expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><call><name>rand</name><argument_list>()</argument_list></call><operator>)</operator> <operator>/</operator> <name>RAND_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>threshold</name> <init>= <expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>remaining</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>total_size</name> <operator>-</operator> <name>index</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>randomDouble</name> <operator>&lt;=</operator> <name>threshold</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpSaveValue</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>klval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>keys</name><index>[<expr><name>picked</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vals</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpSaveValue</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>klval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vals</name><index>[<expr><name>picked</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>picked</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>picked</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>lpRepr</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>vlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>intbuf</name><index>[<expr><name>LP_INTBUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{total bytes %zu} {num entries %lu}\n"</literal></expr></argument>, <argument><expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>encoded_size_bytes</name> <init>= <expr><call><name>lpCurrentEncodedSizeBytes</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>encoded_size</name> <init>= <expr><call><name>lpCurrentEncodedSizeUnsafe</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>back_len</name> <init>= <expr><call><name>lpEncodeBacklen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>encoded_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(
<argument><expr><literal type="string">"{\n"</literal>
<literal type="string">"\taddr: 0x%08lx,\n"</literal>
<literal type="string">"\tindex: %2d,\n"</literal>
<literal type="string">"\toffset: %1lu,\n"</literal>
<literal type="string">"\thdr+entrylen+backlen: %2lu,\n"</literal>
<literal type="string">"\thdrlen: %3u,\n"</literal>
<literal type="string">"\tbacklen: %2lu,\n"</literal>
<literal type="string">"\tpayload: %1u\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>long</name> <name>unsigned</name><operator>)</operator><name>p</name></expr></argument>,
<argument><expr><name>index</name></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <operator>(</operator><name>p</name><operator>-</operator><name>lp</name><operator>)</operator></expr></argument>,
<argument><expr><name>encoded_size</name> <operator>+</operator> <name>back_len</name></expr></argument>,
<argument><expr><name>encoded_size_bytes</name></expr></argument>,
<argument><expr><name>back_len</name></expr></argument>,
<argument><expr><name>encoded_size</name> <operator>-</operator> <name>encoded_size_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\tbytes: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>encoded_size</name> <operator>+</operator> <name>back_len</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%02x|"</literal></expr></argument>,<argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><name>intbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t[str]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vlen</name> <operator>&gt;</operator> <literal type="number">40</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{end}\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>REDIS_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"adlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"testhelp.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>printf("test  %s\n", name);</cpp:value></cpp:define>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>mixlist</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"hello"</literal></expr>, <expr><literal type="string">"foo"</literal></expr>, <expr><literal type="string">"quux"</literal></expr>, <expr><literal type="string">"1024"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>intlist</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"4294967296"</literal></expr>, <expr><literal type="string">"-100"</literal></expr>, <expr><literal type="string">"100"</literal></expr>, <expr><literal type="string">"128000"</literal></expr>,
<expr><literal type="string">"non integer"</literal></expr>, <expr><literal type="string">"much much longer non integer"</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>createList</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpPrepend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>lp</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>createIntList</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>intlist</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>intlist</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>intlist</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>intlist</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpPrepend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>intlist</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>intlist</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpPrepend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>intlist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>intlist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>intlist</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>intlist</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>intlist</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>intlist</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>lp</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name> <name>long</name></type> <name>usec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator><operator>*</operator><literal type="number">1000000</literal><operator>)</operator><operator>+</operator><name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>stress</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxsize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dnum</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>posstr</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">5</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="string">"HEAD"</literal></expr>, <expr><literal type="string">"TAIL"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>start</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxsize</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><name>dnum</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"quux"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>usec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpPrepend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"quux"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"quux"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDelete</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"List size: %8d, bytes: %8zu, %dx push+pop (%s): %6lld usec\n"</literal></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name><name>posstr</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pop</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>vlen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><ternary><condition><expr><name>where</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Pop head: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Pop tail: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vstr</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>vlen</name> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>lpDelete</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>randstring</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>max</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>min</name><operator>+</operator><call><name>rand</name><argument_list>()</argument_list></call><operator>%</operator><operator>(</operator><name>max</name><operator>-</operator><name>min</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>minval</name></decl>, <decl><type ref="prev"/><name>maxval</name></decl>;</decl_stmt>
<switch>switch<condition>(<expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name>minval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>minval</name> <operator>=</operator> <literal type="number">48</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>=</operator> <literal type="number">122</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>minval</name> <operator>=</operator> <literal type="number">48</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>=</operator> <literal type="number">52</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>target</name><index>[<expr><name>p</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>minval</name><operator>+</operator><call><name>rand</name><argument_list>()</argument_list></call><operator>%</operator><operator>(</operator><name>maxval</name><operator>-</operator><name>minval</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>verifyEntry</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>slen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>lpValidation</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>head_count</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>head_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <modifier>*</modifier></type><name>count</name> <init>= <expr><name>userdata</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>lpCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><operator>*</operator><name>count</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><operator>*</operator><name>count</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>count</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>listpackTest</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>vlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>intbuf</name><index>[<expr><name>LP_INTBUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>accurate</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REDIS_TEST_ACCURATE</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Create int list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createIntList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Create list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Test lpPrepend"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpPrepend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpPrepend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Test lpPrependInteger"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpPrependInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">127</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpPrependInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">4095</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpPrependInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">32767</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpPrependInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">8388607</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpPrependInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">2147483647</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpPrependInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">9223372036854775807</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"9223372036854775807"</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"127"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Get element at index"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Pop list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>pop</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>pop</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>pop</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>pop</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Get element at index"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Iterate list from 0 to end"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Iterate list from 1 to end"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Iterate list from 2 to end"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Iterate from back to front"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Iterate from back to front, deleting all items"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDelete</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>TEST</name><argument_list>(<argument><expr><literal type="string">"Delete whole listpack when num == -1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRange</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><index>[<expr><name>LP_HDR_SIZE</name></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>LP_HDR_SIZE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRangeWithEntry</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><index>[<expr><name>LP_HDR_SIZE</name></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>LP_HDR_SIZE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>TEST</name><argument_list>(<argument><expr><literal type="string">"Delete whole listpack with negative index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRange</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><index>[<expr><name>LP_HDR_SIZE</name></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>LP_HDR_SIZE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRangeWithEntry</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><index>[<expr><name>LP_HDR_SIZE</name></expr>]</index></name> <operator>==</operator> <name>LP_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>LP_HDR_SIZE</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>TEST</name><argument_list>(<argument><expr><literal type="string">"Delete inclusive range 0,0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRange</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpSkip</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <name>LP_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRangeWithEntry</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpSkip</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <name>LP_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>TEST</name><argument_list>(<argument><expr><literal type="string">"Delete inclusive range 0,1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRange</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRangeWithEntry</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>TEST</name><argument_list>(<argument><expr><literal type="string">"Delete inclusive range 1,2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRange</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRangeWithEntry</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>TEST</name><argument_list>(<argument><expr><literal type="string">"Delete with start index out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRange</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>TEST</name><argument_list>(<argument><expr><literal type="string">"Delete with num overflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRange</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRangeWithEntry</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>mixlist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mixlist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Delete foo while iterating"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>lpCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"foo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDelete</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Replace with same size"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>orig_lp</name> <init>= <expr><name>lp</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplace</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"zoink"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplace</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"y"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplace</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"65536"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>,
<argument><expr><literal type="string">"\x85zoink\x06"</literal>
<literal type="string">"\xf2\x00\x00\x01\x04"</literal>
<literal type="string">"\x84quux\05"</literal> <literal type="string">"\x81y\x02"</literal> <literal type="string">"\xff"</literal></expr></argument>,
<argument><expr><literal type="number">22</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lp</name> <operator>==</operator> <name>orig_lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Replace with different size"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplace</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"squirrel"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>,
<argument><expr><literal type="string">"\x85hello\x06"</literal> <literal type="string">"\x88squirrel\x09"</literal> <literal type="string">"\x84quux\x05"</literal>
<literal type="string">"\xc4\x00\x02"</literal> <literal type="string">"\xff"</literal></expr></argument>,
<argument><expr><literal type="number">27</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Regression test for &gt;255 byte strings"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>v1</name><index>[<expr><literal type="number">257</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>, <decl><type ref="prev"/><name><name>v2</name><index>[<expr><literal type="number">257</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>v1</name></expr></argument>,<argument><expr><literal type="char">'x'</literal></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>v2</name></expr></argument>,<argument><expr><literal type="char">'y'</literal></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>v1</name></expr></argument> ,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>v2</name></expr></argument> ,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>vstr</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name>v2</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>vstr</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Create long list and check indices"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>-</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">999</literal><operator>-</operator><name>i</name> <operator>==</operator> <name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Compare strings with listpack entries"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hello"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>lpCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hella"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>lpCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1025"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"lpMerge two empty listpacks"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp1</name> <init>= <expr><call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp2</name> <init>= <expr><call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>lp1</name> <operator>=</operator> <call><name>lpMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lp1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp1</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"lpMerge two listpacks - first larger than second"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp1</name> <init>= <expr><call><name>createIntList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp2</name> <init>= <expr><call><name>createList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>lp1_bytes</name> <init>= <expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>lp2_bytes</name> <init>= <expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>lp1_len</name> <init>= <expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>lp2_len</name> <init>= <expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp3</name> <init>= <expr><call><name>lpMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lp1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lp2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lp3</name> <operator>==</operator> <name>lp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lp2</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>lp1_len</name> <operator>+</operator> <name>lp2_len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>lp1_bytes</name> <operator>+</operator> <name>lp2_bytes</name> <operator>-</operator> <name>LP_HDR_SIZE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"4294967296"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"much much longer non integer"</literal></expr></argument>, <argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"lpMerge two listpacks - second larger than first"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp1</name> <init>= <expr><call><name>createList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp2</name> <init>= <expr><call><name>createIntList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>lp1_bytes</name> <init>= <expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>lp2_bytes</name> <init>= <expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>lp1_len</name> <init>= <expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>lp2_len</name> <init>= <expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp3</name> <init>= <expr><call><name>lpMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lp1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lp2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lp3</name> <operator>==</operator> <name>lp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lp1</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>lp1_len</name> <operator>+</operator> <name>lp2_len</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>lp1_bytes</name> <operator>+</operator> <name>lp2_bytes</name> <operator>-</operator> <name>LP_HDR_SIZE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"4294967296"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"much much longer non integer"</literal></expr></argument>, <argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lp3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Random pair with one element"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>listpackEntry</name></type> <name>key</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"123"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpRandomPair</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>sval</name></name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>slen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>val</name><operator>.</operator><name>lval</name></name> <operator>==</operator> <literal type="number">123</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Random pair with many elements"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>listpackEntry</name></type> <name>key</name></decl>, <decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"123"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"456"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"def"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpRandomPair</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>.</operator><name>sval</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>sval</name></name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><name><name>key</name><operator>.</operator><name>slen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>slen</name></name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>val</name><operator>.</operator><name>lval</name></name> <operator>==</operator> <literal type="number">123</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>key</name><operator>.</operator><name>sval</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>key</name><operator>.</operator><name>lval</name></name> <operator>==</operator> <literal type="number">456</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>val</name><operator>.</operator><name>sval</name></name></expr></argument>, <argument><expr><literal type="string">"def"</literal></expr></argument>, <argument><expr><name><name>val</name><operator>.</operator><name>slen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Random pairs with one element"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>keys</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>listpackEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>vals</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>listpackEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"123"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpRandomPairs</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>keys</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>sval</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><name><name>keys</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>slen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>vals</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>.</operator><name>lval</name> <operator>==</operator> <literal type="number">123</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Random pairs with many elements"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>keys</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>listpackEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>vals</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>listpackEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"123"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"456"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"def"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpRandomPairs</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sval</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>slen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>slen</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lval</name> <operator>==</operator> <literal type="number">123</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lval</name> <operator>==</operator> <literal type="number">456</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sval</name></expr></argument>, <argument><expr><literal type="string">"def"</literal></expr></argument>, <argument><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>slen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Random pairs unique with one element"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>picked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>keys</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>listpackEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>vals</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>listpackEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"123"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>picked</name> <operator>=</operator> <call><name>lpRandomPairsUnique</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>picked</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sval</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><name><name>keys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>slen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>lval</name> <operator>==</operator> <literal type="number">123</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Random pairs unique with many elements"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>picked</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>keys</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>listpackEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>vals</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>listpackEntry</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"123"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"456"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"def"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>picked</name> <operator>=</operator> <call><name>lpRandomPairsUnique</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>picked</name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sval</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>slen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>slen</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lval</name> <operator>==</operator> <literal type="number">123</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lval</name> <operator>==</operator> <literal type="number">456</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sval</name></expr></argument>, <argument><expr><literal type="string">"def"</literal></expr></argument>, <argument><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>slen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"push various encodings"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"127"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_7BIT_UINT</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"4095"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_13BIT_INT</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"32767"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_16BIT_INT</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"8388607"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_24BIT_INT</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"2147483647"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_32BIT_INT</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"9223372036854775807"</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_64BIT_INT</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">127</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_7BIT_UINT</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"127"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">4095</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"4095"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_13BIT_INT</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">32767</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"32767"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_16BIT_INT</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">8388607</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"8388607"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_24BIT_INT</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">2147483647</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"2147483647"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_32BIT_INT</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">9223372036854775807</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"9223372036854775807"</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_64BIT_INT</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><literal type="number">65535</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">65535</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">63</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_6BIT_STR</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">4095</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_12BIT_STR</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">65535</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>LP_ENCODING_IS_32BIT_STR</name><argument_list>(<argument><expr><call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Test lpFind"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpFind</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpFind</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verifyEntry</name><argument_list>(<argument><expr><call><name>lpFind</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Test lpValidateIntegrity"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpValidateIntegrity</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>lpValidation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Test number of elements exceeds LP_HDR_NUMELE_UNKNOWN"</literal></argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LP_HDR_NUMELE_UNKNOWN</name> <operator>+</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpGetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LP_HDR_NUMELE_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LP_HDR_NUMELE_UNKNOWN</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpDeleteRange</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpGetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LP_HDR_NUMELE_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LP_HDR_NUMELE_UNKNOWN</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>lpGetNumElements</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>LP_HDR_NUMELE_UNKNOWN</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Stress with random payloads of different encoding"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>j</name></decl>,<decl><type ref="prev"/><name>len</name></decl>,<decl><type ref="prev"/><name>where</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buflen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>refnode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>iteration</name> <init>= <expr><ternary><condition><expr><name>accurate</name></expr> ?</condition><then> <expr><literal type="number">20000</literal></expr> </then><else>: <expr><literal type="number">20</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iteration</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>listSetFreeMethod</name><argument_list>(<argument><expr><name>ref</name></expr></argument>,<argument><expr><operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>sdsfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <literal type="number">256</literal></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>where</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>rand</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>randstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch<condition>(<expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%lld"</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="number">0LL</literal> <operator>+</operator> <call><name>rand</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%lld"</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="number">0LL</literal> <operator>+</operator> <call><name>rand</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%lld"</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="number">0LL</literal> <operator>+</operator> <call><name>rand</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpPrepend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>listAddNodeHead</name><argument_list>(<argument><expr><name>ref</name></expr></argument>,<argument><expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>where</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>ref</name></expr></argument>,<argument><expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>listLength</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lpLength</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>refnode</name> <operator>=</operator> <call><name>listIndex</name><argument_list>(<argument><expr><name>ref</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><name>intbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>,<argument><expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>refnode</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Stress with variable listpack size"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>maxsize</name> <init>= <expr><ternary><condition><expr><name>accurate</name></expr> ?</condition><then> <expr><literal type="number">16384</literal></expr> </then><else>: <expr><literal type="number">16</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>stress</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">100000</literal></expr></argument>,<argument><expr><name>maxsize</name></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>stress</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">100000</literal></expr></argument>,<argument><expr><name>maxsize</name></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>iteration</name> <init>= <expr><ternary><condition><expr><name>accurate</name></expr> ?</condition><then> <expr><literal type="number">100000</literal></expr> </then><else>: <expr><literal type="number">100</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Benchmark lpAppend"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iteration</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name> <init>= <expr><literal type="string">"asdf"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">400</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">4000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"10"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"100"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1000"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"10000"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"100000"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Benchmark lpFind string"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>fptr</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>fptr</name> <operator>=</operator> <call><name>lpFind</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"nothing"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Benchmark lpFind number"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>fptr</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>fptr</name> <operator>=</operator> <call><name>lpFind</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"99999"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Benchmark lpSeek"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">99999</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Benchmark lpValidateIntegrity"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>lpValidateIntegrity</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Benchmark lpCompare with string"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lpCompare</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"nothing"</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Benchmark lpCompare with number"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lpCompare</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"99999"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
