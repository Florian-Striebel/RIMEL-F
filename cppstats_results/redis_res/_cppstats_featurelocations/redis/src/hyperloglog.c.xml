<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/results/redis_res/_cppstats_featurelocations/redis/src/hyperloglog.c">






























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>


















































































































































<struct>struct <name>hllhdr</name> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>magic</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>notused</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>card</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>registers</name><index>[]</index></name></decl>;</decl_stmt>
}</block>;</struct>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_INVALIDATE_CACHE</name><parameter_list>(<parameter><type><name>hdr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(hdr)-&gt;card[7] |= (1&lt;&lt;7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_VALID_CACHE</name><parameter_list>(<parameter><type><name>hdr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((hdr)-&gt;card[7] &amp; (1&lt;&lt;7)) == 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_P</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_Q</name></cpp:macro> <cpp:value>(64-HLL_P)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_REGISTERS</name></cpp:macro> <cpp:value>(1&lt;&lt;HLL_P)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_P_MASK</name></cpp:macro> <cpp:value>(HLL_REGISTERS-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_BITS</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_REGISTER_MAX</name></cpp:macro> <cpp:value>((1&lt;&lt;HLL_BITS)-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_HDR_SIZE</name></cpp:macro> <cpp:value>sizeof(struct hllhdr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_DENSE_SIZE</name></cpp:macro> <cpp:value>(HLL_HDR_SIZE+((HLL_REGISTERS*HLL_BITS+7)/8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_DENSE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_RAW</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_MAX_ENCODING</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>invalid_hll_err</name> <init>= <expr><literal type="string">"-INVALIDOBJ Corrupted HLL object detected"</literal></expr></init></decl>;</decl_stmt>


































































































































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_DENSE_GET_REGISTER</name><parameter_list>(<parameter><type><name>target</name></type></parameter>,<parameter><type><name>p</name></type></parameter>,<parameter><type><name>regnum</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { uint8_t *_p = (uint8_t*) p; unsigned long _byte = regnum*HLL_BITS/8; unsigned long _fb = regnum*HLL_BITS&amp;7; unsigned long _fb8 = 8 - _fb; unsigned long b0 = _p[_byte]; unsigned long b1 = _p[_byte+1]; target = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp; HLL_REGISTER_MAX; } while(0)</cpp:value></cpp:define>











<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_DENSE_SET_REGISTER</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>regnum</name></type></parameter>,<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { uint8_t *_p = (uint8_t*) p; unsigned long _byte = regnum*HLL_BITS/8; unsigned long _fb = regnum*HLL_BITS&amp;7; unsigned long _fb8 = 8 - _fb; unsigned long _v = val; _p[_byte] &amp;= ~(HLL_REGISTER_MAX &lt;&lt; _fb); _p[_byte] |= _v &lt;&lt; _fb; _p[_byte+1] &amp;= ~(HLL_REGISTER_MAX &gt;&gt; _fb8); _p[_byte+1] |= _v &gt;&gt; _fb8; } while(0)</cpp:value></cpp:define>













<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_XZERO_BIT</name></cpp:macro> <cpp:value>0x40</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_BIT</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_IS_ZERO</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((*(p)) &amp; 0xc0) == 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_IS_XZERO</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((*(p)) &amp; 0xc0) == HLL_SPARSE_XZERO_BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_IS_VAL</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((*(p)) &amp; HLL_SPARSE_VAL_BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_ZERO_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((*(p)) &amp; 0x3f)+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_XZERO_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_VALUE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_LEN</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((*(p)) &amp; 0x3)+1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_MAX_VALUE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_MAX_LEN</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_ZERO_MAX_LEN</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_XZERO_MAX_LEN</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_VAL_SET</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>val</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { *(p) = (((val)-1)&lt;&lt;2|((len)-1))|HLL_SPARSE_VAL_BIT; } while(0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_ZERO_SET</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { *(p) = (len)-1; } while(0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_SPARSE_XZERO_SET</name><parameter_list>(<parameter><type><name>p</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { int _l = (len)-1; *(p) = (_l&gt;&gt;8) | HLL_SPARSE_XZERO_BIT; *((p)+1) = (_l&amp;0xff); } while(0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_ALPHA_INF</name></cpp:macro> <cpp:value>0.721347520444481703680</cpp:value></cpp:define>






<macro><name>REDIS_NO_SANITIZE</name><argument_list>(<argument><literal type="string">"alignment"</literal></argument>)</argument_list></macro>
<function><type><name>uint64_t</name></type> <name>MurmurHash64A</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>seed</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>m</name> <init>= <expr><literal type="number">0xc6a4a7935bd1e995</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>r</name> <init>= <expr><literal type="number">47</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>h</name> <init>= <expr><name>seed</name> <operator>^</operator> <operator>(</operator><name>len</name> <operator>*</operator> <name>m</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>data</name> <operator>+</operator> <operator>(</operator><name>len</name><operator>-</operator><operator>(</operator><name>len</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<while>while<condition>(<expr><name>data</name> <operator>!=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>k</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>BYTE_ORDER</name> <operator>==</operator> <name>LITTLE_ENDIAN</name><operator>)</operator></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ALIGNED_ACCESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>k</name></expr></argument>,<argument><expr><name>data</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>k</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>*</operator><operator>)</operator><name>data</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">56</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>k</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>^=</operator> <name>k</name> <operator>&gt;&gt;</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <name>k</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></while>

<switch>switch<condition>(<expr><name>len</name> <operator>&amp;</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>
<case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
<case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
</block_content>}</block></switch><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
<expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <name>r</name></expr>;</expr_stmt>
<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>hllPatLen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elesize</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>regp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>hash</name></decl>, <decl><type ref="prev"/><name>bit</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>












<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>MurmurHash64A</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>elesize</name></expr></argument>,<argument><expr><literal type="number">0xadc83b19ULL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name> <operator>=</operator> <name>hash</name> <operator>&amp;</operator> <name>HLL_P_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hash</name> <operator>&gt;&gt;=</operator> <name>HLL_P</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hash</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><name>HLL_Q</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>bit</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while<condition>(<expr><operator>(</operator><name>hash</name> <operator>&amp;</operator> <name>bit</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>bit</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>regp</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>index</name></expr>;</expr_stmt>
<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>













<function><type><name>int</name></type> <name>hllDenseSet</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>registers</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>oldcount</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>oldcount</name></expr></argument>,<argument><expr><name>registers</name></expr></argument>,<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name>oldcount</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HLL_DENSE_SET_REGISTER</name><argument_list>(<argument><expr><name>registers</name></expr></argument>,<argument><expr><name>index</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>







<function><type><name>int</name></type> <name>hllDenseAdd</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>registers</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elesize</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>count</name> <init>= <expr><call><name>hllPatLen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>elesize</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>hllDenseSet</name><argument_list>(<argument><expr><name>registers</name></expr></argument>,<argument><expr><name>index</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>hllDenseRegHisto</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>registers</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>reghisto</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name>HLL_REGISTERS</name> <operator>==</operator> <literal type="number">16384</literal> <operator>&amp;&amp;</operator> <name>HLL_BITS</name> <operator>==</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><name>registers</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>r0</name></decl>, <decl><type ref="prev"/><name>r1</name></decl>, <decl><type ref="prev"/><name>r2</name></decl>, <decl><type ref="prev"/><name>r3</name></decl>, <decl><type ref="prev"/><name>r4</name></decl>, <decl><type ref="prev"/><name>r5</name></decl>, <decl><type ref="prev"/><name>r6</name></decl>, <decl><type ref="prev"/><name>r7</name></decl>, <decl><type ref="prev"/><name>r8</name></decl>, <decl><type ref="prev"/><name>r9</name></decl>,
<decl><type ref="prev"/><name>r10</name></decl>, <decl><type ref="prev"/><name>r11</name></decl>, <decl><type ref="prev"/><name>r12</name></decl>, <decl><type ref="prev"/><name>r13</name></decl>, <decl><type ref="prev"/><name>r14</name></decl>, <decl><type ref="prev"/><name>r15</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>r0</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r1</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r2</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r3</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r4</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r5</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r6</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r7</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r8</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r9</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r10</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r11</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r12</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r13</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">6</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r14</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal> <operator>|</operator> <name><name>r</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>r15</name> <operator>=</operator> <operator>(</operator><name><name>r</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">2</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">63</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r0</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r1</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r2</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r3</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r4</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r5</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r6</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r7</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r8</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r9</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r10</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r11</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r12</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r13</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r14</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>r15</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>reg</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>reg</name></expr></argument>,<argument><expr><name>registers</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>reg</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>









<function><type><name>int</name></type> <name>hllSparseToDense</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>sds</name></type> <name>sparse</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>, <decl><type ref="prev"/><name>dense</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>oldhdr</name> <init>= <expr><operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator><name>sparse</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>runlen</name></decl>, <decl><type ref="prev"/><name>regval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name>sparse</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>p</name><operator>+</operator><call><name>sdslen</name><argument_list>(<argument><expr><name>sparse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator> <name>sparse</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_OK</name></expr>;</return></block_content></block></if></if_stmt>




<expr_stmt><expr><name>dense</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>HLL_DENSE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator> <name>dense</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>hdr</name> <operator>=</operator> <operator>*</operator><name>oldhdr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>HLL_DENSE</name></expr>;</expr_stmt>



<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>runlen</name> <operator>+</operator> <name>idx</name><operator>)</operator> <operator>&gt;</operator> <name>HLL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<while>while<condition>(<expr><name>runlen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HLL_DENSE_SET_REGISTER</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>idx</name></expr></argument>,<argument><expr><name>regval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>



<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <name>HLL_REGISTERS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>dense</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>dense</name></expr>;</expr_stmt>
<return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>
















<function><type><name>int</name></type> <name>hllSparseSet</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>oldcount</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sparse</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>first</name></decl>, <decl><type ref="prev"/><name>span</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>is_zero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>is_xzero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>is_val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>runlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name>HLL_SPARSE_VAL_MAX_VALUE</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>promote</name>;</goto></block_content></block></if></if_stmt>






<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>sdsMakeRoomFor</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>sparse</name> <operator>=</operator> <name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator> <operator>+</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>span</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>oplen</name></decl>;</decl_stmt>






<expr_stmt><expr><name>oplen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_VAL</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>oplen</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;=</operator> <name>first</name><operator>+</operator><name>span</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>oplen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name> <operator>+=</operator> <name>span</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>span</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>p</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <ternary><condition><expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>p</name><operator>+</operator><literal type="number">2</literal></expr> </then><else>: <expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>next</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>is_zero</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>is_xzero</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>is_val</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>






















<if_stmt><if>if <condition>(<expr><name>is_val</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>oldcount</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>oldcount</name> <operator>&gt;=</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>runlen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>updated</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>is_zero</name> <operator>&amp;&amp;</operator> <name>runlen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>updated</name>;</goto>
</block_content>}</block></if></if_stmt>
















<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>seq</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n</name> <init>= <expr><name>seq</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>last</name> <init>= <expr><name>first</name><operator>+</operator><name>span</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>is_zero</name> <operator>||</operator> <name>is_xzero</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <name>first</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>index</name><operator>-</operator><name>first</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>HLL_SPARSE_ZERO_MAX_LEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HLL_SPARSE_XZERO_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>HLL_SPARSE_ZERO_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <name>last</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>last</name><operator>-</operator><name>index</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>HLL_SPARSE_ZERO_MAX_LEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HLL_SPARSE_XZERO_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>HLL_SPARSE_ZERO_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>curval</name> <init>= <expr><call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <name>first</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>index</name><operator>-</operator><name>first</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>curval</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>!=</operator> <name>last</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>last</name><operator>-</operator><name>index</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>n</name></expr></argument>,<argument><expr><name>curval</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>





<decl_stmt><decl><type><name>int</name></type> <name>seqlen</name> <init>= <expr><name>n</name><operator>-</operator><name>seq</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>oldlen</name> <init>= <expr><ternary><condition><expr><name>is_xzero</name></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>deltalen</name> <init>= <expr><name>seqlen</name><operator>-</operator><name>oldlen</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>deltalen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>+</operator><name>deltalen</name> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>hll_sparse_max_bytes</name></name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>promote</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>deltalen</name> <operator>&amp;&amp;</operator> <name>next</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>next</name><operator>+</operator><name>deltalen</name></expr></argument>,<argument><expr><name>next</name></expr></argument>,<argument><expr><name>end</name><operator>-</operator><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>sdsIncrLen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>deltalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>seq</name></expr></argument>,<argument><expr><name>seqlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>+=</operator> <name>deltalen</name></expr>;</expr_stmt>

<label><name>updated</name>:</label>





<expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><name>prev</name></expr> ?</condition><then> <expr><name>prev</name></expr> </then><else>: <expr><name>sparse</name></expr></else></ternary></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scanlen</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <name>scanlen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>p</name><operator>+</operator><literal type="number">1</literal> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>HLL_SPARSE_IS_VAL</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>v1</name> <init>= <expr><call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>v2</name> <init>= <expr><call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>v1</name> <operator>==</operator> <name>v2</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>+</operator><call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>HLL_SPARSE_VAL_MAX_LEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>HLL_SPARSE_VAL_SET</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>v1</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>end</name><operator>-</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdsIncrLen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name><operator>--</operator></expr>;</expr_stmt>



<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>


<expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HLL_INVALIDATE_CACHE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>

<label><name>promote</name>:</label>
<if_stmt><if>if <condition>(<expr><call><name>hllSparseToDense</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>








<decl_stmt><decl><type><name>int</name></type> <name>dense_retval</name> <init>= <expr><call><name>hllDenseSet</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>index</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>dense_retval</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>dense_retval</name></expr>;</return>
</block_content>}</block></function>







<function><type><name>int</name></type> <name>hllSparseAdd</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elesize</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>count</name> <init>= <expr><call><name>hllPatLen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>elesize</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>hllSparseSet</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><name>index</name></expr></argument>,<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>hllSparseRegHisto</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>sparse</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sparselen</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>invalid</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>reghisto</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>runlen</name></decl>, <decl><type ref="prev"/><name>regval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>sparse</name><operator>+</operator><name>sparselen</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><name>sparse</name></expr></init></decl>;</decl_stmt>

<while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name>regval</name></expr>]</index></name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <name>HLL_REGISTERS</name> <operator>&amp;&amp;</operator> <name>invalid</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>invalid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>









<function><type><name>void</name></type> <name>hllRawRegHisto</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>registers</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>reghisto</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>word</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>*</operator><operator>)</operator> <name>registers</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name><operator>/</operator><literal type="number">8</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>word</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>bytes</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator> <name>word</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>reghisto</name><index>[<expr><name><name>bytes</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>word</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><name>double</name></type> <name>hllSigma</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">1.</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>INFINITY</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>zPrime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>y</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>z</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>*=</operator> <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>zPrime</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>+=</operator> <name>x</name> <operator>*</operator> <name>y</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>+=</operator> <name>y</name></expr>;</expr_stmt>
</block_content>}</block> while<condition>(<expr><name>zPrime</name> <operator>!=</operator> <name>z</name></expr>)</condition>;</do>
<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>double</name></type> <name>hllTau</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <literal type="number">0.</literal> <operator>||</operator> <name>x</name> <operator>==</operator> <literal type="number">1.</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0.</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>zPrime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>y</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>z</name> <init>= <expr><literal type="number">1</literal> <operator>-</operator> <name>x</name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>sqrt</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zPrime</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> <operator>*=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>-=</operator> <call><name>pow</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>-</operator> <name>x</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>*</operator><name>y</name></expr>;</expr_stmt>
</block_content>}</block> while<condition>(<expr><name>zPrime</name> <operator>!=</operator> <name>z</name></expr>)</condition>;</do>
<return>return <expr><name>z</name> <operator>/</operator> <literal type="number">3</literal></expr>;</return>
</block_content>}</block></function>












<function><type><name>uint64_t</name></type> <name>hllCount</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>invalid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>m</name> <init>= <expr><name>HLL_REGISTERS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>E</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>int</name></type> <name><name>reghisto</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hllDenseRegHisto</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>reghisto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hllSparseRegHisto</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,
<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><operator>(</operator><name>sds</name><operator>)</operator><name>hdr</name></expr></argument>)</argument_list></call><operator>-</operator><name>HLL_HDR_SIZE</name></expr></argument>,<argument><expr><name>invalid</name></expr></argument>,<argument><expr><name>reghisto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_RAW</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>hllRawRegHisto</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>reghisto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown HyperLogLog encoding in hllCount()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>




<decl_stmt><decl><type><name>double</name></type> <name>z</name> <init>= <expr><name>m</name> <operator>*</operator> <call><name>hllTau</name><argument_list>(<argument><expr><operator>(</operator><name>m</name><operator>-</operator><name><name>reghisto</name><index>[<expr><name>HLL_Q</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>)</operator><operator>/</operator><operator>(</operator><name>double</name><operator>)</operator><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>HLL_Q</name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>--</operator><name>j</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>z</name> <operator>+=</operator> <name><name>reghisto</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> <operator>*=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>z</name> <operator>+=</operator> <name>m</name> <operator>*</operator> <call><name>hllSigma</name><argument_list>(<argument><expr><name><name>reghisto</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>/</operator><operator>(</operator><name>double</name><operator>)</operator><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>E</name> <operator>=</operator> <call><name>llroundl</name><argument_list>(<argument><expr><name>HLL_ALPHA_INF</name><operator>*</operator><name>m</name><operator>*</operator><name>m</name><operator>/</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>uint64_t</name><operator>)</operator> <name>E</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>hllAdd</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>elesize</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>HLL_DENSE</name></expr>:</case> <return>return <expr><call><name>hllDenseAdd</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>elesize</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>HLL_SPARSE</name></expr>:</case> <return>return <expr><call><name>hllSparseAdd</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>elesize</name></expr></argument>)</argument_list></call></expr>;</return>
<default>default:</default> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>









<function><type><name>int</name></type> <name>hllMerge</name><parameter_list>(<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>max</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>hll</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><name><name>hll</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>val</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>val</name></expr></argument>,<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&gt;</operator> <name><name>max</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>max</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>hll</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>p</name> <operator>+</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>hll</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>runlen</name></decl>, <decl><type ref="prev"/><name>regval</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>runlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>runlen</name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>&gt;</operator> <name>HLL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<while>while<condition>(<expr><name>runlen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>regval</name> <operator>&gt;</operator> <name><name>max</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>max</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>regval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>HLL_REGISTERS</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>robj</name> <modifier>*</modifier></type><name>createHLLObject</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sparselen</name> <init>= <expr><name>HLL_HDR_SIZE</name> <operator>+</operator>
<operator>(</operator><operator>(</operator><operator>(</operator><name>HLL_REGISTERS</name><operator>+</operator><operator>(</operator><name>HLL_SPARSE_XZERO_MAX_LEN</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator>
<name>HLL_SPARSE_XZERO_MAX_LEN</name><operator>)</operator><operator>*</operator><literal type="number">2</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>aux</name></decl>;</decl_stmt>



<expr_stmt><expr><name>aux</name> <operator>=</operator> <name>HLL_REGISTERS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>sparselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name>s</name> <operator>+</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>aux</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>xzero</name> <init>= <expr><name>HLL_SPARSE_XZERO_MAX_LEN</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>xzero</name> <operator>&gt;</operator> <name>aux</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>xzero</name> <operator>=</operator> <name>aux</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>HLL_SPARSE_XZERO_SET</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>xzero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>aux</name> <operator>-=</operator> <name>xzero</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>(</operator><name>p</name><operator>-</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name>s</name><operator>)</operator> <operator>==</operator> <name>sparselen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>magic</name></name></expr></argument>,<argument><expr><literal type="string">"HYLL"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>HLL_SPARSE</name></expr>;</expr_stmt>
<return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>isHLLObjectOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>stringObjectLen</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>hdr</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>magic</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'H'</literal> <operator>||</operator> <name><name>hdr</name><operator>-&gt;</operator><name>magic</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'Y'</literal> <operator>||</operator>
<name><name>hdr</name><operator>-&gt;</operator><name>magic</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'L'</literal> <operator>||</operator> <name><name>hdr</name><operator>-&gt;</operator><name>magic</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'L'</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>&gt;</operator> <name>HLL_MAX_ENCODING</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name> <operator>&amp;&amp;</operator>
<call><name>stringObjectLen</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>HLL_DENSE_SIZE</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>


<return>return <expr><name>C_OK</name></expr>;</return>

<label><name>invalid</name>:</label>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"-WRONGTYPE Key is not a valid "</literal>
<literal type="string">"HyperLogLog string value."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>pfaddCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>updated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createHLLObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>updated</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isHLLObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>dbUnshareStringValue</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>hllAdd</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,
<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name>retval</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>updated</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></switch>
</block_content>}</block></for>
<expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>updated</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STRING</name></expr></argument>,<argument><expr><literal type="string">"pfadd"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>updated</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HLL_INVALIDATE_CACHE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><ternary><condition><expr><name>updated</name></expr> ?</condition><then> <expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr> </then><else>: <expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>pfcountCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>card</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>max</name><index>[<expr><name>HLL_HDR_SIZE</name><operator>+</operator><name>HLL_REGISTERS</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>registers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>max</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hdr</name> <operator>=</operator> <operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator> <name>max</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>HLL_RAW</name></expr>;</expr_stmt>
<expr_stmt><expr><name>registers</name> <operator>=</operator> <name>max</name> <operator>+</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isHLLObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name>hllMerge</name><argument_list>(<argument><expr><name>registers</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>hllCount</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>












<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isHLLObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>dbUnshareStringValue</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HLL_VALID_CACHE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>card</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>card</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">56</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>invalid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>card</name> <operator>=</operator> <call><name>hllCount</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>invalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>invalid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>card</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">40</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">48</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>hdr</name><operator>-&gt;</operator><name>card</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>card</name> <operator>&gt;&gt;</operator> <literal type="number">56</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>



<expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>card</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>pfmergeCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>max</name><index>[<expr><name>HLL_REGISTERS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>use_dense</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>max</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isHLLObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>



<expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_DENSE</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>use_dense</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name>hllMerge</name><argument_list>(<argument><expr><name>max</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createHLLObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>dbUnshareStringValue</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<if_stmt><if>if <condition>(<expr><name>use_dense</name> <operator>&amp;&amp;</operator> <call><name>hllSparseToDense</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>



<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>max</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>HLL_DENSE</name></expr>:</case> <expr_stmt><expr><call><name>hllDenseSet</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>j</name></expr></argument>,<argument><expr><name><name>max</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>HLL_SPARSE</name></expr>:</case> <expr_stmt><expr><call><name>hllSparseSet</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><name>j</name></expr></argument>,<argument><expr><name><name>max</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>HLL_INVALIDATE_CACHE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STRING</name></expr></argument>,<argument><expr><literal type="string">"pfadd"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HLL_TEST_CYCLES</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>pfselftestCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>bitcounters</name> <init>= <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>HLL_DENSE_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator>struct <name>hllhdr</name><operator>*</operator><operator>)</operator> <name>bitcounters</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>hdr2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>bytecounters</name><index>[<expr><name>HLL_REGISTERS</name></expr>]</index></name></decl>;</decl_stmt>





<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_TEST_CYCLES</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>r</name> <init>= <expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>HLL_REGISTER_MAX</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>bytecounters</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>HLL_DENSE_SET_REGISTER</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>val</name></expr></argument>,<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name><name>bytecounters</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
<argument><expr><literal type="string">"TESTFAILED Register %d should be %d but is %d"</literal></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>bytecounters</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>











<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>HLL_DENSE_SIZE</name><operator>-</operator><name>HLL_HDR_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createHLLObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>relerr</name> <init>= <expr><literal type="number">1.04</literal><operator>/</operator><call><name>sqrt</name><argument_list>(<argument><expr><name>HLL_REGISTERS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>checkpoint</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>seed</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>rand</name><argument_list>()</argument_list></call> <operator>|</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>rand</name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ele</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <literal type="number">10000000</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <name>j</name> <operator>^</operator> <name>seed</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hllDenseAdd</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ele</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hllAdd</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ele</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>checkpoint</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name><name>server</name><operator>.</operator><name>hll_sparse_max_bytes</name></name><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>hdr2</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>hdr2</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"TESTFAILED sparse encoding not used"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>checkpoint</name> <operator>&amp;&amp;</operator> <call><name>hllCount</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>hllCount</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"TESTFAILED dense/sparse disagree"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>checkpoint</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>abserr</name> <init>= <expr><name>checkpoint</name> <operator>-</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><call><name>hllCount</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>maxerr</name> <init>= <expr><call><name>ceil</name><argument_list>(<argument><expr><name>relerr</name><operator>*</operator><literal type="number">6</literal><operator>*</operator><name>checkpoint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxerr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>abserr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>abserr</name> <operator>=</operator> <operator>-</operator><name>abserr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>abserr</name> <operator>&gt;</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>maxerr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
<argument><expr><literal type="string">"TESTFAILED Too big error. card:%llu abserr:%llu"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> <name>checkpoint</name></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> <name>abserr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>checkpoint</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>bitcounters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>pfdebugCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hllhdr</name></name> <modifier>*</modifier></type><name>hdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The specified key does not exist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isHLLObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>dbUnshareStringValue</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"getreg"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>arityerr</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>hllSparseToDense</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hdr</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>HLL_REGISTERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>HLL_REGISTERS</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>val</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>val</name></expr></argument>,<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>registers</name></name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"decode"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>arityerr</name>;</goto></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>p</name><operator>+</operator><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>decoded</name> <init>= <expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"HLL encoding is not sparse"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>HLL_HDR_SIZE</name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>runlen</name></decl>, <decl><type ref="prev"/><name>regval</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>HLL_SPARSE_IS_ZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_ZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>decoded</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>,<argument><expr><literal type="string">"z:%d "</literal></expr></argument>,<argument><expr><name>runlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>HLL_SPARSE_IS_XZERO</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_XZERO_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>decoded</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>,<argument><expr><literal type="string">"Z:%d "</literal></expr></argument>,<argument><expr><name>runlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>runlen</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>regval</name> <operator>=</operator> <call><name>HLL_SPARSE_VAL_VALUE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>decoded</name> <operator>=</operator> <call><name>sdscatprintf</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>,<argument><expr><literal type="string">"v:%d,%d "</literal></expr></argument>,<argument><expr><name>regval</name></expr></argument>,<argument><expr><name>runlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>decoded</name> <operator>=</operator> <call><name>sdstrim</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>,<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>decoded</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"encoding"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>encodingstr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="string">"dense"</literal></expr>,<expr><literal type="string">"sparse"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>arityerr</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>addReplyStatus</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>encodingstr</name><index>[<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"todense"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>conv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>arityerr</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hdr</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>HLL_SPARSE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>hllSparseToDense</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>invalid_hll_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>conv</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><name>conv</name></expr> ?</condition><then> <expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr> </then><else>: <expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unknown PFDEBUG subcommand '%s'"</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return;</return>

<label><name>arityerr</name>:</label>
<expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
<argument><expr><literal type="string">"Wrong number of arguments for the '%s' subcommand"</literal></expr></argument>,<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
