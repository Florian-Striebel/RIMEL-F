<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/results/redis_res/_cppstats_featurelocations/redis/src/ziplist.c">





















































































































































































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ziplist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"endianconv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"redisassert.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_END</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_BIG_PREVLEN</name></cpp:macro> <cpp:value>254</cpp:value></cpp:define>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_STR_MASK</name></cpp:macro> <cpp:value>0xc0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_INT_MASK</name></cpp:macro> <cpp:value>0x30</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_STR_06B</name></cpp:macro> <cpp:value>(0 &lt;&lt; 6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_STR_14B</name></cpp:macro> <cpp:value>(1 &lt;&lt; 6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_STR_32B</name></cpp:macro> <cpp:value>(2 &lt;&lt; 6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_INT_16B</name></cpp:macro> <cpp:value>(0xc0 | 0&lt;&lt;4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_INT_32B</name></cpp:macro> <cpp:value>(0xc0 | 1&lt;&lt;4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_INT_64B</name></cpp:macro> <cpp:value>(0xc0 | 2&lt;&lt;4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_INT_24B</name></cpp:macro> <cpp:value>(0xc0 | 3&lt;&lt;4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_INT_8B</name></cpp:macro> <cpp:value>0xfe</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_INT_IMM_MASK</name></cpp:macro> <cpp:value>0x0f</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_INT_IMM_MIN</name></cpp:macro> <cpp:value>0xf1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_INT_IMM_MAX</name></cpp:macro> <cpp:value>0xfd</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT24_MAX</name></cpp:macro> <cpp:value>0x7fffff</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT24_MIN</name></cpp:macro> <cpp:value>(-INT24_MAX - 1)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_IS_STR</name><parameter_list>(<parameter><type><name>enc</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((enc) &amp; ZIP_STR_MASK) &lt; ZIP_STR_MASK)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPLIST_BYTES</name><parameter_list>(<parameter><type><name>zl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*((uint32_t*)(zl)))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPLIST_TAIL_OFFSET</name><parameter_list>(<parameter><type><name>zl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*((uint32_t*)((zl)+sizeof(uint32_t))))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPLIST_LENGTH</name><parameter_list>(<parameter><type><name>zl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(*((uint16_t*)((zl)+sizeof(uint32_t)*2)))</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPLIST_HEADER_SIZE</name></cpp:macro> <cpp:value>(sizeof(uint32_t)*2+sizeof(uint16_t))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPLIST_END_SIZE</name></cpp:macro> <cpp:value>(sizeof(uint8_t))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPLIST_ENTRY_HEAD</name><parameter_list>(<parameter><type><name>zl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((zl)+ZIPLIST_HEADER_SIZE)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPLIST_ENTRY_TAIL</name><parameter_list>(<parameter><type><name>zl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((zl)+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPLIST_ENTRY_END</name><parameter_list>(<parameter><type><name>zl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((zl)+intrev32ifbe(ZIPLIST_BYTES(zl))-1)</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPLIST_INCR_LENGTH</name><parameter_list>(<parameter><type><name>zl</name></type></parameter>,<parameter><type><name>incr</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if (intrev16ifbe(ZIPLIST_LENGTH(zl)) &lt; UINT16_MAX) ZIPLIST_LENGTH(zl) = intrev16ifbe(intrev16ifbe(ZIPLIST_LENGTH(zl))+incr); }</cpp:value></cpp:define>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPLIST_MAX_SAFETY_SIZE</name></cpp:macro> <cpp:value>(1&lt;&lt;30)</cpp:value></cpp:define>
<function><type><name>int</name></type> <name>ziplistSafeToAdd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>zl</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>add</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><ternary><condition><expr><name>zl</name></expr>?</condition><then> <expr><call><name>ziplistBlobLen</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <name>add</name> <operator>&gt;</operator> <name>ZIPLIST_MAX_SAFETY_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>





<typedef>typedef <type><struct>struct <name>zlentry</name> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>prevrawlensize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>prevrawlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>lensize</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>headersize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>encoding</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

}</block></struct></type> <name>zlentry</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIPLIST_ENTRY_ZERO</name><parameter_list>(<parameter><type><name>zle</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ (zle)-&gt;prevrawlensize = (zle)-&gt;prevrawlen = 0; (zle)-&gt;lensize = (zle)-&gt;len = (zle)-&gt;headersize = 0; (zle)-&gt;encoding = 0; (zle)-&gt;p = NULL; }</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_ENTRY_ENCODING</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>encoding</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (encoding) = ((ptr)[0]); if ((encoding) &lt; ZIP_STR_MASK) (encoding) &amp;= ZIP_STR_MASK; } while(0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_ENCODING_SIZE_INVALID</name></cpp:macro> <cpp:value>0xff</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>int</name></type> <name>zipEncodingLenSize</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>encoding</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_INT_16B</name> <operator>||</operator> <name>encoding</name> <operator>==</operator> <name>ZIP_INT_32B</name> <operator>||</operator>
<name>encoding</name> <operator>==</operator> <name>ZIP_INT_24B</name> <operator>||</operator> <name>encoding</name> <operator>==</operator> <name>ZIP_INT_64B</name> <operator>||</operator>
<name>encoding</name> <operator>==</operator> <name>ZIP_INT_8B</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&gt;=</operator> <name>ZIP_INT_IMM_MIN</name> <operator>&amp;&amp;</operator> <name>encoding</name> <operator>&lt;=</operator> <name>ZIP_INT_IMM_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_STR_06B</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_STR_14B</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_STR_32B</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">5</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>ZIP_ENCODING_SIZE_INVALID</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_ASSERT_ENCODING</name><parameter_list>(<parameter><type><name>encoding</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { assert(zipEncodingLenSize(encoding) != ZIP_ENCODING_SIZE_INVALID); } while (0)</cpp:value></cpp:define>




<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>int</name></type> <name>zipIntSize</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>encoding</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch<condition>(<expr><name>encoding</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ZIP_INT_8B</name></expr>:</case> <return>return <expr><literal type="number">1</literal></expr>;</return>
<case>case <expr><name>ZIP_INT_16B</name></expr>:</case> <return>return <expr><literal type="number">2</literal></expr>;</return>
<case>case <expr><name>ZIP_INT_24B</name></expr>:</case> <return>return <expr><literal type="number">3</literal></expr>;</return>
<case>case <expr><name>ZIP_INT_32B</name></expr>:</case> <return>return <expr><literal type="number">4</literal></expr>;</return>
<case>case <expr><name>ZIP_INT_64B</name></expr>:</case> <return>return <expr><literal type="number">8</literal></expr>;</return>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>&gt;=</operator> <name>ZIP_INT_IMM_MIN</name> <operator>&amp;&amp;</operator> <name>encoding</name> <operator>&lt;=</operator> <name>ZIP_INT_IMM_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>redis_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>













<function><type><name>unsigned</name> <name>int</name></type> <name>zipStoreEntryEncoding</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>encoding</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>rawlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name><name>buf</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ZIP_IS_STR</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>rawlen</name> <operator>&lt;=</operator> <literal type="number">0x3f</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ZIP_STR_06B</name> <operator>|</operator> <name>rawlen</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rawlen</name> <operator>&lt;=</operator> <literal type="number">0x3fff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ZIP_STR_14B</name> <operator>|</operator> <operator>(</operator><operator>(</operator><name>rawlen</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>rawlen</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ZIP_STR_32B</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>rawlen</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>rawlen</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>rawlen</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>rawlen</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>encoding</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_DECODE_LENGTH</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>encoding</name></type></parameter>, <parameter><type><name>lensize</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((encoding) &lt; ZIP_STR_MASK) { if ((encoding) == ZIP_STR_06B) { (lensize) = 1; (len) = (ptr)[0] &amp; 0x3f; } else if ((encoding) == ZIP_STR_14B) { (lensize) = 2; (len) = (((ptr)[0] &amp; 0x3f) &lt;&lt; 8) | (ptr)[1]; } else if ((encoding) == ZIP_STR_32B) { (lensize) = 5; (len) = ((uint32_t)(ptr)[1] &lt;&lt; 24) | ((uint32_t)(ptr)[2] &lt;&lt; 16) | ((uint32_t)(ptr)[3] &lt;&lt; 8) | ((uint32_t)(ptr)[4]); } else { (lensize) = 0; (len) = 0; } } else { (lensize) = 1; if ((encoding) == ZIP_INT_8B) (len) = 1; else if ((encoding) == ZIP_INT_16B) (len) = 2; else if ((encoding) == ZIP_INT_24B) (len) = 3; else if ((encoding) == ZIP_INT_32B) (len) = 4; else if ((encoding) == ZIP_INT_64B) (len) = 8; else if (encoding &gt;= ZIP_INT_IMM_MIN &amp;&amp; encoding &lt;= ZIP_INT_IMM_MAX) (len) = 0; else (lensize) = (len) = 0; } } while(0)</cpp:value></cpp:define>


































<function><type><name>int</name></type> <name>zipStorePrevEntryLengthLarge</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>u32</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ZIP_BIG_PREVLEN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>u32</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>u32</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>u32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memrev32ifbe</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>



<function><type><name>unsigned</name> <name>int</name></type> <name>zipStorePrevEntryLength</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>len</name> <operator>&lt;</operator> <name>ZIP_BIG_PREVLEN</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>ZIP_BIG_PREVLEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name>zipStorePrevEntryLengthLarge</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_DECODE_PREVLENSIZE</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>prevlensize</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((ptr)[0] &lt; ZIP_BIG_PREVLEN) { (prevlensize) = 1; } else { (prevlensize) = 5; } } while(0)</cpp:value></cpp:define>














<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZIP_DECODE_PREVLEN</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>prevlensize</name></type></parameter>, <parameter><type><name>prevlen</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { ZIP_DECODE_PREVLENSIZE(ptr, prevlensize); if ((prevlensize) == 1) { (prevlen) = (ptr)[0]; } else { (prevlen) = ((ptr)[4] &lt;&lt; 24) | ((ptr)[3] &lt;&lt; 16) | ((ptr)[2] &lt;&lt; 8) | ((ptr)[1]); } } while(0)</cpp:value></cpp:define>


























<function><type><name>int</name></type> <name>zipPrevLenByteDiff</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>prevlensize</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ZIP_DECODE_PREVLENSIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevlensize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>zipStorePrevEntryLength</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>prevlensize</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>int</name></type> <name>zipTryEncoding</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>entrylen</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>value</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>entrylen</name> <operator>&gt;=</operator> <literal type="number">32</literal> <operator>||</operator> <name>entrylen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>string2ll</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>entry</name></expr></argument>,<argument><expr><name>entrylen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>value</name> <operator>&lt;=</operator> <literal type="number">12</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>encoding</name> <operator>=</operator> <name>ZIP_INT_IMM_MIN</name><operator>+</operator><name>value</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <name>INT8_MIN</name> <operator>&amp;&amp;</operator> <name>value</name> <operator>&lt;=</operator> <name>INT8_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>encoding</name> <operator>=</operator> <name>ZIP_INT_8B</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <name>INT16_MIN</name> <operator>&amp;&amp;</operator> <name>value</name> <operator>&lt;=</operator> <name>INT16_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>encoding</name> <operator>=</operator> <name>ZIP_INT_16B</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <name>INT24_MIN</name> <operator>&amp;&amp;</operator> <name>value</name> <operator>&lt;=</operator> <name>INT24_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>encoding</name> <operator>=</operator> <name>ZIP_INT_24B</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <name>INT32_MIN</name> <operator>&amp;&amp;</operator> <name>value</name> <operator>&lt;=</operator> <name>INT32_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>encoding</name> <operator>=</operator> <name>ZIP_INT_32B</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>encoding</name> <operator>=</operator> <name>ZIP_INT_64B</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>v</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>zipSaveInteger</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>encoding</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int16_t</name></type> <name>i16</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>i32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>i64</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_INT_8B</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>int8_t</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <operator>(</operator><name>int8_t</name><operator>)</operator><name>value</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_INT_16B</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i16</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>i16</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memrev16ifbe</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_INT_24B</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i32</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name>value</name><operator>)</operator><operator>&lt;&lt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memrev32ifbe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>i32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>i32</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i32</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_INT_32B</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i32</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>i32</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memrev32ifbe</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_INT_64B</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i64</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>i64</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memrev64ifbe</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>encoding</name> <operator>&gt;=</operator> <name>ZIP_INT_IMM_MIN</name> <operator>&amp;&amp;</operator> <name>encoding</name> <operator>&lt;=</operator> <name>ZIP_INT_IMM_MAX</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>int64_t</name></type> <name>zipLoadInteger</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name></type> <name>encoding</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int16_t</name></type> <name>i16</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>i32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>i64</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_INT_8B</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int8_t</name><operator>*</operator><operator>)</operator><name>p</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_INT_16B</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>i16</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memrev16ifbe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>i16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>i16</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_INT_32B</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>i32</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memrev32ifbe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>i32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>i32</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_INT_24B</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i32</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>i32</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i32</name></expr></argument>)</argument_list></sizeof><operator>-</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memrev32ifbe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>i32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>i32</name><operator>&gt;&gt;</operator><literal type="number">8</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>encoding</name> <operator>==</operator> <name>ZIP_INT_64B</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>i64</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memrev64ifbe</name><argument_list>(<argument><expr><operator>&amp;</operator><name>i64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>i64</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>encoding</name> <operator>&gt;=</operator> <name>ZIP_INT_IMM_MIN</name> <operator>&amp;&amp;</operator> <name>encoding</name> <operator>&lt;=</operator> <name>ZIP_INT_IMM_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>encoding</name> <operator>&amp;</operator> <name>ZIP_INT_IMM_MASK</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>zipEntry</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>zlentry</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>ZIP_DECODE_PREVLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>prevrawlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZIP_ENTRY_ENCODING</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZIP_DECODE_LENGTH</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>lensize</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>lensize</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>headersize</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>lensize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>zipEntrySafe</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>zl</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zlbytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>zlentry</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>validate_prevlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zlfirst</name> <init>= <expr><name>zl</name> <operator>+</operator> <name>ZIPLIST_HEADER_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zllast</name> <init>= <expr><name>zl</name> <operator>+</operator> <name>zlbytes</name> <operator>-</operator> <name>ZIPLIST_END_SIZE</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUT_OF_RANGE</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(unlikely((p) &lt; zlfirst || (p) &gt; zllast))</cpp:value></cpp:define>



<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>zlfirst</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>+</operator> <literal type="number">10</literal> <operator>&lt;</operator> <name>zllast</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ZIP_DECODE_PREVLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>prevrawlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZIP_ENTRY_ENCODING</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZIP_DECODE_LENGTH</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>lensize</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>headersize</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>lensize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>lensize</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>OUT_OF_RANGE</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>headersize</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>validate_prevlen</name> <operator>&amp;&amp;</operator> <call><name>OUT_OF_RANGE</name><argument_list>(<argument><expr><name>p</name> <operator>-</operator> <name><name>e</name><operator>-&gt;</operator><name>prevrawlen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>OUT_OF_RANGE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>ZIP_DECODE_PREVLENSIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>OUT_OF_RANGE</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>ZIP_ENTRY_ENCODING</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>lensize</name></name> <operator>=</operator> <call><name>zipEncodingLenSize</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>lensize</name></name> <operator>==</operator> <name>ZIP_ENCODING_SIZE_INVALID</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>OUT_OF_RANGE</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>lensize</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>ZIP_DECODE_PREVLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>prevrawlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZIP_DECODE_LENGTH</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>encoding</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>lensize</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>headersize</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>prevrawlensize</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>lensize</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>OUT_OF_RANGE</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>headersize</name></name> <operator>+</operator> <name><name>e</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>validate_prevlen</name> <operator>&amp;&amp;</operator> <call><name>OUT_OF_RANGE</name><argument_list>(<argument><expr><name>p</name> <operator>-</operator> <name><name>e</name><operator>-&gt;</operator><name>prevrawlen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>OUT_OF_RANGE</name></cpp:undef>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>int</name></type> <name>zipRawEntryLengthSafe</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>zl</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zlbytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zlentry</name></type> <name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>zipEntrySafe</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>zlbytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>e</name><operator>.</operator><name>headersize</name></name> <operator>+</operator> <name><name>e</name><operator>.</operator><name>len</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>int</name></type> <name>zipRawEntryLength</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zlentry</name></type> <name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zipEntry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>e</name><operator>.</operator><name>headersize</name></name> <operator>+</operator> <name><name>e</name><operator>.</operator><name>len</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>zipAssertValidEntry</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>zl</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>zlbytes</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zlentry</name></type> <name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>zipEntrySafe</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>zlbytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ziplistNew</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bytes</name> <init>= <expr><name>ZIPLIST_HEADER_SIZE</name><operator>+</operator><name>ZIPLIST_END_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>intrev32ifbe</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>intrev32ifbe</name><argument_list>(<argument><expr><name>ZIPLIST_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZIPLIST_LENGTH</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zl</name><index>[<expr><name>bytes</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>ZIP_END</name></expr>;</expr_stmt>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ziplistResize</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;</operator> <name>UINT32_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>intrev32ifbe</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zl</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>ZIP_END</name></expr>;</expr_stmt>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>





















<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>__ziplistCascadeUpdate</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zlentry</name></type> <name>cur</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>prevlen</name></decl>, <decl><type ref="prev"/><name>prevlensize</name></decl>, <decl><type ref="prev"/><name>prevoffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>firstentrylen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>rawlen</name></decl>, <decl><type ref="prev"/><name>curlen</name> <init>= <expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>extra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>delta</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><name>zl</name> <operator>+</operator> <call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ZIP_END</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>zl</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>zipEntry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>firstentrylen</name> <operator>=</operator> <name>prevlen</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>headersize</name></name> <operator>+</operator> <name><name>cur</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>prevlensize</name> <operator>=</operator> <call><name>zipStorePrevEntryLength</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prevoffset</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>zl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>prevlen</name></expr>;</expr_stmt>


<while>while <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>zipEntrySafe</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>curlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cur</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>.</operator><name>prevrawlen</name></name> <operator>==</operator> <name>prevlen</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>.</operator><name>prevrawlensize</name></name> <operator>&gt;=</operator> <name>prevlensize</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>.</operator><name>prevrawlensize</name></name> <operator>==</operator> <name>prevlensize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zipStorePrevEntryLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><call><name>zipStorePrevEntryLengthLarge</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>cur</name><operator>.</operator><name>prevrawlen</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>cur</name><operator>.</operator><name>prevrawlen</name></name> <operator>+</operator> <name>delta</name> <operator>==</operator> <name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>rawlen</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>headersize</name></name> <operator>+</operator> <name><name>cur</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>prevlen</name> <operator>=</operator> <name>rawlen</name> <operator>+</operator> <name>delta</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prevlensize</name> <operator>=</operator> <call><name>zipStorePrevEntryLength</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prevoffset</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>zl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>rawlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>extra</name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>zl</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>tail</name> <operator>==</operator> <name>zl</name> <operator>+</operator> <name>prevoffset</name></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>-</operator> <name>delta</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call> <operator>=</operator>
<call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>+</operator><name>extra</name><operator>-</operator><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call> <operator>=</operator>
<call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>+</operator><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>zl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistResize</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>curlen</name> <operator>+</operator> <name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>zl</name> <operator>+</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>extra</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>curlen</name> <operator>-</operator> <name>offset</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>extra</name></expr>;</expr_stmt>


<while>while <condition>(<expr><name>cnt</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zipEntry</name><argument_list>(<argument><expr><name>zl</name> <operator>+</operator> <name>prevoffset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rawlen</name> <operator>=</operator> <name><name>cur</name><operator>.</operator><name>headersize</name></name> <operator>+</operator> <name><name>cur</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name> <operator>-</operator> <operator>(</operator><name>rawlen</name> <operator>-</operator> <name><name>cur</name><operator>.</operator><name>prevrawlensize</name></name><operator>)</operator></expr></argument>,
<argument><expr><name>zl</name> <operator>+</operator> <name>prevoffset</name> <operator>+</operator> <name><name>cur</name><operator>.</operator><name>prevrawlensize</name></name></expr></argument>,
<argument><expr><name>rawlen</name> <operator>-</operator> <name><name>cur</name><operator>.</operator><name>prevrawlensize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>-=</operator> <operator>(</operator><name>rawlen</name> <operator>+</operator> <name>delta</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cur</name><operator>.</operator><name>prevrawlen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>zipStorePrevEntryLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>firstentrylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>zipStorePrevEntryLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>cur</name><operator>.</operator><name>prevrawlen</name></name><operator>+</operator><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>prevoffset</name> <operator>-=</operator> <name><name>cur</name><operator>.</operator><name>prevrawlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>cnt</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>__ziplistDelete</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>totlen</name></decl>, <decl><type ref="prev"/><name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nextdiff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zlentry</name></type> <name>first</name></decl>, <decl><type ref="prev"/><name>tail</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>zlbytes</name> <init>= <expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>zipEntry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>ZIP_END</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>zipRawEntryLengthSafe</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>zlbytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>deleted</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>&gt;=</operator> <name><name>first</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>totlen</name> <operator>=</operator> <name>p</name><operator>-</operator><name><name>first</name><operator>.</operator><name>p</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>totlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>set_tail</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>nextdiff</name> <operator>=</operator> <call><name>zipPrevLenByteDiff</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name><name>first</name><operator>.</operator><name>prevrawlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>p</name> <operator>-=</operator> <name>nextdiff</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>&gt;=</operator> <name><name>first</name><operator>.</operator><name>p</name></name> <operator>&amp;&amp;</operator> <name>p</name><operator>&lt;</operator><name>zl</name><operator>+</operator><name>zlbytes</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zipStorePrevEntryLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name><name>first</name><operator>.</operator><name>prevrawlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>set_tail</name> <operator>=</operator> <call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>-</operator><name>totlen</name></expr>;</expr_stmt>




<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>zipEntrySafe</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>zlbytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name><name>tail</name><operator>.</operator><name>headersize</name></name><operator>+</operator><name><name>tail</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>!=</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>set_tail</name> <operator>=</operator> <name>set_tail</name> <operator>+</operator> <name>nextdiff</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<decl_stmt><decl><type><name>size_t</name></type> <name>bytes_to_move</name> <init>= <expr><name>zlbytes</name><operator>-</operator><operator>(</operator><name>p</name><operator>-</operator><name>zl</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>first</name><operator>.</operator><name>p</name></name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>bytes_to_move</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>set_tail</name> <operator>=</operator> <operator>(</operator><name><name>first</name><operator>.</operator><name>p</name></name><operator>-</operator><name>zl</name><operator>)</operator><operator>-</operator><name><name>first</name><operator>.</operator><name>prevrawlen</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>first</name><operator>.</operator><name>p</name></name><operator>-</operator><name>zl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>zlbytes</name> <operator>-=</operator> <name>totlen</name> <operator>-</operator> <name>nextdiff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistResize</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>zlbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>zl</name><operator>+</operator><name>offset</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>ZIPLIST_INCR_LENGTH</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>-</operator><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>set_tail</name> <operator>&lt;=</operator> <name>zlbytes</name> <operator>-</operator> <name>ZIPLIST_END_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>intrev32ifbe</name><argument_list>(<argument><expr><name>set_tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>nextdiff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>__ziplistCascadeUpdate</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>__ziplistInsert</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>slen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>curlen</name> <init>= <expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>reqlen</name></decl>, <decl><type ref="prev"/><name>newlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>prevlensize</name></decl>, <decl><type ref="prev"/><name>prevlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nextdiff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>encoding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>value</name> <init>= <expr><literal type="number">123456789</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>zlentry</name></type> <name>tail</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ZIP_DECODE_PREVLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevlensize</name></expr></argument>, <argument><expr><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptail</name> <init>= <expr><call><name>ZIPLIST_ENTRY_TAIL</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ptail</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prevlen</name> <operator>=</operator> <call><name>zipRawEntryLengthSafe</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>curlen</name></expr></argument>, <argument><expr><name>ptail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>zipTryEncoding</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>reqlen</name> <operator>=</operator> <call><name>zipIntSize</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<expr_stmt><expr><name>reqlen</name> <operator>=</operator> <name>slen</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>reqlen</name> <operator>+=</operator> <call><name>zipStorePrevEntryLength</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>reqlen</name> <operator>+=</operator> <call><name>zipStoreEntryEncoding</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>encoding</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<decl_stmt><decl><type><name>int</name></type> <name>forcelarge</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>nextdiff</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>ZIP_END</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>zipPrevLenByteDiff</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>reqlen</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nextdiff</name> <operator>==</operator> <operator>-</operator><literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>reqlen</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nextdiff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>forcelarge</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>p</name><operator>-</operator><name>zl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>newlen</name> <operator>=</operator> <name>curlen</name><operator>+</operator><name>reqlen</name><operator>+</operator><name>nextdiff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistResize</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>zl</name><operator>+</operator><name>offset</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>reqlen</name></expr></argument>,<argument><expr><name>p</name><operator>-</operator><name>nextdiff</name></expr></argument>,<argument><expr><name>curlen</name><operator>-</operator><name>offset</name><operator>-</operator><literal type="number">1</literal><operator>+</operator><name>nextdiff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>forcelarge</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>zipStorePrevEntryLengthLarge</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>reqlen</name></expr></argument>,<argument><expr><name>reqlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>zipStorePrevEntryLength</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name>reqlen</name></expr></argument>,<argument><expr><name>reqlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call> <operator>=</operator>
<call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>+</operator><name>reqlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>zipEntrySafe</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><name>reqlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>reqlen</name><operator>+</operator><name><name>tail</name><operator>.</operator><name>headersize</name></name><operator>+</operator><name><name>tail</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>!=</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call> <operator>=</operator>
<call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>+</operator><name>nextdiff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>intrev32ifbe</name><argument_list>(<argument><expr><name>p</name><operator>-</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<if_stmt><if>if <condition>(<expr><name>nextdiff</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>p</name><operator>-</operator><name>zl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>__ziplistCascadeUpdate</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>p</name><operator>+</operator><name>reqlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>zl</name><operator>+</operator><name>offset</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>zipStorePrevEntryLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>zipStoreEntryEncoding</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>encoding</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ZIP_IS_STR</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>zipSaveInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>value</name></expr></argument>,<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>ZIPLIST_INCR_LENGTH</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>
















<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ziplistMerge</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>first</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>second</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>first</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>first</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>second</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>second</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>first</name> <operator>==</operator> <operator>*</operator><name>second</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>first_bytes</name> <init>= <expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><operator>*</operator><name>first</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>first_len</name> <init>= <expr><call><name>intrev16ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_LENGTH</name><argument_list>(<argument><expr><operator>*</operator><name>first</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>second_bytes</name> <init>= <expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><operator>*</operator><name>second</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>second_len</name> <init>= <expr><call><name>intrev16ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_LENGTH</name><argument_list>(<argument><expr><operator>*</operator><name>second</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>append</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>source</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>target_bytes</name></decl>, <decl><type ref="prev"/><name>source_bytes</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>first_len</name> <operator>&gt;=</operator> <name>second_len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>*</operator><name>first</name></expr>;</expr_stmt>
<expr_stmt><expr><name>target_bytes</name> <operator>=</operator> <name>first_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>source</name> <operator>=</operator> <operator>*</operator><name>second</name></expr>;</expr_stmt>
<expr_stmt><expr><name>source_bytes</name> <operator>=</operator> <name>second_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>append</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>target</name> <operator>=</operator> <operator>*</operator><name>second</name></expr>;</expr_stmt>
<expr_stmt><expr><name>target_bytes</name> <operator>=</operator> <name>second_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>source</name> <operator>=</operator> <operator>*</operator><name>first</name></expr>;</expr_stmt>
<expr_stmt><expr><name>source_bytes</name> <operator>=</operator> <name>first_bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>append</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>zlbytes</name> <init>= <expr><name>first_bytes</name> <operator>+</operator> <name>second_bytes</name> <operator>-</operator>
<name>ZIPLIST_HEADER_SIZE</name> <operator>-</operator> <name>ZIPLIST_END_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>zllength</name> <init>= <expr><name>first_len</name> <operator>+</operator> <name>second_len</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>zllength</name> <operator>=</operator> <ternary><condition><expr><name>zllength</name> <operator>&lt;</operator> <name>UINT16_MAX</name></expr> ?</condition><then> <expr><name>zllength</name></expr> </then><else>: <expr><name>UINT16_MAX</name></expr></else></ternary></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zlbytes</name> <operator>&lt;</operator> <name>UINT32_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>first_offset</name> <init>= <expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><operator>*</operator><name>first</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>second_offset</name> <init>= <expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><operator>*</operator><name>second</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>zlbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>append</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>target</name> <operator>+</operator> <name>target_bytes</name> <operator>-</operator> <name>ZIPLIST_END_SIZE</name></expr></argument>,
<argument><expr><name>source</name> <operator>+</operator> <name>ZIPLIST_HEADER_SIZE</name></expr></argument>,
<argument><expr><name>source_bytes</name> <operator>-</operator> <name>ZIPLIST_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>target</name> <operator>+</operator> <name>source_bytes</name> <operator>-</operator> <name>ZIPLIST_END_SIZE</name></expr></argument>,
<argument><expr><name>target</name> <operator>+</operator> <name>ZIPLIST_HEADER_SIZE</name></expr></argument>,
<argument><expr><name>target_bytes</name> <operator>-</operator> <name>ZIPLIST_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>source_bytes</name> <operator>-</operator> <name>ZIPLIST_END_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>intrev32ifbe</name><argument_list>(<argument><expr><name>zlbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZIPLIST_LENGTH</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>intrev16ifbe</name><argument_list>(<argument><expr><name>zllength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>intrev32ifbe</name><argument_list>(
<argument><expr><operator>(</operator><name>first_bytes</name> <operator>-</operator> <name>ZIPLIST_END_SIZE</name><operator>)</operator> <operator>+</operator>
<operator>(</operator><name>second_offset</name> <operator>-</operator> <name>ZIPLIST_HEADER_SIZE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>__ziplistCascadeUpdate</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>target</name><operator>+</operator><name>first_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>append</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><operator>*</operator><name>second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>second</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>first</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><operator>*</operator><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>first</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>second</name> <operator>=</operator> <name>target</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>target</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ziplistPush</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>slen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>where</name> <operator>==</operator> <name>ZIPLIST_HEAD</name><operator>)</operator></expr> ?</condition><then> <expr><call><name>ZIPLIST_ENTRY_HEAD</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>ZIPLIST_ENTRY_END</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<return>return <expr><call><name>__ziplistInsert</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ziplistIndex</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>prevlensize</name></decl>, <decl><type ref="prev"/><name>prevlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>zlbytes</name> <init>= <expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><operator>-</operator><name>index</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ZIPLIST_ENTRY_TAIL</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>ZIP_DECODE_PREVLENSIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevlensize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>prevlensize</name> <operator>&lt;</operator> <name>zl</name> <operator>+</operator> <name>zlbytes</name> <operator>-</operator> <name>ZIPLIST_END_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZIP_DECODE_PREVLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevlensize</name></expr></argument>, <argument><expr><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>prevlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>index</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>-=</operator> <name>prevlen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>&gt;=</operator> <name>zl</name> <operator>+</operator> <name>ZIPLIST_HEADER_SIZE</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&lt;</operator> <name>zl</name> <operator>+</operator> <name>zlbytes</name> <operator>-</operator> <name>ZIPLIST_END_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ZIP_DECODE_PREVLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevlensize</name></expr></argument>, <argument><expr><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ZIPLIST_ENTRY_HEAD</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>index</name><operator>--</operator></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>zipRawEntryLengthSafe</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>zlbytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ZIP_END</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ZIP_END</name> <operator>||</operator> <name>index</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>zipAssertValidEntry</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>zlbytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>







<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ziplistNext</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>void</name><operator>)</operator> <name>zl</name><operator>)</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>zlbytes</name> <init>= <expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>zipRawEntryLength</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>zipAssertValidEntry</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>zlbytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ziplistPrev</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>prevlensize</name></decl>, <decl><type ref="prev"/><name>prevlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ZIPLIST_ENTRY_TAIL</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ZIP_END</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>p</name></expr></else></ternary></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>p</name> <operator>==</operator> <call><name>ZIPLIST_ENTRY_HEAD</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>ZIP_DECODE_PREVLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prevlensize</name></expr></argument>, <argument><expr><name>prevlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>prevlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>-=</operator><name>prevlen</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>zlbytes</name> <init>= <expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zipAssertValidEntry</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>zlbytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>





<function><type><name>unsigned</name> <name>int</name></type> <name>ziplistGet</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sstr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name> <modifier>*</modifier></type><name>slen</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name> <modifier>*</modifier></type><name>sval</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zlentry</name></type> <name>entry</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ZIP_END</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sstr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>sstr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>zipEntry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ZIP_IS_STR</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sstr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>slen</name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>sstr</name> <operator>=</operator> <name>p</name><operator>+</operator><name><name>entry</name><operator>.</operator><name>headersize</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>sval</name> <operator>=</operator> <call><name>zipLoadInteger</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name><name>entry</name><operator>.</operator><name>headersize</name></name></expr></argument>,<argument><expr><name><name>entry</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ziplistInsert</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>slen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>__ziplistInsert</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ziplistDelete</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><operator>*</operator><name>p</name><operator>-</operator><name>zl</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>__ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>*</operator><name>p</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>zl</name><operator>+</operator><name>offset</name></expr>;</expr_stmt>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ziplistDeleteRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>p</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>zl</name></expr> </then><else>: <expr><call><name>__ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>



<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ziplistReplace</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>slen</name></decl></parameter>)</parameter_list> <block>{<block_content>


<decl_stmt><decl><type><name>zlentry</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zipEntry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>reqlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>encoding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>value</name> <init>= <expr><literal type="number">123456789</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>zipTryEncoding</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>reqlen</name> <operator>=</operator> <call><name>zipIntSize</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>reqlen</name> <operator>=</operator> <name>slen</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>reqlen</name> <operator>+=</operator> <call><name>zipStoreEntryEncoding</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>encoding</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>reqlen</name> <operator>==</operator> <name><name>entry</name><operator>.</operator><name>lensize</name></name> <operator>+</operator> <name><name>entry</name><operator>.</operator><name>len</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>entry</name><operator>.</operator><name>prevrawlensize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>zipStoreEntryEncoding</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>encoding</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ZIP_IS_STR</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>zipSaveInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>value</name></expr></argument>,<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistInsert</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>p</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>unsigned</name> <name>int</name></type> <name>ziplistCompare</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sstr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>slen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zlentry</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>sencoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>zval</name></decl>, <decl><type ref="prev"/><name>sval</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>ZIP_END</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>zipEntry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ZIP_IS_STR</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>len</name></name> <operator>==</operator> <name>slen</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name><name>entry</name><operator>.</operator><name>headersize</name></name></expr></argument>,<argument><expr><name>sstr</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>zipTryEncoding</name><argument_list>(<argument><expr><name>sstr</name></expr></argument>,<argument><expr><name>slen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sval</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sencoding</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>zval</name> <operator>=</operator> <call><name>zipLoadInteger</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><name><name>entry</name><operator>.</operator><name>headersize</name></name></expr></argument>,<argument><expr><name><name>entry</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>zval</name> <operator>==</operator> <name>sval</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>



<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ziplistFind</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>skip</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>skipcnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>vencoding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>vll</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>zlbytes</name> <init>= <expr><call><name>ziplistBlobLen</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zlentry</name></name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>zipEntrySafe</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>zlbytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name><name>e</name><operator>.</operator><name>prevrawlensize</name></name> <operator>+</operator> <name><name>e</name><operator>.</operator><name>lensize</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>skipcnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ZIP_IS_STR</name><argument_list>(<argument><expr><name><name>e</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>.</operator><name>len</name></name> <operator>==</operator> <name>vlen</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>vstr</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>vencoding</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zipTryEncoding</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vll</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vencoding</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>vencoding</name> <operator>=</operator> <name>UCHAR_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>vencoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>vencoding</name> <operator>!=</operator> <name>UCHAR_MAX</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>ll</name> <init>= <expr><call><name>zipLoadInteger</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>e</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ll</name> <operator>==</operator> <name>vll</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>skipcnt</name> <operator>=</operator> <name>skip</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>skipcnt</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name> <operator>+</operator> <name><name>e</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>unsigned</name> <name>int</name></type> <name>ziplistLen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>intrev16ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_LENGTH</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>UINT16_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>intrev16ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_LENGTH</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>zl</name><operator>+</operator><name>ZIPLIST_HEADER_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>zlbytes</name> <init>= <expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>zipRawEntryLengthSafe</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>zlbytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>UINT16_MAX</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>ZIPLIST_LENGTH</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>intrev16ifbe</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>size_t</name></type> <name>ziplistBlobLen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ziplistRepr</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zlentry</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>zlbytes</name> <init>= <expr><call><name>ziplistBlobLen</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(
<argument><expr><literal type="string">"{total bytes %u} "</literal>
<literal type="string">"{num entries %u}\n"</literal>
<literal type="string">"{tail offset %u}\n"</literal></expr></argument>,
<argument><expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>intrev16ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_LENGTH</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ZIPLIST_ENTRY_HEAD</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>zipEntrySafe</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>zlbytes</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(
<argument><expr><literal type="string">"{\n"</literal>
<literal type="string">"\taddr 0x%08lx,\n"</literal>
<literal type="string">"\tindex %2d,\n"</literal>
<literal type="string">"\toffset %5lu,\n"</literal>
<literal type="string">"\thdr+entry len: %5u,\n"</literal>
<literal type="string">"\thdr len%2u,\n"</literal>
<literal type="string">"\tprevrawlen: %5u,\n"</literal>
<literal type="string">"\tprevrawlensize: %2u,\n"</literal>
<literal type="string">"\tpayload %5u\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>long</name> <name>unsigned</name><operator>)</operator><name>p</name></expr></argument>,
<argument><expr><name>index</name></expr></argument>,
<argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <operator>(</operator><name>p</name><operator>-</operator><name>zl</name><operator>)</operator></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>headersize</name></name><operator>+</operator><name><name>entry</name><operator>.</operator><name>len</name></name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>headersize</name></name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>prevrawlen</name></name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>prevrawlensize</name></name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\tbytes: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>.</operator><name>headersize</name></name><operator>+</operator><name><name>entry</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%02x|"</literal></expr></argument>,<argument><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>entry</name><operator>.</operator><name>headersize</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ZIP_IS_STR</name><argument_list>(<argument><expr><name><name>entry</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t[str]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">40</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><literal type="number">40</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>len</name></name> <operator>&amp;&amp;</operator>
<call><name>fwrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name><name>entry</name><operator>.</operator><name>len</name></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t[int]%lld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator> <call><name>zipLoadInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name><name>entry</name><operator>.</operator><name>encoding</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>entry</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{end}\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>int</name></type> <name>ziplistValidateIntegrity</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deep</name></decl></parameter>,
<parameter><decl><type><name>ziplistValidateEntryCB</name></type> <name>entry_cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cb_userdata</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>ZIPLIST_HEADER_SIZE</name> <operator>+</operator> <name>ZIPLIST_END_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>bytes</name> <init>= <expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>!=</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>zl</name><index>[<expr><name>size</name> <operator>-</operator> <name>ZIPLIST_END_SIZE</name></expr>]</index></name> <operator>!=</operator> <name>ZIP_END</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_TAIL_OFFSET</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>size</name> <operator>-</operator> <name>ZIPLIST_END_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>deep</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>header_count</name> <init>= <expr><call><name>intrev16ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_LENGTH</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ZIPLIST_ENTRY_HEAD</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>prev_raw_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>ZIP_END</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>zlentry</name></name></type> <name>e</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zipEntrySafe</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>.</operator><name>prevrawlen</name></name> <operator>!=</operator> <name>prev_raw_size</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>entry_cb</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>entry_cb</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>header_count</name></expr></argument>, <argument><expr><name>cb_userdata</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>prev_raw_size</name> <operator>=</operator> <name><name>e</name><operator>.</operator><name>headersize</name></name> <operator>+</operator> <name><name>e</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <name><name>e</name><operator>.</operator><name>headersize</name></name> <operator>+</operator> <name><name>e</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>zl</name> <operator>+</operator> <name>bytes</name> <operator>-</operator> <name>ZIPLIST_END_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>!=</operator> <call><name>ZIPLIST_ENTRY_TAIL</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>header_count</name> <operator>!=</operator> <name>UINT16_MAX</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>!=</operator> <name>header_count</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>ziplistRandomPair</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>total_count</name></decl></parameter>, <parameter><decl><type><name>ziplistEntry</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>ziplistEntry</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>total_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><operator>(</operator><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <name>total_count</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>sval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>slen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>key</name><operator>-&gt;</operator><name>lval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>val</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>sval</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>slen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>lval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>uintCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><name>unsigned</name> <name>int</name> <operator>*</operator><operator>)</operator> <name>a</name> <operator>-</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>int</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>ziplistSaveValue</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name></type> <name>lval</name></decl></parameter>, <parameter><decl><type><name>ziplistEntry</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>sval</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>slen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name><operator>-&gt;</operator><name>lval</name></name> <operator>=</operator> <name>lval</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>ziplistRandomPairs</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>ziplistEntry</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>ziplistEntry</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>klen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>vlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>klval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>vlval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>order</name></decl>;</decl_stmt>
}</block></struct></type> <name>rand_pick</name>;</typedef>
<decl_stmt><decl><type><name>rand_pick</name> <modifier>*</modifier></type><name>picks</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rand_pick</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>total_size</name> <init>= <expr><call><name>ziplistLen</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>total_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>picks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>index</name> <operator>=</operator> <operator>(</operator><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <name>total_size</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>picks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>order</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>picks</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rand_pick</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>uintCompare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>zipindex</name> <init>= <expr><name><name>picks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>index</name></expr></init></decl>, <decl><type ref="prev"/><name>pickindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>zipindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klval</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>pickindex</name> <operator>&lt;</operator> <name>count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>pickindex</name> <operator>&lt;</operator> <name>count</name> <operator>&amp;&amp;</operator> <name>zipindex</name> <operator>==</operator> <name><name>picks</name><index>[<expr><name>pickindex</name></expr>]</index></name><operator>.</operator><name>index</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>storeorder</name> <init>= <expr><name><name>picks</name><index>[<expr><name>pickindex</name></expr>]</index></name><operator>.</operator><name>order</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ziplistSaveValue</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>klval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>keys</name><index>[<expr><name>storeorder</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vals</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ziplistSaveValue</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>vlval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vals</name><index>[<expr><name>storeorder</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pickindex</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>zipindex</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>picks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>unsigned</name> <name>int</name></type> <name>ziplistRandomPairsUnique</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>ziplistEntry</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>ziplistEntry</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>klen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>klval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>total_size</name> <init>= <expr><call><name>ziplistLen</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name>total_size</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>count</name> <operator>=</operator> <name>total_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>





<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>picked</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>remaining</name> <init>= <expr><name>count</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>picked</name> <operator>&lt;</operator> <name>count</name> <operator>&amp;&amp;</operator> <name>p</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>randomDouble</name> <init>= <expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><call><name>rand</name><argument_list>()</argument_list></call><operator>)</operator> <operator>/</operator> <name>RAND_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>threshold</name> <init>= <expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>remaining</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>total_size</name> <operator>-</operator> <name>index</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>randomDouble</name> <operator>&lt;=</operator> <name>threshold</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistSaveValue</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>klval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>keys</name><index>[<expr><name>picked</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vals</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>klval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistSaveValue</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>klval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>vals</name><index>[<expr><name>picked</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>picked</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>picked</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>REDIS_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"adlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"testhelp.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>debug</name><parameter_list>(<parameter><type><name>f</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if (DEBUG) printf(f, __VA_ARGS__); }</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>createList</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><call><name>ziplistNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"foo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"quux"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>ZIPLIST_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>createIntList</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><call><name>ziplistNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"100"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"128000"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"-100"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ZIPLIST_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"4294967296"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ZIPLIST_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"non integer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"much much longer non integer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>long</name> <name>long</name></type> <name>usec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator><operator>*</operator><literal type="number">1000000</literal><operator>)</operator><operator>+</operator><name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>stress</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxsize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dnum</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>j</name></decl>,<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>posstr</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">5</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="string">"HEAD"</literal></expr>, <expr><literal type="string">"TAIL"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>start</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>maxsize</name></expr>;</condition> <incr><expr><name>i</name><operator>+=</operator><name>dnum</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"quux"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>,<argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>usec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"quux"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>,<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDeleteRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"List size: %8d, bytes: %8d, %dx push+pop (%s): %6lld usec\n"</literal></expr></argument>,
<argument><expr><name>i</name></expr></argument>,<argument><expr><call><name>intrev32ifbe</name><argument_list>(<argument><expr><call><name>ZIPLIST_BYTES</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>num</name></expr></argument>,<argument><expr><name><name>posstr</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>,<argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pop</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>vlong</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><ternary><condition><expr><name>where</name> <operator>==</operator> <name>ZIPLIST_HEAD</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name>ZIPLIST_HEAD</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Pop head: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Pop tail: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vstr</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>vlen</name> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: Could not pop\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>randstring</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>max</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>min</name><operator>+</operator><call><name>rand</name><argument_list>()</argument_list></call><operator>%</operator><operator>(</operator><name>max</name><operator>-</operator><name>min</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>minval</name></decl>, <decl><type ref="prev"/><name>maxval</name></decl>;</decl_stmt>
<switch>switch<condition>(<expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name>minval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>minval</name> <operator>=</operator> <literal type="number">48</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>=</operator> <literal type="number">122</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>minval</name> <operator>=</operator> <literal type="number">48</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>=</operator> <literal type="number">52</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>target</name><index>[<expr><name>p</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>minval</name><operator>+</operator><call><name>rand</name><argument_list>()</argument_list></call><operator>%</operator><operator>(</operator><name>maxval</name><operator>-</operator><name>minval</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>verify</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zlentry</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>ziplistLen</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zlentry</name></type> <name>_e</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ZIPLIST_ENTRY_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>_e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zlentry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zipEntry</name><argument_list>(<argument><expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>e</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>_e</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zlentry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zipEntry</name><argument_list>(<argument><expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>-</operator><name>len</name><operator>+</operator><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>_e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>e</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_e</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zlentry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>insertHelper</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;=</operator> <name>ZIP_BIG_PREVLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>data</name><index>[<expr><name>ZIP_BIG_PREVLEN</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ziplistInsert</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>compareHelper</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;=</operator> <name>ZIP_BIG_PREVLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>data</name><index>[<expr><name>ZIP_BIG_PREVLEN</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>strEntryBytesSmall</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>slen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>slen</name> <operator>+</operator> <call><name>zipStorePrevEntryLength</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>zipStoreEntryEncoding</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>strEntryBytesLarge</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>slen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>slen</name> <operator>+</operator> <call><name>zipStorePrevEntryLength</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ZIP_BIG_PREVLEN</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>zipStoreEntryEncoding</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>ziplistTest</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>accurate</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REDIS_TEST_ACCURATE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>elen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>iteration</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>srand</name><argument_list>(<argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createIntList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>pop</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>pop</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>ZIPLIST_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>pop</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>pop</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Get element at index 3:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: Could not access index 3\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>elen</name> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,<argument><expr><name>elen</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld\n"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Get element at index 4 (out of range):\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"No entry\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: Out of range index should return NULL, returned offset: %ld\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>p</name><operator>-</operator><name>zl</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Get element at index -1 (last element):\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: Could not access index -1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>elen</name> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,<argument><expr><name>elen</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld\n"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Get element at index -4 (first element):\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: Could not access index -4\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>elen</name> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,<argument><expr><name>elen</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld\n"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Get element at index -5 (reverse out of range):\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"No entry\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: Out of range index should return NULL, returned offset: %ld\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><operator>(</operator><name>p</name><operator>-</operator><name>zl</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Iterate list from 0 to end:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Entry: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>elen</name> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,<argument><expr><name>elen</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Iterate list from 1 to end:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Entry: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>elen</name> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,<argument><expr><name>elen</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Iterate list from 2 to end:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Entry: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>elen</name> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,<argument><expr><name>elen</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Iterate starting out of range:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"No entry\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Iterate from back to front:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Entry: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>elen</name> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,<argument><expr><name>elen</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Iterate from back to front, deleting all items:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Entry: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>elen</name> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,<argument><expr><name>elen</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Delete inclusive range 0,0:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDeleteRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Delete inclusive range 0,1:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDeleteRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Delete inclusive range 1,2:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDeleteRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Delete with start index out of range:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDeleteRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Delete with num overflow:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDeleteRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Delete foo while iterating:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>elen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"foo"</literal></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>entry</name></expr></argument>,<argument><expr><name>elen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Delete foo\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Entry: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>elen</name> <operator>&amp;&amp;</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,<argument><expr><name>elen</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>stdout</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr><literal type="string">"fwrite"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld"</literal></expr></argument>,<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Replace with same size:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>orig_zl</name> <init>= <expr><name>zl</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistReplace</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"zoink"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistReplace</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"yy"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistReplace</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"65536"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>memcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>,
<argument><expr><literal type="string">"\x00\x05zoink"</literal>
<literal type="string">"\x07\xf0\x00\x00\x01"</literal>
<literal type="string">"\x05\x04quux"</literal> <literal type="string">"\x06\x02yy"</literal> <literal type="string">"\xff"</literal></expr></argument>,
<argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>zl</name> <operator>==</operator> <name>orig_zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SUCCESS\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Replace with different size:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistReplace</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"squirrel"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name></expr></argument>,
<argument><expr><literal type="string">"\x00\x05hello"</literal> <literal type="string">"\x07\x08squirrel"</literal> <literal type="string">"\x0a\x04quux"</literal>
<literal type="string">"\x06\xc0\x00\x04"</literal> <literal type="string">"\xff"</literal></expr></argument>,
<argument><expr><literal type="number">28</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SUCCESS\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Regression test for &gt;255 byte strings:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>v1</name><index>[<expr><literal type="number">257</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>, <decl><type ref="prev"/><name><name>v2</name><index>[<expr><literal type="number">257</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>v1</name></expr></argument>,<argument><expr><literal type="char">'x'</literal></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>v2</name></expr></argument>,<argument><expr><literal type="char">'y'</literal></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>v1</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>v2</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>v2</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>elen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name>v1</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>entry</name></expr></argument>,<argument><expr><name>elen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>elen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name>v2</name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>entry</name></expr></argument>,<argument><expr><name>elen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SUCCESS\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Regression test deleting next to last entries:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>v</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">257</literal></expr>]</index></name> <init>= <expr><block>{<expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zlentry</name></type> <name><name>e</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><block>{<expr><operator>.</operator><name>prevrawlensize</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>prevrawlen</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>lensize</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><operator>.</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>headersize</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>encoding</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>p</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>v</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'a'</literal> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>v</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>v</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">256</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[ <expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">256</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>v</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>verify</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>p</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>verify</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SUCCESS\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Create long list and check indices:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%d"</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>-</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">999</literal><operator>-</operator><name>i</name> <operator>==</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SUCCESS. usec=%lld\n\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Compare strings with ziplist entries:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hello"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: not \"hello\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hella"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: \"hella\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: not \"1024\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1025"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: \"1025\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SUCCESS\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Merge test:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>

<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>createList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl2</name> <init>= <expr><call><name>createList</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl3</name> <init>= <expr><call><name>ziplistNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl4</name> <init>= <expr><call><name>ziplistNew</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ziplistMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zl4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl4</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: Allowed merging of one ziplist into itself.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>zl4</name> <operator>=</operator> <call><name>ziplistMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zl3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ziplistLen</name><argument_list>(<argument><expr><name>zl4</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: Merging two empty ziplists created entries.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>zl2</name> <operator>=</operator> <call><name>ziplistMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ziplistLen</name><argument_list>(<argument><expr><name>zl2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: Merged length not 8, but: %u\n"</literal></expr></argument>, <argument><expr><call><name>ziplistLen</name><argument_list>(<argument><expr><name>zl2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl2</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hello"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: not \"hello\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hella"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: \"hella\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl2</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: not \"1024\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1025"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: \"1025\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl2</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hello"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: not \"hello\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"hella"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: \"hella\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl2</name></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1024"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: not \"1024\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1025"</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: \"1025\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"SUCCESS\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Stress with random payloads of different encoding:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>j</name></decl>,<decl><type ref="prev"/><name>len</name></decl>,<decl><type ref="prev"/><name>where</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>buflen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>list</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>listNode</name> <modifier>*</modifier></type><name>refnode</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>slen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>sval</name></decl>;</decl_stmt>

<expr_stmt><expr><name>iteration</name> <operator>=</operator> <ternary><condition><expr><name>accurate</name></expr> ?</condition><then> <expr><literal type="number">20000</literal></expr> </then><else>: <expr><literal type="number">20</literal></expr></else></ternary></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iteration</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ref</name> <operator>=</operator> <call><name>listCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>listSetFreeMethod</name><argument_list>(<argument><expr><name>ref</name></expr></argument>,<argument><expr><operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>sdsfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <literal type="number">256</literal></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>where</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>rand</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name>ZIPLIST_HEAD</name></expr> </then><else>: <expr><name>ZIPLIST_TAIL</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>randstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<switch>switch<condition>(<expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%lld"</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="number">0LL</literal> <operator>+</operator> <call><name>rand</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%lld"</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="number">0LL</literal> <operator>+</operator> <call><name>rand</name><argument_list>()</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%lld"</literal></expr></argument>,<argument><expr><operator>(</operator><literal type="number">0LL</literal> <operator>+</operator> <call><name>rand</name><argument_list>()</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name>ZIPLIST_HEAD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>listAddNodeHead</name><argument_list>(<argument><expr><name>ref</name></expr></argument>,<argument><expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>where</name> <operator>==</operator> <name>ZIPLIST_TAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>listAddNodeTail</name><argument_list>(<argument><expr><name>ref</name></expr></argument>,<argument><expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>listLength</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ziplistLen</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>refnode</name> <operator>=</operator> <call><name>listIndex</name><argument_list>(<argument><expr><name>ref</name></expr></argument>,<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>ziplistGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sstr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>slen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"%lld"</literal></expr></argument>,<argument><expr><name>sval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <name>slen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>sstr</name></expr></argument>,<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>buflen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><call><name>listNodeValue</name><argument_list>(<argument><expr><name>refnode</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>buflen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>listRelease</name><argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Stress with variable ziplist size:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>maxsize</name> <init>= <expr><ternary><condition><expr><name>accurate</name></expr> ?</condition><then> <expr><literal type="number">16384</literal></expr> </then><else>: <expr><literal type="number">16</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>stress</name><argument_list>(<argument><expr><name>ZIPLIST_HEAD</name></expr></argument>,<argument><expr><literal type="number">100000</literal></expr></argument>,<argument><expr><name>maxsize</name></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>stress</name><argument_list>(<argument><expr><name>ZIPLIST_TAIL</name></expr></argument>,<argument><expr><literal type="number">100000</literal></expr></argument>,<argument><expr><name>maxsize</name></expr></argument>,<argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iteration</name> <operator>=</operator> <ternary><condition><expr><name>accurate</name></expr> ?</condition><then> <expr><literal type="number">100000</literal></expr> </then><else>: <expr><literal type="number">100</literal></expr></else></ternary></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>iteration</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name> <init>= <expr><literal type="string">"asdf"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">400</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">4000</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"10"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"100"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"1000"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"10000"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"100000"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Benchmark ziplistFind:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>fptr</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>ZIPLIST_HEAD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>fptr</name> <operator>=</operator> <call><name>ziplistFind</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>fptr</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"nothing"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Benchmark ziplistIndex:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">99999</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Benchmark ziplistValidateIntegrity:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ziplistValidateIntegrity</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><call><name>ziplistBlobLen</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%lld\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Benchmark ziplistCompare with string\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"nothing"</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Benchmark ziplistCompare with number\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"99999"</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>ziplistNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Stress __ziplistCascadeUpdate:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>data</name><index>[<expr><name>ZIP_BIG_PREVLEN</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iteration</name> <operator>=</operator> <ternary><condition><expr><name>accurate</name></expr> ?</condition><then> <expr><literal type="number">100000</literal></expr> </then><else>: <expr><literal type="number">100</literal></expr></else></ternary></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>iteration</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>data</name></expr></argument>, <argument><expr><name>ZIP_BIG_PREVLEN</name><operator>-</operator><literal type="number">4</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>usec</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>data</name></expr></argument>, <argument><expr><name>ZIP_BIG_PREVLEN</name><operator>-</operator><literal type="number">3</literal></expr></argument>, <argument><expr><name>ZIPLIST_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Done. usec=%lld\n\n"</literal></expr></argument>, <argument><expr><call><name>usec</name><argument_list>()</argument_list></call><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Edge cases of __ziplistCascadeUpdate:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>


<decl_stmt><decl><type><name>size_t</name></type> <name>s1</name> <init>= <expr><name>ZIP_BIG_PREVLEN</name><operator>-</operator><literal type="number">4</literal></expr></init></decl>, <decl><type ref="prev"/><name>s2</name> <init>= <expr><name>ZIP_BIG_PREVLEN</name><operator>-</operator><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>zlentry</name></type> <name><name>e</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><block>{<expr><operator>.</operator><name>prevrawlensize</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>prevrawlen</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>lensize</name> <operator>=</operator> <literal type="number">0</literal></expr>,
<expr><operator>.</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>headersize</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>encoding</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><operator>.</operator><name>p</name> <operator>=</operator> <name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>insertHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><call><name>ZIPLIST_ENTRY_HEAD</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verify</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>prevrawlen</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>compareHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>insertHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><call><name>ZIPLIST_ENTRY_HEAD</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verify</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>prevrawlen</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>compareHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>prevrawlen</name> <operator>==</operator> <call><name>strEntryBytesSmall</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>compareHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>insertHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><call><name>ZIPLIST_ENTRY_HEAD</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verify</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>prevrawlen</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>compareHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>prevrawlen</name> <operator>==</operator> <call><name>strEntryBytesSmall</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>compareHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <name><name>e</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>prevrawlen</name> <operator>==</operator> <call><name>strEntryBytesLarge</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>compareHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>insertHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><call><name>ZIPLIST_ENTRY_HEAD</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verify</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>prevrawlen</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>compareHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>prevrawlen</name> <operator>==</operator> <call><name>strEntryBytesSmall</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>compareHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <name><name>e</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>prevrawlen</name> <operator>==</operator> <call><name>strEntryBytesLarge</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>compareHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <name><name>e</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>prevrawlen</name> <operator>==</operator> <call><name>strEntryBytesLarge</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>compareHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verify</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>prevrawlen</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>compareHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>prevrawlen</name> <operator>==</operator> <call><name>strEntryBytesSmall</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>compareHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><name>s2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>prevrawlensize</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <name><name>e</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>prevrawlen</name> <operator>==</operator> <call><name>strEntryBytesLarge</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>compareHelper</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><name>s1</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"__ziplistInsert nextdiff == -4 &amp;&amp; reqlen &lt; 4 (issue #7170):\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>char</name></type> <name><name>A_252</name><index>[<expr><literal type="number">253</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>, <decl><type ref="prev"/><name><name>A_250</name><index>[<expr><literal type="number">251</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>A_252</name></expr></argument>, <argument><expr><literal type="char">'A'</literal></expr></argument>, <argument><expr><literal type="number">252</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>A_250</name></expr></argument>, <argument><expr><literal type="char">'A'</literal></expr></argument>, <argument><expr><literal type="number">250</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"one"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"two"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>A_252</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>A_252</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>A_250</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>A_250</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"three"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistPush</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"10"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ZIPLIST_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>A_252</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>A_252</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: not \"A_252\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>






<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistDelete</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"three"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: not \"three\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>ziplistInsert</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"10"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ziplistRepr</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ziplistIndex</name><argument_list>(<argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ziplistCompare</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><literal type="string">"10"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ERROR: not \"10\"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ALL TESTS PASSED!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
