<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/results/redis_res/_cppstats_featurelocations/redis/deps/jemalloc/src/prof.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JEMALLOC_PROF_C_</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_preamble.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/jemalloc_internal_includes.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/ckh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/malloc_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jemalloc/internal/emitter.h"</cpp:file></cpp:include>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_PROF_LIBUNWIND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNW_LOCAL_ONLY</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libunwind.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_PROF_LIBGCC</name></expr></argument>)</argument_list></call></expr></cpp:if>





<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_Unwind_Backtrace</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unwind.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_Unwind_Backtrace</name></cpp:macro> <cpp:value>JEMALLOC_HOOK(_Unwind_Backtrace, test_hooks_libc_hook)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<decl_stmt><decl><type><name>bool</name></type> <name>opt_prof</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>opt_prof_active</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>opt_prof_thread_active_init</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>opt_lg_prof_sample</name> <init>= <expr><name>LG_PROF_SAMPLE_DEFAULT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>opt_lg_prof_interval</name> <init>= <expr><name>LG_PROF_INTERVAL_DEFAULT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>opt_prof_gdump</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>opt_prof_final</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>opt_prof_leak</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>opt_prof_accum</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>opt_prof_log</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>opt_prof_prefix</name><index>[

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_PROF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><name>PATH_MAX</name> <operator>+</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>prof_active</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type> <name>prof_active_mtx</name></decl>;</decl_stmt>





<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>prof_thread_active_init</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type> <name>prof_thread_active_init_mtx</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>prof_gdump_val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type> <name>prof_gdump_mtx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>prof_interval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>lg_prof_sample</name></decl>;</decl_stmt>

<typedef>typedef <type><name><name>enum</name> <name>prof_logging_state_e</name></name></type> <name>prof_logging_state_t</name>;</typedef>
<enum>enum <name>prof_logging_state_e</name> <block>{
<decl><name>prof_logging_state_stopped</name></decl>,
<decl><name>prof_logging_state_started</name></decl>,
<decl><name>prof_logging_state_dumping</name></decl>
}</block>;</enum>






<decl_stmt><decl><type><name>prof_logging_state_t</name></type> <name>prof_logging_state</name> <init>= <expr><name>prof_logging_state_stopped</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_JET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>prof_log_dummy</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>log_seq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>log_filename</name><index>[

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_PROF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><name>PATH_MAX</name> <operator>+</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>nstime_t</name></type> <name>log_start_timestamp</name> <init>= <expr><name>NSTIME_ZERO_INITIALIZER</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>log_bt_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>log_thr_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<typedef>typedef <type><name><name>struct</name> <name>prof_bt_node_s</name></name></type> <name>prof_bt_node_t</name>;</typedef>

<struct>struct <name>prof_bt_node_s</name> <block>{
<decl_stmt><decl><type><name>prof_bt_node_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_bt_t</name></type> <name>bt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>vec</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>prof_thr_node_s</name></name></type> <name>prof_thr_node_t</name>;</typedef>

<struct>struct <name>prof_thr_node_s</name> <block>{
<decl_stmt><decl><type><name>prof_thr_node_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>thr_uid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>prof_alloc_node_s</name></name></type> <name>prof_alloc_node_t</name>;</typedef>


<struct>struct <name>prof_alloc_node_s</name> <block>{
<decl_stmt><decl><type><name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>alloc_thr_ind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>free_thr_ind</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>size_t</name></type> <name>alloc_bt_ind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>free_bt_ind</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint64_t</name></type> <name>alloc_time_ns</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>free_time_ns</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>usize</name></decl>;</decl_stmt>
}</block>;</struct>






<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>log_tables_initialized</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ckh_t</name></type> <name>log_bt_node_set</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ckh_t</name></type> <name>log_thr_node_set</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>prof_bt_node_t</name> <modifier>*</modifier></type><name>log_bt_first</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>prof_bt_node_t</name> <modifier>*</modifier></type><name>log_bt_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>prof_thr_node_t</name> <modifier>*</modifier></type><name>log_thr_first</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>prof_thr_node_t</name> <modifier>*</modifier></type><name>log_thr_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>log_alloc_first</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>log_alloc_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type> <name>log_mtx</name></decl>;</decl_stmt>








<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name> <modifier>*</modifier></type><name>gctx_locks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>atomic_u_t</name></type> <name>cum_gctxs</name></decl>;</decl_stmt>







<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name> <modifier>*</modifier></type><name>tdata_locks</name></decl>;</decl_stmt>





<decl_stmt><decl><type><specifier>static</specifier> <name>ckh_t</name></type> <name>bt2gctx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>malloc_mutex_t</name></type> <name>bt2gctx_mtx</name></decl>;</decl_stmt>





<decl_stmt><decl><type><specifier>static</specifier> <name>prof_tdata_tree_t</name></type> <name>tdatas</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type> <name>tdatas_mtx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>next_thr_uid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type> <name>next_thr_uid_mtx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type> <name>prof_dump_seq_mtx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>prof_dump_seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>prof_dump_iseq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>prof_dump_mseq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint64_t</name></type> <name>prof_dump_useq</name></decl>;</decl_stmt>





<decl_stmt><decl><type><specifier>static</specifier> <name>malloc_mutex_t</name></type> <name>prof_dump_mtx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>prof_dump_buf</name><index>[

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_PROF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><name>PROF_DUMP_BUFSIZE</name>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<literal type="number">1</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>prof_dump_buf_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>prof_dump_fd</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>prof_booted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>







<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>prof_tctx_should_destroy</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prof_tctx_destroy</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>prof_tdata_should_destroy</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>even_if_attached</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prof_tdata_destroy</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>even_if_attached</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>prof_thread_name_alloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>thread_name</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prof_thr_node_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name><name>r_hash</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>prof_thr_node_keycomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prof_bt_node_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name><name>r_hash</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>prof_bt_node_keycomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k2</name></decl></parameter>)</parameter_list>;</function_decl>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_tctx_comp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>prof_tctx_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>prof_tctx_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>a_thr_uid</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>b_thr_uid</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><operator>(</operator><name>a_thr_uid</name> <operator>&gt;</operator> <name>b_thr_uid</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>a_thr_uid</name> <operator>&lt;</operator> <name>b_thr_uid</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>a_thr_discrim</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>thr_discrim</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>b_thr_discrim</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>thr_discrim</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>a_thr_discrim</name> <operator>&gt;</operator> <name>b_thr_discrim</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>a_thr_discrim</name> <operator>&lt;</operator>
<name>b_thr_discrim</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>a_tctx_uid</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>tctx_uid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>b_tctx_uid</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>tctx_uid</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>a_tctx_uid</name> <operator>&gt;</operator> <name>b_tctx_uid</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>a_tctx_uid</name> <operator>&lt;</operator>
<name>b_tctx_uid</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<macro><name>rb_gen</name><argument_list>(<argument>static UNUSED</argument>, <argument>tctx_tree_</argument>, <argument>prof_tctx_tree_t</argument>, <argument>prof_tctx_t</argument>,
<argument>tctx_link</argument>, <argument>prof_tctx_comp</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_gctx_comp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>prof_gctx_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>prof_gctx_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>a_len</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>b_len</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>comp_len</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>a_len</name> <operator>&lt;</operator> <name>b_len</name><operator>)</operator></expr> ?</condition><then> <expr><name>a_len</name></expr> </then><else>: <expr><name>b_len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>vec</name></name></expr></argument>, <argument><expr><name>comp_len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>a_len</name> <operator>&gt;</operator> <name>b_len</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>a_len</name> <operator>&lt;</operator> <name>b_len</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<macro><name>rb_gen</name><argument_list>(<argument>static UNUSED</argument>, <argument>gctx_tree_</argument>, <argument>prof_gctx_tree_t</argument>, <argument>prof_gctx_t</argument>, <argument>dump_link</argument>,
<argument>prof_gctx_comp</argument>)</argument_list></macro>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_tdata_comp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>a_uid</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>b_uid</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>a_uid</name> <operator>&gt;</operator> <name>b_uid</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>a_uid</name> <operator>&lt;</operator> <name>b_uid</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>a_discrim</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>thr_discrim</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>b_discrim</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>thr_discrim</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>a_discrim</name> <operator>&gt;</operator> <name>b_discrim</name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>a_discrim</name> <operator>&lt;</operator> <name>b_discrim</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<macro><name>rb_gen</name><argument_list>(<argument>static UNUSED</argument>, <argument>tdata_tree_</argument>, <argument>prof_tdata_tree_t</argument>, <argument>prof_tdata_t</argument>, <argument>tdata_link</argument>,
<argument>prof_tdata_comp</argument>)</argument_list></macro>



<function><type><name>void</name></type>
<name>prof_alloc_rollback</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>updated</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>updated</name></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prof_sample_threshold_update</name><argument_list>(<argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>tctx</name> <operator>&gt;</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><literal type="number">1U</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>prepared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>prof_tctx_should_destroy</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prof_tctx_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_malloc_sample_object</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>,
<parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>prof_tctx_set</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<decl_stmt><decl><type><name>nstime_t</name></type> <name>t</name> <init>= <expr><name>NSTIME_ZERO_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>nstime_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_alloc_time_set</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curobjs</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curbytes</name></name> <operator>+=</operator> <name>usize</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>opt_prof_accum</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>accumobjs</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>accumbytes</name></name> <operator>+=</operator> <name>usize</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>prepared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>prof_log_bt_index</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>prof_logging_state</name> <operator>==</operator> <name>prof_logging_state_started</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>prof_bt_node_t</name></type> <name>dummy_node</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dummy_node</name><operator>.</operator><name>bt</name></name> <operator>=</operator> <operator>*</operator><name>bt</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>prof_bt_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>ckh_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>log_bt_node_set</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>dummy_node</name><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>node</name><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>prof_bt_node_t</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>)</argument_list></call> <operator>+</operator>
<operator>(</operator><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_bt_node_t</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><operator>(</operator><name>prof_bt_node_t</name> <operator>*</operator><operator>)</operator>
<call><name>iallocztm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>log_bt_first</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>log_bt_first</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>log_bt_last</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>log_bt_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>log_bt_last</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>log_bt_index</name></expr>;</expr_stmt>




<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>bt</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>vec</name></name> <operator>=</operator> <name><name>new_node</name><operator>-&gt;</operator><name>vec</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>log_bt_index</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ckh_insert</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_bt_node_set</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>new_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>new_node</name><operator>-&gt;</operator><name>index</name></name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>index</name></name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>prof_log_thr_index</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>thr_uid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>prof_logging_state</name> <operator>==</operator> <name>prof_logging_state_started</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>prof_thr_node_t</name></type> <name>dummy_node</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dummy_node</name><operator>.</operator><name>thr_uid</name></name> <operator>=</operator> <name>thr_uid</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>prof_thr_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><call><name>ckh_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>log_thr_node_set</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>dummy_node</name><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>node</name><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>prof_thr_node_t</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_thr_node_t</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><operator>(</operator><name>prof_thr_node_t</name> <operator>*</operator><operator>)</operator>
<call><name>iallocztm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>log_thr_first</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>log_thr_first</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>log_thr_last</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>log_thr_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>log_thr_last</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>log_thr_index</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>thr_uid</name></name> <operator>=</operator> <name>thr_uid</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>log_thr_index</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ckh_insert</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_thr_node_set</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>new_node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>new_node</name><operator>-&gt;</operator><name>index</name></name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><name><name>node</name><operator>-&gt;</operator><name>index</name></name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_try_log</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>cons_tdata</name> <init>= <expr><call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cons_tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>





<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prof_logging_state</name> <operator>!=</operator> <name>prof_logging_state_started</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>label_done</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>log_tables_initialized</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>err1</name> <init>= <expr><call><name>ckh_new</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_bt_node_set</name></expr></argument>, <argument><expr><name>PROF_CKH_MINITEMS</name></expr></argument>,
<argument><expr><name>prof_bt_node_hash</name></expr></argument>, <argument><expr><name>prof_bt_node_keycomp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>err2</name> <init>= <expr><call><name>ckh_new</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_thr_node_set</name></expr></argument>, <argument><expr><name>PROF_CKH_MINITEMS</name></expr></argument>,
<argument><expr><name>prof_thr_node_hash</name></expr></argument>, <argument><expr><name>prof_thr_node_keycomp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>err1</name> <operator>||</operator> <name>err2</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>label_done</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>log_tables_initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>nstime_t</name></type> <name>alloc_time</name> <init>= <expr><call><name>prof_alloc_time_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,
<argument><expr><operator>(</operator><name>alloc_ctx_t</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>nstime_t</name></type> <name>free_time</name> <init>= <expr><name>NSTIME_ZERO_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>nstime_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>free_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_alloc_node_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><operator>(</operator><name>prof_alloc_node_t</name> <operator>*</operator><operator>)</operator>
<call><name>iallocztm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prod_thr_name</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>?</condition><then>
<expr><literal type="string">""</literal></expr> </then><else>: <expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cons_thr_name</name> <init>= <expr><call><name>prof_thread_name_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>prof_bt_t</name></type> <name>bt</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>bt_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt</name></expr></argument>, <argument><expr><name><name>cons_tdata</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_backtrace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>cons_bt</name> <init>= <expr><operator>&amp;</operator><name>bt</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>prod_bt</name> <init>= <expr><operator>&amp;</operator><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>bt</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>alloc_thr_ind</name></name> <operator>=</operator> <call><name>prof_log_thr_index</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></argument>,
<argument><expr><name>prod_thr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>free_thr_ind</name></name> <operator>=</operator> <call><name>prof_log_thr_index</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name><name>cons_tdata</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></argument>,
<argument><expr><name>cons_thr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>alloc_bt_ind</name></name> <operator>=</operator> <call><name>prof_log_bt_index</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>prod_bt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>free_bt_ind</name></name> <operator>=</operator> <call><name>prof_log_bt_index</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>cons_bt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>alloc_time_ns</name></name> <operator>=</operator> <call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alloc_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>free_time_ns</name></name> <operator>=</operator> <call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>free_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>usize</name></name> <operator>=</operator> <name>usize</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>log_alloc_first</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>log_alloc_first</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>log_alloc_last</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>log_alloc_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>log_alloc_last</name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<label><name>label_done</name>:</label>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_free_sampled_object</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>usize</name></decl></parameter>,
<parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curobjs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curbytes</name></name> <operator>&gt;=</operator> <name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curobjs</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curbytes</name></name> <operator>-=</operator> <name>usize</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>prof_try_log</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prof_tctx_should_destroy</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prof_tctx_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>bt_init</name><parameter_list>(<parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>vec</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bt</name><operator>-&gt;</operator><name>vec</name></name> <operator>=</operator> <name>vec</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_enter</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tdata</name> <operator>==</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_leave</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>tdata</name> <operator>==</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>idump</name></decl>, <decl><type ref="prev"/><name>gdump</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idump</name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>enq_idump</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq_idump</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>gdump</name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>enq_gdump</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq_gdump</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idump</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prof_idump</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>gdump</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prof_gdump</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_PROF_LIBUNWIND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type>
<name>prof_backtrace</name><parameter_list>(<parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nframes</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>bt</name><operator>-&gt;</operator><name>vec</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nframes</name> <operator>=</operator> <call><name>unw_backtrace</name><argument_list>(<argument><expr><name><name>bt</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name>PROF_BT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nframes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>nframes</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_PROF_LIBGCC</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>
<function><type><specifier>static</specifier> <name>_Unwind_Reason_Code</name></type>
<name>prof_unwind_init_callback</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>_Unwind_Context</name></name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>_URC_NO_REASON</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>_Unwind_Reason_Code</name></type>
<name>prof_unwind_callback</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>_Unwind_Context</name></name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_unwind_data_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>prof_unwind_data_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ip</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>_Unwind_GetIP</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ip</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>_URC_END_OF_STACK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>bt</name><operator>-&gt;</operator><name>vec</name><index>[<expr><name><name>data</name><operator>-&gt;</operator><name>bt</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>bt</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <name><name>data</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>_URC_END_OF_STACK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>_URC_NO_REASON</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_backtrace</name><parameter_list>(<parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_unwind_data_t</name></type> <name>data</name> <init>= <expr><block>{<expr><name>bt</name></expr>, <expr><name>PROF_BT_MAX</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>_Unwind_Backtrace</name><argument_list>(<argument><expr><name>prof_unwind_callback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_PROF_GCC</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:elif>
<function><type><name>void</name></type>
<name>prof_backtrace</name><parameter_list>(<parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BT_FRAME</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if ((i) &lt; PROF_BT_MAX) { void *p; if (__builtin_frame_address(i) == 0) { return; } p = __builtin_return_address(i); if (p == NULL) { return; } bt-&gt;vec[(i)] = p; bt-&gt;len = (i) + 1; } else { return; }</cpp:value></cpp:define>















<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">1</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">2</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">3</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">4</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">5</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">6</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">7</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">8</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">9</literal></argument>)</argument_list></macro>

<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">10</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">11</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">12</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">13</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">14</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">15</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">16</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">17</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">18</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">19</literal></argument>)</argument_list></macro>

<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">20</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">21</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">22</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">23</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">24</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">25</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">26</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">27</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">28</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">29</literal></argument>)</argument_list></macro>

<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">30</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">31</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">32</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">33</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">34</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">35</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">36</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">37</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">38</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">39</literal></argument>)</argument_list></macro>

<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">40</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">41</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">42</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">43</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">44</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">45</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">46</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">47</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">48</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">49</literal></argument>)</argument_list></macro>

<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">50</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">51</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">52</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">53</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">54</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">55</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">56</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">57</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">58</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">59</literal></argument>)</argument_list></macro>

<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">60</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">61</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">62</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">63</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">64</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">65</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">66</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">67</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">68</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">69</literal></argument>)</argument_list></macro>

<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">70</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">71</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">72</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">73</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">74</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">75</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">76</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">77</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">78</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">79</literal></argument>)</argument_list></macro>

<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">80</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">81</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">82</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">83</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">84</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">85</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">86</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">87</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">88</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">89</literal></argument>)</argument_list></macro>

<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">90</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">91</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">92</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">93</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">94</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">95</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">96</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">97</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">98</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">99</literal></argument>)</argument_list></macro>

<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">100</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">101</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">102</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">103</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">104</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">105</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">106</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">107</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">108</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">109</literal></argument>)</argument_list></macro>

<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">110</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">111</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">112</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">113</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">114</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">115</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">116</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">117</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">118</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">119</literal></argument>)</argument_list></macro>

<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">120</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">121</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">122</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">123</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">124</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">125</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">126</literal></argument>)</argument_list></macro>
<macro><name>BT_FRAME</name><argument_list>(<argument><literal type="number">127</literal></argument>)</argument_list></macro>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BT_FRAME</name></cpp:undef>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><name>void</name></type>
<name>prof_backtrace</name><parameter_list>(<parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>malloc_mutex_t</name> <modifier>*</modifier></type>
<name>prof_gctx_mutex_choose</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ngctxs</name> <init>= <expr><call><name>atomic_fetch_add_u</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cum_gctxs</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>&amp;</operator><name><name>gctx_locks</name><index>[<expr><operator>(</operator><name>ngctxs</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>PROF_NCTX_LOCKS</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>malloc_mutex_t</name> <modifier>*</modifier></type>
<name>prof_tdata_mutex_choose</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>thr_uid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>&amp;</operator><name><name>tdata_locks</name><index>[<expr><name>thr_uid</name> <operator>%</operator> <name>PROF_NTDATA_LOCKS</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prof_gctx_t</name> <modifier>*</modifier></type>
<name>prof_gctx_create</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>



<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>prof_gctx_t</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name> <init>= <expr><operator>(</operator><name>prof_gctx_t</name> <operator>*</operator><operator>)</operator><call><name>iallocztm</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
<argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>gctx</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <call><name>prof_gctx_mutex_choose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tctx_tree_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>vec</name></name> <operator>=</operator> <name><name>gctx</name><operator>-&gt;</operator><name>vec</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>bt</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<return>return <expr><name>gctx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_gctx_try_destroy</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata_self</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>,
<parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<expr_stmt><expr><call><name>prof_enter</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tctx_tree_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ckh_remove</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>bt</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>prof_leave</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_leave</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata_self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_tctx_should_destroy</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_prof_accum</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curobjs</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>prepared</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_gctx_should_destroy</name><parameter_list>(<parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>opt_prof_accum</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>tctx_tree_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_tctx_destroy</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name> <init>= <expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name> <init>= <expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>destroy_tdata</name></decl>, <decl><type ref="prev"/><name>destroy_tctx</name></decl>, <decl><type ref="prev"/><name>destroy_gctx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curobjs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>curbytes</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>opt_prof_accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>accumobjs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name><operator>.</operator><name>accumbytes</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ckh_remove</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>bt</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>destroy_tdata</name> <operator>=</operator> <call><name>prof_tdata_should_destroy</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>prof_tctx_state_nominal</name></expr>:</case>
<expr_stmt><expr><call><name>tctx_tree_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>destroy_tctx</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>prof_gctx_should_destroy</name><argument_list>(<argument><expr><name>gctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>














<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>destroy_gctx</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>destroy_gctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>prof_tctx_state_dumping</name></expr>:</case>





<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>prof_tctx_state_purgatory</name></expr>;</expr_stmt>
<expr_stmt><expr><name>destroy_tctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>destroy_gctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>destroy_tctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>destroy_gctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>destroy_gctx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prof_gctx_try_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gctx</name></expr></argument>,
<argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>malloc_mutex_assert_not_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>destroy_tdata</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prof_tdata_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>destroy_tctx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_lookup_global</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_btkey</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_gctx</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>p_new_gctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<union>union <block>{
<decl_stmt><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
}</block> <decl><name>gctx</name></decl>, <decl><type ref="prev"/><name>tgctx</name></decl>;</union>
<union>union <block>{
<decl_stmt><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
}</block> <decl><name>btkey</name></decl>;</union>
<decl_stmt><decl><type><name>bool</name></type> <name>new_gctx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>prof_enter</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ckh_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>, <argument><expr><name>bt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>btkey</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>prof_leave</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tgctx</name><operator>.</operator><name>p</name></name> <operator>=</operator> <call><name>prof_gctx_create</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tgctx</name><operator>.</operator><name>v</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>prof_enter</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ckh_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>, <argument><expr><name>bt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>btkey</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>gctx</name><operator>.</operator><name>p</name></name> <operator>=</operator> <name><name>tgctx</name><operator>.</operator><name>p</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>btkey</name><operator>.</operator><name>p</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>gctx</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>bt</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ckh_insert</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>, <argument><expr><name><name>btkey</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>prof_leave</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>new_gctx</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>new_gctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>tgctx</name><operator>.</operator><name>v</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_gctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_gctx</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gctx</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_gctx</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tgctx</name><operator>.</operator><name>v</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tgctx</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>prof_leave</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p_btkey</name> <operator>=</operator> <name><name>btkey</name><operator>.</operator><name>v</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p_gctx</name> <operator>=</operator> <name><name>gctx</name><operator>.</operator><name>p</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p_new_gctx</name> <operator>=</operator> <name>new_gctx</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>prof_tctx_t</name> <modifier>*</modifier></type>
<name>prof_lookup</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<union>union <block>{
<decl_stmt><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
}</block> <decl><name>ret</name></decl>;</union>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>not_found</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>not_found</name> <operator>=</operator> <call><name>ckh_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>, <argument><expr><name>bt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ret</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>not_found</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>prepared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>not_found</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>btkey</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>new_gctx</name></decl>, <decl><type ref="prev"/><name>error</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><call><name>prof_lookup_global</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>bt</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>btkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gctx</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>new_gctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>v</name></name> <operator>=</operator> <call><name>iallocztm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_tctx_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_tctx_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><call><name>arena_ichoose</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ret</name><operator>.</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>new_gctx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prof_gctx_try_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>tdata</name></name> <operator>=</operator> <name>tdata</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>thr_uid</name></name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>thr_uid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>thr_discrim</name></name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>thr_discrim</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>cnts</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_cnt_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>gctx</name></name> <operator>=</operator> <name>gctx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>tctx_uid</name></name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tctx_uid_next</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>prepared</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>prof_tctx_state_initializing</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>ckh_insert</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>, <argument><expr><name>btkey</name></expr></argument>, <argument><expr><name><name>ret</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>new_gctx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prof_gctx_try_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ret</name><operator>.</operator><name>v</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>prof_tctx_state_nominal</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tctx_tree_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>, <argument><expr><name><name>ret</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>ret</name><operator>.</operator><name>p</name></name></expr>;</return>
</block_content>}</block></function>














<function><type><name>void</name></type>
<name>prof_sample_threshold_update</name><parameter_list>(<parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_PROF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_prof</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>lg_prof_sample</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>tsd_bytes_until_sample_set</name><argument_list>(<argument><expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>



















<decl_stmt><decl><type><name>uint64_t</name></type> <name>r</name> <init>= <expr><call><name>prng_lg_range_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>prng_state</name></name></expr></argument>, <argument><expr><literal type="number">53</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>u</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><name>r</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal><operator>/</operator><literal type="number">9007199254740992.0L</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>bytes_until_sample</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><call><name>log</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> <operator>/</operator>
<call><name>log</name><argument_list>(<argument><expr><literal type="number">1.0</literal> <operator>-</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>lg_prof_sample</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator>
<operator>+</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1U</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bytes_until_sample</name> <operator>&gt;</operator> <name>SSIZE_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bytes_until_sample</name> <operator>=</operator> <name>SSIZE_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>tsd_bytes_until_sample_set</name><argument_list>(<argument><expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>bytes_until_sample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_JET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_count_iter</name><parameter_list>(<parameter><decl><type><name>prof_tdata_tree_t</name> <modifier>*</modifier></type><name>tdatas</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name> <modifier>*</modifier></type><name>tdata_count</name> <init>= <expr><operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>tdata_count</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>prof_tdata_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>tdata_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tsdn</name> <operator>=</operator> <call><name>tsdn_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tdata_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_tdata_count_iter</name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tdata_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>tdata_count</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>prof_bt_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>bt_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bt_count</name> <operator>=</operator> <call><name>ckh_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>bt_count</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_dump_open_impl</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>creat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>propagate_err</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: creat(\"%s\"), 0644) failed\n"</literal></expr></argument>,
<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><name>prof_dump_open_t</name> <modifier>*</modifier><name>JET_MUTABLE</name></type> <name>prof_dump_open</name> <init>= <expr><name>prof_dump_open_impl</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_flush</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>err</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>malloc_write_fd</name><argument_list>(<argument><expr><name>prof_dump_fd</name></expr></argument>, <argument><expr><name>prof_dump_buf</name></expr></argument>, <argument><expr><name>prof_dump_buf_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>propagate_err</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: write() failed during heap "</literal>
<literal type="string">"profile flush\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>prof_dump_buf_end</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_close</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>prof_dump_fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>prof_dump_flush</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>prof_dump_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_dump_fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_write</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>slen</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>slen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>slen</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>prof_dump_buf_end</name> <operator>==</operator> <name>PROF_DUMP_BUFSIZE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>prof_dump_flush</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>propagate_err</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>prof_dump_buf_end</name> <operator>+</operator> <name>slen</name> <operator>-</operator> <name>i</name> <operator>&lt;=</operator> <name>PROF_DUMP_BUFSIZE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name>slen</name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name>PROF_DUMP_BUFSIZE</name> <operator>-</operator> <name>prof_dump_buf_end</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prof_dump_buf</name><index>[<expr><name>prof_dump_buf_end</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_dump_buf_end</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<macro><name>JEMALLOC_FORMAT_PRINTF</name><argument_list>(<argument><literal type="number">2</literal></argument>, <argument><literal type="number">3</literal></argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_printf</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>PROF_PRINTF_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>prof_dump_write</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_tctx_merge_tdata</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>prof_tctx_state_initializing</name></expr>:</case>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><name>prof_tctx_state_nominal</name></expr>:</case>
<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>prof_tctx_state_dumping</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tctx</name><operator>-&gt;</operator><name>cnts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_cnt_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name> <operator>+=</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>curobjs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curbytes</name></name> <operator>+=</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>curbytes</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>opt_prof_accum</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name> <operator>+=</operator>
<name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>accumobjs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumbytes</name></name> <operator>+=</operator>
<name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>accumbytes</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>prof_tctx_state_dumping</name></expr>:</case>
<case>case <expr><name>prof_tctx_state_purgatory</name></expr>:</case>
<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_tctx_merge_gctx</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name> <operator>+=</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>curobjs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curbytes</name></name> <operator>+=</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>curbytes</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>opt_prof_accum</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name> <operator>+=</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>accumobjs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumbytes</name></name> <operator>+=</operator> <name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>accumbytes</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prof_tctx_t</name> <modifier>*</modifier></type>
<name>prof_tctx_merge_iter</name><parameter_list>(<parameter><decl><type><name>prof_tctx_tree_t</name> <modifier>*</modifier></type><name>tctxs</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name> <init>= <expr><operator>(</operator><name>tsdn_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>prof_tctx_state_nominal</name></expr>:</case>

<break>break;</break>
<case>case <expr><name>prof_tctx_state_dumping</name></expr>:</case>
<case>case <expr><name>prof_tctx_state_purgatory</name></expr>:</case>
<expr_stmt><expr><call><name>prof_tctx_merge_gctx</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>tctx</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<struct>struct <name>prof_tctx_dump_iter_arg_s</name> <block>{
<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>propagate_err</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>prof_tctx_t</name> <modifier>*</modifier></type>
<name>prof_tctx_dump_iter</name><parameter_list>(<parameter><decl><type><name>prof_tctx_tree_t</name> <modifier>*</modifier></type><name>tctxs</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>prof_tctx_dump_iter_arg_s</name></name> <modifier>*</modifier></type><name>arg</name> <init>=
<expr><operator>(</operator>struct <name>prof_tctx_dump_iter_arg_s</name> <operator>*</operator><operator>)</operator><name>opaque</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>prof_tctx_state_initializing</name></expr>:</case>
<case>case <expr><name>prof_tctx_state_nominal</name></expr>:</case>

<break>break;</break>
<case>case <expr><name>prof_tctx_state_dumping</name></expr>:</case>
<case>case <expr><name>prof_tctx_state_purgatory</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>prof_dump_printf</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>propagate_err</name></name></expr></argument>,
<argument><expr><literal type="string">" t%"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">" [%"</literal><name>FMTu64</name><literal type="string">": "</literal>
<literal type="string">"%"</literal><name>FMTu64</name><literal type="string">"]\n"</literal></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>curobjs</name></name></expr></argument>,
<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>curbytes</name></name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>accumobjs</name></name></expr></argument>,
<argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>dump_cnts</name><operator>.</operator><name>accumbytes</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>tctx</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prof_tctx_t</name> <modifier>*</modifier></type>
<name>prof_tctx_finish_iter</name><parameter_list>(<parameter><decl><type><name>prof_tctx_tree_t</name> <modifier>*</modifier></type><name>tctxs</name></decl></parameter>, <parameter><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>tctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name> <init>= <expr><operator>(</operator><name>tsdn_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tctx</name><operator>-&gt;</operator><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>prof_tctx_state_nominal</name></expr>:</case>

<break>break;</break>
<case>case <expr><name>prof_tctx_state_dumping</name></expr>:</case>
<expr_stmt><expr><name><name>tctx</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>prof_tctx_state_nominal</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>prof_tctx_state_purgatory</name></expr>:</case>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>tctx</name></expr>;</expr_stmt>
<goto>goto <name>label_return</name>;</goto>
<default>default:</default>
<expr_stmt><expr><call><name>not_reached</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_dump_gctx_prep</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gctx_tree_insert</name><argument_list>(<argument><expr><name>gctxs</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_cnt_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>prof_gctx_merge_iter_arg_s</name> <block>{
<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>leak_ngctx</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>prof_gctx_t</name> <modifier>*</modifier></type>
<name>prof_gctx_merge_iter</name><parameter_list>(<parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>prof_gctx_merge_iter_arg_s</name></name> <modifier>*</modifier></type><name>arg</name> <init>=
<expr><operator>(</operator>struct <name>prof_gctx_merge_iter_arg_s</name> <operator>*</operator><operator>)</operator><name>opaque</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tctx_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_tctx_merge_iter</name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>leak_ngctx</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_gctx_finish</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name> <init>= <expr><call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl>;</decl_stmt>







<while>while <condition>(<expr><operator>(</operator><name>gctx</name> <operator>=</operator> <call><name>gctx_tree_first</name><argument_list>(<argument><expr><name>gctxs</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gctx_tree_remove</name><argument_list>(<argument><expr><name>gctxs</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<block>{<block_content>
<decl_stmt><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>to_destroy</name> <init>=
<expr><call><name>tctx_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>,
<argument><expr><name>prof_tctx_finish_iter</name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>to_destroy</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>tctx_tree_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>,
<argument><expr><name>to_destroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tctx_tree_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>,
<argument><expr><name>to_destroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>to_destroy</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block> while <condition>(<expr><name>next</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
</block_content>}</block>
<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>prof_gctx_should_destroy</name><argument_list>(<argument><expr><name>gctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>gctx</name><operator>-&gt;</operator><name>nlimbo</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_gctx_try_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<struct>struct <name>prof_tdata_merge_iter_arg_s</name> <block>{
<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_cnt_t</name></type> <name>cnt_all</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_merge_iter</name><parameter_list>(<parameter><decl><type><name>prof_tdata_tree_t</name> <modifier>*</modifier></type><name>tdatas</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>prof_tdata_merge_iter_arg_s</name></name> <modifier>*</modifier></type><name>arg</name> <init>=
<expr><operator>(</operator>struct <name>prof_tdata_merge_iter_arg_s</name> <operator>*</operator><operator>)</operator><name>opaque</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tdata</name><operator>-&gt;</operator><name>expired</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>tabind</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>prof_tctx_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
}</block> <decl><name>tctx</name></decl>;</union>

<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>dumping</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_cnt_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>tabind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><call><name>ckh_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tabind</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>tctx</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>prof_tctx_merge_tdata</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>tctx</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>cnt_all</name><operator>.</operator><name>curobjs</name></name> <operator>+=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>cnt_all</name><operator>.</operator><name>curbytes</name></name> <operator>+=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curbytes</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>opt_prof_accum</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>cnt_all</name><operator>.</operator><name>accumobjs</name></name> <operator>+=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>cnt_all</name><operator>.</operator><name>accumbytes</name></name> <operator>+=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumbytes</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>dumping</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_dump_iter</name><parameter_list>(<parameter><decl><type><name>prof_tdata_tree_t</name> <modifier>*</modifier></type><name>tdatas</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>propagate_err</name> <init>= <expr><operator>*</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tdata</name><operator>-&gt;</operator><name>dumping</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prof_dump_printf</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>,
<argument><expr><literal type="string">" t%"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">" [%"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">"]%s%s\n"</literal></expr></argument>,
<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name></expr></argument>,
<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curbytes</name></name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name></expr></argument>,
<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumbytes</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>tdata</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_header_impl</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>prof_cnt_t</name> <modifier>*</modifier></type><name>cnt_all</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prof_dump_printf</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>,
<argument><expr><literal type="string">"heap_v2/%"</literal><name>FMTu64</name><literal type="string">"\n"</literal>
<literal type="string">" t*: %"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">" [%"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">"]\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <name>lg_prof_sample</name><operator>)</operator></expr></argument>, <argument><expr><name><name>cnt_all</name><operator>-&gt;</operator><name>curobjs</name></name></expr></argument>,
<argument><expr><name><name>cnt_all</name><operator>-&gt;</operator><name>curbytes</name></name></expr></argument>, <argument><expr><name><name>cnt_all</name><operator>-&gt;</operator><name>accumobjs</name></name></expr></argument>, <argument><expr><name><name>cnt_all</name><operator>-&gt;</operator><name>accumbytes</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><call><name>tdata_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_tdata_dump_iter</name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>propagate_err</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><name>prof_dump_header_t</name> <modifier>*</modifier><name>JET_MUTABLE</name></type> <name>prof_dump_header</name> <init>= <expr><name>prof_dump_header_impl</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_gctx</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>prof_tctx_dump_iter_arg_s</name></name></type> <name>prof_tctx_dump_iter_arg</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>opt_prof_accum</name> <operator>&amp;&amp;</operator> <name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>opt_prof_accum</name> <operator>&amp;&amp;</operator> <name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curbytes</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumbytes</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<goto>goto <name>label_return</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prof_dump_printf</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>, <argument><expr><literal type="string">"@"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>label_return</name>;</goto>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bt</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>prof_dump_printf</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>, <argument><expr><literal type="string">" %#"</literal><name>FMTxPTR</name></expr></argument>,
<argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>bt</name><operator>-&gt;</operator><name>vec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>label_return</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>prof_dump_printf</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>,
<argument><expr><literal type="string">"\n"</literal>
<literal type="string">" t*: %"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">" [%"</literal><name>FMTu64</name><literal type="string">": %"</literal><name>FMTu64</name><literal type="string">"]\n"</literal></expr></argument>,
<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curobjs</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>curbytes</name></name></expr></argument>,
<argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumobjs</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>cnt_summed</name><operator>.</operator><name>accumbytes</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>label_return</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>prof_tctx_dump_iter_arg</name><operator>.</operator><name>tsdn</name></name> <operator>=</operator> <name>tsdn</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>prof_tctx_dump_iter_arg</name><operator>.</operator><name>propagate_err</name></name> <operator>=</operator> <name>propagate_err</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tctx_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>tctxs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_tctx_dump_iter</name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>prof_tctx_dump_iter_arg</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>label_return</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>JEMALLOC_FORMAT_PRINTF</name><argument_list>(<argument><literal type="number">1</literal></argument>, <argument><literal type="number">2</literal></argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_open_maps</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>mfd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>filename</name><index>[<expr><name>PATH_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_vsnprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_CLOEXEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>mfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name> <operator>|</operator> <name>O_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>mfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>mfd</name></expr></argument>, <argument><expr><name>F_SETFD</name></expr></argument>, <argument><expr><call><name>fcntl</name><argument_list>(<argument><expr><name>mfd</name></expr></argument>, <argument><expr><name>F_GETFD</name></expr></argument>)</argument_list></call> <operator>|</operator> <name>FD_CLOEXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>mfd</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>prof_getpid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>GetCurrentProcessId</name><argument_list>()</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>getpid</name><argument_list>()</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_maps</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mfd</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>mfd</name> <operator>=</operator> <call><name>prof_open_maps</name><argument_list>(<argument><expr><literal type="string">"/proc/curproc/map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>mfd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><call><name>prof_getpid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>mfd</name> <operator>=</operator> <call><name>prof_open_maps</name><argument_list>(<argument><expr><literal type="string">"/proc/%d/task/%d/maps"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mfd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>mfd</name> <operator>=</operator> <call><name>prof_open_maps</name><argument_list>(<argument><expr><literal type="string">"/proc/%d/maps"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>mfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>nread</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prof_dump_write</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>, <argument><expr><literal type="string">"\nMAPPED_LIBRARIES:\n"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name>propagate_err</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>label_return</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nread</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>prof_dump_buf_end</name> <operator>+=</operator> <name>nread</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>prof_dump_buf_end</name> <operator>==</operator> <name>PROF_DUMP_BUFSIZE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>prof_dump_flush</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name>propagate_err</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>label_return</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>malloc_read_fd</name><argument_list>(<argument><expr><name>mfd</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>prof_dump_buf</name><index>[<expr><name>prof_dump_buf_end</name></expr>]</index></name></expr></argument>, <argument><expr><name>PROF_DUMP_BUFSIZE</name>
<operator>-</operator> <name>prof_dump_buf_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>nread</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<goto>goto <name>label_return</name>;</goto>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
<if_stmt><if>if <condition>(<expr><name>mfd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>mfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_leakcheck</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>prof_cnt_t</name> <modifier>*</modifier></type><name>cnt_all</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>leak_ngctx</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_PROF</name></expr></argument>)</argument_list></call></expr></cpp:if>






<if_stmt><if>if <condition>(<expr><name><name>cnt_all</name><operator>-&gt;</operator><name>curbytes</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>sample_period</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>lg_prof_sample</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>ratio</name> <init>= <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>cnt_all</name><operator>-&gt;</operator><name>curbytes</name></name><operator>)</operator> <operator>/</operator>
<operator>(</operator><name>double</name><operator>)</operator><name><name>cnt_all</name><operator>-&gt;</operator><name>curobjs</name></name><operator>)</operator> <operator>/</operator> <name>sample_period</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>scale_factor</name> <init>= <expr><literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <call><name>exp</name><argument_list>(<argument><expr><operator>-</operator><name>ratio</name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>curbytes</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>round</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>cnt_all</name><operator>-&gt;</operator><name>curbytes</name></name><operator>)</operator>
<operator>*</operator> <name>scale_factor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>curobjs</name> <init>= <expr><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>round</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>cnt_all</name><operator>-&gt;</operator><name>curobjs</name></name><operator>)</operator> <operator>*</operator>
<name>scale_factor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Leak approximation summary: ~%"</literal><name>FMTu64</name>
<literal type="string">" byte%s, ~%"</literal><name>FMTu64</name><literal type="string">" object%s, &gt;= %zu context%s\n"</literal></expr></argument>,
<argument><expr><name>curbytes</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>curbytes</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>curobjs</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>curobjs</name> <operator>!=</operator>
<literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>leak_ngctx</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>leak_ngctx</name> <operator>!=</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(
<argument><expr><literal type="string">"&lt;jemalloc&gt;: Run jeprof on \"%s\" for leak detail\n"</literal></expr></argument>,
<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<struct>struct <name>prof_gctx_dump_iter_arg_s</name> <block>{
<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>propagate_err</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>prof_gctx_t</name> <modifier>*</modifier></type>
<name>prof_gctx_dump_iter</name><parameter_list>(<parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>, <parameter><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>gctx</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>prof_gctx_dump_iter_arg_s</name></name> <modifier>*</modifier></type><name>arg</name> <init>=
<expr><operator>(</operator>struct <name>prof_gctx_dump_iter_arg_s</name> <operator>*</operator><operator>)</operator><name>opaque</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prof_dump_gctx</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>propagate_err</name></name></expr></argument>, <argument><expr><name>gctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>-&gt;</operator><name>bt</name></name></expr></argument>,
<argument><expr><name>gctxs</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>gctx</name></expr>;</expr_stmt>
<goto>goto <name>label_return</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<label><name>label_return</name>:</label>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>tsdn</name></name></expr></argument>, <argument><expr><name><name>gctx</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_dump_prep</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>prof_tdata_merge_iter_arg_s</name></name> <modifier>*</modifier></type><name>prof_tdata_merge_iter_arg</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>prof_gctx_merge_iter_arg_s</name></name> <modifier>*</modifier></type><name>prof_gctx_merge_iter_arg</name></decl></parameter>,
<parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>tabind</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>prof_gctx_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
}</block> <decl><name>gctx</name></decl>;</union>

<expr_stmt><expr><call><name>prof_enter</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>gctx_tree_new</name><argument_list>(<argument><expr><name>gctxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>tabind</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><call><name>ckh_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tabind</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx</name><operator>.</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>prof_dump_gctx_prep</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>gctx</name><operator>.</operator><name>p</name></name></expr></argument>, <argument><expr><name>gctxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>





<expr_stmt><expr><name><name>prof_tdata_merge_iter_arg</name><operator>-&gt;</operator><name>tsdn</name></name> <operator>=</operator> <call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prof_tdata_merge_iter_arg</name><operator>-&gt;</operator><name>cnt_all</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_cnt_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tdata_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_tdata_merge_iter</name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>prof_tdata_merge_iter_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>prof_gctx_merge_iter_arg</name><operator>-&gt;</operator><name>tsdn</name></name> <operator>=</operator> <call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>prof_gctx_merge_iter_arg</name><operator>-&gt;</operator><name>leak_ngctx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gctx_tree_iter</name><argument_list>(<argument><expr><name>gctxs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_gctx_merge_iter</name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>prof_gctx_merge_iter_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>prof_leave</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump_file</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>leakcheck</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>prof_tdata_merge_iter_arg_s</name></name> <modifier>*</modifier></type><name>prof_tdata_merge_iter_arg</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>prof_gctx_merge_iter_arg_s</name></name> <modifier>*</modifier></type><name>prof_gctx_merge_iter_arg</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>prof_gctx_dump_iter_arg_s</name></name> <modifier>*</modifier></type><name>prof_gctx_dump_iter_arg</name></decl></parameter>,
<parameter><decl><type><name>prof_gctx_tree_t</name> <modifier>*</modifier></type><name>gctxs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prof_dump_fd</name> <operator>=</operator> <call><name>prof_dump_open</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>prof_dump_header</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>propagate_err</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>prof_tdata_merge_iter_arg</name><operator>-&gt;</operator><name>cnt_all</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>label_write_error</name>;</goto>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>prof_gctx_dump_iter_arg</name><operator>-&gt;</operator><name>tsdn</name></name> <operator>=</operator> <call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>prof_gctx_dump_iter_arg</name><operator>-&gt;</operator><name>propagate_err</name></name> <operator>=</operator> <name>propagate_err</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gctx_tree_iter</name><argument_list>(<argument><expr><name>gctxs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>prof_gctx_dump_iter</name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>prof_gctx_dump_iter_arg</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>label_write_error</name>;</goto>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>prof_dump_maps</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<goto>goto <name>label_write_error</name>;</goto>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>prof_dump_close</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>
<label><name>label_write_error</name>:</label>
<expr_stmt><expr><call><name>prof_dump_close</name><argument_list>(<argument><expr><name>propagate_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_dump</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>propagate_err</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>leakcheck</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type> <name>tdata</name> <init>= <expr><call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pre_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>prof_gctx_tree_t</name></type> <name>gctxs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>prof_tdata_merge_iter_arg_s</name></name></type> <name>prof_tdata_merge_iter_arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>prof_gctx_merge_iter_arg_s</name></name></type> <name>prof_gctx_merge_iter_arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>prof_gctx_dump_iter_arg_s</name></name></type> <name>prof_gctx_dump_iter_arg</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>prof_dump_prep</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_tdata_merge_iter_arg</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>prof_gctx_merge_iter_arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gctxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>err</name> <init>= <expr><call><name>prof_dump_file</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>propagate_err</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>leakcheck</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>prof_tdata_merge_iter_arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gctx_merge_iter_arg</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>prof_gctx_dump_iter_arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gctxs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>prof_gctx_finish</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gctxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>post_reentrancy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>leakcheck</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prof_leakcheck</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prof_tdata_merge_iter_arg</name><operator>.</operator><name>cnt_all</name></name></expr></argument>,
<argument><expr><name><name>prof_gctx_merge_iter_arg</name><operator>.</operator><name>leak_ngctx</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_JET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type>
<name>prof_cnt_all</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>curobjs</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>curbytes</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>accumobjs</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>accumbytes</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>prof_tdata_merge_iter_arg_s</name></name></type> <name>prof_tdata_merge_iter_arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>prof_gctx_merge_iter_arg_s</name></name></type> <name>prof_gctx_merge_iter_arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_gctx_tree_t</name></type> <name>gctxs</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>curobjs</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>curobjs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>curbytes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>curbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>accumobjs</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>accumobjs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>accumbytes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>accumbytes</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>prof_dump_prep</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_tdata_merge_iter_arg</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>prof_gctx_merge_iter_arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gctxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_gctx_finish</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>gctxs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>curobjs</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>curobjs</name> <operator>=</operator> <name><name>prof_tdata_merge_iter_arg</name><operator>.</operator><name>cnt_all</name><operator>.</operator><name>curobjs</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>curbytes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>curbytes</name> <operator>=</operator> <name><name>prof_tdata_merge_iter_arg</name><operator>.</operator><name>cnt_all</name><operator>.</operator><name>curbytes</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>accumobjs</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>accumobjs</name> <operator>=</operator> <name><name>prof_tdata_merge_iter_arg</name><operator>.</operator><name>cnt_all</name><operator>.</operator><name>accumobjs</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>accumbytes</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>accumbytes</name> <operator>=</operator> <name><name>prof_tdata_merge_iter_arg</name><operator>.</operator><name>cnt_all</name><operator>.</operator><name>accumbytes</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_FILENAME_BUFSIZE</name></cpp:macro> <cpp:value>(PATH_MAX + 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VSEQ_INVALID</name></cpp:macro> <cpp:value>UINT64_C(0xffffffffffffffff)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_dump_filename</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>v</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>vseq</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vseq</name> <operator>!=</operator> <name>VSEQ_INVALID</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>DUMP_FILENAME_BUFSIZE</name></expr></argument>,
<argument><expr><literal type="string">"%s.%d.%"</literal><name>FMTu64</name><literal type="string">".%c%"</literal><name>FMTu64</name><literal type="string">".heap"</literal></expr></argument>,
<argument><expr><name>opt_prof_prefix</name></expr></argument>, <argument><expr><call><name>prof_getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>prof_dump_seq</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>vseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>DUMP_FILENAME_BUFSIZE</name></expr></argument>,
<argument><expr><literal type="string">"%s.%d.%"</literal><name>FMTu64</name><literal type="string">".%c.heap"</literal></expr></argument>,
<argument><expr><name>opt_prof_prefix</name></expr></argument>, <argument><expr><call><name>prof_getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>prof_dump_seq</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>prof_dump_seq</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_fdump</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>filename</name><index>[<expr><name>DUMP_FILENAME_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>opt_prof_final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>opt_prof_prefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prof_booted</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_dump_filename</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="char">'f'</literal></expr></argument>, <argument><expr><name>VSEQ_INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_dump</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>opt_prof_leak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_accum_init</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_accum_t</name> <modifier>*</modifier></type><name>prof_accum</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_ATOMIC_U64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prof_accum</name><operator>-&gt;</operator><name>mtx</name></name></expr></argument>, <argument><expr><literal type="string">"prof_accum"</literal></expr></argument>,
<argument><expr><name>WITNESS_RANK_PROF_ACCUM</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>prof_accum</name><operator>-&gt;</operator><name>accumbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>atomic_store_u64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>prof_accum</name><operator>-&gt;</operator><name>accumbytes</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATOMIC_RELAXED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_idump</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prof_booted</name> <operator>||</operator> <call><name>tsdn_null</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>prof_active_get_unlocked</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq_idump</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt_prof_prefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>filename</name><index>[<expr><name>PATH_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_dump_filename</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><name>prof_dump_iseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_dump_iseq</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_dump</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_mdump</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_prof</name> <operator>||</operator> <operator>!</operator><name>prof_booted</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>filename_buf</name><index>[<expr><name>DUMP_FILENAME_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>opt_prof_prefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_dump_filename</name><argument_list>(<argument><expr><name>filename_buf</name></expr></argument>, <argument><expr><literal type="char">'m'</literal></expr></argument>, <argument><expr><name>prof_dump_mseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_dump_mseq</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>filename_buf</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>prof_dump</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_gdump</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prof_booted</name> <operator>||</operator> <call><name>tsdn_null</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>prof_active_get_unlocked</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tsd</name> <operator>=</operator> <call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>tsd_reentrancy_level_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq_gdump</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt_prof_prefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>filename</name><index>[<expr><name>DUMP_FILENAME_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_dump_filename</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="char">'u'</literal></expr></argument>, <argument><expr><name>prof_dump_useq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_dump_useq</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_dump</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_bt_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name><name>r_hash</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_bt_t</name> <modifier>*</modifier></type><name>bt</name> <init>= <expr><operator>(</operator><name>prof_bt_t</name> <operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash</name><argument_list>(<argument><expr><name><name>bt</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0x94122f33U</literal></expr></argument>, <argument><expr><name>r_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_bt_keycomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>prof_bt_t</name> <modifier>*</modifier></type><name>bt1</name> <init>= <expr><operator>(</operator><name>prof_bt_t</name> <operator>*</operator><operator>)</operator><name>k1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>prof_bt_t</name> <modifier>*</modifier></type><name>bt2</name> <init>= <expr><operator>(</operator><name>prof_bt_t</name> <operator>*</operator><operator>)</operator><name>k2</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bt1</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <name><name>bt2</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>bt1</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt2</name><operator>-&gt;</operator><name>vec</name></name></expr></argument>, <argument><expr><name><name>bt1</name><operator>-&gt;</operator><name>len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_bt_node_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name><name>r_hash</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>prof_bt_node_t</name> <modifier>*</modifier></type><name>bt_node</name> <init>= <expr><operator>(</operator><name>prof_bt_node_t</name> <operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>prof_bt_hash</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>bt_node</name><operator>-&gt;</operator><name>bt</name></name><operator>)</operator></expr></argument>, <argument><expr><name>r_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_bt_node_keycomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>prof_bt_node_t</name> <modifier>*</modifier></type><name>bt_node1</name> <init>= <expr><operator>(</operator><name>prof_bt_node_t</name> <operator>*</operator><operator>)</operator><name>k1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>prof_bt_node_t</name> <modifier>*</modifier></type><name>bt_node2</name> <init>= <expr><operator>(</operator><name>prof_bt_node_t</name> <operator>*</operator><operator>)</operator><name>k2</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>prof_bt_keycomp</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>bt_node1</name><operator>-&gt;</operator><name>bt</name></name><operator>)</operator></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>bt_node2</name><operator>-&gt;</operator><name>bt</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_thr_node_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name><name>r_hash</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>prof_thr_node_t</name> <modifier>*</modifier></type><name>thr_node</name> <init>= <expr><operator>(</operator><name>prof_thr_node_t</name> <operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>hash</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>thr_node</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0x94122f35U</literal></expr></argument>, <argument><expr><name>r_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_thr_node_keycomp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>k2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>prof_thr_node_t</name> <modifier>*</modifier></type><name>thr_node1</name> <init>= <expr><operator>(</operator><name>prof_thr_node_t</name> <operator>*</operator><operator>)</operator><name>k1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>prof_thr_node_t</name> <modifier>*</modifier></type><name>thr_node2</name> <init>= <expr><operator>(</operator><name>prof_thr_node_t</name> <operator>*</operator><operator>)</operator><name>k2</name></expr></init></decl>;</decl_stmt>
<return>return <expr><name><name>thr_node1</name><operator>-&gt;</operator><name>thr_uid</name></name> <operator>==</operator> <name><name>thr_node2</name><operator>-&gt;</operator><name>thr_uid</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>prof_thr_uid_alloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>thr_uid</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_thr_uid_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>thr_uid</name> <operator>=</operator> <name>next_thr_uid</name></expr>;</expr_stmt>
<expr_stmt><expr><name>next_thr_uid</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_thr_uid_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>thr_uid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_init_impl</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>thr_uid</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>thr_discrim</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>thread_name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>active</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>tdata</name> <operator>=</operator> <operator>(</operator><name>prof_tdata_t</name> <operator>*</operator><operator>)</operator><call><name>iallocztm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_tdata_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>prof_tdata_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <call><name>prof_tdata_mutex_choose</name><argument_list>(<argument><expr><name>thr_uid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>thr_uid</name></name> <operator>=</operator> <name>thr_uid</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>thr_discrim</name></name> <operator>=</operator> <name>thr_discrim</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>=</operator> <name>thread_name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>attached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>tctx_uid_next</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ckh_new</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>, <argument><expr><name>PROF_CKH_MINITEMS</name></expr></argument>, <argument><expr><name>prof_bt_hash</name></expr></argument>,
<argument><expr><name>prof_bt_keycomp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>prng_state</name></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>tdata</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_sample_threshold_update</name><argument_list>(<argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq_idump</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>enq_gdump</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>dumping</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <name>active</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tdata_tree_insert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>tdata</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_init</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>prof_tdata_init_impl</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><call><name>prof_thr_uid_alloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>prof_thread_active_init_get</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_tdata_should_destroy_unlocked</name><parameter_list>(<parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>even_if_attached</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>attached</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>even_if_attached</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ckh_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_tdata_should_destroy</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>even_if_attached</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>prof_tdata_should_destroy_unlocked</name><argument_list>(<argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>even_if_attached</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_tdata_destroy_locked</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>even_if_attached</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_assert_owner</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>tdata_tree_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>prof_tdata_should_destroy_unlocked</name><argument_list>(<argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>even_if_attached</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ckh_delete</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata</name><operator>-&gt;</operator><name>bt2tctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_tdata_destroy</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>even_if_attached</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_tdata_destroy_locked</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>even_if_attached</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_tdata_detach</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>destroy_tdata</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>attached</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>destroy_tdata</name> <operator>=</operator> <call><name>prof_tdata_should_destroy</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tdata</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><name>destroy_tdata</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>attached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>tsd_prof_tdata_set</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>destroy_tdata</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>destroy_tdata</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prof_tdata_destroy</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_reinit</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>thr_uid</name> <init>= <expr><name><name>tdata</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>thr_discrim</name> <init>= <expr><name><name>tdata</name><operator>-&gt;</operator><name>thr_discrim</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>thread_name</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then>
<expr><call><name>prof_thread_name_alloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>active</name> <init>= <expr><name><name>tdata</name><operator>-&gt;</operator><name>active</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>prof_tdata_detach</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>prof_tdata_init_impl</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>thr_uid</name></expr></argument>, <argument><expr><name>thr_discrim</name></expr></argument>, <argument><expr><name>thread_name</name></expr></argument>,
<argument><expr><name>active</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>prof_tdata_expire</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>destroy_tdata</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tdata</name><operator>-&gt;</operator><name>expired</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>expired</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>destroy_tdata</name> <operator>=</operator> <ternary><condition><expr><name><name>tdata</name><operator>-&gt;</operator><name>attached</name></name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>:
<expr><call><name>prof_tdata_should_destroy</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>destroy_tdata</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>destroy_tdata</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prof_tdata_t</name> <modifier>*</modifier></type>
<name>prof_tdata_reset_iter</name><parameter_list>(<parameter><decl><type><name>prof_tdata_tree_t</name> <modifier>*</modifier></type><name>tdatas</name></decl></parameter>, <parameter><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name> <init>= <expr><operator>(</operator><name>tsdn_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><ternary><condition><expr><call><name>prof_tdata_expire</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>tdata</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_reset</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>lg_sample</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lg_sample</name> <operator>&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lg_prof_sample</name> <operator>=</operator> <name>lg_sample</name></expr>;</expr_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>to_destroy</name> <init>= <expr><call><name>tdata_tree_iter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>next</name></expr></argument>,
<argument><expr><name>prof_tdata_reset_iter</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>tsd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>to_destroy</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>tdata_tree_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>, <argument><expr><name>to_destroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_tdata_destroy_locked</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>to_destroy</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block> while <condition>(<expr><name>next</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_tdata_cleanup</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>config_prof</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>tsd_prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prof_tdata_detach</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_active_get</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>prof_active_current</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_active_current</name> <operator>=</operator> <name>prof_active</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>prof_active_current</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_active_set</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>active</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>prof_active_old</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_active_old</name> <operator>=</operator> <name>prof_active</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_active</name> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>prof_active_old</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_JET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>size_t</name></type>
<name>prof_log_bt_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_bt_node_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>log_bt_first</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>prof_log_alloc_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>log_alloc_first</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type>
<name>prof_log_thr_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_thr_node_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>log_thr_first</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cnt</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_log_is_logging</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>prof_logging_state</name> <operator>==</operator> <name>prof_logging_state_started</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_log_rep_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>prof_logging_state</name> <operator>==</operator> <name>prof_logging_state_stopped</name>
<operator>&amp;&amp;</operator> <name>log_tables_initialized</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>log_bt_last</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>log_bt_last</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>log_thr_last</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>log_thr_last</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>log_alloc_last</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>log_alloc_last</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>bt_count</name> <init>= <expr><call><name>prof_log_bt_count</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>thr_count</name> <init>= <expr><call><name>prof_log_thr_count</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>alloc_count</name> <init>= <expr><call><name>prof_log_alloc_count</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>prof_logging_state</name> <operator>==</operator> <name>prof_logging_state_stopped</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bt_count</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>thr_count</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>alloc_count</name> <operator>||</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>log_alloc_first</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>alloc_bt_ind</name></name> <operator>&gt;=</operator> <name>bt_count</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>free_bt_ind</name></name> <operator>&gt;=</operator> <name>bt_count</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>alloc_thr_ind</name></name> <operator>&gt;=</operator> <name>thr_count</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>free_thr_ind</name></name> <operator>&gt;=</operator> <name>thr_count</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>alloc_time_ns</name></name> <operator>&gt;</operator> <name><name>node</name><operator>-&gt;</operator><name>free_time_ns</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_log_dummy_set</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>new_value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>prof_log_dummy</name> <operator>=</operator> <name>new_value</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>bool</name></type>
<name>prof_log_start</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_prof</name> <operator>||</operator> <operator>!</operator><name>prof_booted</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buf_size</name> <init>= <expr><name>PATH_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prof_logging_state</name> <operator>!=</operator> <name>prof_logging_state_stopped</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>log_filename</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>, <argument><expr><literal type="string">"%s.%d.%"</literal><name>FMTu64</name><literal type="string">".json"</literal></expr></argument>,
<argument><expr><name>opt_prof_prefix</name></expr></argument>, <argument><expr><call><name>prof_getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>log_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>log_seq</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_logging_state</name> <operator>=</operator> <name>prof_logging_state_started</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>buf_size</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>log_filename</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_logging_state</name> <operator>=</operator> <name>prof_logging_state_started</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>nstime_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>log_start_timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_log_stop_final</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsd_fetch</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>prof_log_stop</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>prof_emitter_cb_arg_s</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>ret</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_emitter_write_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>to_write</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>prof_emitter_cb_arg_s</name></name> <modifier>*</modifier></type><name>arg</name> <init>=
<expr><operator>(</operator>struct <name>prof_emitter_cb_arg_s</name> <operator>*</operator><operator>)</operator><name>opaque</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bytes</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>to_write</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_JET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>prof_log_dummy</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>arg</name><operator>-&gt;</operator><name>ret</name></name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>to_write</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_log_emit_threads</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>emitter_json_array_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"threads"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>prof_thr_node_t</name> <modifier>*</modifier></type><name>thr_node</name> <init>= <expr><name>log_thr_first</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_thr_node_t</name> <modifier>*</modifier></type><name>thr_old_node</name></decl>;</decl_stmt>
<while>while <condition>(<expr><name>thr_node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emitter_json_object_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"thr_uid"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>thr_node</name><operator>-&gt;</operator><name>thr_uid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>thr_name</name> <init>= <expr><name><name>thr_node</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"thr_name"</literal></expr></argument>, <argument><expr><name>emitter_type_string</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>thr_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>thr_old_node</name> <operator>=</operator> <name>thr_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>thr_node</name> <operator>=</operator> <name><name>thr_node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>idalloc</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>thr_old_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_log_emit_traces</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>emitter_json_array_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"stack_traces"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>prof_bt_node_t</name> <modifier>*</modifier></type><name>bt_node</name> <init>= <expr><name>log_bt_first</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_bt_node_t</name> <modifier>*</modifier></type><name>bt_old_node</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>intptr_t</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buf_sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>bt_node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emitter_json_array_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bt_node</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_sz</name></expr></argument>, <argument><expr><literal type="string">"%p"</literal></expr></argument>, <argument><expr><name><name>bt_node</name><operator>-&gt;</operator><name>bt</name><operator>.</operator><name>vec</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>trace_str</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>emitter_json_value</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><name>emitter_type_string</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>trace_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bt_old_node</name> <operator>=</operator> <name>bt_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bt_node</name> <operator>=</operator> <name><name>bt_node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>idalloc</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>bt_old_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_log_emit_allocs</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>emitter_json_array_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"allocations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>alloc_node</name> <init>= <expr><name>log_alloc_first</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prof_alloc_node_t</name> <modifier>*</modifier></type><name>alloc_old_node</name></decl>;</decl_stmt>
<while>while <condition>(<expr><name>alloc_node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>emitter_json_object_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"alloc_thread"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>alloc_thr_ind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"free_thread"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>free_thr_ind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"alloc_trace"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>alloc_bt_ind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"free_trace"</literal></expr></argument>, <argument><expr><name>emitter_type_size</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>free_bt_ind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"alloc_timestamp"</literal></expr></argument>,
<argument><expr><name>emitter_type_uint64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>alloc_time_ns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"free_timestamp"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>free_time_ns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"usize"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>alloc_node</name><operator>-&gt;</operator><name>usize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>alloc_old_node</name> <operator>=</operator> <name>alloc_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>alloc_node</name> <operator>=</operator> <name><name>alloc_node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>idalloc</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>alloc_old_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>emitter_json_array_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>prof_log_emit_metadata</name><parameter_list>(<parameter><decl><type><name>emitter_t</name> <modifier>*</modifier></type><name>emitter</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>emitter_json_object_kv_begin</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"info"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>nstime_t</name></type> <name>now</name> <init>= <expr><name>NSTIME_ZERO_INITIALIZER</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>nstime_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ns</name> <init>= <expr><call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>nstime_ns</name><argument_list>(<argument><expr><operator>&amp;</operator><name>log_start_timestamp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"duration"</literal></expr></argument>, <argument><expr><name>emitter_type_uint64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vers</name> <init>= <expr><name>JEMALLOC_VERSION</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"version"</literal></expr></argument>,
<argument><expr><name>emitter_type_string</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"lg_sample_rate"</literal></expr></argument>,
<argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lg_prof_sample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pid</name> <init>= <expr><call><name>prof_getpid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>emitter_json_kv</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>, <argument><expr><literal type="string">"pid"</literal></expr></argument>, <argument><expr><name>emitter_type_int</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emitter_json_object_end</name><argument_list>(<argument><expr><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>bool</name></type>
<name>prof_log_stop</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opt_prof</name> <operator>||</operator> <operator>!</operator><name>prof_booted</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name> <init>= <expr><call><name>tsdn_tsd</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prof_logging_state</name> <operator>!=</operator> <name>prof_logging_state_started</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>






<expr_stmt><expr><name>prof_logging_state</name> <operator>=</operator> <name>prof_logging_state_dumping</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>emitter_t</name></type> <name>emitter</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_JET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>prof_log_dummy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>creat</name><argument_list>(<argument><expr><name>log_filename</name></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>creat</name><argument_list>(<argument><expr><name>log_filename</name></expr></argument>, <argument><expr><literal type="number">0644</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_printf</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: creat() for log file \"%s\" "</literal>
<literal type="string">" failed with %d\n"</literal></expr></argument>, <argument><expr><name>log_filename</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<decl_stmt><decl><type><name><name>struct</name> <name>prof_emitter_cb_arg_s</name></name></type> <name>arg</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>arg</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>emitter_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>, <argument><expr><name>emitter_output_json</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_emitter_write_cb</name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name>arg</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>emitter_begin</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_log_emit_metadata</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_log_emit_threads</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_log_emit_traces</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>prof_log_emit_allocs</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>emitter_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>emitter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>log_tables_initialized</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ckh_delete</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_bt_node_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ckh_delete</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_thr_node_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>log_tables_initialized</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>log_bt_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>log_thr_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>log_bt_first</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>log_bt_last</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>log_thr_first</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>log_thr_last</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>log_alloc_first</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>log_alloc_last</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_logging_state</name> <operator>=</operator> <name>prof_logging_state_stopped</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_JET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>prof_log_dummy</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>prof_thread_name_get</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>prof_thread_name_alloc</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>thread_name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>thread_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>thread_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="string">""</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>iallocztm</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>sz_size2index</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><call><name>arena_get</name><argument_list>(<argument><expr><name>TSDN_NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>thread_name</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>prof_thread_name_set</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>thread_name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>EAGAIN</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>thread_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>EFAULT</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>thread_name</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>thread_name</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isgraph</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isblank</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>EFAULT</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>prof_thread_name_alloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>thread_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>EAGAIN</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>idalloctm</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>thread_name</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_thread_active_get</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>tdata</name><operator>-&gt;</operator><name>active</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_thread_active_set</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>active</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>prof_tdata_t</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tdata</name> <operator>=</operator> <call><name>prof_tdata_get</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tdata</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <name>active</name></expr>;</expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_thread_active_init_get</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>active_init</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>active_init</name> <operator>=</operator> <name>prof_thread_active_init</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>active_init</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_thread_active_init_set</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>active_init</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>active_init_old</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>active_init_old</name> <operator>=</operator> <name>prof_thread_active_init</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_thread_active_init</name> <operator>=</operator> <name>active_init</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>active_init_old</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_gdump_get</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>prof_gdump_current</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_gdump_current</name> <operator>=</operator> <name>prof_gdump_val</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>prof_gdump_current</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_gdump_set</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>gdump</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>prof_gdump_old</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_lock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_gdump_old</name> <operator>=</operator> <name>prof_gdump_val</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prof_gdump_val</name> <operator>=</operator> <name>gdump</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_unlock</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>prof_gdump_old</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_boot0</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>opt_prof_prefix</name></expr></argument>, <argument><expr><name>PROF_PREFIX_DEFAULT</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PROF_PREFIX_DEFAULT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_boot1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><name>opt_prof_leak</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>opt_prof</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>opt_prof</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>opt_prof_gdump</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>opt_prof</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>opt_lg_prof_interval</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prof_interval</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1U</literal><operator>)</operator> <operator>&lt;&lt;</operator>
<name>opt_lg_prof_interval</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>prof_boot2</name><parameter_list>(<parameter><decl><type><name>tsd_t</name> <modifier>*</modifier></type><name>tsd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>cassert</name><argument_list>(<argument><expr><name>config_prof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_prof</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>lg_prof_sample</name> <operator>=</operator> <name>opt_lg_prof_sample</name></expr>;</expr_stmt>

<expr_stmt><expr><name>prof_active</name> <operator>=</operator> <name>opt_prof_active</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_active"</literal></expr></argument>,
<argument><expr><name>WITNESS_RANK_PROF_ACTIVE</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>prof_gdump_val</name> <operator>=</operator> <name>opt_prof_gdump</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_gdump"</literal></expr></argument>,
<argument><expr><name>WITNESS_RANK_PROF_GDUMP</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>prof_thread_active_init</name> <operator>=</operator> <name>opt_prof_thread_active_init</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>,
<argument><expr><literal type="string">"prof_thread_active_init"</literal></expr></argument>,
<argument><expr><name>WITNESS_RANK_PROF_THREAD_ACTIVE_INIT</name></expr></argument>,
<argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ckh_new</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx</name></expr></argument>, <argument><expr><name>PROF_CKH_MINITEMS</name></expr></argument>, <argument><expr><name>prof_bt_hash</name></expr></argument>,
<argument><expr><name>prof_bt_keycomp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_bt2gctx"</literal></expr></argument>,
<argument><expr><name>WITNESS_RANK_PROF_BT2GCTX</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>tdata_tree_new</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_tdatas"</literal></expr></argument>,
<argument><expr><name>WITNESS_RANK_PROF_TDATAS</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>next_thr_uid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>next_thr_uid_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_next_thr_uid"</literal></expr></argument>,
<argument><expr><name>WITNESS_RANK_PROF_NEXT_THR_UID</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_dump_seq"</literal></expr></argument>,
<argument><expr><name>WITNESS_RANK_PROF_DUMP_SEQ</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_dump"</literal></expr></argument>,
<argument><expr><name>WITNESS_RANK_PROF_DUMP</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_prof_final</name> <operator>&amp;&amp;</operator> <name><name>opt_prof_prefix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
<call><name>atexit</name><argument_list>(<argument><expr><name>prof_fdump</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Error in atexit()\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_prof_log</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>prof_log_start</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>atexit</name><argument_list>(<argument><expr><name>prof_log_stop_final</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_write</name><argument_list>(<argument><expr><literal type="string">"&lt;jemalloc&gt;: Error in atexit() "</literal>
<literal type="string">"for logging\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>opt_abort</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>log_mtx</name></expr></argument>, <argument><expr><literal type="string">"prof_log"</literal></expr></argument>,
<argument><expr><name>WITNESS_RANK_PROF_LOG</name></expr></argument>, <argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ckh_new</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_bt_node_set</name></expr></argument>, <argument><expr><name>PROF_CKH_MINITEMS</name></expr></argument>,
<argument><expr><name>prof_bt_node_hash</name></expr></argument>, <argument><expr><name>prof_bt_node_keycomp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ckh_new</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>log_thr_node_set</name></expr></argument>, <argument><expr><name>PROF_CKH_MINITEMS</name></expr></argument>,
<argument><expr><name>prof_thr_node_hash</name></expr></argument>, <argument><expr><name>prof_thr_node_keycomp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>log_tables_initialized</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>gctx_locks</name> <operator>=</operator> <operator>(</operator><name>malloc_mutex_t</name> <operator>*</operator><operator>)</operator><call><name>base_alloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>b0get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PROF_NCTX_LOCKS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>malloc_mutex_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>CACHELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>gctx_locks</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NCTX_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gctx_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"prof_gctx"</literal></expr></argument>,
<argument><expr><name>WITNESS_RANK_PROF_GCTX</name></expr></argument>,
<argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>tdata_locks</name> <operator>=</operator> <operator>(</operator><name>malloc_mutex_t</name> <operator>*</operator><operator>)</operator><call><name>base_alloc</name><argument_list>(<argument><expr><call><name>tsd_tsdn</name><argument_list>(<argument><expr><name>tsd</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>b0get</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>PROF_NTDATA_LOCKS</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>malloc_mutex_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>CACHELINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tdata_locks</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NTDATA_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>malloc_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tdata_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"prof_tdata"</literal></expr></argument>,
<argument><expr><name>WITNESS_RANK_PROF_TDATA</name></expr></argument>,
<argument><expr><name>malloc_mutex_rank_exclusive</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>JEMALLOC_PROF_LIBGCC</name></expr></argument>)</argument_list></call></expr></cpp:if>




<expr_stmt><expr><call><name>_Unwind_Backtrace</name><argument_list>(<argument><expr><name>prof_unwind_init_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>prof_booted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_prefork0</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NTDATA_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NCTX_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_prefork1</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_thr_uid_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_prefork</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_postfork_parent</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_thr_uid_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NCTX_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NTDATA_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_postfork_parent</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>prof_postfork_child</name><parameter_list>(<parameter><decl><type><name>tsdn_t</name> <modifier>*</modifier></type><name>tsdn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>config_prof</name> <operator>&amp;&amp;</operator> <name>opt_prof</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_thread_active_init_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next_thr_uid_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_gdump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_seq_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_active_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NCTX_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gctx_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>PROF_NTDATA_LOCKS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tdata_locks</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tdatas_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bt2gctx_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>malloc_mutex_postfork_child</name><argument_list>(<argument><expr><name>tsdn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prof_dump_mtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


</unit>
