<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/results/redis_res/_cppstats/redis/deps/hdr_histogram/hdr_histogram.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hdr_histogram.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hdr_atomic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"hdr_alloc.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>malloc</name></cpp:macro> <cpp:value>hdr_malloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>calloc</name></cpp:macro> <cpp:value>hdr_calloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>free</name></cpp:macro> <cpp:value>hdr_free</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>realloc</name></cpp:macro> <cpp:value>hdr_realloc</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>normalize_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>normalized_index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>adjustment</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>normalizing_index_offset</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>normalized_index</name> <operator>=</operator> <name>index</name> <operator>-</operator> <name><name>h</name><operator>-&gt;</operator><name>normalizing_index_offset</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>normalized_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>adjustment</name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>counts_len</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>normalized_index</name> <operator>&gt;=</operator> <name><name>h</name><operator>-&gt;</operator><name>counts_len</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>adjustment</name> <operator>=</operator> <operator>-</operator><name><name>h</name><operator>-&gt;</operator><name>counts_len</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>normalized_index</name> <operator>+</operator> <name>adjustment</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>counts_get_direct</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>h</name><operator>-&gt;</operator><name>counts</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>counts_get_normalised</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>counts_get_direct</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>normalize_index</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>counts_inc_normalised</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>normalised_index</name> <init>= <expr><call><name>normalize_index</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>counts</name><index>[<expr><name>normalised_index</name></expr>]</index></name> <operator>+=</operator> <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>total_count</name></name> <operator>+=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>counts_inc_normalised_atomic</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>normalised_index</name> <init>= <expr><call><name>normalize_index</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>hdr_atomic_add_fetch_64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>counts</name><index>[<expr><name>normalised_index</name></expr>]</index></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hdr_atomic_add_fetch_64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>total_count</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>update_min_max</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>min_value</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>value</name> <operator>&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>min_value</name></name> <operator>&amp;&amp;</operator> <name>value</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>value</name></expr> </then><else>: <expr><name><name>h</name><operator>-&gt;</operator><name>min_value</name></name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>max_value</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>value</name> <operator>&gt;</operator> <name><name>h</name><operator>-&gt;</operator><name>max_value</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>value</name></expr> </then><else>: <expr><name><name>h</name><operator>-&gt;</operator><name>max_value</name></name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>update_min_max_atomic</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>current_min_value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>current_max_value</name></decl>;</decl_stmt>
<do>do
<block>{<block_content>
<expr_stmt><expr><name>current_min_value</name> <operator>=</operator> <call><name>hdr_atomic_load_64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>min_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name>value</name> <operator>||</operator> <name>current_min_value</name> <operator>&lt;=</operator> <name>value</name></expr>)</condition>
<block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
while <condition>(<expr><operator>!</operator><call><name>hdr_atomic_compare_exchange_64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>min_value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_min_value</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<do>do
<block>{<block_content>
<expr_stmt><expr><name>current_max_value</name> <operator>=</operator> <call><name>hdr_atomic_load_64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>max_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;=</operator> <name>current_max_value</name></expr>)</condition>
<block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
while <condition>(<expr><operator>!</operator><call><name>hdr_atomic_compare_exchange_64</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>max_value</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>current_max_value</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>power</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>exp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>result</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>exp</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>*=</operator> <name>base</name></expr>;</expr_stmt> <expr_stmt><expr><name>exp</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>intrinsic</name><name>(</name><name>_BitScanReverse64</name><name>)</name></cpp:pragma>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>intrinsic</name><name>(</name><name>_BitScanReverse</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>count_leading_zeros_64</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>leading_zero</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>_BitScanReverse64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>leading_zero</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>high</name> <init>= <expr><name>value</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_BitScanReverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>leading_zero</name></expr></argument>, <argument><expr><name>high</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>leading_zero</name> <operator>+=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>low</name> <init>= <expr><name>value</name> <operator>&amp;</operator> <literal type="number">0x00000000FFFFFFFF</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>_BitScanReverse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>leading_zero</name></expr></argument>, <argument><expr><name>low</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><literal type="number">63</literal> <operator>-</operator> <name>leading_zero</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>__builtin_clzll</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>get_bucket_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>pow2ceiling</name> <init>= <expr><literal type="number">64</literal> <operator>-</operator> <call><name>count_leading_zeros_64</name><argument_list>(<argument><expr><name>value</name> <operator>|</operator> <name><name>h</name><operator>-&gt;</operator><name>sub_bucket_mask</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>pow2ceiling</name> <operator>-</operator> <name><name>h</name><operator>-&gt;</operator><name>unit_magnitude</name></name> <operator>-</operator> <operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>sub_bucket_half_count_magnitude</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>get_sub_bucket_index</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>bucket_index</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>unit_magnitude</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>int32_t</name><operator>)</operator><operator>(</operator><name>value</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>bucket_index</name> <operator>+</operator> <name>unit_magnitude</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>counts_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>bucket_index</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>sub_bucket_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>bucket_base_index</name> <init>= <expr><operator>(</operator><name>bucket_index</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>sub_bucket_half_count_magnitude</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>offset_in_bucket</name> <init>= <expr><name>sub_bucket_index</name> <operator>-</operator> <name><name>h</name><operator>-&gt;</operator><name>sub_bucket_half_count</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><name>bucket_base_index</name> <operator>+</operator> <name>offset_in_bucket</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>value_from_index</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>bucket_index</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>sub_bucket_index</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>unit_magnitude</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator> <name>sub_bucket_index</name><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>bucket_index</name> <operator>+</operator> <name>unit_magnitude</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int32_t</name></type> <name>counts_index_for</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>bucket_index</name> <init>= <expr><call><name>get_bucket_index</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>sub_bucket_index</name> <init>= <expr><call><name>get_sub_bucket_index</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>bucket_index</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>unit_magnitude</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>counts_index</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>bucket_index</name></expr></argument>, <argument><expr><name>sub_bucket_index</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>hdr_value_at_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>bucket_index</name> <init>= <expr><operator>(</operator><name>index</name> <operator>&gt;&gt;</operator> <name><name>h</name><operator>-&gt;</operator><name>sub_bucket_half_count_magnitude</name></name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>sub_bucket_index</name> <init>= <expr><operator>(</operator><name>index</name> <operator>&amp;</operator> <operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>sub_bucket_half_count</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <name><name>h</name><operator>-&gt;</operator><name>sub_bucket_half_count</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bucket_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>sub_bucket_index</name> <operator>-=</operator> <name><name>h</name><operator>-&gt;</operator><name>sub_bucket_half_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>bucket_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>value_from_index</name><argument_list>(<argument><expr><name>bucket_index</name></expr></argument>, <argument><expr><name>sub_bucket_index</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>unit_magnitude</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>hdr_size_of_equivalent_value_range</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>bucket_index</name> <init>= <expr><call><name>get_bucket_index</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>sub_bucket_index</name> <init>= <expr><call><name>get_sub_bucket_index</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>bucket_index</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>unit_magnitude</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>adjusted_bucket</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>sub_bucket_index</name> <operator>&gt;=</operator> <name><name>h</name><operator>-&gt;</operator><name>sub_bucket_count</name></name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>bucket_index</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name>bucket_index</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>INT64_C</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>h</name><operator>-&gt;</operator><name>unit_magnitude</name></name> <operator>+</operator> <name>adjusted_bucket</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>lowest_equivalent_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>bucket_index</name> <init>= <expr><call><name>get_bucket_index</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>sub_bucket_index</name> <init>= <expr><call><name>get_sub_bucket_index</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>bucket_index</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>unit_magnitude</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>value_from_index</name><argument_list>(<argument><expr><name>bucket_index</name></expr></argument>, <argument><expr><name>sub_bucket_index</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>unit_magnitude</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>hdr_next_non_equivalent_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>lowest_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>hdr_size_of_equivalent_value_range</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>highest_equivalent_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>hdr_next_non_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>hdr_median_equivalent_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>lowest_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><call><name>hdr_size_of_equivalent_value_range</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>non_zero_min</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>INT64_MAX</name> <operator>==</operator> <name><name>h</name><operator>-&gt;</operator><name>min_value</name></name></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>INT64_MAX</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>lowest_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>min_value</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>hdr_reset_internal_counters</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>min_non_zero_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>observed_total_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>h</name><operator>-&gt;</operator><name>counts_len</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>count_at_index</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>count_at_index</name> <operator>=</operator> <call><name>counts_get_direct</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>observed_total_count</name> <operator>+=</operator> <name>count_at_index</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>min_non_zero_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>min_non_zero_index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>max_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>max_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>max_value</name> <init>= <expr><call><name>hdr_value_at_index</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>max_index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>max_value</name></name> <operator>=</operator> <call><name>highest_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>max_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>min_non_zero_index</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>min_value</name></name> <operator>=</operator> <name>INT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>min_value</name></name> <operator>=</operator> <call><name>hdr_value_at_index</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>min_non_zero_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>total_count</name></name> <operator>=</operator> <name>observed_total_count</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int32_t</name></type> <name>buckets_needed_to_cover_value</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>sub_bucket_count</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>unit_magnitude</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>smallest_untrackable_value</name> <init>= <expr><operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator> <name>sub_bucket_count</name><operator>)</operator> <operator>&lt;&lt;</operator> <name>unit_magnitude</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int32_t</name></type> <name>buckets_needed</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>smallest_untrackable_value</name> <operator>&lt;=</operator> <name>value</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>smallest_untrackable_value</name> <operator>&gt;</operator> <name>INT64_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>buckets_needed</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>smallest_untrackable_value</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>buckets_needed</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>buckets_needed</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>hdr_calculate_bucket_config</name><parameter_list>(
<parameter><decl><type><name>int64_t</name></type> <name>lowest_trackable_value</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>highest_trackable_value</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>significant_figures</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hdr_histogram_bucket_config</name></name><modifier>*</modifier></type> <name>cfg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>sub_bucket_count_magnitude</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>largest_value_with_single_unit_resolution</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lowest_trackable_value</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator>
<name><name>significant_figures</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <literal type="number">5</literal> <operator>&lt;</operator> <name>significant_figures</name> <operator>||</operator>
<name>lowest_trackable_value</name> <operator>*</operator> <literal type="number">2</literal></expr></argument> &gt;</argument_list></name> <name>highest_trackable_value</name></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>EINVAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>lowest_trackable_value</name></name> <operator>=</operator> <name>lowest_trackable_value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>significant_figures</name></name> <operator>=</operator> <name>significant_figures</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>highest_trackable_value</name></name> <operator>=</operator> <name>highest_trackable_value</name></expr>;</expr_stmt>
<expr_stmt><expr><name>largest_value_with_single_unit_resolution</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <call><name>power</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><name>significant_figures</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sub_bucket_count_magnitude</name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator> <call><name>ceil</name><argument_list>(<argument><expr><call><name>log</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>largest_value_with_single_unit_resolution</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>log</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_half_count_magnitude</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>sub_bucket_count_magnitude</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name>sub_bucket_count_magnitude</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>unit_magnitude</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator> <call><name>floor</name><argument_list>(<argument><expr><call><name>log</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name>lowest_trackable_value</name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>log</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_count</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator> <call><name>pow</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_half_count_magnitude</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_half_count</name></name> <operator>=</operator> <name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_count</name></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_mask</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int64_t</name><operator>)</operator> <name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_count</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <name><name>cfg</name><operator>-&gt;</operator><name>unit_magnitude</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cfg</name><operator>-&gt;</operator><name>unit_magnitude</name></name> <operator>+</operator> <name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_half_count_magnitude</name></name> <operator>&gt;</operator> <literal type="number">61</literal></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>EINVAL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>bucket_count</name></name> <operator>=</operator> <call><name>buckets_needed_to_cover_value</name><argument_list>(<argument><expr><name>highest_trackable_value</name></expr></argument>, <argument><expr><name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_count</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int32_t</name><operator>)</operator><name><name>cfg</name><operator>-&gt;</operator><name>unit_magnitude</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cfg</name><operator>-&gt;</operator><name>counts_len</name></name> <operator>=</operator> <operator>(</operator><name><name>cfg</name><operator>-&gt;</operator><name>bucket_count</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_count</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>hdr_init_preallocated</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>hdr_histogram_bucket_config</name></name><modifier>*</modifier></type> <name>cfg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>lowest_trackable_value</name></name> <operator>=</operator> <name><name>cfg</name><operator>-&gt;</operator><name>lowest_trackable_value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>highest_trackable_value</name></name> <operator>=</operator> <name><name>cfg</name><operator>-&gt;</operator><name>highest_trackable_value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>unit_magnitude</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name><name>cfg</name><operator>-&gt;</operator><name>unit_magnitude</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>significant_figures</name></name> <operator>=</operator> <operator>(</operator><name>int32_t</name><operator>)</operator><name><name>cfg</name><operator>-&gt;</operator><name>significant_figures</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>sub_bucket_half_count_magnitude</name></name> <operator>=</operator> <name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_half_count_magnitude</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>sub_bucket_half_count</name></name> <operator>=</operator> <name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_half_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>sub_bucket_mask</name></name> <operator>=</operator> <name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_mask</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>sub_bucket_count</name></name> <operator>=</operator> <name><name>cfg</name><operator>-&gt;</operator><name>sub_bucket_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>min_value</name></name> <operator>=</operator> <name>INT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>max_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>normalizing_index_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>conversion_ratio</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>bucket_count</name></name> <operator>=</operator> <name><name>cfg</name><operator>-&gt;</operator><name>bucket_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>counts_len</name></name> <operator>=</operator> <name><name>cfg</name><operator>-&gt;</operator><name>counts_len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>total_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>hdr_init</name><parameter_list>(
<parameter><decl><type><name>int64_t</name></type> <name>lowest_trackable_value</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>highest_trackable_value</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>significant_figures</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier><modifier>*</modifier></type> <name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name><modifier>*</modifier></type> <name>counts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hdr_histogram_bucket_config</name></name></type> <name>cfg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>histogram</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><name>hdr_calculate_bucket_config</name><argument_list>(<argument><expr><name>lowest_trackable_value</name></expr></argument>, <argument><expr><name>highest_trackable_value</name></expr></argument>, <argument><expr><name>significant_figures</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cfg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>counts</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>cfg</name><operator>.</operator><name>counts_len</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>counts</name></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>ENOMEM</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>histogram</name> <operator>=</operator> <operator>(</operator>struct <name>hdr_histogram</name><operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>hdr_histogram</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>histogram</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>counts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ENOMEM</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>histogram</name><operator>-&gt;</operator><name>counts</name></name> <operator>=</operator> <name>counts</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hdr_init_preallocated</name><argument_list>(<argument><expr><name>histogram</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cfg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>histogram</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>hdr_close</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>h</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>counts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>hdr_alloc</name><parameter_list>(<parameter><decl><type><name>int64_t</name></type> <name>highest_trackable_value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>significant_figures</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier><modifier>*</modifier></type> <name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>hdr_init</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>highest_trackable_value</name></expr></argument>, <argument><expr><name>significant_figures</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>hdr_reset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>total_count</name></name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>min_value</name></name> <operator>=</operator> <name>INT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>max_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>counts</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>counts_len</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>size_t</name></type> <name>hdr_get_memory_size</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>hdr_histogram</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>h</name><operator>-&gt;</operator><name>counts_len</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int64_t</name></expr></argument>)</argument_list></sizeof></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>hdr_record_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>hdr_record_values</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>hdr_record_value_atomic</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>hdr_record_values_atomic</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>hdr_record_values</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>counts_index</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>counts_index</name> <operator>=</operator> <call><name>counts_index_for</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>counts_index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>h</name><operator>-&gt;</operator><name>counts_len</name></name> <operator>&lt;=</operator> <name>counts_index</name></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>counts_inc_normalised</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>counts_index</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_min_max</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>hdr_record_values_atomic</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int32_t</name></type> <name>counts_index</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>counts_index</name> <operator>=</operator> <call><name>counts_index_for</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>counts_index</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>h</name><operator>-&gt;</operator><name>counts_len</name></name> <operator>&lt;=</operator> <name>counts_index</name></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>counts_inc_normalised_atomic</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>counts_index</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>update_min_max_atomic</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>hdr_record_corrected_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>expected_interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>hdr_record_corrected_values</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>expected_interval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>hdr_record_corrected_value_atomic</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>expected_interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>hdr_record_corrected_values_atomic</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>expected_interval</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>hdr_record_corrected_values</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>expected_interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>missing_value</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hdr_record_values</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>expected_interval</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>value</name> <operator>&lt;=</operator> <name>expected_interval</name></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>missing_value</name> <operator>=</operator> <name>value</name> <operator>-</operator> <name>expected_interval</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>missing_value</name> <operator>&gt;=</operator> <name>expected_interval</name></expr>;</condition> <incr><expr><name>missing_value</name> <operator>-=</operator> <name>expected_interval</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hdr_record_values</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>missing_value</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>hdr_record_corrected_values_atomic</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>expected_interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>missing_value</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hdr_record_values_atomic</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>expected_interval</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>value</name> <operator>&lt;=</operator> <name>expected_interval</name></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>missing_value</name> <operator>=</operator> <name>value</name> <operator>-</operator> <name>expected_interval</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>missing_value</name> <operator>&gt;=</operator> <name>expected_interval</name></expr>;</condition> <incr><expr><name>missing_value</name> <operator>-=</operator> <name>expected_interval</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hdr_record_values_atomic</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>missing_value</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>hdr_add</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>from</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hdr_iter</name></name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>dropped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>hdr_iter_recorded_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>hdr_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>value</name> <init>= <expr><name><name>iter</name><operator>.</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>count</name> <init>= <expr><name><name>iter</name><operator>.</operator><name>count</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hdr_record_values</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>dropped</name> <operator>+=</operator> <name>count</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>dropped</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>hdr_add_while_correcting_for_coordinated_omission</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>expected_interval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hdr_iter</name></name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>dropped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>hdr_iter_recorded_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>hdr_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>value</name> <init>= <expr><name><name>iter</name><operator>.</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>count</name> <init>= <expr><name><name>iter</name><operator>.</operator><name>count</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hdr_record_corrected_values</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>expected_interval</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>dropped</name> <operator>+=</operator> <name>count</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>dropped</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>hdr_max</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name><name>h</name><operator>-&gt;</operator><name>max_value</name></name></expr>)</condition>
<block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>highest_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>max_value</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>hdr_min</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <call><name>hdr_count_at_index</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>non_zero_min</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>hdr_value_at_percentile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>percentile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hdr_iter</name></name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>requested_percentile</name> <init>= <expr><ternary><condition><expr><name>percentile</name> <operator>&lt;</operator> <literal type="number">100.0</literal></expr> ?</condition><then> <expr><name>percentile</name></expr> </then><else>: <expr><literal type="number">100.0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>count_at_percentile</name> <init>=
<expr><operator>(</operator><name>int64_t</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>requested_percentile</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>total_count</name></name><operator>)</operator> <operator>+</operator> <literal type="number">0.5</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>count_at_percentile</name> <operator>=</operator> <ternary><condition><expr><name>count_at_percentile</name> <operator>&gt;</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>count_at_percentile</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hdr_iter_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>hdr_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>iter</name><operator>.</operator><name>count</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>total</name> <operator>&gt;=</operator> <name>count_at_percentile</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>value_from_index</name> <init>= <expr><name><name>iter</name><operator>.</operator><name>value</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>highest_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value_from_index</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>double</name></type> <name>hdr_mean</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hdr_iter</name></name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>hdr_iter_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>hdr_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <name><name>iter</name><operator>.</operator><name>count</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>total</name> <operator>+=</operator> <name><name>iter</name><operator>.</operator><name>count</name></name> <operator>*</operator> <call><name>hdr_median_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><name>total</name> <operator>*</operator> <literal type="number">1.0</literal><operator>)</operator> <operator>/</operator> <name><name>h</name><operator>-&gt;</operator><name>total_count</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>double</name></type> <name>hdr_stddev</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>mean</name> <init>= <expr><call><name>hdr_mean</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>geometric_dev_total</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hdr_iter</name></name></type> <name>iter</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>hdr_iter_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>hdr_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <name><name>iter</name><operator>.</operator><name>count</name></name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>dev</name> <init>= <expr><operator>(</operator><call><name>hdr_median_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1.0</literal><operator>)</operator> <operator>-</operator> <name>mean</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>geometric_dev_total</name> <operator>+=</operator> <operator>(</operator><name>dev</name> <operator>*</operator> <name>dev</name><operator>)</operator> <operator>*</operator> <name><name>iter</name><operator>.</operator><name>count</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><call><name>sqrt</name><argument_list>(<argument><expr><name>geometric_dev_total</name> <operator>/</operator> <name><name>h</name><operator>-&gt;</operator><name>total_count</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>hdr_values_are_equivalent</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>lowest_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lowest_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>hdr_lowest_equivalent_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>lowest_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>hdr_count_at_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>counts_get_normalised</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><call><name>counts_index_for</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>hdr_count_at_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>counts_get_normalised</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>has_buckets</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>counts_index</name></name> <operator>&lt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>counts_len</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>has_next</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><name><name>iter</name><operator>-&gt;</operator><name>cumulative_count</name></name> <operator>&lt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>total_count</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>move_next</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>counts_index</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_buckets</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <call><name>counts_get_normalised</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>counts_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>cumulative_count</name></name> <operator>+=</operator> <name><name>iter</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>hdr_value_at_index</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>counts_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>highest_equivalent_value</name></name> <operator>=</operator> <call><name>highest_equivalent_value</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>lowest_equivalent_value</name></name> <operator>=</operator> <call><name>lowest_equivalent_value</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>median_equivalent_value</name></name> <operator>=</operator> <call><name>hdr_median_equivalent_value</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int64_t</name></type> <name>peek_next_value_from_index</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>hdr_value_at_index</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>counts_index</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>next_value_greater_than_reporting_level_upper_bound</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>reporting_level_upper_bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>counts_index</name></name> <operator>&gt;=</operator> <name><name>iter</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>counts_len</name></name></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>peek_next_value_from_index</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>reporting_level_upper_bound</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>basic_iter_next</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>iter</name><operator>-&gt;</operator><name>counts_index</name></name> <operator>&gt;=</operator> <name><name>iter</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>counts_len</name></name></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>move_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>update_iterated_values</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>new_value_iterated_to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>value_iterated_from</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>value_iterated_to</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>value_iterated_to</name></name> <operator>=</operator> <name>new_value_iterated_to</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>all_values_iter_next</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><call><name>move_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>update_iterated_values</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>hdr_iter_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>counts_index</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>total_count</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>total_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>cumulative_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>highest_equivalent_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>value_iterated_from</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>value_iterated_to</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>_next_fp</name></name> <operator>=</operator> <name>all_values_iter_next</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>hdr_iter_next</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name><name>iter</name><operator>-&gt;</operator><name>_next_fp</name></name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>percentile_iter_next</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>temp</name></decl>, <decl><type ref="prev"/><name>half_distance</name></decl>, <decl><type ref="prev"/><name>percentile_reporting_ticks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hdr_iter_percentiles</name></name><modifier>*</modifier></type> <name>percentiles</name> <init>= <expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>percentiles</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>percentiles</name><operator>-&gt;</operator><name>seen_last_value</name></name></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>percentiles</name><operator>-&gt;</operator><name>seen_last_value</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>percentiles</name><operator>-&gt;</operator><name>percentile</name></name> <operator>=</operator> <literal type="number">100.0</literal></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>counts_index</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>basic_iter_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<do>do
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>current_percentile</name> <init>= <expr><operator>(</operator><literal type="number">100.0</literal> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>iter</name><operator>-&gt;</operator><name>cumulative_count</name></name><operator>)</operator> <operator>/</operator> <name><name>iter</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>total_count</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>percentiles</name><operator>-&gt;</operator><name>percentile_to_iterate_to</name></name> <operator>&lt;=</operator> <name>current_percentile</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>update_iterated_values</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><call><name>highest_equivalent_value</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>percentiles</name><operator>-&gt;</operator><name>percentile</name></name> <operator>=</operator> <name><name>percentiles</name><operator>-&gt;</operator><name>percentile_to_iterate_to</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><call><name>log</name><argument_list>(<argument><expr><literal type="number">100</literal> <operator>/</operator> <operator>(</operator><literal type="number">100.0</literal> <operator>-</operator> <operator>(</operator><name><name>percentiles</name><operator>-&gt;</operator><name>percentile_to_iterate_to</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>log</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>half_distance</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator> <call><name>pow</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>percentile_reporting_ticks</name> <operator>=</operator> <name><name>percentiles</name><operator>-&gt;</operator><name>ticks_per_half_distance</name></name> <operator>*</operator> <name>half_distance</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>percentiles</name><operator>-&gt;</operator><name>percentile_to_iterate_to</name></name> <operator>+=</operator> <literal type="number">100.0</literal> <operator>/</operator> <name>percentile_reporting_ticks</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
while <condition>(<expr><call><name>basic_iter_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>hdr_iter_percentile_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>ticks_per_half_distance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hdr_iter_init</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>percentiles</name><operator>.</operator><name>seen_last_value</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>percentiles</name><operator>.</operator><name>ticks_per_half_distance</name></name> <operator>=</operator> <name>ticks_per_half_distance</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>percentiles</name><operator>.</operator><name>percentile_to_iterate_to</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>percentiles</name><operator>.</operator><name>percentile</name></name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>_next_fp</name></name> <operator>=</operator> <name>percentile_iter_next</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>format_line_string</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>significant_figures</name></decl></parameter>, <parameter><decl><type><name>format_type</name></type> <name>format</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>snprintf</name></cpp:macro> <cpp:value>_snprintf</cpp:value></cpp:define>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>push</name><name>)</name></cpp:pragma>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name> <name>4996</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>format_str</name> <init>= <expr><literal type="string">"%s%d%s"</literal></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>format</name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>CSV</name></expr>:</case>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>format_str</name></expr></argument>, <argument><expr><literal type="string">"%."</literal></expr></argument>, <argument><expr><name>significant_figures</name></expr></argument>, <argument><expr><literal type="string">"f,%f,%d,%.2f\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CLASSIC</name></expr>:</case>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>format_str</name></expr></argument>, <argument><expr><literal type="string">"%12."</literal></expr></argument>, <argument><expr><name>significant_figures</name></expr></argument>, <argument><expr><literal type="string">"f %12f %12d %12.2f\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>format_str</name></expr></argument>, <argument><expr><literal type="string">"%12."</literal></expr></argument>, <argument><expr><name>significant_figures</name></expr></argument>, <argument><expr><literal type="string">"f %12f %12d %12.2f\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>snprintf</name></cpp:undef>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>pop</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>recorded_iter_next</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><call><name>basic_iter_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>update_iterated_values</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>recorded</name><operator>.</operator><name>count_added_in_this_iteration_step</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>hdr_iter_recorded_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>hdr_iter_init</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>recorded</name><operator>.</operator><name>count_added_in_this_iteration_step</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>_next_fp</name></name> <operator>=</operator> <name>recorded_iter_next</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>iter_linear_next</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hdr_iter_linear</name></name><modifier>*</modifier></type> <name>linear</name> <init>= <expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>linear</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>linear</name><operator>-&gt;</operator><name>count_added_in_this_iteration_step</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>has_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>next_value_greater_than_reporting_level_upper_bound</name><argument_list>(
<argument><expr><name>iter</name></expr></argument>, <argument><expr><name><name>linear</name><operator>-&gt;</operator><name>next_value_reporting_level_lowest_equivalent</name></name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<do>do
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>value</name></name> <operator>&gt;=</operator> <name><name>linear</name><operator>-&gt;</operator><name>next_value_reporting_level_lowest_equivalent</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>update_iterated_values</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name><name>linear</name><operator>-&gt;</operator><name>next_value_reporting_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>linear</name><operator>-&gt;</operator><name>next_value_reporting_level</name></name> <operator>+=</operator> <name><name>linear</name><operator>-&gt;</operator><name>value_units_per_bucket</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>linear</name><operator>-&gt;</operator><name>next_value_reporting_level_lowest_equivalent</name></name> <operator>=</operator>
<call><name>lowest_equivalent_value</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>linear</name><operator>-&gt;</operator><name>next_value_reporting_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>move_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>linear</name><operator>-&gt;</operator><name>count_added_in_this_iteration_step</name></name> <operator>+=</operator> <name><name>iter</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
</block_content>}</block>
while <condition>(<expr><name>true</name></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>hdr_iter_linear_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value_units_per_bucket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>hdr_iter_init</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>linear</name><operator>.</operator><name>count_added_in_this_iteration_step</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>linear</name><operator>.</operator><name>value_units_per_bucket</name></name> <operator>=</operator> <name>value_units_per_bucket</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>linear</name><operator>.</operator><name>next_value_reporting_level</name></name> <operator>=</operator> <name>value_units_per_bucket</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>linear</name><operator>.</operator><name>next_value_reporting_level_lowest_equivalent</name></name> <operator>=</operator> <call><name>lowest_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value_units_per_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>_next_fp</name></name> <operator>=</operator> <name>iter_linear_next</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>hdr_iter_linear_set_value_units_per_bucket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>value_units_per_bucket</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>linear</name><operator>.</operator><name>value_units_per_bucket</name></name> <operator>=</operator> <name>value_units_per_bucket</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>log_iter_next</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>hdr_iter_log</name></name><modifier>*</modifier></type> <name>logarithmic</name> <init>= <expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>log</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>logarithmic</name><operator>-&gt;</operator><name>count_added_in_this_iteration_step</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>has_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>next_value_greater_than_reporting_level_upper_bound</name><argument_list>(
<argument><expr><name>iter</name></expr></argument>, <argument><expr><name><name>logarithmic</name><operator>-&gt;</operator><name>next_value_reporting_level_lowest_equivalent</name></name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<do>do
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>value</name></name> <operator>&gt;=</operator> <name><name>logarithmic</name><operator>-&gt;</operator><name>next_value_reporting_level_lowest_equivalent</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>update_iterated_values</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name><name>logarithmic</name><operator>-&gt;</operator><name>next_value_reporting_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>logarithmic</name><operator>-&gt;</operator><name>next_value_reporting_level</name></name> <operator>*=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>logarithmic</name><operator>-&gt;</operator><name>log_base</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>logarithmic</name><operator>-&gt;</operator><name>next_value_reporting_level_lowest_equivalent</name></name> <operator>=</operator> <call><name>lowest_equivalent_value</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><name><name>logarithmic</name><operator>-&gt;</operator><name>next_value_reporting_level</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>move_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>logarithmic</name><operator>-&gt;</operator><name>count_added_in_this_iteration_step</name></name> <operator>+=</operator> <name><name>iter</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
</block_content>}</block>
while <condition>(<expr><name>true</name></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>hdr_iter_log_init</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>hdr_iter</name></name><modifier>*</modifier></type> <name>iter</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>,
<parameter><decl><type><name>int64_t</name></type> <name>value_units_first_bucket</name></decl></parameter>,
<parameter><decl><type><name>double</name></type> <name>log_base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>hdr_iter_init</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>log</name><operator>.</operator><name>count_added_in_this_iteration_step</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>log</name><operator>.</operator><name>log_base</name></name> <operator>=</operator> <name>log_base</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>log</name><operator>.</operator><name>next_value_reporting_level</name></name> <operator>=</operator> <name>value_units_first_bucket</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>specifics</name><operator>.</operator><name>log</name><operator>.</operator><name>next_value_reporting_level_lowest_equivalent</name></name> <operator>=</operator> <call><name>lowest_equivalent_value</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>value_units_first_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>_next_fp</name></name> <operator>=</operator> <name>log_iter_next</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>format_head_string</name><parameter_list>(<parameter><decl><type><name>format_type</name></type> <name>format</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>format</name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>CSV</name></expr>:</case>
<return>return <expr><literal type="string">"%s,%s,%s,%s\n"</literal></expr>;</return>
<case>case <expr><name>CLASSIC</name></expr>:</case>
<default>default:</default>
<return>return <expr><literal type="string">"%12s %12s %12s %12s\n\n"</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>CLASSIC_FOOTER</name><index>[]</index></name> <init>=
<expr><literal type="string">"#[Mean = %12.3f, StdDeviation = %12.3f]\n"</literal>
<literal type="string">"#[Max = %12.3f, Total count = %12"</literal> <name>PRIu64</name> <literal type="string">"]\n"</literal>
<literal type="string">"#[Buckets = %12d, SubBuckets = %12d]\n"</literal></expr></init></decl>;</decl_stmt>
<function><type><name>int</name></type> <name>hdr_percentiles_print</name><parameter_list>(
<parameter><decl><type><name><name>struct</name> <name>hdr_histogram</name></name><modifier>*</modifier></type> <name>h</name></decl></parameter>, <parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>stream</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>ticks_per_half_distance</name></decl></parameter>,
<parameter><decl><type><name>double</name></type> <name>value_scale</name></decl></parameter>, <parameter><decl><type><name>format_type</name></type> <name>format</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>line_format</name><index>[<expr><literal type="number">25</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>head_format</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hdr_iter</name></name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>hdr_iter_percentiles</name></name> <modifier>*</modifier></type> <name>percentiles</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>format_line_string</name><argument_list>(<argument><expr><name>line_format</name></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>significant_figures</name></name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>head_format</name> <operator>=</operator> <call><name>format_head_string</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hdr_iter_percentile_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>ticks_per_half_distance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fprintf</name><argument_list>(
<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>head_format</name></expr></argument>,
<argument><expr><literal type="string">"Value"</literal></expr></argument>, <argument><expr><literal type="string">"Percentile"</literal></expr></argument>, <argument><expr><literal type="string">"TotalCount"</literal></expr></argument>, <argument><expr><literal type="string">"1/(1-Percentile)"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>EIO</name></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>percentiles</name> <operator>=</operator> <operator>&amp;</operator><name><name>iter</name><operator>.</operator><name>specifics</name><operator>.</operator><name>percentiles</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>hdr_iter_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>value</name> <init>= <expr><name><name>iter</name><operator>.</operator><name>highest_equivalent_value</name></name> <operator>/</operator> <name>value_scale</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>percentile</name> <init>= <expr><name><name>percentiles</name><operator>-&gt;</operator><name>percentile</name></name> <operator>/</operator> <literal type="number">100.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>total_count</name> <init>= <expr><name><name>iter</name><operator>.</operator><name>cumulative_count</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>inverted_percentile</name> <init>= <expr><operator>(</operator><literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>percentile</name><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fprintf</name><argument_list>(
<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>line_format</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>percentile</name></expr></argument>, <argument><expr><name>total_count</name></expr></argument>, <argument><expr><name>inverted_percentile</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>EIO</name></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>CLASSIC</name> <operator>==</operator> <name>format</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>mean</name> <init>= <expr><call><name>hdr_mean</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>value_scale</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>stddev</name> <init>= <expr><call><name>hdr_stddev</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>value_scale</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>max</name> <init>= <expr><call><name>hdr_max</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>value_scale</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fprintf</name><argument_list>(
<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>CLASSIC_FOOTER</name></expr></argument>, <argument><expr><name>mean</name></expr></argument>, <argument><expr><name>stddev</name></expr></argument>, <argument><expr><name>max</name></expr></argument>,
<argument><expr><name><name>h</name><operator>-&gt;</operator><name>total_count</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>bucket_count</name></name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>sub_bucket_count</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>EIO</name></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<label><name>cleanup</name>:</label>
<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
</unit>
