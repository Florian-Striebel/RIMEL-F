<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/results/redis_res/_cppstats/redis/deps/lua/src/lgc.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lgc_c</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LUA_CORE</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lua.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ldo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lfunc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lgc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lstring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ltm.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCSTEPSIZE</name></cpp:macro> <cpp:value>1024u</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCSWEEPMAX</name></cpp:macro> <cpp:value>40</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCSWEEPCOST</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCFINALIZECOST</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>maskmarks</name></cpp:macro> <cpp:value>cast_byte(~(bitmask(BLACKBIT)|WHITEBITS))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>makewhite</name><parameter_list>(<parameter><type><name>g</name></type></parameter>,<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x)-&gt;gch.marked = cast_byte(((x)-&gt;gch.marked &amp; maskmarks) | luaC_white(g)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>white2gray</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>reset2bits((x)-&gt;gch.marked, WHITE0BIT, WHITE1BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>black2gray</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>resetbit((x)-&gt;gch.marked, BLACKBIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>stringmark</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>reset2bits((s)-&gt;tsv.marked, WHITE0BIT, WHITE1BIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isfinalized</name><parameter_list>(<parameter><type><name>u</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>testbit((u)-&gt;marked, FINALIZEDBIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>markfinalized</name><parameter_list>(<parameter><type><name>u</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>l_setbit((u)-&gt;marked, FINALIZEDBIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEYWEAK</name></cpp:macro> <cpp:value>bitmask(KEYWEAKBIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VALUEWEAK</name></cpp:macro> <cpp:value>bitmask(VALUEWEAKBIT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>markvalue</name><parameter_list>(<parameter><type><name>g</name></type></parameter>,<parameter><type><name>o</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ checkconsistency(o); if (iscollectable(o) &amp;&amp; iswhite(gcvalue(o))) reallymarkobject(g,gcvalue(o)); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>markobject</name><parameter_list>(<parameter><type><name>g</name></type></parameter>,<parameter><type><name>t</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if (iswhite(obj2gco(t))) reallymarkobject(g, obj2gco(t)); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>setthreshold</name><parameter_list>(<parameter><type><name>g</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(g-&gt;GCthreshold = (g-&gt;estimate/100) * g-&gt;gcpause)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>removeentry</name> <parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>iscollectable</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setttype</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LUA_TDEADKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>reallymarkobject</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>iswhite</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>white2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LUA_TSTRING</name></expr>:</case> <block>{<block_content>
<return>return;</return>
</block_content>}</block>
<case>case <expr><name>LUA_TUSERDATA</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><call><name>gco2u</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mt</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>env</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block>
<case>case <expr><name>LUA_TUPVAL</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>UpVal</name> <modifier>*</modifier></type><name>uv</name> <init>= <expr><call><name>gco2uv</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block>
<case>case <expr><name>LUA_TFUNCTION</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>gco2cl</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>c</name><operator>.</operator><name>gclist</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>LUA_TTABLE</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>gco2h</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>gclist</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>LUA_TTHREAD</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>gclist</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>LUA_TPROTO</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>gco2p</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>gclist</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>marktmu</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>u</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>u</name></expr>)</condition> <block>{<block_content>
<do>do <block>{<block_content>
<expr_stmt><expr><name>u</name> <operator>=</operator> <name><name>u</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reallymarkobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><name>u</name> <operator>!=</operator> <name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name></expr>)</condition>;</do>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>size_t</name></type> <name>luaC_separateudata</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>all</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>deadmem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name> <init>= <expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>mainthread</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>curr</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>iswhite</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>all</name><operator>)</operator> <operator>||</operator> <call><name>isfinalized</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>metatable</name></expr></argument>, <argument><expr><name>TM_GC</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>markfinalized</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>deadmem</name> <operator>+=</operator> <call><name>sizeudata</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markfinalized</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>tmudata</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>deadmem</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>traversetable</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>weakkey</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>weakvalue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>metatable</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>gfasttm</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>h</name><operator>-&gt;</operator><name>metatable</name></name></expr></argument>, <argument><expr><name>TM_MODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>&amp;&amp;</operator> <call><name>ttisstring</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>weakkey</name> <operator>=</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><call><name>svalue</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'k'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>weakvalue</name> <operator>=</operator> <operator>(</operator><call><name>strchr</name><argument_list>(<argument><expr><call><name>svalue</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'v'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>weakkey</name> <operator>||</operator> <name>weakvalue</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>marked</name></name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>KEYWEAK</name> <operator>|</operator> <name>VALUEWEAK</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>marked</name></name> <operator>|=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><operator>(</operator><name>weakkey</name> <operator>&lt;&lt;</operator> <name>KEYWEAKBIT</name><operator>)</operator> <operator>|</operator>
<operator>(</operator><name>weakvalue</name> <operator>&lt;&lt;</operator> <name>VALUEWEAKBIT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>gclist</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>weak</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name> <operator>=</operator> <call><name>obj2gco</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>weakkey</name> <operator>&amp;&amp;</operator> <name>weakvalue</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>weakvalue</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>sizearray</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>sizenode</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>gnode</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ttype</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LUA_TDEADKEY</name> <operator>||</operator> <call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>removeentry</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>weakkey</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gkey</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>weakvalue</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>weakkey</name> <operator>||</operator> <name>weakvalue</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>traverseproto</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>Proto</name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>source</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>stringmark</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizek</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>k</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>stringmark</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>upvalues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizep</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>f</name><operator>-&gt;</operator><name>sizelocvars</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>varname</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>stringmark</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>locvars</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>traverseclosure</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>Closure</name> <modifier>*</modifier></type><name>cl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>isC</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>upvalue</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>nupvalues</name></name> <operator>==</operator> <name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>p</name><operator>-&gt;</operator><name>nups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>nupvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>upvals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkstacksizes</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>StkId</name></type> <name>max</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ci_used</name> <init>= <expr><call><name>cast_int</name><argument_list>(<argument><expr><name><name>L</name><operator>-&gt;</operator><name>ci</name></name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>base_ci</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s_used</name> <init>= <expr><call><name>cast_int</name><argument_list>(<argument><expr><name>max</name> <operator>-</operator> <name><name>L</name><operator>-&gt;</operator><name>stack</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name> <operator>&gt;</operator> <name>LUAI_MAXCALLS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">4</literal><operator>*</operator><name>ci_used</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name> <operator>&amp;&amp;</operator> <literal type="number">2</literal><operator>*</operator><name>BASIC_CI_SIZE</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaD_reallocCI</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>size_ci</name></name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>condhardstacktests</name><argument_list>(<argument><expr><call><name>luaD_reallocCI</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>ci_used</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><literal type="number">4</literal><operator>*</operator><name>s_used</name> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name> <operator>&amp;&amp;</operator>
<literal type="number">2</literal><operator>*</operator><operator>(</operator><name>BASIC_STACK_SIZE</name><operator>+</operator><name>EXTRA_STACK</name><operator>)</operator> <operator>&lt;</operator> <name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaD_reallocstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>stacksize</name></name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>condhardstacktests</name><argument_list>(<argument><expr><call><name>luaD_reallocstack</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>s_used</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>traversestack</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>StkId</name></type> <name>o</name></decl>, <decl><type ref="prev"/><name>lim</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CallInfo</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gt</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lim</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>ci</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>base_ci</name></name></expr>;</init> <condition><expr><name>ci</name> <operator>&lt;=</operator> <name><name>l</name><operator>-&gt;</operator><name>ci</name></name></expr>;</condition> <incr><expr><name>ci</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>top</name></name> <operator>&lt;=</operator> <name><name>l</name><operator>-&gt;</operator><name>stack_last</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lim</name> <operator>&lt;</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>lim</name> <operator>=</operator> <name><name>ci</name><operator>-&gt;</operator><name>top</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>o</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>stack</name></name></expr>;</init> <condition><expr><name>o</name> <operator>&lt;</operator> <name><name>l</name><operator>-&gt;</operator><name>top</name></name></expr>;</condition> <incr><expr><name>o</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init>;</init> <condition><expr><name>o</name> <operator>&lt;=</operator> <name>lim</name></expr>;</condition> <incr><expr><name>o</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>checkstacksizes</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>lim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>l_mem</name></type> <name>propagatemark</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isgray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LUA_TTABLE</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>gco2h</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>gclist</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>traversetable</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>black2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Table</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>h</name><operator>-&gt;</operator><name>sizearray</name></name> <operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <call><name>sizenode</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block>
<case>case <expr><name>LUA_TFUNCTION</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>Closure</name> <modifier>*</modifier></type><name>cl</name> <init>= <expr><call><name>gco2cl</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>gclist</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>traverseclosure</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>cl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>isC</name></name><operator>)</operator></expr> ?</condition><then> <expr><call><name>sizeCclosure</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>c</name><operator>.</operator><name>nupvalues</name></name></expr></argument>)</argument_list></call></expr> </then><else>:
<expr><call><name>sizeLclosure</name><argument_list>(<argument><expr><name><name>cl</name><operator>-&gt;</operator><name>l</name><operator>.</operator><name>nupvalues</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block>
<case>case <expr><name>LUA_TTHREAD</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>th</name> <init>= <expr><call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name><name>th</name><operator>-&gt;</operator><name>gclist</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>th</name><operator>-&gt;</operator><name>gclist</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>black2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>traversestack</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>th</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>lua_State</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>th</name><operator>-&gt;</operator><name>stacksize</name></name> <operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>CallInfo</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>th</name><operator>-&gt;</operator><name>size_ci</name></name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>LUA_TPROTO</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>Proto</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>gco2p</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>gclist</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>traverseproto</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Proto</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Instruction</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>sizecode</name></name> <operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>Proto</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>sizep</name></name> <operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>TValue</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>sizek</name></name> <operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>sizelineinfo</name></name> <operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>LocVar</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>sizelocvars</name></name> <operator>+</operator>
<sizeof>sizeof<argument_list>(<argument><expr><name>TString</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p</name><operator>-&gt;</operator><name>sizeupvalues</name></name></expr>;</return>
</block_content>}</block>
<default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>propagateall</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>m</name> <operator>+=</operator> <call><name>propagatemark</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name>m</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>iscleared</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iskey</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>iscollectable</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ttisstring</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>stringmark</name><argument_list>(<argument><expr><call><name>rawtsvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>iswhite</name><argument_list>(<argument><expr><call><name>gcvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name>ttisuserdata</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>iskey</name> <operator>&amp;&amp;</operator> <call><name>isfinalized</name><argument_list>(<argument><expr><call><name>uvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>cleartable</name> <parameter_list>(<parameter><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><name>l</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Table</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>gco2h</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>h</name><operator>-&gt;</operator><name>sizearray</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>testbit</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>marked</name></name></expr></argument>, <argument><expr><name>VALUEWEAKBIT</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>testbit</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>marked</name></name></expr></argument>, <argument><expr><name>KEYWEAKBIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>testbit</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>marked</name></name></expr></argument>, <argument><expr><name>VALUEWEAKBIT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>TValue</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><operator>&amp;</operator><name><name>h</name><operator>-&gt;</operator><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>iscleared</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>sizenode</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>gnode</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ttisnil</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>iscleared</name><argument_list>(<argument><expr><call><name>key2tval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>iscleared</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setnilvalue</name><argument_list>(<argument><expr><call><name>gval</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>removeentry</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>l</name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>gclist</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeobj</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>LUA_TPROTO</name></expr>:</case> <expr_stmt><expr><call><name>luaF_freeproto</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>gco2p</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>LUA_TFUNCTION</name></expr>:</case> <expr_stmt><expr><call><name>luaF_freeclosure</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>gco2cl</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>LUA_TUPVAL</name></expr>:</case> <expr_stmt><expr><call><name>luaF_freeupval</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>gco2uv</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>LUA_TTABLE</name></expr>:</case> <expr_stmt><expr><call><name>luaH_free</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>gco2h</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>LUA_TTHREAD</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>L</name> <operator>&amp;&amp;</operator> <call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>mainthread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaE_freethread</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><call><name>gco2th</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>LUA_TSTRING</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>strt</name><operator>.</operator><name>nuse</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaM_freemem</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>sizestring</name><argument_list>(<argument><expr><call><name>gco2ts</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>LUA_TUSERDATA</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>luaM_freemem</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>o</name></expr></argument>, <argument><expr><call><name>sizeudata</name><argument_list>(<argument><expr><call><name>gco2u</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sweepwholelist</name><parameter_list>(<parameter><type><name>L</name></type></parameter>,<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>sweeplist(L,p,MAX_LUMEM)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>GCObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>sweeplist</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCObject</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>lu_mem</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>deadmask</name> <init>= <expr><call><name>otherwhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><name>curr</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>count</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name> <operator>==</operator> <name>LUA_TTHREAD</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sweepwholelist</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>gco2th</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>openupval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>marked</name></name> <operator>^</operator> <name>WHITEBITS</name><operator>)</operator> <operator>&amp;</operator> <name>deadmask</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>testbit</name><argument_list>(<argument><expr><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>marked</name></name></expr></argument>, <argument><expr><name>FIXEDBIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>deadmask</name> <operator>==</operator> <call><name>bitmask</name><argument_list>(<argument><expr><name>SFIXEDBIT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>curr</name> <operator>==</operator> <name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>freeobj</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>checkSizes</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>nuse</name></name> <operator>&lt;</operator> <call><name>cast</name><argument_list>(<argument><expr><name>lu_int32</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name><operator>/</operator><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <name>MINSTRTABSIZE</name><operator>*</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>luaS_resize</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name><operator>/</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>luaZ_sizebuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>LUA_MINBUFFER</name><operator>*</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>newsize</name> <init>= <expr><call><name>luaZ_sizebuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>luaZ_resizebuffer</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>buff</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>GCTM</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Udata</name> <modifier>*</modifier></type><name>udata</name> <init>= <expr><call><name>rawgco2u</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>TValue</name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>udata</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>udata</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>mainthread</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>fasttm</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>udata</name><operator>-&gt;</operator><name>uv</name><operator>.</operator><name>metatable</name></name></expr></argument>, <argument><expr><name>TM_GC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tm</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>lu_byte</name></type> <name>oldah</name> <init>= <expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lu_mem</name></type> <name>oldt</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name> <operator>=</operator> <literal type="number">2</literal><operator>*</operator><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setobj2s</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setuvalue</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>udata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaD_call</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>L</name><operator>-&gt;</operator><name>top</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>L</name><operator>-&gt;</operator><name>allowhook</name></name> <operator>=</operator> <name>oldah</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name> <operator>=</operator> <name>oldt</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>luaC_callGCTM</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>tmudata</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>GCTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>luaC_freeall</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>currentwhite</name></name> <operator>=</operator> <name>WHITEBITS</name> <operator>|</operator> <call><name>bitmask</name><argument_list>(<argument><expr><name>SFIXEDBIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sweepwholelist</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sweepwholelist</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>hash</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>markmt</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>NUM_TAGS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>mt</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>mt</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>markroot</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>gt</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>registry</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markmt</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>=</operator> <name>GCSpropagate</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>remarkupvals</name> <parameter_list>(<parameter><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>UpVal</name> <modifier>*</modifier></type><name>uv</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>uv</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>uvhead</name><operator>.</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name></expr>;</init> <condition><expr><name>uv</name> <operator>!=</operator> <operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>uvhead</name></name></expr>;</condition> <incr><expr><name>uv</name> <operator>=</operator> <name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>prev</name></name> <operator>==</operator> <name>uv</name> <operator>&amp;&amp;</operator> <name><name>uv</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>prev</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>l</name><operator>.</operator><name>next</name></name> <operator>==</operator> <name>uv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isgray</name><argument_list>(<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>markvalue</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>atomic</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>udsize</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>remarkupvals</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>propagateall</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>weak</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>iswhite</name><argument_list>(<argument><expr><call><name>obj2gco</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>mainthread</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>markmt</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>propagateall</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>propagateall</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>udsize</name> <operator>=</operator> <call><name>luaC_separateudata</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>marktmu</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>udsize</name> <operator>+=</operator> <call><name>propagateall</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>cleartable</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>currentwhite</name></name> <operator>=</operator> <call><name>cast_byte</name><argument_list>(<argument><expr><call><name>otherwhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepstrgc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>=</operator> <name>GCSsweepstring</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name> <operator>-</operator> <name>udsize</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>l_mem</name></type> <name>singlestep</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>GCSpause</name></expr>:</case> <block>{<block_content>
<expr_stmt><expr><call><name>markroot</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block>
<case>case <expr><name>GCSpropagate</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>propagatemark</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>atomic</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<case>case <expr><name>GCSsweepstring</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>lu_mem</name></type> <name>old</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sweepwholelist</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>hash</name><index>[<expr><name><name>g</name><operator>-&gt;</operator><name>sweepstrgc</name></name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>sweepstrgc</name></name> <operator>&gt;=</operator> <name><name>g</name><operator>-&gt;</operator><name>strt</name><operator>.</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>=</operator> <name>GCSsweep</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>old</name> <operator>&gt;=</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name> <operator>-=</operator> <name>old</name> <operator>-</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr>;</expr_stmt>
<return>return <expr><name>GCSWEEPCOST</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>GCSsweep</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>lu_mem</name></type> <name>old</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name> <operator>=</operator> <call><name>sweeplist</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name></expr></argument>, <argument><expr><name>GCSWEEPMAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>checkSizes</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>=</operator> <name>GCSfinalize</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name>old</name> <operator>&gt;=</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name> <operator>-=</operator> <name>old</name> <operator>-</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr>;</expr_stmt>
<return>return <expr><name>GCSWEEPMAX</name><operator>*</operator><name>GCSWEEPCOST</name></expr>;</return>
</block_content>}</block>
<case>case <expr><name>GCSfinalize</name></expr>:</case> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>tmudata</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>GCTM</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name> <operator>&gt;</operator> <name>GCFINALIZECOST</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>estimate</name></name> <operator>-=</operator> <name>GCFINALIZECOST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>GCFINALIZECOST</name></expr>;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>=</operator> <name>GCSpause</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcdept</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<default>default:</default> <expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>luaC_step</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>l_mem</name></type> <name>lim</name> <init>= <expr><operator>(</operator><name>GCSTEPSIZE</name><operator>/</operator><literal type="number">100</literal><operator>)</operator> <operator>*</operator> <name><name>g</name><operator>-&gt;</operator><name>gcstepmul</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lim</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lim</name> <operator>=</operator> <operator>(</operator><name>MAX_LUMEM</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcdept</name></name> <operator>+=</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name> <operator>-</operator> <name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>lim</name> <operator>-=</operator> <call><name>singlestep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>==</operator> <name>GCSpause</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>lim</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpause</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcdept</name></name> <operator>&lt;</operator> <name>GCSTEPSIZE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name> <operator>+</operator> <name>GCSTEPSIZE</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcdept</name></name> <operator>-=</operator> <name>GCSTEPSIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>GCthreshold</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>totalbytes</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>setthreshold</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>luaC_fullgc</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>&lt;=</operator> <name>GCSpropagate</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepstrgc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>sweepgc</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gray</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>weak</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>=</operator> <name>GCSsweepstring</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpause</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpropagate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSfinalize</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>==</operator> <name>GCSsweepstring</name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>==</operator> <name>GCSsweep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>singlestep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>markroot</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpause</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>singlestep</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>setthreshold</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>luaC_barrierf</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isblack</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>iswhite</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSfinalize</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>ttype</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>o</name><operator>-&gt;</operator><name>gch</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>LUA_TTABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>==</operator> <name>GCSpropagate</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reallymarkobject</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>luaC_barrierback</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>Table</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><call><name>isblack</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isdead</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSfinalize</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>black2gray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>gclist</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>grayagain</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>luaC_link</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>lu_byte</name></type> <name>tt</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>marked</name></name> <operator>=</operator> <call><name>luaC_white</name><argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>tt</name></name> <operator>=</operator> <name>tt</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>luaC_linkupval</name> <parameter_list>(<parameter><decl><type><name>lua_State</name> <modifier>*</modifier></type><name>L</name></decl></parameter>, <parameter><decl><type><name>UpVal</name> <modifier>*</modifier></type><name>uv</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>global_State</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>G</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GCObject</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>obj2gco</name><argument_list>(<argument><expr><name>uv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>o</name><operator>-&gt;</operator><name>gch</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>rootgc</name></name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isgray</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>==</operator> <name>GCSpropagate</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>gray2black</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>luaC_barrier</name><argument_list>(<argument><expr><name>L</name></expr></argument>, <argument><expr><name>uv</name></expr></argument>, <argument><expr><name><name>uv</name><operator>-&gt;</operator><name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>makewhite</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lua_assert</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSfinalize</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>gcstate</name></name> <operator>!=</operator> <name>GCSpause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
