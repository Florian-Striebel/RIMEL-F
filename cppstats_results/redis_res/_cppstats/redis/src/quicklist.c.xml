<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/results/redis_res/_cppstats/redis/src/quicklist.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"quicklist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zmalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"listpack.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lzf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"redisassert.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>REDIS_STATIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_STATIC</name></cpp:macro> <cpp:value>static</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name><name>optimization_level</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">4096</literal></expr>, <expr><literal type="number">8192</literal></expr>, <expr><literal type="number">16384</literal></expr>, <expr><literal type="number">32768</literal></expr>, <expr><literal type="number">65536</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>packed_threshold</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">30</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isLargeElement</name><parameter_list>(<parameter><type><name>size</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((size) &gt;= packed_threshold)</cpp:value></cpp:define>
<function><type><name>int</name></type> <name>quicklistisSetPackedThreshold</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1ull</literal><operator>&lt;&lt;</operator><literal type="number">32</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">20</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>packed_threshold</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_SAFETY_LIMIT</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_ESTIMATE_OVERHEAD</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_COMPRESS_BYTES</name></cpp:macro> <cpp:value>48</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_COMPRESS_IMPROVE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>REDIS_TEST_VERBOSE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>D</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { printf("%s:%s:%d:\t", __FILE__, __func__, __LINE__); printf(__VA_ARGS__); printf("\n"); } while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QL_MAX_BM</name></cpp:macro> <cpp:value>((1 &lt;&lt; QL_BM_BITS)-1)</cpp:value></cpp:define>
<function_decl><type><name>quicklistBookmark</name> <modifier>*</modifier></type><name>_quicklistBookmarkFindByName</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>quicklistBookmark</name> <modifier>*</modifier></type><name>_quicklistBookmarkFindByNode</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>_quicklistBookmarkDelete</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><name>quicklistBookmark</name> <modifier>*</modifier></type><name>bm</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>initEntry</name><parameter_list>(<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (e)-&gt;zi = (e)-&gt;value = NULL; (e)-&gt;longval = -123456789; (e)-&gt;quicklist = NULL; (e)-&gt;node = NULL; (e)-&gt;offset = 123456789; (e)-&gt;sz = 0; } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>resetIterator</name><parameter_list>(<parameter><type><name>iter</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (iter)-&gt;current = NULL; (iter)-&gt;zi = NULL; } while (0)</cpp:value></cpp:define>
<function><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklistCreate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>quicklist</name></name> <modifier>*</modifier></type><name>quicklist</name></decl>;</decl_stmt>
<expr_stmt><expr><name>quicklist</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>quicklist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>fill</name></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>bookmark_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>quicklist</name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPRESS_MAX</name></cpp:macro> <cpp:value>((1 &lt;&lt; QL_COMP_BITS)-1)</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>quicklistSetCompressDepth</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compress</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>compress</name> <operator>&gt;</operator> <name>COMPRESS_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>compress</name> <operator>=</operator> <name>COMPRESS_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>compress</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>compress</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>compress</name></name> <operator>=</operator> <name>compress</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILL_MAX</name></cpp:macro> <cpp:value>((1 &lt;&lt; (QL_FILL_BITS-1))-1)</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>quicklistSetFill</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fill</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fill</name> <operator>&gt;</operator> <name>FILL_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fill</name> <operator>=</operator> <name>FILL_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fill</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">5</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fill</name> <operator>=</operator> <operator>-</operator><literal type="number">5</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>fill</name></name> <operator>=</operator> <name>fill</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistSetOptions</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fill</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistSetCompressDepth</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklistNew</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fill</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>compress</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name> <init>= <expr><call><name>quicklistCreate</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistSetOptions</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>compress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>quicklist</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>REDIS_STATIC</name> <name>quicklistNode</name> <modifier>*</modifier></type><name>quicklistCreateNode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>QUICKLIST_NODE_ENCODING_RAW</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>container</name></name> <operator>=</operator> <name>QUICKLIST_NODE_CONTAINER_PACKED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>recompress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>long</name></type> <name>quicklistCount</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistRelease</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>current</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>len</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>-=</operator> <name><name>current</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>current</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>quicklistBookmarksClear</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>REDIS_STATIC</name> <name>int</name></type> <name>__quicklistCompressNode</name><parameter_list>(<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>REDIS_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>attempted_compress</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>recompress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name> <operator>&lt;</operator> <name>MIN_COMPRESS_BYTES</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>quicklistLZF</name> <modifier>*</modifier></type><name>lzf</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>lzf</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>lzf</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <call><name>lzf_compress</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>, <argument><expr><name><name>lzf</name><operator>-&gt;</operator><name>compressed</name></name></expr></argument>,
<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<name><name>lzf</name><operator>-&gt;</operator><name>sz</name></name> <operator>+</operator> <name>MIN_COMPRESS_IMPROVE</name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lzf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>lzf</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>lzf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>lzf</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>lzf</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>lzf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>QUICKLIST_NODE_ENCODING_LZF</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistCompressNode</name><parameter_list>(<parameter><type><name>_node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((_node) &amp;&amp; (_node)-&gt;encoding == QUICKLIST_NODE_ENCODING_RAW) { __quicklistCompressNode((_node)); } } while (0)</cpp:value></cpp:define>
<function><type><name>REDIS_STATIC</name> <name>int</name></type> <name>__quicklistDecompressNode</name><parameter_list>(<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>REDIS_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>attempted_compress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>recompress</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>decompressed</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistLZF</name> <modifier>*</modifier></type><name>lzf</name> <init>= <expr><operator>(</operator><name>quicklistLZF</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>lzf_decompress</name><argument_list>(<argument><expr><name><name>lzf</name><operator>-&gt;</operator><name>compressed</name></name></expr></argument>, <argument><expr><name><name>lzf</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>, <argument><expr><name>decompressed</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>decompressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>lzf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name>decompressed</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>QUICKLIST_NODE_ENCODING_RAW</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistDecompressNode</name><parameter_list>(<parameter><type><name>_node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((_node) &amp;&amp; (_node)-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF) { __quicklistDecompressNode((_node)); } } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistDecompressNodeForUse</name><parameter_list>(<parameter><type><name>_node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((_node) &amp;&amp; (_node)-&gt;encoding == QUICKLIST_NODE_ENCODING_LZF) { __quicklistDecompressNode((_node)); (_node)-&gt;recompress = 1; } } while (0)</cpp:value></cpp:define>
<function><type><name>size_t</name></type> <name>quicklistGetLzf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistLZF</name> <modifier>*</modifier></type><name>lzf</name> <init>= <expr><operator>(</operator><name>quicklistLZF</name> <operator>*</operator><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name><name>lzf</name><operator>-&gt;</operator><name>compressed</name></name></expr>;</expr_stmt>
<return>return <expr><name><name>lzf</name><operator>-&gt;</operator><name>sz</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistAllowsCompression</name><parameter_list>(<parameter><type><name>_ql</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((_ql)-&gt;compress != 0)</cpp:value></cpp:define>
<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>__quicklistCompress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>recompress</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>recompress</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>quicklistAllowsCompression</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>)</argument_list></call> <operator>||</operator>
<name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name><name>quicklist</name><operator>-&gt;</operator><name>compress</name></name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
if (quicklist-&gt;compress == 1) {
quicklistNode *h = quicklist-&gt;head, *t = quicklist-&gt;tail;
quicklistDecompressNode(h);
quicklistDecompressNode(t);
if (h != node &amp;&amp; t != node)
quicklistCompressNode(node);
return;
} else if (quicklist-&gt;compress == 2) {
quicklistNode *h = quicklist-&gt;head, *hn = h-&gt;next, *hnn = hn-&gt;next;
quicklistNode *t = quicklist-&gt;tail, *tp = t-&gt;prev, *tpp = tp-&gt;prev;
quicklistDecompressNode(h);
quicklistDecompressNode(hn);
quicklistDecompressNode(t);
quicklistDecompressNode(tp);
if (h != node &amp;&amp; hn != node &amp;&amp; t != node &amp;&amp; tp != node) {
quicklistCompressNode(node);
}
if (hnn != t) {
quicklistCompressNode(hnn);
}
if (tpp != h) {
quicklistCompressNode(tpp);
}
return;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>forward</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>reverse</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>in_depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>depth</name><operator>++</operator> <operator>&lt;</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>compress</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistDecompressNode</name><argument_list>(<argument><expr><name>forward</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDecompressNode</name><argument_list>(<argument><expr><name>reverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>forward</name> <operator>==</operator> <name>node</name> <operator>||</operator> <name>reverse</name> <operator>==</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>in_depth</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>forward</name> <operator>==</operator> <name>reverse</name> <operator>||</operator> <name><name>forward</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>forward</name> <operator>=</operator> <name><name>forward</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>reverse</name> <operator>=</operator> <name><name>reverse</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_depth</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistCompressNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistCompressNode</name><argument_list>(<argument><expr><name>forward</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistCompressNode</name><argument_list>(<argument><expr><name>reverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistCompress</name><parameter_list>(<parameter><type><name>_ql</name></type></parameter>, <parameter><type><name>_node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((_node)-&gt;recompress) quicklistCompressNode((_node)); else __quicklistCompress((_ql), (_node)); } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistRecompressOnly</name><parameter_list>(<parameter><type><name>_node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((_node)-&gt;recompress) quicklistCompressNode((_node)); } while (0)</cpp:value></cpp:define>
<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>__quicklistInsertNode</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>old_node</name></decl></parameter>,
<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>new_node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>after</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>after</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>old_node</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>old_node</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>old_node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>old_node</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>old_node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>old_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name> <operator>==</operator> <name>old_node</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>old_node</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>old_node</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>old_node</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>old_node</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>old_node</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>old_node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>old_node</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>new_node</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>old_node</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistCompress</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>old_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistCompress</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>_quicklistInsertNodeBefore</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>old_node</name></decl></parameter>,
<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>new_node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>__quicklistInsertNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>old_node</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>_quicklistInsertNodeAfter</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>old_node</name></decl></parameter>,
<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>new_node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>__quicklistInsertNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>old_node</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>REDIS_STATIC</name> <name>int</name></type>
<name>_quicklistNodeSizeMeetsOptimizationRequirement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>sz</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>fill</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fill</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><operator>(</operator><operator>-</operator><name>fill</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>optimization_level</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>optimization_level</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;=</operator> <name><name>optimization_level</name><index>[<expr><name>offset</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sizeMeetsSafetyLimit</name><parameter_list>(<parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((sz) &lt;= SIZE_SAFETY_LIMIT)</cpp:value></cpp:define>
<function><type><name>REDIS_STATIC</name> <name>int</name></type> <name>_quicklistNodeAllowInsert</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>fill</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><operator>!</operator><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isLargeElement</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>new_sz</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name> <operator>+</operator> <name>sz</name> <operator>+</operator> <name>SIZE_ESTIMATE_OVERHEAD</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>_quicklistNodeSizeMeetsOptimizationRequirement</name><argument_list>(<argument><expr><name>new_sz</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>sizeMeetsSafetyLimit</name><argument_list>(<argument><expr><name>new_sz</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>&lt;</operator> <name>fill</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>REDIS_STATIC</name> <name>int</name></type> <name>_quicklistNodeAllowMerge</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>quicklistNode</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>quicklistNode</name> <modifier>*</modifier></type><name>b</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>fill</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name> <operator>||</operator> <operator>!</operator><name>b</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>merge_sz</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>sz</name></name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>sz</name></name> <operator>-</operator> <literal type="number">11</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><call><name>_quicklistNodeSizeMeetsOptimizationRequirement</name><argument_list>(<argument><expr><name>merge_sz</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>sizeMeetsSafetyLimit</name><argument_list>(<argument><expr><name>merge_sz</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>count</name></name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>count</name></name><operator>)</operator> <operator>&lt;=</operator> <name>fill</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistNodeUpdateSz</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { (node)-&gt;sz = lpBytes((node)-&gt;entry); } while (0)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>quicklistNode</name><modifier>*</modifier></type> <name>__quicklistCreatePlainNode</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>container</name></name> <operator>=</operator> <name>QUICKLIST_NODE_CONTAINER_PLAIN</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>new_node</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>__quicklistInsertPlainNode</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>old_node</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>after</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>__quicklistInsertNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>old_node</name></expr></argument>, <argument><expr><call><name>__quicklistCreatePlainNode</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>quicklistPushHead</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>orig_head</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>isLargeElement</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__quicklistInsertPlainNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(
<argument><expr><call><name>_quicklistNodeAllowInsert</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>fill</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpPrepend</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpPrepend</name><argument_list>(<argument><expr><call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_quicklistInsertNodeBefore</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>orig_head</name> <operator>!=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>quicklistPushTail</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>orig_tail</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>isLargeElement</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__quicklistInsertPlainNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(
<argument><expr><call><name>_quicklistNodeAllowInsert</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>fill</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_quicklistInsertNodeAfter</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>orig_tail</name> <operator>!=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistAppendListpack</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name>zl</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <call><name>lpLength</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <call><name>lpBytes</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_quicklistInsertNodeAfter</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>+=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistAppendPlainNode</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>container</name></name> <operator>=</operator> <name>QUICKLIST_NODE_CONTAINER_PLAIN</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_quicklistInsertNodeAfter</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>+=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>quicklistDeleteIfEmpty</name><parameter_list>(<parameter><type><name>ql</name></type></parameter>, <parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((n)-&gt;count == 0) { __quicklistDelNode((ql), (n)); (n) = NULL; } } while (0)</cpp:value></cpp:define>
<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>__quicklistDelNode</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistBookmark</name> <modifier>*</modifier></type><name>bm</name> <init>= <expr><call><name>_quicklistBookmarkFindByNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bm</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bm</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bm</name><operator>-&gt;</operator><name>node</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>_quicklistBookmarkDelete</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>-=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__quicklistCompress</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>REDIS_STATIC</name> <name>int</name></type> <name>quicklistDelIndex</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>gone</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__quicklistDelNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpDelete</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>gone</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__quicklistDelNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><name>gone</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistDelEntry</name><parameter_list>(<parameter><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>quicklistEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>deleted_node</name> <init>= <expr><call><name>quicklistDelIndex</name><argument_list>(<argument><expr><operator>(</operator><name>quicklist</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>quicklist</name></name></expr></argument>,
<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>deleted_node</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>AL_START_HEAD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>AL_START_TAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistReplaceEntry</name><parameter_list>(<parameter><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>quicklistEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name><modifier>*</modifier></type> <name>quicklist</name> <init>= <expr><name><name>iter</name><operator>-&gt;</operator><name>quicklist</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><operator>!</operator><call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isLargeElement</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpReplace</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistCompress</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isLargeElement</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistCompress</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>quicklistInsertAfter</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__quicklistDelNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>quicklistInsertAfter</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__quicklistDelNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lpSeek</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistDelIndex</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistCompress</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>resetIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>quicklistReplaceAtIndex</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistReplaceEntry</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>REDIS_STATIC</name> <name>quicklistNode</name> <modifier>*</modifier></type><name>_quicklistListpackMerge</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Requested merge (a,b) (%u, %u)"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDecompressNode</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDecompressNode</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>lpMerge</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>keep</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nokeep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>entry</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nokeep</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
<expr_stmt><expr><name>keep</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>entry</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nokeep</name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>keep</name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>keep</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <call><name>lpLength</name><argument_list>(<argument><expr><name><name>keep</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nokeep</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__quicklistDelNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>nokeep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistCompress</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>keep</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>_quicklistMergeNodes</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>center</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fill</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>fill</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>prev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev_prev</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next_next</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>target</name></decl>;</decl_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>prev_prev</name> <operator>=</operator> <name>next</name> <operator>=</operator> <name>next_next</name> <operator>=</operator> <name>target</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>center</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>center</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>center</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>prev_prev</name> <operator>=</operator> <name><name>center</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>center</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>center</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>center</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>next_next</name> <operator>=</operator> <name><name>center</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_quicklistNodeAllowMerge</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>prev_prev</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>_quicklistListpackMerge</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>prev_prev</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_prev</name> <operator>=</operator> <name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_quicklistNodeAllowMerge</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>next_next</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>_quicklistListpackMerge</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>next_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>next_next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_quicklistNodeAllowMerge</name><argument_list>(<argument><expr><name>center</name></expr></argument>, <argument><expr><name><name>center</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>target</name> <operator>=</operator> <call><name>_quicklistListpackMerge</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>center</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>center</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>center</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>target</name> <operator>=</operator> <name>center</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_quicklistNodeAllowMerge</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>_quicklistListpackMerge</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>target</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>REDIS_STATIC</name> <name>quicklistNode</name> <modifier>*</modifier></type><name>_quicklistSplitNode</name><parameter_list>(<parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>after</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>zl_sz</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>zl_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>zl_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>orig_start</name> <init>= <expr><ternary><condition><expr><name>after</name></expr> ?</condition><then> <expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>orig_extent</name> <init>= <expr><ternary><condition><expr><name>after</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>offset</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_start</name> <init>= <expr><ternary><condition><expr><name>after</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>offset</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_extent</name> <init>= <expr><ternary><condition><expr><name>after</name></expr> ?</condition><then> <expr><name>offset</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"After %d (%d); ranges: [%d, %d], [%d, %d]"</literal></expr></argument>, <argument><expr><name>after</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>orig_start</name></expr></argument>,
<argument><expr><name>orig_extent</name></expr></argument>, <argument><expr><name>new_start</name></expr></argument>, <argument><expr><name>new_extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpDeleteRange</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>orig_start</name></expr></argument>, <argument><expr><name>orig_extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <call><name>lpLength</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpDeleteRange</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>new_start</name></expr></argument>, <argument><expr><name>new_extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <call><name>lpLength</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"After split lengths: orig (%d), new (%d)"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>new_node</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>REDIS_STATIC</name> <name>void</name></type> <name>_quicklistInsert</name><parameter_list>(<parameter><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>quicklistEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>after</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name> <init>= <expr><name><name>iter</name><operator>-&gt;</operator><name>quicklist</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>full</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>at_tail</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>at_head</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>avail_next</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>avail_prev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fill</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>fill</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"No node given!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>isLargeElement</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__quicklistInsertPlainNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpPrepend</name><argument_list>(<argument><expr><call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__quicklistInsertNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_quicklistNodeAllowInsert</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Current node is full with count %d with requested fill %d"</literal></expr></argument>,
<argument><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>fill</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>full</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>after</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>==</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"At Tail of current listpack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>at_tail</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_quicklistNodeAllowInsert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Next node is available."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>avail_next</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>after</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>==</operator> <operator>-</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>count</name></name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"At Head"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>at_head</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>_quicklistNodeAllowInsert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Prev node is available."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>avail_prev</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>isLargeElement</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>at_tail</name> <operator>&amp;&amp;</operator> <name>after</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>at_head</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>after</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__quicklistInsertPlainNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>_quicklistSplitNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>entry_node</name> <init>= <expr><call><name>__quicklistCreatePlainNode</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>__quicklistInsertNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>entry_node</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__quicklistInsertNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>entry_node</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>full</name> <operator>&amp;&amp;</operator> <name>after</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Not full, inserting after current position."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpInsertString</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name></expr></argument>, <argument><expr><name>LP_AFTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRecompressOnly</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>full</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>after</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Not full, inserting before current position."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpInsertString</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name></expr></argument>, <argument><expr><name>LP_BEFORE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRecompressOnly</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>full</name> <operator>&amp;&amp;</operator> <name>at_tail</name> <operator>&amp;&amp;</operator> <name>avail_next</name> <operator>&amp;&amp;</operator> <name>after</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Full and tail, but next isn't full; inserting next node head"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpPrepend</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRecompressOnly</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRecompressOnly</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>full</name> <operator>&amp;&amp;</operator> <name>at_head</name> <operator>&amp;&amp;</operator> <name>avail_prev</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>after</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Full and head, but prev isn't full, inserting prev node tail"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRecompressOnly</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRecompressOnly</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>full</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>at_tail</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>avail_next</name> <operator>&amp;&amp;</operator> <name>after</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>at_head</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>avail_prev</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>after</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"\tprovisioning new node..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpPrepend</name><argument_list>(<argument><expr><call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__quicklistInsertNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>full</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"\tsplitting node..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>_quicklistSplitNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>after</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpPrepend</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name><name>new_node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>new_node</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>__quicklistInsertNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>after</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_quicklistMergeNodes</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>resetIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistInsertBefore</name><parameter_list>(<parameter><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>quicklistEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>_quicklistInsert</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistInsertAfter</name><parameter_list>(<parameter><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>quicklistEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>_quicklistInsert</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>quicklistDelRange</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>start</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>long</name></type> <name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>extent</name> <init>= <expr><name>count</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>extent</name> <operator>&gt;</operator> <operator>(</operator><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <name>start</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>extent</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><macro><name>start</name></macro> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>extent</name> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><operator>(</operator><operator>-</operator><name>start</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>extent</name> <operator>=</operator> <operator>-</operator><name>start</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIteratorAtIdx</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>AL_START_TAIL</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iter</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Quicklist delete request for start %ld, count %ld, extent: %ld"</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>,
<argument><expr><name>count</name></expr></argument>, <argument><expr><name>extent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>offset</name> <init>= <expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>extent</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>del</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>delete_entire_node</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>extent</name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>delete_entire_node</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>del</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>extent</name> <operator>+</operator> <name>offset</name> <operator>&gt;=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>del</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>del</name> <operator>=</operator> <operator>-</operator><name>offset</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>del</name> <operator>&gt;</operator> <name>extent</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>del</name> <operator>=</operator> <name>extent</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>del</name> <operator>=</operator> <name>extent</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"[%ld]: asking to del: %ld because offset: %d; (ENTIRE NODE: %d), "</literal>
<literal type="string">"node count: %u"</literal></expr></argument>,
<argument><expr><name>extent</name></expr></argument>, <argument><expr><name>del</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>delete_entire_node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>delete_entire_node</name> <operator>||</operator> <call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>__quicklistDelNode</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpDeleteRange</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>del</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>-=</operator> <name>del</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>-=</operator> <name>del</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDeleteIfEmpty</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistRecompressOnly</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>extent</name> <operator>-=</operator> <name>del</name></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>quicklistCompare</name><parameter_list>(<parameter><decl><type><name>quicklistEntry</name><modifier>*</modifier></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>p2_len</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>sz</name></name> <operator>==</operator> <name>p2_len</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>memcmp</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p2_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><call><name>lpCompare</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p2_len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>quicklistIter</name> <modifier>*</modifier></type><name>quicklistGetIterator</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>direction</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>iter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>direction</name> <operator>==</operator> <name>AL_START_HEAD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>direction</name> <operator>==</operator> <name>AL_START_TAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>=</operator> <name>direction</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>quicklist</name></name> <operator>=</operator> <name>quicklist</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>iter</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>quicklistIter</name> <modifier>*</modifier></type><name>quicklistGetIteratorAtIdx</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>direction</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>long</name> <name>long</name></type> <name>idx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>accum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>forward</name> <init>= <expr><ternary><condition><expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>index</name> <operator>=</operator> <ternary><condition><expr><name>forward</name></expr> ?</condition><then> <expr><name>idx</name></expr> </then><else>: <expr><operator>(</operator><operator>-</operator><name>idx</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>seek_forward</name> <init>= <expr><name>forward</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>seek_index</name> <init>= <expr><name>index</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;</operator> <operator>(</operator><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>seek_forward</name> <operator>=</operator> <operator>!</operator><name>forward</name></expr>;</expr_stmt>
<expr_stmt><expr><name>seek_index</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>index</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><name>seek_forward</name></expr> ?</condition><then> <expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr> </then><else>: <expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></else></ternary></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>likely</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>accum</name> <operator>+</operator> <name><name>n</name><operator>-&gt;</operator><name>count</name></name><operator>)</operator> <operator>&gt;</operator> <name>seek_index</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Skipping over (%p) %u at accum %lld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>n</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>count</name></name></expr></argument>,
<argument><expr><name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>accum</name> <operator>+=</operator> <name><name>n</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><name>seek_forward</name></expr> ?</condition><then> <expr><name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr> </then><else>: <expr><name><name>n</name><operator>-&gt;</operator><name>prev</name></name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>seek_forward</name> <operator>!=</operator> <name>forward</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>accum</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <name><name>n</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <name>accum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Found node: %p at accum %llu, idx %llu, sub+ %llu, sub- %llu"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>n</name></expr></argument>,
<argument><expr><name>accum</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>index</name> <operator>-</operator> <name>accum</name></expr></argument>, <argument><expr><operator>(</operator><operator>-</operator><name>index</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>forward</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name>index</name> <operator>-</operator> <name>accum</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>(</operator><operator>-</operator><name>index</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>accum</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>iter</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistReleaseIterator</name><parameter_list>(<parameter><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iter</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistCompress</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>quicklist</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>quicklistNext</name><parameter_list>(<parameter><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>quicklistEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>initEntry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iter</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Returning because no iter!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>quicklist</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>quicklist</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Returning because current node is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<function_decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>nextFn</name>)<parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>= <expr><name>NULL</name></expr></init>;</function_decl>
<decl_stmt><decl><type><name>int</name></type> <name>offset_update</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>plain</name> <init>= <expr><call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistDecompressNodeForUse</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>plain</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>current</name><operator>-&gt;</operator><name>entry</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>plain</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>AL_START_HEAD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nextFn</name> <operator>=</operator> <name>lpNext</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset_update</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>AL_START_TAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nextFn</name> <operator>=</operator> <name>lpPrev</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset_update</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <call><name>nextFn</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>+=</operator> <name>offset_update</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>zi</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>plain</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>zi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>quicklistCompress</name><argument_list>(<argument><expr><name><name>iter</name><operator>-&gt;</operator><name>quicklist</name></name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>AL_START_HEAD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Jumping to start of next node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>current</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>AL_START_TAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><literal type="string">"Jumping to end of previous node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>current</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>zi</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistSetDirection</name><parameter_list>(<parameter><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>direction</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>direction</name></name> <operator>=</operator> <name>direction</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklistDup</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>copy</name></decl>;</decl_stmt>
<expr_stmt><expr><name>copy</name> <operator>=</operator> <call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>orig</name><operator>-&gt;</operator><name>fill</name></name></expr></argument>, <argument><expr><name><name>orig</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>current</name> <init>= <expr><name><name>orig</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</init> <condition><expr><name>current</name></expr>;</condition>
<incr><expr><name>current</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>QUICKLIST_NODE_ENCODING_LZF</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistLZF</name> <modifier>*</modifier></type><name>lzf</name> <init>= <expr><operator>(</operator><name>quicklistLZF</name> <operator>*</operator><operator>)</operator><name><name>current</name><operator>-&gt;</operator><name>entry</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>lzf_sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>lzf</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name><name>lzf</name><operator>-&gt;</operator><name>sz</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>lzf_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>lzf_sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>current</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>QUICKLIST_NODE_ENCODING_RAW</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name><name>current</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name><name>current</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>copy</name><operator>-&gt;</operator><name>count</name></name> <operator>+=</operator> <name><name>node</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>sz</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>encoding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>container</name></name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>container</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_quicklistInsertNodeAfter</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name><name>copy</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>copy</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>quicklistIter</name> <modifier>*</modifier></type><name>quicklistGetIteratorEntryAtIdx</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>long</name> <name>long</name></type> <name>idx</name></decl></parameter>,
<parameter><decl><type><name>quicklistEntry</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIteratorAtIdx</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>AL_START_TAIL</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>iter</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>iter</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>quicklistRotatePlain</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>new_head</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>new_tail</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>new_head</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_head</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_head</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>new_head</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>new_tail</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistRotate</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistRotatePlain</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lpSeek</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>value</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>longval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>longstr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>longval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><name>longstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>longstr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>longval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>longstr</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistDelIndex</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>longstr</name> <operator>&amp;&amp;</operator> <name>value</name> <operator>!=</operator> <name>tmp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>quicklistPopCustom</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>sz</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name> <modifier>*</modifier></type><name>sval</name></decl></parameter>,
<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>saver</name>)<parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>vlong</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>where</name> <operator>==</operator> <name>QUICKLIST_HEAD</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sz</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>sz</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sval</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>sval</name> <operator>=</operator> <operator>-</operator><literal type="number">123456789</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name>QUICKLIST_HEAD</name> <operator>&amp;&amp;</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>where</name> <operator>==</operator> <name>QUICKLIST_TAIL</name> <operator>&amp;&amp;</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>QUICKLIST_NODE_ENCODING_LZF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <call><name>saver</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sz</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>sz</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistDelIndex</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vstr</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <call><name>saver</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sz</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>sz</name> <operator>=</operator> <name>vlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sval</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>sval</name> <operator>=</operator> <name>vlong</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>quicklistDelIndex</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>REDIS_STATIC</name> <name>void</name> <modifier>*</modifier></type><name>_quicklistSaver</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>vstr</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>quicklistPop</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>sz</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name> <modifier>*</modifier></type><name>slong</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>vlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>vlong</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>quicklistPopCustom</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vstr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>,
<argument><expr><name>_quicklistSaver</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name>vstr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>slong</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>slong</name> <operator>=</operator> <name>vlong</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>sz</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>sz</name> <operator>=</operator> <name>vlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistPush</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>sz</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>QUICKLIST_NODE_ENCODING_LZF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>QUICKLIST_NODE_ENCODING_LZF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>where</name> <operator>==</operator> <name>QUICKLIST_HEAD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>where</name> <operator>==</operator> <name>QUICKLIST_TAIL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>quicklist</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistRepr</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>full</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>quicklist</name> <init>= <expr><operator>(</operator>struct <name>quicklist</name><operator>*</operator><operator>)</operator> <name>ql</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{count : %ld}\n"</literal></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{len : %ld}\n"</literal></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{fill : %d}\n"</literal></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>fill</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{compress : %d}\n"</literal></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{bookmark_count : %d}\n"</literal></expr></argument>, <argument><expr><name><name>quicklist</name><operator>-&gt;</operator><name>bookmark_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistNode</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><name><name>quicklist</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{quicklist node(%d)\n"</literal></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{container : %s, encoding: %s, size: %zu, recompress: %d, attempted_compress: %d}\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"PLAIN"</literal></expr></then><else>: <expr><literal type="string">"PACKED"</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>QUICKLIST_NODE_ENCODING_RAW</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"RAW"</literal></expr></then><else>: <expr><literal type="string">"LZF"</literal></expr></else></ternary></expr></argument>,
<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>,
<argument><expr><name><name>node</name><operator>-&gt;</operator><name>recompress</name></name></expr></argument>,
<argument><expr><name><name>node</name><operator>-&gt;</operator><name>attempted_compress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>full</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistDecompressNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>container</name></name> <operator>==</operator> <name>QUICKLIST_NODE_CONTAINER_PACKED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{ listpack:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpRepr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>QL_NODE_IS_PLAIN</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"{ entry : %s }\n"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRecompressOnly</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>quicklistBookmarkCreate</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier><modifier>*</modifier></type><name>ql_ref</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><operator>*</operator><name>ql_ref</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>bookmark_count</name></name> <operator>&gt;=</operator> <name>QL_MAX_BM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>quicklistBookmark</name> <modifier>*</modifier></type><name>bm</name> <init>= <expr><call><name>_quicklistBookmarkFindByName</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>bm</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>bm</name><operator>-&gt;</operator><name>node</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ql</name> <operator>=</operator> <call><name>zrealloc</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>quicklist</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name><name>ql</name><operator>-&gt;</operator><name>bookmark_count</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>quicklistBookmark</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ql_ref</name> <operator>=</operator> <name>ql</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ql</name><operator>-&gt;</operator><name>bookmarks</name><index>[<expr><name><name>ql</name><operator>-&gt;</operator><name>bookmark_count</name></name></expr>]</index></name><operator>.</operator><name>node</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ql</name><operator>-&gt;</operator><name>bookmarks</name><index>[<expr><name><name>ql</name><operator>-&gt;</operator><name>bookmark_count</name></name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <call><name>zstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ql</name><operator>-&gt;</operator><name>bookmark_count</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>quicklistNode</name> <modifier>*</modifier></type><name>quicklistBookmarkFind</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistBookmark</name> <modifier>*</modifier></type><name>bm</name> <init>= <expr><call><name>_quicklistBookmarkFindByName</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bm</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name><name>bm</name><operator>-&gt;</operator><name>node</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>quicklistBookmarkDelete</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistBookmark</name> <modifier>*</modifier></type><name>bm</name> <init>= <expr><call><name>_quicklistBookmarkFindByName</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bm</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>_quicklistBookmarkDelete</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>quicklistBookmark</name> <modifier>*</modifier></type><name>_quicklistBookmarkFindByName</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>ql</name><operator>-&gt;</operator><name>bookmark_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>bookmarks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>&amp;</operator><name><name>ql</name><operator>-&gt;</operator><name>bookmarks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>quicklistBookmark</name> <modifier>*</modifier></type><name>_quicklistBookmarkFindByNode</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>ql</name><operator>-&gt;</operator><name>bookmark_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>bookmarks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>node</name> <operator>==</operator> <name>node</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>&amp;</operator><name><name>ql</name><operator>-&gt;</operator><name>bookmarks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>_quicklistBookmarkDelete</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><name>quicklistBookmark</name> <modifier>*</modifier></type><name>bm</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><name>bm</name> <operator>-</operator> <name><name>ql</name><operator>-&gt;</operator><name>bookmarks</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>bm</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ql</name><operator>-&gt;</operator><name>bookmark_count</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>bm</name></expr></argument>, <argument><expr><name>bm</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>ql</name><operator>-&gt;</operator><name>bookmark_count</name></name> <operator>-</operator> <name>index</name><operator>)</operator><operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>bm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>quicklistBookmarksClear</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>bookmark_count</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>bookmarks</name><index>[<expr><operator>--</operator><name><name>ql</name><operator>-&gt;</operator><name>bookmark_count</name></name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>REDIS_TEST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"testhelp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yell</name><parameter_list>(<parameter><type><name>str</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>printf("ERROR! " str "\n\n", __VA_ARGS__)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR</name></cpp:macro> <cpp:value>do { printf("\tERROR!\n"); err++; } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { printf("%s:%s:%d:\t", __FILE__, __func__, __LINE__); printf("ERROR! " x "\n", __VA_ARGS__); err++; } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST</name><parameter_list>(<parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>printf("test â %s\n", name);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_DESC</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>printf("test â " name "\n", __VA_ARGS__);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QL_TEST_VERBOSE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(void)(x)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ql_info</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>QL_TEST_VERBOSE</name></expr></cpp:if>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Container length: %lu\n"</literal></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Container size: %lu\n"</literal></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t(zsize head: %lu)\n"</literal></expr></argument>, <argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\t(zsize tail: %lu)\n"</literal></expr></argument>, <argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>long</name> <name>long</name></type> <name>ustime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>ust</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ust</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name><name>tv</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator> <operator>*</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ust</name> <operator>+=</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
<return>return <expr><name>ust</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>long</name> <name>long</name></type> <name>mstime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>ustime</name><argument_list>()</argument_list></call> <operator>/</operator> <literal type="number">1000</literal></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_itrprintr</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>print</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forward</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>=
<expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><ternary><condition><expr><name>forward</name></expr> ?</condition><then> <expr><name>AL_START_HEAD</name></expr> </then><else>: <expr><name>AL_START_TAIL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>node</name></name> <operator>!=</operator> <name>prev</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>node</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>print</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>entry</name><operator>.</operator><name>sz</name></name> <operator>&gt;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">20</literal><operator>)</operator><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal><operator>&lt;&lt;</operator><literal type="number">20</literal></expr> </then><else>: <expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"[%3d (%2d)]: [%.*s] (%lld)\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>itrprintr</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>print</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>_itrprintr</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>print</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>itrprintr_rev</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>print</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>_itrprintr</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>print</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ql_verify</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>, <parameter><type><name>c</name></type></parameter>, <parameter><type><name>d</name></type></parameter>, <parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { err += _ql_verify((a), (b), (c), (d), (e)); } while (0)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_ql_verify_compress</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>errors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>quicklistAllowsCompression</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ql</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>low_raw</name> <init>= <expr><name><name>ql</name><operator>-&gt;</operator><name>compress</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>high_raw</name> <init>= <expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>ql</name><operator>-&gt;</operator><name>compress</name></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>at</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition> <incr><expr><name>at</name><operator>++</operator></expr><operator>,</operator> <expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>at</name> <operator>&lt;</operator> <name>low_raw</name> <operator>||</operator> <name>at</name> <operator>&gt;=</operator> <name>high_raw</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>QUICKLIST_NODE_ENCODING_RAW</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"Incorrect compression: node %d is "</literal>
<literal type="string">"compressed at depth %d ((%u, %u); total "</literal>
<literal type="string">"nodes: %lu; size: %zu; recompress: %d)"</literal></expr></argument>,
<argument><expr><name>at</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>, <argument><expr><name>low_raw</name></expr></argument>, <argument><expr><name>high_raw</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>,
<argument><expr><name><name>node</name><operator>-&gt;</operator><name>recompress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>QUICKLIST_NODE_ENCODING_LZF</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>node</name><operator>-&gt;</operator><name>attempted_compress</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"Incorrect non-compression: node %d is NOT "</literal>
<literal type="string">"compressed at depth %d ((%u, %u); total "</literal>
<literal type="string">"nodes: %lu; size: %zu; recompress: %d; attempted: %d)"</literal></expr></argument>,
<argument><expr><name>at</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>compress</name></name></expr></argument>, <argument><expr><name>low_raw</name></expr></argument>, <argument><expr><name>high_raw</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>,
<argument><expr><name><name>node</name><operator>-&gt;</operator><name>recompress</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>attempted_compress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>errors</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_ql_verify</name><parameter_list>(<parameter><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>count</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name></type> <name>head_count</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>tail_count</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>errors</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ql_info</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"quicklist length wrong: expected %d, got %lu"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"quicklist count wrong: expected %d, got %lu"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>loopr</name> <init>= <expr><call><name>itrprintr</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>loopr</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"quicklist cached count not match actual count: expected %lu, got "</literal>
<literal type="string">"%d"</literal></expr></argument>,
<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>loopr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rloopr</name> <init>= <expr><call><name>itrprintr_rev</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>loopr</name> <operator>!=</operator> <name>rloopr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"quicklist has different forward count than reverse count! "</literal>
<literal type="string">"Forward count is %d, reverse count is %d."</literal></expr></argument>,
<argument><expr><name>loopr</name></expr></argument>, <argument><expr><name>rloopr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>errors</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>errors</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>head</name></name> <operator>&amp;&amp;</operator> <name>head_count</name> <operator>!=</operator> <name><name>ql</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>count</name></name> <operator>&amp;&amp;</operator>
<name>head_count</name> <operator>!=</operator> <call><name>lpLength</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"quicklist head count wrong: expected %d, "</literal>
<literal type="string">"got cached %d vs. actual %lu"</literal></expr></argument>,
<argument><expr><name>head_count</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>tail</name></name> <operator>&amp;&amp;</operator> <name>tail_count</name> <operator>!=</operator> <name><name>ql</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>count</name></name> <operator>&amp;&amp;</operator>
<name>tail_count</name> <operator>!=</operator> <call><name>lpLength</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>yell</name><argument_list>(<argument><expr><literal type="string">"quicklist tail count wrong: expected %d, "</literal>
<literal type="string">"got cached %u vs. actual %lu"</literal></expr></argument>,
<argument><expr><name>tail_count</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><call><name>lpLength</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errors</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>errors</name> <operator>+=</operator> <call><name>_ql_verify_compress</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>errors</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ql_release_iterator</name><parameter_list>(<parameter><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>iter</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ql</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>quicklist</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistReleaseIterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ql</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>_ql_verify_compress</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>genstr</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>result</name><index>[<expr><literal type="number">64</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>randstring</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>minval</name></decl>, <decl><type ref="prev"/><name>maxval</name></decl>;</decl_stmt>
<switch>switch<condition>(<expr><call><name>rand</name><argument_list>()</argument_list></call> <operator>%</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name>minval</name> <operator>=</operator> <literal type="char">'a'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>=</operator> <literal type="char">'z'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>minval</name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>=</operator> <literal type="char">'9'</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>minval</name> <operator>=</operator> <literal type="char">'A'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>=</operator> <literal type="char">'Z'</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<while>while<condition>(<expr><name>p</name> <operator>&lt;</operator> <name>sz</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>target</name><index>[<expr><name>p</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>minval</name><operator>+</operator><call><name>rand</name><argument_list>()</argument_list></call><operator>%</operator><operator>(</operator><name>maxval</name><operator>-</operator><name>minval</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>quicklistTest</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>accurate</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REDIS_TEST_ACCURATE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>optimize_start</name> <init>=
<expr><operator>-</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>optimization_level</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>optimization_level</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Starting optimization offset at: %d\n"</literal></expr></argument>, <argument><expr><name>optimize_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>options</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">10</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>fills</name><index>[]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">5</literal></expr>, <expr><operator>-</operator><literal type="number">4</literal></expr>, <expr><operator>-</operator><literal type="number">3</literal></expr>, <expr><operator>-</operator><literal type="number">2</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>,
<expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">32</literal></expr>, <expr><literal type="number">66</literal></expr>, <expr><literal type="number">128</literal></expr>, <expr><literal type="number">999</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>option_count</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>options</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fill_count</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>fills</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>fills</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name><name>runtime</name><index>[<expr><name>option_count</name></expr>]</index></name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>_i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>_i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>option_count</name></expr>;</condition> <incr><expr><name>_i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Testing Compression option %d\n"</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"create list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"add to tail of empty list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"add to head of empty list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"add to tail 5x at compress %d"</literal></argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"add to head 5x at compress %d"</literal></argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"add to tail 500x at compress %d"</literal></argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">500</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"add to head 500x at compress %d"</literal></argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">500</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"rotate empty"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistRotate</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"Comprassion Plain node"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistisSetPackedThreshold</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"hello%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_TAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"hello%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"value [%s] didn't match [%s] at position %d"</literal></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"NEXT plain node"</literal></argument>)</argument_list></macro>
<block>{<block_content>
<expr_stmt><expr><name>packed_threshold</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>strings</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"hello1"</literal></expr>, <expr><literal type="string">"hello2"</literal></expr>, <expr><literal type="string">"h3"</literal></expr>, <expr><literal type="string">"h4"</literal></expr>, <expr><literal type="string">"hello5"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name><name>strings</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>strings</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_TAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>strings</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>strings</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"rotate plain node "</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>lv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>packed_threshold</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello1"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello4"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello3"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello2"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRotate</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistPop</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>QUICKLIST_HEAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>temp_char</name> <init>= <expr><name><name>data</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>temp_char</name> <operator>==</operator> <operator>(</operator><literal type="char">'0'</literal> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>packed_threshold</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">30</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"rotate one val once"</literal></argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRotate</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"rotate 500 val 5000 times at compress %d"</literal></argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"900"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"7000"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"-1200"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"42"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ql_info</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>ql_info</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRotate</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">504</literal></expr></argument>, <argument><expr><literal type="number">504</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">252</literal></expr></argument>, <argument><expr><literal type="number">504</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">504</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"pop empty"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPop</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>QUICKLIST_HEAD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"pop 1 string from 1"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>populate</name> <init>= <expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">331</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>populate</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>lv</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ql_info</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistPop</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>QUICKLIST_HEAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sz</name> <operator>==</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>populate</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name>sz</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Pop'd value (%.*s) didn't equal original value (%s)"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>,
<argument><expr><name>data</name></expr></argument>, <argument><expr><name>populate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"pop head 1 number from 1"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"55513"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>lv</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ql_info</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistPop</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>QUICKLIST_HEAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>data</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lv</name> <operator>==</operator> <literal type="number">55513</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"pop head 500 from 500"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ql_info</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>lv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>quicklistPop</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>QUICKLIST_HEAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sz</name> <operator>==</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">499</literal> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name>sz</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Pop'd value (%.*s) didn't equal original value (%s)"</literal></expr></argument>,
<argument><expr><name>size</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">499</literal> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"pop head 5000 from 500"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>lv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>quicklistPop</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>QUICKLIST_HEAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>sz</name> <operator>==</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">499</literal> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name>sz</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Pop'd value (%.*s) didn't equal original value "</literal>
<literal type="string">"(%s)"</literal></expr></argument>,
<argument><expr><name>size</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">499</literal> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"iterate forward over 500 list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_HEAD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">499</literal></expr></init></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"value [%s] didn't match [%s] at position %d"</literal></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">500</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Didn't iterate over exactly 500 elements (%d)"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"iterate reverse over 500 list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_TAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"value [%s] didn't match [%s] at position %d"</literal></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">500</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Didn't iterate over exactly 500 elements (%d)"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"insert after 1 element"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistInsertAfter</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 0 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>sz</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 1 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"insert before 1 element"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistInsertBefore</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 0 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> <operator>=</operator> <name><name>entry</name><operator>.</operator><name>sz</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 1 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"insert head while head node is full"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">10</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistInsertBefore</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"insert tail while tail node is full"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistInsertAfter</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"insert once in elements while iterating at compress %d"</literal></argument>,
<argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"def"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"bob"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"foo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"zoo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>itrprintr</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_HEAD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"bob"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistInsertBefore</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><literal type="string">"bar"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>itrprintr</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 0 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"def"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 1 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"bar"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 2 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"bob"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 3 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"foo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 4 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"zoo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value 5 didn't match, instead got: %.*s"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"insert [before] 250 new in middle of 500 elements at compress %d"</literal></argument>,
<argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">250</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">250</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistInsertBefore</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>, <argument><expr><literal type="number">750</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"insert [after] 250 new in middle of 500 elements at compress %d"</literal></argument>,
<argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">250</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">250</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistInsertAfter</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">750</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"List size not 750, but rather %ld"</literal></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">26</literal></expr></argument>, <argument><expr><literal type="number">750</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"duplicate empty list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>copy</name> <init>= <expr><call><name>quicklistDup</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"duplicate list of 1 element"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>copy</name> <init>= <expr><call><name>quicklistDup</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"duplicate list of 500"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>copy</name> <init>= <expr><call><name>quicklistDup</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"index 1,200 from 500 list at fill %d at compress %d"</literal></argument>, <argument>f</argument>,
<argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"hello2"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value: %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">200</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"hello201"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value: %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"index -1,-2 from 500 list at fill %d at compress %d"</literal></argument>,
<argument>fills[f]</argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"hello500"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value: %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"hello499"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value: %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"index -100 from 500 list at fill %d at compress %d"</literal></argument>,
<argument>fills[f]</argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">100</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"hello401"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value: %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"index too big +1 from 50 list at fill %d at compress %d"</literal></argument>,
<argument>fills[f]</argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">50</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>iter</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Index found at 50 with 50 list: %.*s"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></for>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete range empty list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete range of entire node in list of one node"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete range of entire node with overflow counts"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete middle 100 of 500 list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">200</literal></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>, <argument><expr><literal type="number">400</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete less than fill but across nodes"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">60</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">490</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete negative 1 from 500 list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">499</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete negative 1 from 500 list with overflow counts"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">499</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete negative 100 from 500 list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">500</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">100</literal></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>, <argument><expr><literal type="number">400</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"delete -10 count 5 from 50 list"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">50</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">45</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"numbers only list read"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"1111"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"2222"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"3333"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"4444"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">1111</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 1111, %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">2222</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 2222, %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">3333</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 3333, %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">4444</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 4444, %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>iter</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Index past elements: %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">4444</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 4444 (reverse), %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">3333</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 3333 (reverse), %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">2222</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 2222 (reverse), %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">4</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">1111</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Not 1111 (reverse), %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>iter</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Index past elements (reverse), %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"numbers larger list read"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistSetFill</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name><name>nums</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">5157318210846258176</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"xxxxxxxxxxxxxxxxxxxx"</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5000</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"[%d] Not longval %lld but rather %lld"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>=</operator> <literal type="number">0xdeadbeef</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">5000</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"xxxxxxxxxxxxxxxxxxxx"</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"String val not match: %s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">157</literal></expr></argument>, <argument><expr><literal type="number">5001</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"numbers larger list read B"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"99"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"98"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"xxxxxxxxxxxxxxxxxxxx"</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"96"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"95"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistReplaceAtIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"foo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistReplaceAtIndex</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"bar"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"lrem test at compress %d"</literal></argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>words</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"abc"</literal></expr>, <expr><literal type="string">"foo"</literal></expr>, <expr><literal type="string">"bar"</literal></expr>, <expr><literal type="string">"foobar"</literal></expr>, <expr><literal type="string">"foobared"</literal></expr>,
<expr><literal type="string">"zap"</literal></expr>, <expr><literal type="string">"bar"</literal></expr>, <expr><literal type="string">"test"</literal></expr>, <expr><literal type="string">"foo"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>result</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"abc"</literal></expr>, <expr><literal type="string">"foo"</literal></expr>, <expr><literal type="string">"foobar"</literal></expr>, <expr><literal type="string">"foobared"</literal></expr>,
<expr><literal type="string">"zap"</literal></expr>, <expr><literal type="string">"test"</literal></expr>, <expr><literal type="string">"foo"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>resultB</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"abc"</literal></expr>, <expr><literal type="string">"foo"</literal></expr>, <expr><literal type="string">"foobar"</literal></expr>,
<expr><literal type="string">"foobared"</literal></expr>, <expr><literal type="string">"zap"</literal></expr>, <expr><literal type="string">"test"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">9</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>words</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_HEAD</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>quicklistCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"bar"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistDelEntry</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"No match at position %d, got %.*s instead of %s"</literal></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"foo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>del</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>quicklistCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"foo"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistDelEntry</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>del</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>del</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_TAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>resB</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>resultB</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>resultB</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>resultB</name><index>[<expr><name>resB</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"No match at position %d, got %.*s instead of %s"</literal></expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>resultB</name><index>[<expr><name>resB</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"iterate reverse + delete at compress %d"</literal></argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"abc"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"def"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"hij"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"jkl"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"oop"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_TAIL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>quicklistCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><literal type="string">"hij"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistDelEntry</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Didn't iterate 5 times, iterated %d times."</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIterator</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_HEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>vals</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"abc"</literal></expr>, <expr><literal type="string">"def"</literal></expr>, <expr><literal type="string">"jkl"</literal></expr>, <expr><literal type="string">"oop"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>quicklistCompare</name><argument_list>(<argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Value at %d didn't match %s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"iterator at index test at compress %d"</literal></argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name><name>nums</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">760</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">5157318210846258176</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklistIter</name> <modifier>*</modifier></type><name>iter</name> <init>=
<expr><call><name>quicklistGetIteratorAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>AL_START_HEAD</name></expr></argument>, <argument><expr><literal type="number">437</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">437</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>quicklistNext</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Expected %lld, but got %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>,
<argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"ltrim test A at compress %d"</literal></argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name><name>nums</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">5157318210846258176</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">7</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <name><name>nums</name><index>[<expr><literal type="number">25</literal> <operator>+</operator> <name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Deleted invalid range! Expected %lld but got "</literal>
<literal type="string">"%lld"</literal></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><literal type="number">25</literal> <operator>+</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"ltrim test B at compress %d"</literal></argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name>QUICKLIST_NOCOMPRESS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name><name>nums</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">33</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"A: longval not 5, but %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"B! got instead: %lld"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"bobobob"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><name><name>entry</name><operator>.</operator><name>sz</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>, <argument><expr><literal type="string">"bobobob"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Tail doesn't match bobobob, it's %.*s instead"</literal></expr></argument>,
<argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>entry</name><operator>.</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">12</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <name><name>nums</name><index>[<expr><literal type="number">5</literal> <operator>+</operator> <name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Deleted invalid range! Expected %lld but got "</literal>
<literal type="string">"%lld"</literal></expr></argument>,
<argument><expr><name><name>entry</name><operator>.</operator><name>longval</name></name></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><literal type="number">5</literal> <operator>+</operator> <name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"ltrim test C at compress %d"</literal></argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name><name>nums</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">33</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">5157318210846258176</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">29</literal></expr></argument>,
<argument><expr><literal type="number">4000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>quicklistEntry</name></type> <name>entry</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> <operator>=</operator> <call><name>quicklistGetIteratorEntryAtIdx</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>.</operator><name>longval</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">5157318210846258173</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>ql_release_iterator</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"ltrim test D at compress %d"</literal></argument>, <argument>options[_i]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>_i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>num</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name><name>nums</name><index>[<expr><literal type="number">5000</literal></expr>]</index></name></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">33</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">5157318210846258176</literal> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><call><name>ll2string</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>nums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ql_verify</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">33</literal></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">12</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name> <operator>!=</operator> <literal type="number">30</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Didn't delete exactly three elements! Count is: %lu"</literal></expr></argument>,
<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>stop</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>runtime</name><index>[<expr><name>_i</name></expr>]</index></name> <operator>=</operator> <name>stop</name> <operator>-</operator> <name>start</name></expr>;</expr_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>int</name></type> <name><name>list_sizes</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">250</literal></expr>, <expr><literal type="number">251</literal></expr>, <expr><literal type="number">500</literal></expr>, <expr><literal type="number">999</literal></expr>, <expr><literal type="number">1000</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>list_count</name> <init>= <expr><ternary><condition><expr><name>accurate</name></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>list_sizes</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>list_sizes</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>list</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>list</name> <operator>&lt;</operator> <name>list_count</name></expr>;</condition> <incr><expr><name>list</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<macro><name>TEST_DESC</name><argument_list>(<argument><literal type="string">"verify specific compression of interior nodes with %d list "</literal></argument>,
<argument>list_sizes[list]</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>f</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>fill_count</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>depth</name> <operator>&lt;</operator> <literal type="number">40</literal></expr>;</condition> <incr><expr><name>depth</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><name><name>fills</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>list_sizes</name><index>[<expr><name>list</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello TAIL"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">"hello HEAD"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><decl><type><name>int</name></type> <name>step</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>step</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>step</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>step</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>list_sizes</name><index>[<expr><name>list</name></expr>]</index></name> <operator>/</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistPop</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>QUICKLIST_HEAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistPop</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><name>QUICKLIST_TAIL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>ql</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>low_raw</name> <init>= <expr><name><name>ql</name><operator>-&gt;</operator><name>compress</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>high_raw</name> <init>= <expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>ql</name><operator>-&gt;</operator><name>compress</name></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name> <name>int</name></type> <name>at</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr>;</condition>
<incr><expr><name>at</name><operator>++</operator></expr><operator>,</operator> <expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>at</name> <operator>&lt;</operator> <name>low_raw</name> <operator>||</operator> <name>at</name> <operator>&gt;=</operator> <name>high_raw</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>QUICKLIST_NODE_ENCODING_RAW</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Incorrect compression: node %d is "</literal>
<literal type="string">"compressed at depth %d ((%u, %u); total "</literal>
<literal type="string">"nodes: %lu; size: %zu)"</literal></expr></argument>,
<argument><expr><name>at</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>low_raw</name></expr></argument>, <argument><expr><name>high_raw</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>encoding</name></name> <operator>!=</operator> <name>QUICKLIST_NODE_ENCODING_LZF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Incorrect non-compression: node %d is NOT "</literal>
<literal type="string">"compressed at depth %d ((%u, %u); total "</literal>
<literal type="string">"nodes: %lu; size: %zu; attempted: %d)"</literal></expr></argument>,
<argument><expr><name>at</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>low_raw</name></expr></argument>, <argument><expr><name>high_raw</name></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>attempted_compress</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
</block_content>}</block>
</block_content>}</block></for>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>stop</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>option_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Test Loop %02d: %0.2f seconds.\n"</literal></expr></argument>, <argument><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><operator>(</operator><name>float</name><operator>)</operator><name><name>runtime</name><index>[<expr><name>i</name></expr>]</index></name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Compressions: %0.2f seconds.\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>float</name><operator>)</operator><operator>(</operator><name>stop</name> <operator>-</operator> <name>start</name><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"bookmark get updated to next item"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"3"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"4"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistPushTail</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"5"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name><operator>==</operator><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistBookmarkCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ql</name></expr></argument>, <argument><expr><literal type="string">"_dummy"</literal></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistBookmarkCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ql</name></expr></argument>, <argument><expr><literal type="string">"_test"</literal></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistBookmarkFind</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"_test"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>ql</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistBookmarkFind</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"_test"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>ql</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistDelRange</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistBookmarkFind</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"_test"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistBookmarkFind</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"_dummy"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>ql</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistBookmarkFind</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"_missing"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ql</name><operator>-&gt;</operator><name>len</name></name><operator>==</operator><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistBookmarksClear</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistBookmarkFind</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"_dummy"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"bookmark limit"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>quicklist</name> <modifier>*</modifier></type><name>ql</name> <init>= <expr><call><name>quicklistNew</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>quicklistPushHead</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>QL_MAX_BM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistBookmarkCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>quicklistBookmarkCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ql</name></expr></argument>, <argument><expr><literal type="string">"_test"</literal></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistBookmarkDelete</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistBookmarkCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ql</name></expr></argument>, <argument><expr><literal type="string">"_test"</literal></expr></argument>, <argument><expr><name><name>ql</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistBookmarkDelete</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"_test"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>QL_MAX_BM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>quicklistBookmarkFind</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><call><name>genstr</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>ql</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>quicklistBookmarkFind</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>quicklistBookmarkFind</name><argument_list>(<argument><expr><name>ql</name></expr></argument>, <argument><expr><literal type="string">"_test"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistRelease</name><argument_list>(<argument><expr><name>ql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REDIS_TEST_LARGE_MEMORY</name></expr>)</condition> <block>{<block_content>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"compress and decompress quicklist listpack node"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">25</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>randstring</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>quicklistNodeUpdateSz</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>__quicklistCompressNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>__quicklistDecompressNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Compress and decompress: %zu MB in %.2f seconds.\n"</literal></expr></argument>,
<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name><operator>/</operator><literal type="number">1024</literal><operator>/</operator><literal type="number">1024</literal></expr></argument>, <argument><expr><operator>(</operator><name>float</name><operator>)</operator><operator>(</operator><call><name>mstime</name><argument_list>()</argument_list></call> <operator>-</operator> <name>start</name><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>ULONG_MAX</name> <operator>&gt;=</operator> <literal type="number">0xffffffffffffffff</literal></expr></cpp:if>
<macro><name>TEST</name><argument_list>(<argument><literal type="string">"compress and decomress quicklist plain node large than UINT32_MAX"</literal></argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><operator>(</operator><literal type="number">1ull</literal> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>randstring</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"helloworld"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name> <operator>+</operator> <name>sz</name> <operator>-</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"1234567890"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>quicklistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>__quicklistCreatePlainNode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <call><name>quicklistCreateNode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>start</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>__quicklistCompressNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>__quicklistDecompressNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Compress and decompress: %zu MB in %.2f seconds.\n"</literal></expr></argument>,
<argument><expr><name><name>node</name><operator>-&gt;</operator><name>sz</name></name><operator>/</operator><literal type="number">1024</literal><operator>/</operator><literal type="number">1024</literal></expr></argument>, <argument><expr><operator>(</operator><name>float</name><operator>)</operator><operator>(</operator><call><name>mstime</name><argument_list>()</argument_list></call> <operator>-</operator> <name>start</name><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>, <argument><expr><literal type="string">"helloworld"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name> <operator>+</operator> <name>sz</name> <operator>-</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"1234567890"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"ALL TESTS PASSED!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ERR</name><argument_list>(<argument><expr><literal type="string">"Sorry, not all tests passed! In fact, %d tests failed."</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>err</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
