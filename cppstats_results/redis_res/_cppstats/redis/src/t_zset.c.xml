<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/results/redis_res/_cppstats/redis/src/t_zset.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<function_decl><type><name>int</name></type> <name>zslLexValueGteMin</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>zslLexValueLteMax</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslCreateNode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zn</name> <init>=
<expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>zn</name></expr></argument>)</argument_list></sizeof><operator>+</operator><name>level</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr>struct <name>zskiplistLevel</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>zn</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zn</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <name>ele</name></expr>;</expr_stmt>
<return>return <expr><name>zn</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>zskiplist</name> <modifier>*</modifier></type><name>zslCreate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl>;</decl_stmt>
<expr_stmt><expr><name>zsl</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>zsl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <call><name>zslCreateNode</name><argument_list>(<argument><expr><name>ZSKIPLIST_MAXLEVEL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>ZSKIPLIST_MAXLEVEL</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>backward</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>zsl</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zslFreeNode</name><parameter_list>(<parameter><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zslFree</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zslRandomLevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><operator>(</operator><call><name>random</name><argument_list>()</argument_list></call><operator>&amp;</operator><literal type="number">0xFFFF</literal><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name>ZSKIPLIST_P</name> <operator>*</operator> <literal type="number">0xFFFF</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>level</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>level</name><operator>&lt;</operator><name>ZSKIPLIST_MAXLEVEL</name><operator>)</operator></expr> ?</condition><then> <expr><name>level</name></expr> </then><else>: <expr><name>ZSKIPLIST_MAXLEVEL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslInsert</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name><name>update</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name><name>rank</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>level</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isnan</name><argument_list>(<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>rank</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>==</operator> <operator>(</operator><name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>rank</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;</operator> <name>score</name> <operator>||</operator>
<operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>==</operator> <name>score</name> <operator>&amp;&amp;</operator>
<call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>rank</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>level</name> <operator>=</operator> <call><name>zslRandomLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>rank</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>level</name></name> <operator>=</operator> <name>level</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>zslCreateNode</name><argument_list>(<argument><expr><name>level</name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>level</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>=</operator> <name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>=</operator> <name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>-</operator> <operator>(</operator><name><name>rank</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>rank</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>=</operator> <operator>(</operator><name><name>rank</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>rank</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>level</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>backward</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>update</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>update</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>backward</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zslDeleteNode</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>zskiplistNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>update</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>==</operator> <name>x</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>+=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>backward</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<while>while<condition>(<expr><name><name>zsl</name><operator>-&gt;</operator><name>level</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>forward</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zslDelete</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>zskiplistNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name><name>update</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;</operator> <name>score</name> <operator>||</operator>
<operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>==</operator> <name>score</name> <operator>&amp;&amp;</operator>
<call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <name>score</name> <operator>==</operator> <name><name>x</name><operator>-&gt;</operator><name>score</name></name> <operator>&amp;&amp;</operator> <call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zslDeleteNode</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>node</name> <operator>=</operator> <name>x</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslUpdateScore</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>curscore</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>newscore</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name><name>update</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;</operator> <name>curscore</name> <operator>||</operator>
<operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>==</operator> <name>curscore</name> <operator>&amp;&amp;</operator>
<call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>x</name> <operator>&amp;&amp;</operator> <name>curscore</name> <operator>==</operator> <name><name>x</name><operator>-&gt;</operator><name>score</name></name> <operator>&amp;&amp;</operator> <call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>backward</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>x</name><operator>-&gt;</operator><name>backward</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;</operator> <name>newscore</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>&gt;</operator> <name>newscore</name><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <name>newscore</name></expr>;</expr_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>zslDeleteNode</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>newnode</name> <init>= <expr><call><name>zslInsert</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>newscore</name></expr></argument>,<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>newnode</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zslValueGteMin</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name><name>spec</name><operator>-&gt;</operator><name>minex</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>value</name> <operator>&gt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>min</name></name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>value</name> <operator>&gt;=</operator> <name><name>spec</name><operator>-&gt;</operator><name>min</name></name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zslValueLteMax</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name><name>spec</name><operator>-&gt;</operator><name>maxex</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>value</name> <operator>&lt;</operator> <name><name>spec</name><operator>-&gt;</operator><name>max</name></name><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name>value</name> <operator>&lt;=</operator> <name><name>spec</name><operator>-&gt;</operator><name>max</name></name><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zslIsInRange</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>range</name><operator>-&gt;</operator><name>min</name></name> <operator>&gt;</operator> <name><name>range</name><operator>-&gt;</operator><name>max</name></name> <operator>||</operator>
<operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>min</name></name> <operator>==</operator> <name><name>range</name><operator>-&gt;</operator><name>max</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>minex</name></name> <operator>||</operator> <name><name>range</name><operator>-&gt;</operator><name>maxex</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslFirstInRange</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslIsInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></for>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>x</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslLastInRange</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslIsInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
<call><name>zslValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></for>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>x</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>long</name></type> <name>zslDeleteRangeByScore</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>, <parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>dict</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name><name>update</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>removed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <call><name>zslValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>score</name></name></expr></argument>, <argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zslDeleteNode</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>x</name></expr></argument>,<argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>removed</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>removed</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>long</name></type> <name>zslDeleteRangeByLex</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>, <parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>dict</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name><name>update</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>removed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>zslLexValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <call><name>zslLexValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zslDeleteNode</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>x</name></expr></argument>,<argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>removed</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>removed</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>long</name></type> <name>zslDeleteRangeByRank</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>dict</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name><name>update</name><index>[<expr><name>ZSKIPLIST_MAXLEVEL</name></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>traversed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>removed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>traversed</name> <operator>+</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name><operator>)</operator> <operator>&lt;</operator> <name>start</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>traversed</name> <operator>+=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>update</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>traversed</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <name>traversed</name> <operator>&lt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zslDeleteNode</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>x</name></expr></argument>,<argument><expr><name>update</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictDelete</name><argument_list>(<argument><expr><name>dict</name></expr></argument>,<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>removed</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>traversed</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>removed</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>long</name></type> <name>zslGetRank</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>rank</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>&lt;</operator> <name>score</name> <operator>||</operator>
<operator>(</operator><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>score</name></name> <operator>==</operator> <name>score</name> <operator>&amp;&amp;</operator>
<call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rank</name> <operator>+=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name> <operator>&amp;&amp;</operator> <name><name>x</name><operator>-&gt;</operator><name>score</name></name> <operator>==</operator> <name>score</name> <operator>&amp;&amp;</operator> <call><name>sdscmp</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><name>rank</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>zskiplistNode</name><modifier>*</modifier></type> <name>zslGetElementByRank</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>rank</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>traversed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>traversed</name> <operator>+</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name><operator>)</operator> <operator>&lt;=</operator> <name>rank</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>traversed</name> <operator>+=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>span</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>traversed</name> <operator>==</operator> <name>rank</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zslParseRange</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>max</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>minex</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>maxex</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>min</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>min</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>min</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>min</name><operator>-&gt;</operator><name>ptr</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>eptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>minex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>min</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>eptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>max</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name><name>max</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>max</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>max</name><operator>-&gt;</operator><name>ptr</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>eptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>maxex</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>max</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>eptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zslParseLexRangeItem</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>sds</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ex</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>ex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>maxstring</name></name></expr>;</expr_stmt>
<return>return <expr><name>C_OK</name></expr>;</return>
<case>case <expr><literal type="char">'-'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>ex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>minstring</name></name></expr>;</expr_stmt>
<return>return <expr><name>C_OK</name></expr>;</return>
<case>case <expr><literal type="char">'('</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>ex</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>C_OK</name></expr>;</return>
<case>case <expr><literal type="char">'['</literal></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>ex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>c</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>C_OK</name></expr>;</return>
<default>default:</default>
<return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zslFreeLexRange</name><parameter_list>(<parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name> <operator>!=</operator> <name><name>shared</name><operator>.</operator><name>minstring</name></name> <operator>&amp;&amp;</operator>
<name><name>spec</name><operator>-&gt;</operator><name>min</name></name> <operator>!=</operator> <name><name>shared</name><operator>.</operator><name>maxstring</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name> <operator>!=</operator> <name><name>shared</name><operator>.</operator><name>minstring</name></name> <operator>&amp;&amp;</operator>
<name><name>spec</name><operator>-&gt;</operator><name>max</name></name> <operator>!=</operator> <name><name>shared</name><operator>.</operator><name>maxstring</name></name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zslParseLexRange</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>max</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>min</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name> <operator>||</operator>
<name><name>max</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INT</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name><name>spec</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>zslParseLexRangeItem</name><argument_list>(<argument><expr><name>min</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>min</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>minex</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name> <operator>||</operator>
<call><name>zslParseLexRangeItem</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>max</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>spec</name><operator>-&gt;</operator><name>maxex</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>sdscmplex</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name><name>shared</name><operator>.</operator><name>minstring</name></name> <operator>||</operator> <name>b</name> <operator>==</operator> <name><name>shared</name><operator>.</operator><name>maxstring</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name><name>shared</name><operator>.</operator><name>maxstring</name></name> <operator>||</operator> <name>b</name> <operator>==</operator> <name><name>shared</name><operator>.</operator><name>minstring</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>sdscmp</name><argument_list>(<argument><expr><name>a</name></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zslLexValueGteMin</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name><name>spec</name><operator>-&gt;</operator><name>minex</name></name></expr> ?</condition><then>
<expr><operator>(</operator><call><name>sdscmplex</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr> </then><else>:
<expr><operator>(</operator><call><name>sdscmplex</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zslLexValueLteMax</name><parameter_list>(<parameter><decl><type><name>sds</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name><name>spec</name><operator>-&gt;</operator><name>maxex</name></name></expr> ?</condition><then>
<expr><operator>(</operator><call><name>sdscmplex</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> </then><else>:
<expr><operator>(</operator><call><name>sdscmplex</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zslIsInLexRange</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>sdscmplex</name><argument_list>(<argument><expr><name><name>range</name><operator>-&gt;</operator><name>min</name></name></expr></argument>,<argument><expr><name><name>range</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>minex</name></name> <operator>||</operator> <name><name>range</name><operator>-&gt;</operator><name>maxex</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>zslLexValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>zslLexValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslFirstInLexRange</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslIsInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>zslLexValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></for>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>x</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslLexValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zslLastInLexRange</name><parameter_list>(<parameter><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslIsInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>level</name></name><operator>-</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name> <operator>&amp;&amp;</operator>
<call><name>zslLexValueLteMax</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>forward</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>level</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></for>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>x</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslLexValueGteMin</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>double</name></type> <name>zzlStrtod</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>vlen</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>vlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>vlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><call><name>strtod</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>double</name></type> <name>zzlGetScore</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>vlong</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vstr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlStrtod</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>score</name> <operator>=</operator> <name>vlong</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>score</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>sds</name></type> <name>lpGetObject</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>vlong</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vstr</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>vlong</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zzlCompareElements</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cstr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>clen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>vlong</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>vbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>minlen</name></decl>, <decl><type ref="prev"/><name>cmp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>vlen</name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>vbuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <name>vbuf</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>minlen</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>vlen</name> <operator>&lt;</operator> <name>clen</name><operator>)</operator></expr> ?</condition><then> <expr><name>vlen</name></expr> </then><else>: <expr><name>clen</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>,<argument><expr><name>cstr</name></expr></argument>,<argument><expr><name>minlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>vlen</name><operator>-</operator><name>clen</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>cmp</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>int</name></type> <name>zzlLength</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>lpLength</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call><operator>/</operator><literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zzlNext</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>_eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>_sptr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>*</operator><name>eptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>_eptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>*</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>_eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>_sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>_eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>_sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>_sptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>eptr</name> <operator>=</operator> <name>_eptr</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>sptr</name> <operator>=</operator> <name>_sptr</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zzlPrev</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>eptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>_eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>_sptr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>*</operator><name>eptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>_sptr</name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>*</operator><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>_sptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>_eptr</name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>_sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>_eptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>_eptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>eptr</name> <operator>=</operator> <name>_eptr</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>sptr</name> <operator>=</operator> <name>_sptr</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zzlIsInRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>range</name><operator>-&gt;</operator><name>min</name></name> <operator>&gt;</operator> <name><name>range</name><operator>-&gt;</operator><name>max</name></name> <operator>||</operator>
<operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>min</name></name> <operator>==</operator> <name><name>range</name><operator>-&gt;</operator><name>max</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>minex</name></name> <operator>||</operator> <name><name>range</name><operator>-&gt;</operator><name>maxex</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlFirstInRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlIsInRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>eptr</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlLastInRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlIsInRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>eptr</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>(</operator><name>eptr</name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>sptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zzlLexValueGteMin</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>sds</name></type> <name>value</name> <init>= <expr><call><name>lpGetObject</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>zslLexValueGteMin</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zzlLexValueLteMax</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>sds</name></type> <name>value</name> <init>= <expr><call><name>lpGetObject</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>zslLexValueLteMax</name><argument_list>(<argument><expr><name>value</name></expr></argument>,<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zzlIsInLexRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>sdscmplex</name><argument_list>(<argument><expr><name><name>range</name><operator>-&gt;</operator><name>min</name></name></expr></argument>,<argument><expr><name><name>range</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>cmp</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>range</name><operator>-&gt;</operator><name>minex</name></name> <operator>||</operator> <name><name>range</name><operator>-&gt;</operator><name>maxex</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlLexValueGteMin</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlFirstInLexRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlIsInLexRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zzlLexValueGteMin</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>eptr</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlLastInLexRange</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlIsInLexRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zzlLexValueGteMin</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>eptr</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>(</operator><name>eptr</name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>sptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlFind</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>score</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eptr</name> <operator>=</operator> <call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>lpFind</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>eptr</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>ele</name></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eptr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>score</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>eptr</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlDelete</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>lpDeleteRangeWithEntry</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlInsertAt</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>scorebuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scorelen</name></decl>;</decl_stmt>
<expr_stmt><expr><name>scorelen</name> <operator>=</operator> <call><name>d2string</name><argument_list>(<argument><expr><name>scorebuf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>scorebuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>scorebuf</name></expr></argument>,<argument><expr><name>scorelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>lpInsertString</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>LP_BEFORE</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>lpInsertString</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>scorebuf</name></expr></argument>,<argument><expr><name>scorelen</name></expr></argument>,<argument><expr><name>sptr</name></expr></argument>,<argument><expr><name>LP_AFTER</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlInsert</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name> <init>= <expr><call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>s</name></decl>;</decl_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <name>score</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>zzlInsertAt</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>s</name> <operator>==</operator> <name>score</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zzlCompareElements</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>zzlInsertAt</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>zzlInsertAt</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlDeleteRangeByScore</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>deleted</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>deleted</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlFirstInRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>zl</name></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>lpDeleteRangeWithEntry</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>deleted</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlDeleteRangeByLex</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>deleted</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>deleted</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlFirstInLexRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>zl</name></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>lpDeleteRangeWithEntry</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>deleted</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zzlDeleteRangeByRank</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>deleted</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>num</name> <init>= <expr><operator>(</operator><name>end</name><operator>-</operator><name>start</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>lpDeleteRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">2</literal><operator>*</operator><operator>(</operator><name>start</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>,<argument><expr><literal type="number">2</literal><operator>*</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>zl</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>long</name></type> <name>zsetLength</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>zzlLength</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>zset</name><operator>*</operator><operator>)</operator><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name><operator>)</operator><operator>-&gt;</operator><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>length</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zsetConvert</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>encoding</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>node</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>encoding</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>vlong</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>!=</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown target encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>zs</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>zs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name> <operator>=</operator> <call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zsetDictType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name> <operator>=</operator> <call><name>zslCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>zslInsert</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>zs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><call><name>lpNew</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>!=</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown target encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>zs</name> <operator>=</operator> <name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>zs</name><operator>-&gt;</operator><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name><operator>-&gt;</operator><name>header</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>zzlInsertAt</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name><name>node</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zslFreeNode</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>zs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>zl</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zsetConvertToListpackIfNeeded</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxelelen</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>totelelen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zset</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zset</name><operator>-&gt;</operator><name>zsl</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;=</operator> <name><name>server</name><operator>.</operator><name>zset_max_listpack_entries</name></name> <operator>&amp;&amp;</operator>
<name>maxelelen</name> <operator>&lt;=</operator> <name><name>server</name><operator>.</operator><name>zset_max_listpack_value</name></name> <operator>&amp;&amp;</operator>
<call><name>lpSafeToAdd</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>totelelen</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>zsetConvert</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ENCODING_LISTPACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zsetScore</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>member</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>score</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>zobj</name> <operator>||</operator> <operator>!</operator><name>member</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zzlFind</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>member</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictFind</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>, <argument><expr><name>member</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>de</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zsetAdd</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>in_flags</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>out_flags</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>newscore</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>incr</name> <init>= <expr><operator>(</operator><name>in_flags</name> <operator>&amp;</operator> <name>ZADD_IN_INCR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nx</name> <init>= <expr><operator>(</operator><name>in_flags</name> <operator>&amp;</operator> <name>ZADD_IN_NX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>xx</name> <init>= <expr><operator>(</operator><name>in_flags</name> <operator>&amp;</operator> <name>ZADD_IN_XX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>gt</name> <init>= <expr><operator>(</operator><name>in_flags</name> <operator>&amp;</operator> <name>ZADD_IN_GT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lt</name> <init>= <expr><operator>(</operator><name>in_flags</name> <operator>&amp;</operator> <name>ZADD_IN_LT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>curscore</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>=</operator> <name>ZADD_OUT_NAN</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eptr</name> <operator>=</operator> <call><name>zzlFind</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>curscore</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>|=</operator> <name>ZADD_OUT_NOP</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>incr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>curscore</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>|=</operator> <name>ZADD_OUT_NAN</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lt</name> <operator>&amp;&amp;</operator> <name>score</name> <operator>&gt;=</operator> <name>curscore</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>gt</name> <operator>&amp;&amp;</operator> <name>score</name> <operator>&lt;=</operator> <name>curscore</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>|=</operator> <name>ZADD_OUT_NOP</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>newscore</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>newscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>score</name> <operator>!=</operator> <name>curscore</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlDelete</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlInsert</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>|=</operator> <name>ZADD_OUT_UPDATED</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>xx</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zzlLength</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>zset_max_listpack_entries</name></name> <operator>||</operator>
<call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>server</name><operator>.</operator><name>zset_max_listpack_value</name></name> <operator>||</operator>
<operator>!</operator><call><name>lpSafeToAdd</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>zsetConvert</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ENCODING_SKIPLIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlInsert</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>newscore</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>newscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>|=</operator> <name>ZADD_OUT_ADDED</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>|=</operator> <name>ZADD_OUT_NOP</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>znode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
<expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>de</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>nx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>|=</operator> <name>ZADD_OUT_NOP</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>curscore</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>incr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>curscore</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>|=</operator> <name>ZADD_OUT_NAN</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lt</name> <operator>&amp;&amp;</operator> <name>score</name> <operator>&gt;=</operator> <name>curscore</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>gt</name> <operator>&amp;&amp;</operator> <name>score</name> <operator>&lt;=</operator> <name>curscore</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>|=</operator> <name>ZADD_OUT_NOP</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>newscore</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>newscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>score</name> <operator>!=</operator> <name>curscore</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>znode</name> <operator>=</operator> <call><name>zslUpdateScore</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>curscore</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call> <operator>=</operator> <operator>&amp;</operator><name><name>znode</name><operator>-&gt;</operator><name>score</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>|=</operator> <name>ZADD_OUT_UPDATED</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>xx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>sdsdup</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>znode</name> <operator>=</operator> <call><name>zslInsert</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>znode</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>DICT_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>|=</operator> <name>ZADD_OUT_ADDED</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>newscore</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>newscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>out_flags</name> <operator>|=</operator> <name>ZADD_OUT_NOP</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zsetRemoveFromSkiplist</name><parameter_list>(<parameter><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictUnlink</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>de</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>score</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictFreeUnlinkedEntry</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>zslDelete</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zsetDel</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eptr</name> <operator>=</operator> <call><name>zzlFind</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlDelete</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>zsetRemoveFromSkiplist</name><argument_list>(<argument><expr><name>zs</name></expr></argument>, <argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>htNeedsResize</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dictResize</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>long</name></type> <name>zsetRank</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>ele</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>llen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>rank</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llen</name> <operator>=</operator> <call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rank</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while<condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>lpCompare</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rank</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>llen</name><operator>-</operator><name>rank</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>rank</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>de</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>score</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>zslGetRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>rank</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>llen</name><operator>-</operator><name>rank</name></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><name>rank</name><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>robj</name> <modifier>*</modifier></type><name>zsetDup</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>new_zs</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><call><name>lpBytes</name><argument_list>(<argument><expr><name>zl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>new_zl</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_zl</name></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zobj</name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_ZSET</name></expr></argument>, <argument><expr><name>new_zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>=</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>zobj</name> <operator>=</operator> <call><name>createZsetObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zs</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_zs</name> <operator>=</operator> <name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictExpand</name><argument_list>(<argument><expr><name><name>new_zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>llen</name> <init>= <expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>llen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>new_ele</name> <init>= <expr><call><name>sdsdup</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>znode</name> <init>= <expr><call><name>zslInsert</name><argument_list>(<argument><expr><name><name>new_zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>new_ele</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>new_zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>new_ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>znode</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>zobj</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>sds</name></type> <name>zsetSdsFromListpackEntry</name><parameter_list>(<parameter><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><name><name>e</name><operator>-&gt;</operator><name>sval</name></name></expr> ?</condition><then> <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>sval</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>slen</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>lval</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zsetReplyFromListpackEntry</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>-&gt;</operator><name>sval</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>sval</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>slen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>lval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zsetTypeRandomElement</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zsetobj</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>zsetsize</name></decl></parameter>, <parameter><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>score</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zsetobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zsetobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictGetFairRandomKey</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>s</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>sval</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>slen</name></name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>score</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zsetobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>listpackEntry</name></type> <name>val</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lpRandomPair</name><argument_list>(<argument><expr><name><name>zsetobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>zsetsize</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>score</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>.</operator><name>sval</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <call><name>zzlStrtod</name><argument_list>(<argument><expr><name><name>val</name><operator>.</operator><name>sval</name></name></expr></argument>,<argument><expr><name><name>val</name><operator>.</operator><name>slen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator><name><name>val</name><operator>.</operator><name>lval</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown zset encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zaddGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>nanerr</name> <init>= <expr><literal type="string">"resulting score is not a number (NaN)"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>scores</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>elements</name></decl>, <decl><type ref="prev"/><name>ch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scoreidx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>added</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>updated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>processed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>scoreidx</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<while>while<condition>(<expr><name>scoreidx</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>scoreidx</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"nx"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ZADD_IN_NX</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"xx"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ZADD_IN_XX</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"ch"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>ch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"incr"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ZADD_IN_INCR</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"gt"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ZADD_IN_GT</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"lt"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>ZADD_IN_LT</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content> <break>break;</break></block_content></block></else></if_stmt>
<expr_stmt><expr><name>scoreidx</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<decl_stmt><decl><type><name>int</name></type> <name>incr</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ZADD_IN_INCR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nx</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ZADD_IN_NX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>xx</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ZADD_IN_XX</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>gt</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ZADD_IN_GT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lt</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>ZADD_IN_LT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>elements</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>scoreidx</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elements</name> <operator>%</operator> <literal type="number">2</literal> <operator>||</operator> <operator>!</operator><name>elements</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>elements</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nx</name> <operator>&amp;&amp;</operator> <name>xx</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
<argument><expr><literal type="string">"XX and NX options at the same time are not compatible"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>gt</name> <operator>&amp;&amp;</operator> <name>nx</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>lt</name> <operator>&amp;&amp;</operator> <name>nx</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>gt</name> <operator>&amp;&amp;</operator> <name>lt</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
<argument><expr><literal type="string">"GT, LT, and/or NX options at the same time are not compatible"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>incr</name> <operator>&amp;&amp;</operator> <name>elements</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
<argument><expr><literal type="string">"INCR option supports a single increment-element pair"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>scores</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>elements</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getDoubleFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>scoreidx</name><operator>+</operator><name>j</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>scores</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>zobj</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>zobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>xx</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>reply_to_client</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>zset_max_listpack_entries</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
<name><name>server</name><operator>.</operator><name>zset_max_listpack_value</name></name> <operator>&lt;</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>scoreidx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>zobj</name> <operator>=</operator> <call><name>createZsetObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>zobj</name> <operator>=</operator> <call><name>createZsetListpackObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>elements</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>newscore</name></decl>;</decl_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <name><name>scores</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>scoreidx</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><name>j</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>zsetAdd</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>score</name></expr></argument>, <argument><expr><name>ele</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retflags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newscore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>nanerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>retflags</name> <operator>&amp;</operator> <name>ZADD_OUT_ADDED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>added</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>retflags</name> <operator>&amp;</operator> <name>ZADD_OUT_UPDATED</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>updated</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>retflags</name> <operator>&amp;</operator> <name>ZADD_OUT_NOP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>processed</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <name>newscore</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <operator>(</operator><name>added</name><operator>+</operator><name>updated</name><operator>)</operator></expr>;</expr_stmt>
<label><name>reply_to_client</name>:</label>
<if_stmt><if>if <condition>(<expr><name>incr</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>processed</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyNull</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><name>ch</name></expr> ?</condition><then> <expr><name>added</name><operator>+</operator><name>updated</name></expr> </then><else>: <expr><name>added</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>scores</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>added</name> <operator>||</operator> <name>updated</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_ZSET</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>incr</name></expr> ?</condition><then> <expr><literal type="string">"zincr"</literal></expr> </then><else>: <expr><literal type="string">"zadd"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zaddCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zaddGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ZADD_IN_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zincrbyCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zaddGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ZADD_IN_INCR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zremCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>keyremoved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zsetDel</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>deleted</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>keyremoved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_ZSET</name></expr></argument>,<argument><expr><literal type="string">"zrem"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>keyremoved</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>deleted</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<typedef>typedef <type><enum>enum <block>{
<decl><name>ZRANGE_AUTO</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>ZRANGE_RANK</name></decl>,
<decl><name>ZRANGE_SCORE</name></decl>,
<decl><name>ZRANGE_LEX</name></decl>,
}</block></enum></type> <name>zrange_type</name>;</typedef>
<function><type><name>void</name></type> <name>zremrangeGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>zrange_type</name></type> <name>rangetype</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>keyremoved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zrangespec</name></type> <name>range</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zlexrangespec</name></type> <name>lexrange</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>, <decl><type ref="prev"/><name>llen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>notify_type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_RANK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>notify_type</name> <operator>=</operator> <literal type="string">"zremrangebyrank"</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_SCORE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>notify_type</name> <operator>=</operator> <literal type="string">"zremrangebyscore"</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>zslParseRange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"min or max is not a float"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_LEX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>notify_type</name> <operator>=</operator> <literal type="string">"zremrangebylex"</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>zslParseLexRange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lexrange</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"min or max not valid string range item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"unknown rangetype %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>rangetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_RANK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>llen</name> <operator>=</operator> <call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <name>llen</name><operator>+</operator><name>start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name> <operator>=</operator> <name>llen</name><operator>+</operator><name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name>end</name> <operator>||</operator> <name>start</name> <operator>&gt;=</operator> <name>llen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;=</operator> <name>llen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name> <operator>=</operator> <name>llen</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<switch>switch<condition>(<expr><name>rangetype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ZRANGE_AUTO</name></expr>:</case>
<case>case <expr><name>ZRANGE_RANK</name></expr>:</case>
<expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlDeleteRangeByRank</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>start</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>end</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ZRANGE_SCORE</name></expr>:</case>
<expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlDeleteRangeByScore</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ZRANGE_LEX</name></expr>:</case>
<expr_stmt><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>zzlDeleteRangeByLex</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lexrange</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><call><name>zzlLength</name><argument_list>(<argument><expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>keyremoved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<switch>switch<condition>(<expr><name>rangetype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ZRANGE_AUTO</name></expr>:</case>
<case>case <expr><name>ZRANGE_RANK</name></expr>:</case>
<expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>zslDeleteRangeByRank</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>start</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>end</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ZRANGE_SCORE</name></expr>:</case>
<expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>zslDeleteRangeByScore</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>,<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ZRANGE_LEX</name></expr>:</case>
<expr_stmt><expr><name>deleted</name> <operator>=</operator> <call><name>zslDeleteRangeByLex</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lexrange</name></expr></argument>,<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><call><name>htNeedsResize</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dictResize</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dictSize</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>keyremoved</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_ZSET</name></expr></argument>,<argument><expr><name>notify_type</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>keyremoved</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>deleted</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
<if_stmt><if>if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_LEX</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexrange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zremrangebyrankCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zremrangeGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ZRANGE_RANK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zremrangebyscoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zremrangeGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ZRANGE_SCORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zremrangebylexCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zremrangeGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ZRANGE_LEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>subject</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>weight</name></decl>;</decl_stmt>
<union>union <block>{
<union>union <name>_iterset</name> <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>intset</name> <modifier>*</modifier></type><name>is</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ii</name></decl>;</decl_stmt>
}</block> <decl><name>is</name></decl>;</struct>
<struct>struct <block>{
<decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>dict</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
}</block> <decl><name>ht</name></decl>;</struct>
}</block> <decl><name>set</name></decl>;</union>
<union>union <name>_iterzset</name> <block>{
<struct>struct <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <modifier>*</modifier><name>sptr</name>;</decl_stmt>
}</block> <decl><name>zl</name></decl>;</struct>
<struct>struct <block>{
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
}</block> <decl><name>sl</name></decl>;</struct>
}</block> <decl><name>zset</name></decl>;</union>
}</block> <decl><name>iter</name></decl>;</union>
}</block></struct></type> <name>zsetopsrc</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPVAL_DIRTY_SDS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPVAL_DIRTY_LL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPVAL_VALID_LL</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>_buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>estr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>elen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>ell</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
}</block></struct></type> <name>zsetopval</name>;</typedef>
<typedef>typedef <type><name><name>union</name> <name>_iterset</name></name></type> <name>iterset</name>;</typedef>
<typedef>typedef <type><name><name>union</name> <name>_iterzset</name></name></type> <name>iterzset</name>;</typedef>
<function><type><name>void</name></type> <name>zuiInitIterator</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>subject</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>iterset</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>iter</name><operator>.</operator><name>set</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>is</name><operator>.</operator><name>is</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>is</name><operator>.</operator><name>ii</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>dict</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>di</name></name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>de</name></name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>di</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>iterzset</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>iter</name><operator>.</operator><name>zset</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>zl</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>eptr</name></name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>zl</name></name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>eptr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>sptr</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>zl</name></name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>eptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>sptr</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>zs</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>zs</name><operator>-&gt;</operator><name>zsl</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zuiClearIterator</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>subject</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>iterset</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>iter</name><operator>.</operator><name>set</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>di</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>iterzset</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>iter</name><operator>.</operator><name>zset</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zuiDiscardDirtyValue</name><parameter_list>(<parameter><decl><type><name>zsetopval</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>OPVAL_DIRTY_SDS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>OPVAL_DIRTY_SDS</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>long</name></type> <name>zuiLength</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>subject</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>intsetLen</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>dictSize</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>zzlLength</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name><operator>-&gt;</operator><name>length</name></name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zuiNext</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>zsetopval</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>subject</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>zuiDiscardDirtyValue</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>val</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zsetopval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>iterset</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>iter</name><operator>.</operator><name>set</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>ell</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>intsetGet</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>is</name><operator>.</operator><name>is</name></name></expr></argument>,<argument><expr><name><name>it</name><operator>-&gt;</operator><name>is</name><operator>.</operator><name>ii</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ell</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>ell</name></name> <operator>=</operator> <name>ell</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>is</name><operator>.</operator><name>ii</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>de</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <call><name>dictGetKey</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>de</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>de</name></name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>ht</name><operator>.</operator><name>di</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>iterzset</name> <modifier>*</modifier></type><name>it</name> <init>= <expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>iter</name><operator>.</operator><name>zset</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>eptr</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>sptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>estr</name></name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>eptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>elen</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>sptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zzlPrev</name><argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>zl</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>eptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>it</name><operator>-&gt;</operator><name>zl</name><operator>.</operator><name>sptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>node</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>node</name><operator>-&gt;</operator><name>ele</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>score</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>node</name><operator>-&gt;</operator><name>score</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>node</name></name> <operator>=</operator> <name><name>it</name><operator>-&gt;</operator><name>sl</name><operator>.</operator><name>node</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zuiLongLongFromValue</name><parameter_list>(<parameter><decl><type><name>zsetopval</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>OPVAL_DIRTY_LL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>OPVAL_DIRTY_LL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>string2ll</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>OPVAL_VALID_LL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>estr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>string2ll</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>val</name><operator>-&gt;</operator><name>estr</name></name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>elen</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>OPVAL_VALID_LL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>OPVAL_VALID_LL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>OPVAL_VALID_LL</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>sds</name></type> <name>zuiSdsFromValue</name><parameter_list>(<parameter><decl><type><name>zsetopval</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>estr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>val</name><operator>-&gt;</operator><name>estr</name></name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>elen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>OPVAL_DIRTY_SDS</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>sds</name></type> <name>zuiNewSdsFromValue</name><parameter_list>(<parameter><decl><type><name>zsetopval</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>OPVAL_DIRTY_SDS</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>sds</name></type> <name>ele</name> <init>= <expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>OPVAL_DIRTY_SDS</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>ele</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>sdsdup</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>estr</name></name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>val</name><operator>-&gt;</operator><name>estr</name></name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>elen</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zuiBufferFromValue</name><parameter_list>(<parameter><decl><type><name>zsetopval</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>estr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>elen</name></name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>estr</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>elen</name></name> <operator>=</operator> <call><name>ll2string</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>val</name><operator>-&gt;</operator><name>_buf</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>_buf</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>estr</name></name> <operator>=</operator> <name><name>val</name><operator>-&gt;</operator><name>_buf</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zuiFind</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>zsetopval</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>score</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>subject</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_INTSET</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zuiLongLongFromValue</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<call><name>intsetFind</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ell</name></name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_HT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zuiSdsFromValue</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dictFind</name><argument_list>(<argument><expr><name>ht</name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_ZSET</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zuiSdsFromValue</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zzlFind</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictFind</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name><name>val</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>score</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unsupported type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>zuiCompareByCardinality</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>first</name> <init>= <expr><call><name>zuiLength</name><argument_list>(<argument><expr><operator>(</operator><name>zsetopsrc</name><operator>*</operator><operator>)</operator><name>s1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>second</name> <init>= <expr><call><name>zuiLength</name><argument_list>(<argument><expr><operator>(</operator><name>zsetopsrc</name><operator>*</operator><operator>)</operator><name>s2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>first</name> <operator>&gt;</operator> <name>second</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>first</name> <operator>&lt;</operator> <name>second</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zuiCompareByRevCardinality</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>zuiCompareByCardinality</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_AGGR_SUM</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_AGGR_MIN</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIS_AGGR_MAX</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zunionInterDictValue</name><parameter_list>(<parameter><type><name>_e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(dictGetVal(_e) == NULL ? 1.0 : *(double*)dictGetVal(_e))</cpp:value></cpp:define>
<function><type><specifier>inline</specifier> <specifier>static</specifier> <name>void</name></type> <name>zunionInterAggregate</name><parameter_list>(<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>target</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>aggregate</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>aggregate</name> <operator>==</operator> <name>REDIS_AGGR_SUM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <operator>*</operator><name>target</name> <operator>+</operator> <name>val</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><operator>*</operator><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>aggregate</name> <operator>==</operator> <name>REDIS_AGGR_MIN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <ternary><condition><expr><name>val</name> <operator>&lt;</operator> <operator>*</operator><name>target</name></expr> ?</condition><then> <expr><name>val</name></expr> </then><else>: <expr><operator>*</operator><name>target</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>aggregate</name> <operator>==</operator> <name>REDIS_AGGR_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>target</name> <operator>=</operator> <ternary><condition><expr><name>val</name> <operator>&gt;</operator> <operator>*</operator><name>target</name></expr> ?</condition><then> <expr><name>val</name></expr> </then><else>: <expr><operator>*</operator><name>target</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown ZUNION/INTER aggregate type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>zsetDictGetMaxElementLength</name><parameter_list>(<parameter><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>totallen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>maxelelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>sds</name></type> <name>ele</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxelelen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxelelen</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>totallen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>totallen</name><operator>)</operator> <operator>+=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>maxelelen</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zdiffAlgorithm1</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>setnum</name></decl></parameter>, <parameter><decl><type><name>zset</name> <modifier>*</modifier></type><name>dstzset</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>maxelelen</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>totelelen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zsetopval</name></type> <name>zval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>znode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>tmp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>src</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>setnum</name><operator>-</operator><literal type="number">1</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zsetopsrc</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zuiCompareByRevCardinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zuiInitIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>zuiNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>exists</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>src</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>subject</name> <operator>==</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>subject</name> <operator>||</operator>
<call><name>zuiFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>exists</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>zuiNewSdsFromValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>znode</name> <operator>=</operator> <call><name>zslInsert</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name><name>zval</name><operator>.</operator><name>score</name></name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>znode</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <operator>*</operator><name>maxelelen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>maxelelen</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>totelelen</name><operator>)</operator> <operator>+=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>zuiClearIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zdiffAlgorithm2</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>setnum</name></decl></parameter>, <parameter><decl><type><name>zset</name> <modifier>*</modifier></type><name>dstzset</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>maxelelen</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>totelelen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cardinality</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zsetopval</name></type> <name>zval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>znode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>tmp</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zuiLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zuiInitIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>zuiNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>zuiNewSdsFromValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>znode</name> <operator>=</operator> <call><name>zslInsert</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name><name>zval</name><operator>.</operator><name>score</name></name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>znode</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cardinality</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>zuiSdsFromValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>zsetRemoveFromSkiplist</name><argument_list>(<argument><expr><name>dstzset</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cardinality</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cardinality</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>zuiClearIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cardinality</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>htNeedsResize</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>dictResize</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>maxelelen</name> <operator>=</operator> <call><name>zsetDictGetMaxElementLength</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>, <argument><expr><name>totelelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>zsetChooseDiffAlgorithm</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>setnum</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>algo_one_work</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>algo_two_work</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>subject</name> <operator>==</operator> <name><name>src</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>subject</name></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>algo_one_work</name> <operator>+=</operator> <call><name>zuiLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>algo_two_work</name> <operator>+=</operator> <call><name>zuiLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>algo_one_work</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>algo_one_work</name> <operator>&lt;=</operator> <name>algo_two_work</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zdiff</name><parameter_list>(<parameter><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>setnum</name></decl></parameter>, <parameter><decl><type><name>zset</name> <modifier>*</modifier></type><name>dstzset</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>maxelelen</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>totelelen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zuiLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>diff_algo</name> <init>= <expr><call><name>zsetChooseDiffAlgorithm</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>setnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>diff_algo</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zdiffAlgorithm1</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>setnum</name></expr></argument>, <argument><expr><name>dstzset</name></expr></argument>, <argument><expr><name>maxelelen</name></expr></argument>, <argument><expr><name>totelelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>diff_algo</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zdiffAlgorithm2</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>setnum</name></expr></argument>, <argument><expr><name>dstzset</name></expr></argument>, <argument><expr><name>maxelelen</name></expr></argument>, <argument><expr><name>totelelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>diff_algo</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown algorithm"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<decl_stmt><decl><type><name>dictType</name></type> <name>setAccumulatorDictType</name> <init>= <expr><block>{
<expr><name>dictSdsHash</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>dictSdsKeyCompare</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>void</name></type> <name>zunionInterDiffGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>dstkey</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numkeysIndex</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>cardinality_only</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>setnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>aggregate</name> <init>= <expr><name>REDIS_AGGR_SUM</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zsetopsrc</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zsetopval</name></type> <name>zval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>maxelelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>totelelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>dstobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>dstzset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>znode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>withscores</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>cardinality</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>limit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>numkeysIndex</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>setnum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>setnum</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
<argument><expr><literal type="string">"at least 1 input key is needed for '%s' command"</literal></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name><operator>-&gt;</operator><name>fullname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>setnum</name> <operator>&gt;</operator> <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><operator>(</operator><name>numkeysIndex</name><operator>+</operator><literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>src</name> <operator>=</operator> <call><name>zcalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zsetopsrc</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>setnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <name>numkeysIndex</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_ZSET</name> <operator>&amp;&amp;</operator> <name><name>obj</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>OBJ_SET</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>wrongtypeerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subject</name> <operator>=</operator> <name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>encoding</name> <operator>=</operator> <name><name>obj</name><operator>-&gt;</operator><name>encoding</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>subject</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>remaining</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <name>j</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>remaining</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>SET_OP_DIFF</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cardinality_only</name> <operator>&amp;&amp;</operator>
<name>remaining</name> <operator>&gt;=</operator> <operator>(</operator><name>setnum</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"weights"</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>remaining</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getDoubleFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name></expr></argument>,
<argument><expr><literal type="string">"weight value is not a float"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>!=</operator> <name>SET_OP_DIFF</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cardinality_only</name> <operator>&amp;&amp;</operator>
<name>remaining</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"aggregate"</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"sum"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>aggregate</name> <operator>=</operator> <name>REDIS_AGGR_SUM</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"min"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>aggregate</name> <operator>=</operator> <name>REDIS_AGGR_MIN</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"max"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>aggregate</name> <operator>=</operator> <name>REDIS_AGGR_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>remaining</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><name>dstkey</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cardinality_only</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"withscores"</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>withscores</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cardinality_only</name> <operator>&amp;&amp;</operator> <name>remaining</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"limit"</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getPositiveLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>limit</name></expr></argument>,
<argument><expr><literal type="string">"LIMIT can't be negative"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt> <expr_stmt><expr><name>remaining</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>!=</operator> <name>SET_OP_DIFF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>src</name></expr></argument>,<argument><expr><name>setnum</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zsetopsrc</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>zuiCompareByCardinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dstobj</name> <operator>=</operator> <call><name>createZsetObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dstzset</name> <operator>=</operator> <name><name>dstobj</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>SET_OP_INTER</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zuiLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zuiInitIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>zuiNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>, <decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>weight</name> <operator>*</operator> <name><name>zval</name><operator>.</operator><name>score</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>src</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>subject</name> <operator>==</operator> <name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>subject</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>zval</name><operator>.</operator><name>score</name></name><operator>*</operator><name><name>src</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>weight</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zunionInterAggregate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>score</name></expr></argument>,<argument><expr><name>value</name></expr></argument>,<argument><expr><name>aggregate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>zuiFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>value</name> <operator>*=</operator> <name><name>src</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>weight</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zunionInterAggregate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>score</name></expr></argument>,<argument><expr><name>value</name></expr></argument>,<argument><expr><name>aggregate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>setnum</name> <operator>&amp;&amp;</operator> <name>cardinality_only</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>cardinality</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&amp;&amp;</operator> <name>cardinality</name> <operator>&gt;=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator><name>limit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zuiDiscardDirtyValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>j</name> <operator>==</operator> <name>setnum</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>zuiNewSdsFromValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>znode</name> <operator>=</operator> <call><name>zslInsert</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>tmp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>znode</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>totelelen</name> <operator>+=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxelelen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxelelen</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>zuiClearIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>SET_OP_UNION</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>accumulator</name> <init>= <expr><call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>setAccumulatorDictType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>existing</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>setnum</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dictExpand</name><argument_list>(<argument><expr><name>accumulator</name></expr></argument>,<argument><expr><call><name>zuiLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>setnum</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>setnum</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>zuiLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>zuiInitIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>zuiNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>score</name> <operator>=</operator> <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>weight</name> <operator>*</operator> <name><name>zval</name><operator>.</operator><name>score</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictAddRaw</name><argument_list>(<argument><expr><name>accumulator</name></expr></argument>,<argument><expr><call><name>zuiSdsFromValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name>existing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>existing</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>zuiNewSdsFromValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>totelelen</name> <operator>+=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>maxelelen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>maxelelen</name> <operator>=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dictSetKey</name><argument_list>(<argument><expr><name>accumulator</name></expr></argument>, <argument><expr><name>de</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictSetDoubleVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>zunionInterAggregate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>existing</name><operator>-&gt;</operator><name>v</name><operator>.</operator><name>d</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>aggregate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>zuiClearIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name>accumulator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictExpand</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><call><name>dictSize</name><argument_list>(<argument><expr><name>accumulator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>sds</name></type> <name>ele</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>dictGetDoubleVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>znode</name> <operator>=</operator> <call><name>zslInsert</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>zsl</name></name></expr></argument>,<argument><expr><name>score</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictAdd</name><argument_list>(<argument><expr><name><name>dstzset</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>znode</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name>accumulator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>op</name> <operator>==</operator> <name>SET_OP_DIFF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zdiff</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>setnum</name></expr></argument>, <argument><expr><name>dstzset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxelelen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>totelelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown operator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dstkey</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dstzset</name><operator>-&gt;</operator><name>zsl</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zsetConvertToListpackIfNeeded</name><argument_list>(<argument><expr><name>dstobj</name></expr></argument>, <argument><expr><name>maxelelen</name></expr></argument>, <argument><expr><name>totelelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>dstkey</name></expr></argument>, <argument><expr><name>dstobj</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>dstobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_ZSET</name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>op</name> <operator>==</operator> <name>SET_OP_UNION</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"zunionstore"</literal></expr> </then><else>:
<expr><operator>(</operator><ternary><condition><expr><name>op</name> <operator>==</operator> <name>SET_OP_INTER</name></expr> ?</condition><then> <expr><literal type="string">"zinterstore"</literal></expr> </then><else>: <expr><literal type="string">"zdiffstore"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>,
<argument><expr><name>dstkey</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>dstkey</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>dstkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>, <argument><expr><literal type="string">"del"</literal></expr></argument>, <argument><expr><name>dstkey</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cardinality_only</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cardinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>length</name> <init>= <expr><name><name>dstzset</name><operator>-&gt;</operator><name>zsl</name><operator>-&gt;</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>dstzset</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zn</name> <init>= <expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>resp</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>length</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<while>while <condition>(<expr><name>zn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>withscores</name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>resp</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>zn</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>zn</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>zn</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <name><name>zn</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>dstobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zunionstoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zunionInterDiffGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SET_OP_UNION</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zinterstoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zunionInterDiffGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SET_OP_INTER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zdiffstoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zunionInterDiffGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>SET_OP_DIFF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zunionCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zunionInterDiffGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SET_OP_UNION</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zinterCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zunionInterDiffGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SET_OP_INTER</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zinterCardCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zunionInterDiffGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SET_OP_INTER</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zdiffCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zunionInterDiffGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SET_OP_DIFF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<typedef>typedef <type><enum>enum <block>{
<decl><name>ZRANGE_DIRECTION_AUTO</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>ZRANGE_DIRECTION_FORWARD</name></decl>,
<decl><name>ZRANGE_DIRECTION_REVERSE</name></decl>
}</block></enum></type> <name>zrange_direction</name>;</typedef>
<typedef>typedef <type><enum>enum <block>{
<decl><name>ZRANGE_CONSUMER_TYPE_CLIENT</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>ZRANGE_CONSUMER_TYPE_INTERNAL</name></decl>
}</block></enum></type> <name>zrange_consumer_type</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>zrange_result_handler</name></name></type> <name>zrange_result_handler</name>;</typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>zrangeResultBeginFunction</name>)<parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>zrangeResultFinalizeFunction</name>)<parameter_list>(
<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>result_count</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>zrangeResultEmitCBufferFunction</name>)<parameter_list>(
<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>zrangeResultEmitLongLongFunction</name>)<parameter_list>(
<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name></type> <name>ll</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function_decl><type><name>void</name></type> <name>zrangeGenericCommand</name> <parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc_start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>store</name></decl></parameter>,
<parameter><decl><type><name>zrange_type</name></type> <name>rangetype</name></decl></parameter>, <parameter><decl><type><name>zrange_direction</name></type> <name>direction</name></decl></parameter>)</parameter_list>;</function_decl>
<struct>struct <name>zrange_result_handler</name> <block>{
<decl_stmt><decl><type><name>zrange_consumer_type</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>client</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>dstkey</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>dstobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>userdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>withscores</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>should_emit_array_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zrangeResultBeginFunction</name></type> <name>beginResultEmission</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zrangeResultFinalizeFunction</name></type> <name>finalizeResultEmission</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zrangeResultEmitCBufferFunction</name></type> <name>emitResultFromCBuffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zrangeResultEmitLongLongFunction</name></type> <name>emitResultFromLongLong</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zrangeResultBeginClient</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>userdata</name></name> <operator>=</operator> <call><name>addReplyDeferredLen</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zrangeResultEmitCBufferToClient</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>value_length_in_bytes</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>handler</name><operator>-&gt;</operator><name>should_emit_array_length</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>value_length_in_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>handler</name><operator>-&gt;</operator><name>withscores</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zrangeResultEmitLongLongToClient</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>,
<parameter><decl><type><name>long</name> <name>long</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>handler</name><operator>-&gt;</operator><name>should_emit_array_length</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>handler</name><operator>-&gt;</operator><name>withscores</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zrangeResultFinalizeClient</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>result_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>handler</name><operator>-&gt;</operator><name>withscores</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>handler</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>resp</name></name> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result_count</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>setDeferredArrayLen</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><name><name>handler</name><operator>-&gt;</operator><name>userdata</name></name></expr></argument>, <argument><expr><name>result_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zrangeResultBeginStore</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>dstobj</name></name> <operator>=</operator> <call><name>createZsetListpackObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zrangeResultEmitCBufferForStore</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>value_length_in_bytes</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>newscore</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>ele</name> <init>= <expr><call><name>sdsnewlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>value_length_in_bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>zsetAdd</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>dstobj</name></name></expr></argument>, <argument><expr><name>score</name></expr></argument>, <argument><expr><name>ele</name></expr></argument>, <argument><expr><name>ZADD_IN_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retflags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newscore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zrangeResultEmitLongLongForStore</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>,
<parameter><decl><type><name>long</name> <name>long</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>score</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>newscore</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>ele</name> <init>= <expr><call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>zsetAdd</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>dstobj</name></name></expr></argument>, <argument><expr><name>score</name></expr></argument>, <argument><expr><name>ele</name></expr></argument>, <argument><expr><name>ZADD_IN_NONE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>retflags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newscore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zrangeResultFinalizeStore</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>result_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>result_count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setKey</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>handler</name><operator>-&gt;</operator><name>dstkey</name></name></expr></argument>, <argument><expr><name><name>handler</name><operator>-&gt;</operator><name>dstobj</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><name>result_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_ZSET</name></expr></argument>, <argument><expr><literal type="string">"zrangestore"</literal></expr></argument>, <argument><expr><name><name>handler</name><operator>-&gt;</operator><name>dstkey</name></name></expr></argument>, <argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>handler</name><operator>-&gt;</operator><name>dstkey</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></argument>, <argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>handler</name><operator>-&gt;</operator><name>dstkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>, <argument><expr><literal type="string">"del"</literal></expr></argument>, <argument><expr><name><name>handler</name><operator>-&gt;</operator><name>dstkey</name></name></expr></argument>, <argument><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>dstobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zrangeResultHandlerInit</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>,
<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>client</name></decl></parameter>, <parameter><decl><type><name>zrange_consumer_type</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>handler</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name> <operator>=</operator> <name>client</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ZRANGE_CONSUMER_TYPE_CLIENT</name></expr>:</case>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>beginResultEmission</name></name> <operator>=</operator> <name>zrangeResultBeginClient</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>finalizeResultEmission</name></name> <operator>=</operator> <name>zrangeResultFinalizeClient</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>emitResultFromCBuffer</name></name> <operator>=</operator> <name>zrangeResultEmitCBufferToClient</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>emitResultFromLongLong</name></name> <operator>=</operator> <name>zrangeResultEmitLongLongToClient</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ZRANGE_CONSUMER_TYPE_INTERNAL</name></expr>:</case>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>beginResultEmission</name></name> <operator>=</operator> <name>zrangeResultBeginStore</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>finalizeResultEmission</name></name> <operator>=</operator> <name>zrangeResultFinalizeStore</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>emitResultFromCBuffer</name></name> <operator>=</operator> <name>zrangeResultEmitCBufferForStore</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>emitResultFromLongLong</name></name> <operator>=</operator> <name>zrangeResultEmitLongLongForStore</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zrangeResultHandlerScoreEmissionEnable</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>withscores</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>should_emit_array_length</name></name> <operator>=</operator> <operator>(</operator><name><name>handler</name><operator>-&gt;</operator><name>client</name><operator>-&gt;</operator><name>resp</name></name> <operator>&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zrangeResultHandlerDestinationKeySet</name> <parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>,
<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>dstkey</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>handler</name><operator>-&gt;</operator><name>dstkey</name></name> <operator>=</operator> <name>dstkey</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>genericZrangebyrankCommand</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>,
<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>withscores</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>llen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>rangelen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>result_cardinality</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llen</name> <operator>=</operator> <call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <name>llen</name><operator>+</operator><name>start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name> <operator>=</operator> <name>llen</name><operator>+</operator><name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>beginResultEmission</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <name>end</name> <operator>||</operator> <name>start</name> <operator>&gt;=</operator> <name>llen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>finalizeResultEmission</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;=</operator> <name>llen</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>end</name> <operator>=</operator> <name>llen</name><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rangelen</name> <operator>=</operator> <operator>(</operator><name>end</name><operator>-</operator><name>start</name><operator>)</operator><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>result_cardinality</name> <operator>=</operator> <name>rangelen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>vlong</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>-</operator><literal type="number">2</literal><operator>-</operator><operator>(</operator><literal type="number">2</literal><operator>*</operator><name>start</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><literal type="number">2</literal><operator>*</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>rangelen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>eptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>vstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>emitResultFromLongLong</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>vlong</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>emitResultFromCBuffer</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>vstr</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>zzlPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslGetElementByRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>llen</name><operator>-</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslGetElementByRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>start</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<while>while<condition>(<expr><name>rangelen</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>ln</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>ele</name> <init>= <expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>emitResultFromCBuffer</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>ele</name></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ln</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <ternary><condition><expr><name>reverse</name></expr> ?</condition><then> <expr><name><name>ln</name><operator>-&gt;</operator><name>backward</name></name></expr> </then><else>: <expr><name><name>ln</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>finalizeResultEmission</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>result_cardinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zrangestoreCommand</name> <parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>dstkey</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zrange_result_handler</name></type> <name>handler</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zrangeResultHandlerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>ZRANGE_CONSUMER_TYPE_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zrangeResultHandlerDestinationKeySet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><name>dstkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zrangeGenericCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ZRANGE_AUTO</name></expr></argument>, <argument><expr><name>ZRANGE_DIRECTION_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zrangeCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zrange_result_handler</name></type> <name>handler</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zrangeResultHandlerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>ZRANGE_CONSUMER_TYPE_CLIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zrangeGenericCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZRANGE_AUTO</name></expr></argument>, <argument><expr><name>ZRANGE_DIRECTION_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zrevrangeCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zrange_result_handler</name></type> <name>handler</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zrangeResultHandlerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>ZRANGE_CONSUMER_TYPE_CLIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zrangeGenericCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZRANGE_RANK</name></expr></argument>, <argument><expr><name>ZRANGE_DIRECTION_REVERSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>genericZrangebyscoreCommand</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>,
<parameter><decl><type><name>zrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>limit</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>rangelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>beginResultEmission</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&gt;=</operator> <operator>(</operator><name>long</name><operator>)</operator><call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>finalizeResultEmission</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>vlong</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlLastInRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlFirstInRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>eptr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>&amp;&amp;</operator> <name>offset</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zzlPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<while>while <condition>(<expr><name>eptr</name> <operator>&amp;&amp;</operator> <name>limit</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>score</name> <init>= <expr><call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rangelen</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>emitResultFromLongLong</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>vlong</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>emitResultFromCBuffer</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>vstr</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zzlPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslLastInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslFirstInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<while>while <condition>(<expr><name>ln</name> <operator>&amp;&amp;</operator> <name>offset</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<while>while <condition>(<expr><name>ln</name> <operator>&amp;&amp;</operator> <name>limit</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueGteMin</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>score</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>rangelen</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>emitResultFromCBuffer</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ln</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>finalizeResultEmission</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>rangelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zrangebyscoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zrange_result_handler</name></type> <name>handler</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zrangeResultHandlerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>ZRANGE_CONSUMER_TYPE_CLIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zrangeGenericCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZRANGE_SCORE</name></expr></argument>, <argument><expr><name>ZRANGE_DIRECTION_FORWARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zrevrangebyscoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zrange_result_handler</name></type> <name>handler</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zrangeResultHandlerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>ZRANGE_CONSUMER_TYPE_CLIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zrangeGenericCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZRANGE_SCORE</name></expr></argument>, <argument><expr><name>ZRANGE_DIRECTION_REVERSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zcountCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zrangespec</name></type> <name>range</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>zslParseRange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"min or max is not a float"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlFirstInRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>eptr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslValueLteMax</name><argument_list>(<argument><expr><name>score</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>rank</name></decl>;</decl_stmt>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <call><name>zslFirstInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>zn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>zslGetRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>score</name></name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>=</operator> <operator>(</operator><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <operator>(</operator><name>rank</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <call><name>zslLastInRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>zn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>zslGetRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>score</name></name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>-=</operator> <operator>(</operator><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>rank</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zlexcountCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zlexrangespec</name></type> <name>range</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>zslParseLexRange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"min or max not valid string range item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlFirstInLexRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>eptr</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>rank</name></decl>;</decl_stmt>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <call><name>zslFirstInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>zn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>zslGetRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>score</name></name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>=</operator> <operator>(</operator><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <operator>(</operator><name>rank</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>zn</name> <operator>=</operator> <call><name>zslLastInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>zn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>zslGetRank</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>score</name></name></expr></argument>, <argument><expr><name><name>zn</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>-=</operator> <operator>(</operator><name><name>zsl</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>rank</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>genericZrangebylexCommand</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>,
<parameter><decl><type><name>zlexrangespec</name> <modifier>*</modifier></type><name>range</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>withscores</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>limit</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>rangelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>beginResultEmission</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>vlong</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlLastInLexRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>zzlFirstInLexRange</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>eptr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>eptr</name> <operator>&amp;&amp;</operator> <name>offset</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zzlPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<while>while <condition>(<expr><name>eptr</name> <operator>&amp;&amp;</operator> <name>limit</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>double</name></type> <name>score</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlLexValueGteMin</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zzlLexValueLteMax</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rangelen</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>emitResultFromLongLong</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>vlong</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>emitResultFromCBuffer</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>vstr</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zzlPrev</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>zzlNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>ln</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslLastInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <call><name>zslFirstInLexRange</name><argument_list>(<argument><expr><name>zsl</name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<while>while <condition>(<expr><name>ln</name> <operator>&amp;&amp;</operator> <name>offset</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<while>while <condition>(<expr><name>ln</name> <operator>&amp;&amp;</operator> <name>limit</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslLexValueGteMin</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>zslLexValueLteMax</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>,<argument><expr><name>range</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>rangelen</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>emitResultFromCBuffer</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ln</name><operator>-&gt;</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>backward</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>finalizeResultEmission</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>rangelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zrangebylexCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zrange_result_handler</name></type> <name>handler</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zrangeResultHandlerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>ZRANGE_CONSUMER_TYPE_CLIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zrangeGenericCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZRANGE_LEX</name></expr></argument>, <argument><expr><name>ZRANGE_DIRECTION_FORWARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zrevrangebylexCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>zrange_result_handler</name></type> <name>handler</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zrangeResultHandlerInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>ZRANGE_CONSUMER_TYPE_CLIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zrangeGenericCommand</name><argument_list>(<argument><expr><operator>&amp;</operator><name>handler</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ZRANGE_LEX</name></expr></argument>, <argument><expr><name>ZRANGE_DIRECTION_REVERSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zrangeGenericCommand</name><parameter_list>(<parameter><decl><type><name>zrange_result_handler</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc_start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>store</name></decl></parameter>,
<parameter><decl><type><name>zrange_type</name></type> <name>rangetype</name></decl></parameter>, <parameter><decl><type><name>zrange_direction</name></type> <name>direction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><name><name>handler</name><operator>-&gt;</operator><name>client</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>argc_start</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zrangespec</name></type> <name>range</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zlexrangespec</name></type> <name>lexrange</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>minidx</name> <init>= <expr><name>argc_start</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>maxidx</name> <init>= <expr><name>argc_start</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>opt_start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>opt_end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>opt_withscores</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>opt_offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>opt_limit</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name><init>=<expr><name>argc_start</name> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>leftargs</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>j</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>store</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"withscores"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>opt_withscores</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"limit"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>leftargs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt_offset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt_limit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator></expr>)</condition>
<block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>j</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>direction</name> <operator>==</operator> <name>ZRANGE_DIRECTION_AUTO</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"rev"</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>ZRANGE_DIRECTION_REVERSE</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_AUTO</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"bylex"</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>rangetype</name> <operator>=</operator> <name>ZRANGE_LEX</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_AUTO</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"byscore"</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>rangetype</name> <operator>=</operator> <name>ZRANGE_SCORE</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>direction</name> <operator>==</operator> <name>ZRANGE_DIRECTION_AUTO</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>direction</name> <operator>=</operator> <name>ZRANGE_DIRECTION_FORWARD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_AUTO</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rangetype</name> <operator>=</operator> <name>ZRANGE_RANK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>opt_limit</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>rangetype</name> <operator>==</operator> <name>ZRANGE_RANK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"syntax error, LIMIT is only supported in combination with either BYSCORE or BYLEX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>opt_withscores</name> <operator>&amp;&amp;</operator> <name>rangetype</name> <operator>==</operator> <name>ZRANGE_LEX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"syntax error, WITHSCORES not supported in combination with BYLEX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>direction</name> <operator>==</operator> <name>ZRANGE_DIRECTION_REVERSE</name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name>ZRANGE_SCORE</name> <operator>==</operator> <name>rangetype</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>ZRANGE_LEX</name> <operator>==</operator> <name>rangetype</name><operator>)</operator><operator>)</operator></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>tmp</name> <init>= <expr><name>maxidx</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>maxidx</name> <operator>=</operator> <name>minidx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>minidx</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>rangetype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ZRANGE_AUTO</name></expr>:</case>
<case>case <expr><name>ZRANGE_RANK</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>minidx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt_start</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>maxidx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt_end</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name><operator>)</operator></expr>)</condition>
<block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>ZRANGE_SCORE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>zslParseRange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>minidx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>maxidx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"min or max is not a float"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>ZRANGE_LEX</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>zslParseLexRange</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>minidx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>maxidx</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lexrange</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"min or max not valid string range item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>opt_withscores</name> <operator>||</operator> <name>store</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zrangeResultHandlerScoreEmissionEnable</name><argument_list>(<argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>zobj</name> <operator>=</operator> <call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>zobj</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>store</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>beginResultEmission</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>handler</name><operator>-&gt;</operator><name>finalizeResultEmission</name></name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>emptyarray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>rangetype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ZRANGE_AUTO</name></expr>:</case>
<case>case <expr><name>ZRANGE_RANK</name></expr>:</case>
<expr_stmt><expr><call><name>genericZrangebyrankCommand</name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>opt_start</name></expr></argument>, <argument><expr><name>opt_end</name></expr></argument>,
<argument><expr><name>opt_withscores</name> <operator>||</operator> <name>store</name></expr></argument>, <argument><expr><name>direction</name> <operator>==</operator> <name>ZRANGE_DIRECTION_REVERSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ZRANGE_SCORE</name></expr>:</case>
<expr_stmt><expr><call><name>genericZrangebyscoreCommand</name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>range</name></expr></argument>, <argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>opt_offset</name></expr></argument>,
<argument><expr><name>opt_limit</name></expr></argument>, <argument><expr><name>direction</name> <operator>==</operator> <name>ZRANGE_DIRECTION_REVERSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>ZRANGE_LEX</name></expr>:</case>
<expr_stmt><expr><call><name>genericZrangebylexCommand</name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lexrange</name></expr></argument>, <argument><expr><name>zobj</name></expr></argument>, <argument><expr><name>opt_withscores</name> <operator>||</operator> <name>store</name></expr></argument>,
<argument><expr><name>opt_offset</name></expr></argument>, <argument><expr><name>opt_limit</name></expr></argument>, <argument><expr><name>direction</name> <operator>==</operator> <name>ZRANGE_DIRECTION_REVERSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<label><name>cleanup</name>:</label>
<if_stmt><if>if <condition>(<expr><name>rangetype</name> <operator>==</operator> <name>ZRANGE_LEX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zslFreeLexRange</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lexrange</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zcardCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zscoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>null</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>resp</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>zsetScore</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>score</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyNull</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zmscoreCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<expr_stmt><expr><name>zobj</name> <operator>=</operator> <call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>zobj</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>zsetScore</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>score</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyNull</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zrankGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reverse</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>ele</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>rank</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>zobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>null</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>resp</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><call><name>sdsEncodedObject</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rank</name> <operator>=</operator> <call><name>zsetRank</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name><name>ele</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>reverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rank</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>rank</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyNull</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zrankCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zrankGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zrevrankCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zrankGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zscanCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>cursor</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>parseScanCursorOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptyscan</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>scanGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>genericZpopCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>keyv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keyc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>emitkey</name></decl></parameter>,
<parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_nested_array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reply_nil_when_empty</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>deleted</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>ele</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name>keyc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>keyv</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>zobj</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>zobj</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>zobj</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>reply_nil_when_empty</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyNullArray</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptyarray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>emptyarray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>result_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>llen</name> <init>= <expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>rangelen</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>count</name> <operator>&gt;</operator> <name>llen</name><operator>)</operator></expr> ?</condition><then> <expr><name>llen</name></expr> </then><else>: <expr><name>count</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>use_nested_array</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>emitkey</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>rangelen</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>use_nested_array</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>emitkey</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>rangelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>use_nested_array</name> <operator>&amp;&amp;</operator> <name>emitkey</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>rangelen</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>use_nested_array</name> <operator>&amp;&amp;</operator> <name>emitkey</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>rangelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>zl</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>eptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>vstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>vlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>vlong</name></decl>;</decl_stmt>
<expr_stmt><expr><name>eptr</name> <operator>=</operator> <call><name>lpSeek</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><ternary><condition><expr><name>where</name> <operator>==</operator> <name>ZSET_MAX</name></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>eptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>vstr</name> <operator>=</operator> <call><name>lpGetValue</name><argument_list>(<argument><expr><name>eptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlen</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>vstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>sdsfromlonglong</name><argument_list>(<argument><expr><name>vlong</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>sdsnewlen</name><argument_list>(<argument><expr><name>vstr</name></expr></argument>,<argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>sptr</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>zl</name></expr></argument>,<argument><expr><name>eptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>sptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>zzlGetScore</name><argument_list>(<argument><expr><name>sptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplist</name> <modifier>*</modifier></type><name>zsl</name> <init>= <expr><name><name>zs</name><operator>-&gt;</operator><name>zsl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zskiplistNode</name> <modifier>*</modifier></type><name>zln</name></decl>;</decl_stmt>
<expr_stmt><expr><name>zln</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>where</name> <operator>==</operator> <name>ZSET_MAX</name></expr> ?</condition><then> <expr><name><name>zsl</name><operator>-&gt;</operator><name>tail</name></name></expr> </then><else>:
<expr><name><name>zsl</name><operator>-&gt;</operator><name>header</name><operator>-&gt;</operator><name>level</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>forward</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>zln</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ele</name> <operator>=</operator> <call><name>sdsdup</name><argument_list>(<argument><expr><name><name>zln</name><operator>-&gt;</operator><name>ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <name><name>zln</name><operator>-&gt;</operator><name>score</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Unknown sorted set encoding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>serverAssertWithInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zobj</name></expr></argument>,<argument><expr><call><name>zsetDel</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>result_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>events</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="string">"zpopmin"</literal></expr>,<expr><literal type="string">"zpopmax"</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_ZSET</name></expr></argument>,<argument><expr><name><name>events</name><index>[<expr><name>where</name></expr>]</index></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>use_nested_array</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>ele</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>result_count</name></expr>;</expr_stmt>
</block_content>}</block> while<condition>(<expr><operator>--</operator><name>rangelen</name></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>zobj</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>deleted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dbDelete</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_GENERIC</name></expr></argument>,<argument><expr><literal type="string">"del"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>cmd</name><operator>-&gt;</operator><name>proc</name></name> <operator>==</operator> <name>zmpopCommand</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>count_obj</name> <init>= <expr><call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>count</name> <operator>&gt;</operator> <name>llen</name><operator>)</operator></expr> ?</condition><then> <expr><name>llen</name></expr> </then><else>: <expr><name>count</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rewriteClientCommandVector</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>where</name> <operator>==</operator> <name>ZSET_MAX</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>shared</name><operator>.</operator><name>zpopmax</name></name></expr> </then><else>: <expr><name><name>shared</name><operator>.</operator><name>zpopmin</name></name></expr></else></ternary></expr></argument>,
<argument><expr><name>key</name></expr></argument>, <argument><expr><name>count_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>count_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zpopMinMaxCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>getPositiveLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>use_nested_array</name> <init>= <expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>resp</name></name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>count</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>genericZpopCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>use_nested_array</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zpopminCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zpopMinMaxCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ZSET_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zpopmaxCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zpopMinMaxCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ZSET_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>blockingGenericZpopCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numkeys</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>timeout_idx</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_nested_array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>reply_nil_when_empty</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mstime_t</name></type> <name>timeout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getTimeoutFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>timeout_idx</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>,<argument><expr><name>UNIT_SECONDS</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>numkeys</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>keys</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>llen</name> <init>= <expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>llen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>genericZpopCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>use_nested_array</name></expr></argument>, <argument><expr><name>reply_nil_when_empty</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>rewriteClientCommandVector</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>where</name> <operator>==</operator> <name>ZSET_MAX</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>shared</name><operator>.</operator><name>zpopmax</name></name></expr> </then><else>: <expr><name><name>shared</name><operator>.</operator><name>zpopmin</name></name></expr></else></ternary></expr></argument>,
<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>count_obj</name> <init>= <expr><call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>count</name> <operator>&gt;</operator> <name>llen</name><operator>)</operator></expr> ?</condition><then> <expr><name>llen</name></expr> </then><else>: <expr><name>count</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rewriteClientCommandVector</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>where</name> <operator>==</operator> <name>ZSET_MAX</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>shared</name><operator>.</operator><name>zpopmax</name></name></expr> </then><else>: <expr><name><name>shared</name><operator>.</operator><name>zpopmin</name></name></expr></else></ternary></expr></argument>,
<argument><expr><name>key</name></expr></argument>, <argument><expr><name>count_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>count_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return;</return>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_DENY_BLOCKING</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyNullArray</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>blockPos</name></name></type> <name>pos</name> <init>= <expr><block>{<expr><name>where</name></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>blockForKeys</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>BLOCKED_ZSET</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><name>timeout</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>bzpopminCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>blockingGenericZpopCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>ZSET_MIN</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>bzpopmaxCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>blockingGenericZpopCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>ZSET_MAX</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>zarndmemberReplyWithListpack</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>keys</name></decl></parameter>, <parameter><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><name>unsigned</name> <name>long</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>vals</name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>resp</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sval</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sval</name></expr></argument>, <argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>vals</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sval</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>zzlStrtod</name><argument_list>(<argument><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sval</name></expr></argument>,<argument><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>slen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZRANDMEMBER_SUB_STRATEGY_MUL</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZRANDMEMBER_RANDOM_SAMPLE_LIMIT</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>zrandmemberWithCountCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>withscores</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>count</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>uniq</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zsetobj</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>zsetobj</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>emptyarray</name></name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>zsetobj</name></expr></argument>, <argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>zsetLength</name><argument_list>(<argument><expr><name>zsetobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>l</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>count</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>count</name> <operator>=</operator> <operator>-</operator><name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name>uniq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptyarray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>uniq</name> <operator>||</operator> <name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>withscores</name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>resp</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>count</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>zsetobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_SKIPLIST</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>zset</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><name><name>zsetobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>count</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictGetFairRandomKey</name><argument_list>(<argument><expr><name><name>zs</name><operator>-&gt;</operator><name>dict</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>key</name> <init>= <expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>resp</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator><call><name>dictGetVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>zsetobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>keys</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>limit</name></decl>, <decl><type ref="prev"/><name>sample_count</name></decl>;</decl_stmt>
<expr_stmt><expr><name>limit</name> <operator>=</operator> <ternary><condition><expr><name>count</name> <operator>&gt;</operator> <name>ZRANDMEMBER_RANDOM_SAMPLE_LIMIT</name></expr> ?</condition><then> <expr><name>ZRANDMEMBER_RANDOM_SAMPLE_LIMIT</name></expr> </then><else>: <expr><name>count</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>listpackEntry</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>vals</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>listpackEntry</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>count</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>sample_count</name> <operator>=</operator> <ternary><condition><expr><name>count</name> <operator>&gt;</operator> <name>limit</name></expr> ?</condition><then> <expr><name>limit</name></expr> </then><else>: <expr><name>count</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>-=</operator> <name>sample_count</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpRandomPairs</name><argument_list>(<argument><expr><name><name>zsetobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>sample_count</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zarndmemberReplyWithListpack</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>sample_count</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>zsetopsrc</name></type> <name>src</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>zsetopval</name></type> <name>zval</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>src</name><operator>.</operator><name>subject</name></name> <operator>=</operator> <name>zsetobj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name><name>zsetobj</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>src</name><operator>.</operator><name>encoding</name></name> <operator>=</operator> <name><name>zsetobj</name><operator>-&gt;</operator><name>encoding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zuiInitIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>reply_size</name> <init>= <expr><ternary><condition><expr><name>count</name> <operator>&lt;</operator> <name>size</name></expr> ?</condition><then> <expr><name>count</name></expr> </then><else>: <expr><name>size</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>resp</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>reply_size</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>reply_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><call><name>zuiNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>withscores</name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>resp</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyBulkSds</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>zuiNewSdsFromValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>zval</name><operator>.</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>zuiClearIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name><operator>*</operator><name>ZRANDMEMBER_SUB_STRATEGY_MUL</name> <operator>&gt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sdsReplyDictType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>dictExpand</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>zuiNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>sds</name></type> <name>key</name> <init>= <expr><call><name>zuiNewSdsFromValue</name><argument_list>(<argument><expr><operator>&amp;</operator><name>zval</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name> <init>= <expr><call><name>dictAddRaw</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dictSetDoubleVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>, <argument><expr><name><name>zval</name><operator>.</operator><name>score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>dictSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>count</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
<expr_stmt><expr><name>de</name> <operator>=</operator> <call><name>dictGetFairRandomKey</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictUnlink</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictFreeUnlinkedEntry</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<decl_stmt><decl><type><name>dictIterator</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dictEntry</name> <modifier>*</modifier></type><name>de</name></decl>;</decl_stmt>
<expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictGetIterator</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>de</name> <operator>=</operator> <call><name>dictNext</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>withscores</name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>resp</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyBulkSds</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>dictGetKey</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>dictGetDoubleVal</name><argument_list>(<argument><expr><name>de</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>dictReleaseIterator</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>zsetobj</name><operator>-&gt;</operator><name>encoding</name></name> <operator>==</operator> <name>OBJ_ENCODING_LISTPACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>listpackEntry</name> <modifier>*</modifier></type><name>keys</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>listpackEntry</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>vals</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>listpackEntry</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><call><name>lpRandomPairsUnique</name><argument_list>(<argument><expr><name><name>zsetobj</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zarndmemberReplyWithListpack</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zuiClearIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>added</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dict</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>dictCreate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashDictType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>dictExpand</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>added</name> <operator>&lt;</operator> <name>count</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>listpackEntry</name></type> <name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>score</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>zsetTypeRandomElement</name><argument_list>(<argument><expr><name>zsetobj</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><ternary><condition><expr><name>withscores</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>score</name></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>skey</name> <init>= <expr><call><name>zsetSdsFromListpackEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dictAdd</name><argument_list>(<argument><expr><name>d</name></expr></argument>,<argument><expr><name>skey</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DICT_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>added</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>resp</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>zsetReplyFromListpackEntry</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>withscores</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyDouble</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>dictRelease</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>zuiClearIterator</name><argument_list>(<argument><expr><operator>&amp;</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zrandmemberCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>withscores</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>zset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>listpackEntry</name></type> <name>ele</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>l</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>||</operator> <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"withscores"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>withscores</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>zrandmemberWithCountCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>withscores</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>zset</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>null</name><index>[<expr><name><name>c</name><operator>-&gt;</operator><name>resp</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>zset</name></expr></argument>,<argument><expr><name>OBJ_ZSET</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>zsetTypeRandomElement</name><argument_list>(<argument><expr><name>zset</name></expr></argument>, <argument><expr><call><name>zsetLength</name><argument_list>(<argument><expr><name>zset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ele</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zsetReplyFromListpackEntry</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zmpopGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numkeys_idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_block</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>numkeys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>where</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getRangeLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>numkeys_idx</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LONG_MAX</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>numkeys</name></expr></argument>, <argument><expr><literal type="string">"numkeys should be greater than 0"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>where_idx</name> <init>= <expr><name>numkeys_idx</name> <operator>+</operator> <name>numkeys</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>where_idx</name> <operator>&gt;=</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>where_idx</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"MIN"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>where</name> <operator>=</operator> <name>ZSET_MIN</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>where_idx</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"MAX"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>where</name> <operator>=</operator> <name>ZSET_MAX</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></else></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>where_idx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>moreargs</name> <init>= <expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>j</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><literal type="string">"COUNT"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getRangeLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LONG_MAX</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>count</name></expr></argument>,<argument><expr><literal type="string">"count should be greater than 0"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>is_block</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>blockingGenericZpopCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><name>numkeys_idx</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>numkeys</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>genericZpopCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><name>numkeys_idx</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>numkeys</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>zmpopCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zmpopGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>bzmpopCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zmpopGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
