<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/results/redis_res/_cppstats/redis/src/t_stream.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"endianconv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stream.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_ITEM_FLAG_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_ITEM_FLAG_DELETED</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_ITEM_FLAG_SAMEFIELDS</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAMID_STATIC_VECTOR_LEN</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_LISTPACK_MAX_PRE_ALLOCATE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_LISTPACK_MAX_SIZE</name></cpp:macro> <cpp:value>(1&lt;&lt;30)</cpp:value></cpp:define>
<function_decl><type><name>void</name></type> <name>streamFreeCG</name><parameter_list>(<parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>streamFreeNACK</name><parameter_list>(<parameter><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>na</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>size_t</name></type> <name>streamReplyWithRangeFromConsumerPEL</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>streamParseStrictIDOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>missing_seq</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>seq_given</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>streamParseIDOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>missing_seq</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>stream</name> <modifier>*</modifier></type><name>streamNew</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_id</name><operator>.</operator><name>ms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_id</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>freeStream</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>raxFreeWithCallback</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>lpFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>raxFreeWithCallback</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>,<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>streamFreeCG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>unsigned</name> <name>long</name></type> <name>streamLength</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>robj</name> <modifier>*</modifier></type><name>subject</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>subject</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>streamIncrID</name><parameter_list>(<parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>C_OK</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>==</operator> <name>UINT64_MAX</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>==</operator> <name>UINT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>C_ERR</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>streamDecrID</name><parameter_list>(<parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>C_OK</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>C_ERR</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamNextID</name><parameter_list>(<parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>last_id</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>new_id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ms</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ms</name> <operator>&gt;</operator> <name><name>last_id</name><operator>-&gt;</operator><name>ms</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>new_id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <name>ms</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>new_id</name> <operator>=</operator> <operator>*</operator><name>last_id</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamIncrID</name><argument_list>(<argument><expr><name>new_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>robj</name> <modifier>*</modifier></type><name>streamDup</name><parameter_list>(<parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>sobj</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>o</name><operator>-&gt;</operator><name>encoding</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OBJ_ENCODING_STREAM</name></expr>:</case>
<expr_stmt><expr><name>sobj</name> <operator>=</operator> <call><name>createStreamObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Wrong encoding."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>new_s</name></decl>;</decl_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_s</name> <operator>=</operator> <name><name>sobj</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>rax_key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>lp_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>ri</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>lp_bytes</name> <operator>=</operator> <call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>new_lp</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><name>lp_bytes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_lp</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lp_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>rax_key</name></expr></argument>, <argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rax_key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>new_s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>rax_key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rax_key</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>new_lp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>new_s</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_s</name><operator>-&gt;</operator><name>last_id</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>sobj</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri_cgroups</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cgroups</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cgroups</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cgroups</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><name><name>ri_cgroups</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>new_cg</name> <init>= <expr><call><name>streamCreateCG</name><argument_list>(<argument><expr><name>new_s</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>ri_cgroups</name><operator>.</operator><name>key</name></name></expr></argument>,
<argument><expr><name><name>ri_cgroups</name><operator>.</operator><name>key_len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cg</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>new_cg</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri_cg_pel</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cg_pel</name></expr></argument>,<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cg_pel</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cg_pel</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
<decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><name><name>ri_cg_pel</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>new_nack</name> <init>= <expr><call><name>streamCreateNACK</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>new_nack</name><operator>-&gt;</operator><name>delivery_time</name></name> <operator>=</operator> <name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_nack</name><operator>-&gt;</operator><name>delivery_count</name></name> <operator>=</operator> <name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>new_cg</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>, <argument><expr><name><name>ri_cg_pel</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>new_nack</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cg_pel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri_consumers</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_consumers</name></expr></argument>, <argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_consumers</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_consumers</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name><name>ri_consumers</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>new_consumer</name></decl>;</decl_stmt>
<expr_stmt><expr><name>new_consumer</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>new_consumer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_consumer</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>sdsdup</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_consumer</name><operator>-&gt;</operator><name>pel</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>new_cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name><name>new_consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>new_consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>new_consumer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_consumer</name><operator>-&gt;</operator><name>seen_time</name></name> <operator>=</operator> <name><name>consumer</name><operator>-&gt;</operator><name>seen_time</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri_cpel</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cpel</name></expr></argument>, <argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cpel</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cpel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>new_nack</name> <init>= <expr><call><name>raxFind</name><argument_list>(<argument><expr><name><name>new_cg</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name><name>ri_cpel</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>new_nack</name> <operator>!=</operator> <name>raxNotFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>=</operator> <name>new_consumer</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>new_consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name><name>ri_cpel</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>new_nack</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cpel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_consumers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cgroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>sobj</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int64_t</name></type> <name>lpGetIntegerIfValid</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>valid</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>lpGet</name><argument_list>(<argument><expr><name>ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>valid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>ll</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>string2ll</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>e</name></expr></argument>,<argument><expr><name>v</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ll</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>valid</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name>ll</name></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lpGetInteger</name><parameter_list>(<parameter><type><name>ele</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>lpGetIntegerIfValid(ele, NULL)</cpp:value></cpp:define>
<function><type><name>int</name></type> <name>lpGetEdgeStreamID</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>master_id</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>edge_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>lp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp_ele</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>master_fields_count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>master_fields_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lp_ele</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpLast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>lp_count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lp_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>lp_count</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>id</name> <init>= <expr><operator>*</operator><name>master_id</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>id</name><operator>.</operator><name>ms</name></name> <operator>+=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>id</name><operator>.</operator><name>seq</name></name> <operator>+=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>edge_id</name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamLogListpackContent</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><name>LP_INTBUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ele</name> <init>= <expr><call><name>lpGet</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>v</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>serverLog</name><argument_list>(<argument><expr><name>LL_WARNING</name></expr></argument>,<argument><expr><literal type="string">"- [%d] '%.*s'"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>v</name></expr></argument>, <argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamEncodeID</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>e</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>htonu64</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>htonu64</name><argument_list>(<argument><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>e</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamDecodeID</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>e</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>e</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <call><name>ntohu64</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <call><name>ntohu64</name><argument_list>(<argument><expr><name><name>e</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>streamCompareID</name><parameter_list>(<parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ms</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ms</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>ms</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>ms</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>seq</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>seq</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>seq</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>seq</name></name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamGetEdgeID</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>edge_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>empty</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>empty</name> <operator>=</operator> <operator>!</operator><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>, <argument><expr><literal type="string">"$"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>empty</name> <operator>=</operator> <operator>!</operator><call><name>raxPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>edge_id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <ternary><condition><expr><name>first</name></expr> ?</condition><then> <expr><name>UINT64_MAX</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>edge_id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <ternary><condition><expr><name>first</name></expr> ?</condition><then> <expr><name>UINT64_MAX</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>master_id</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>master_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>lpGetEdgeStreamID</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>first</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>master_id</name></expr></argument>, <argument><expr><name>edge_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>streamAppendItem</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>numfields</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>added_id</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>use_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>seq_given</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>use_id</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>seq_given</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>id</name> <operator>=</operator> <operator>*</operator><name>use_id</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_id</name><operator>.</operator><name>ms</name></name> <operator>==</operator> <name><name>use_id</name><operator>-&gt;</operator><name>ms</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_id</name><operator>.</operator><name>seq</name></name> <operator>==</operator> <name>UINT64_MAX</name></expr>)</condition> <block>{<block_content>
<return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>id</name><operator>.</operator><name>seq</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>id</name> <operator>=</operator> <operator>*</operator><name>use_id</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>streamNextID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EDOM</name></expr>;</expr_stmt>
<return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>totelelen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfields</name><operator>*</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>sds</name></type> <name>ele</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>totelelen</name> <operator>+=</operator> <call><name>sdslen</name><argument_list>(<argument><expr><name>ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>totelelen</name> <operator>&gt;</operator> <name>STREAM_LISTPACK_MAX_SIZE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ERANGE</name></expr>;</expr_stmt>
<return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>lp_bytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>raxEOF</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>ri</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>lp_bytes</name> <operator>=</operator> <call><name>lpBytes</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>rax_key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>master_id</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>node_max_bytes</name> <init>= <expr><name><name>server</name><operator>.</operator><name>stream_node_max_bytes</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>node_max_bytes</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>node_max_bytes</name> <operator>&gt;</operator> <name>STREAM_LISTPACK_MAX_SIZE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>node_max_bytes</name> <operator>=</operator> <name>STREAM_LISTPACK_MAX_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>lp_bytes</name> <operator>+</operator> <name>totelelen</name> <operator>&gt;=</operator> <name>node_max_bytes</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>server</name><operator>.</operator><name>stream_node_max_entries</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp_ele</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <name><name>server</name><operator>.</operator><name>stream_node_max_entries</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpShrinkToFit</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>.</operator><name>data</name></name> <operator>!=</operator> <name>lp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>STREAM_ITEM_FLAG_NONE</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>master_id</name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>rax_key</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>prealloc</name> <init>= <expr><name>STREAM_LISTPACK_MAX_PRE_ALLOCATE</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>server</name><operator>.</operator><name>stream_node_max_bytes</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>server</name><operator>.</operator><name>stream_node_max_bytes</name></name> <operator>&lt;</operator> <name>prealloc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prealloc</name> <operator>=</operator> <name><name>server</name><operator>.</operator><name>stream_node_max_bytes</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpNew</name><argument_list>(<argument><expr><name>prealloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>numfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfields</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>sds</name></type> <name>field</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>field</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>rax_key</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rax_key</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>rax_key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>rax_key</name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rax_key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name>rax_key</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>master_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp_ele</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>lp_ele</name></expr></argument>,<argument><expr><name>count</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>master_fields_count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>numfields</name> <operator>==</operator> <name>master_fields_count</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>master_fields_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>sds</name></type> <name>field</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>e_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><name>LP_INTBUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>lpGet</name><argument_list>(<argument><expr><name>lp_ele</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>e_len</name></expr></argument>,<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>e_len</name> <operator>||</operator>
<call><name>memcmp</name><argument_list>(<argument><expr><name>e</name></expr></argument>,<argument><expr><name>field</name></expr></argument>,<argument><expr><name>e_len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>lp_ele</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>lp_ele</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>master_fields_count</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name><name>id</name><operator>.</operator><name>ms</name></name> <operator>-</operator> <name><name>master_id</name><operator>.</operator><name>ms</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name><name>id</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <name><name>master_id</name><operator>.</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>numfields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfields</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>sds</name></type> <name>field</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>, <decl><type ref="prev"/><name>value</name> <init>= <expr><name><name>argv</name><index>[<expr><name>i</name><operator>*</operator><literal type="number">2</literal><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>field</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppend</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>value</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>int64_t</name></type> <name>lp_count</name> <init>= <expr><name>numfields</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp_count</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lp_count</name> <operator>+=</operator> <name>numfields</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpAppendInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>lp_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ri</name><operator>.</operator><name>data</name></name> <operator>!=</operator> <name>lp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>rax_key</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rax_key</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>added_id</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>added_id</name> <operator>=</operator> <name>id</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>id_given</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>seq_given</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>no_mkstream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>trim_strategy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>trim_strategy_arg_idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>approx_trim</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>maxlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>minid</name></decl>;</decl_stmt>
}</block></struct></type> <name>streamAddTrimArgs</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRIM_STRATEGY_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRIM_STRATEGY_MAXLEN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRIM_STRATEGY_MINID</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<function><type><name>int64_t</name></type> <name>streamTrim</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamAddTrimArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>maxlen</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>maxlen</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name> <init>= <expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>minid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>approx</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>approx_trim</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>limit</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>limit</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>trim_strategy</name> <init>= <expr><name><name>args</name><operator>-&gt;</operator><name>trim_strategy</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>trim_strategy</name> <operator>==</operator> <name>TRIM_STRATEGY_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>trim_strategy</name> <operator>==</operator> <name>TRIM_STRATEGY_MAXLEN</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;=</operator> <name>maxlen</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>entries</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>deleted</name> <operator>+</operator> <name>entries</name><operator>)</operator> <operator>&gt;</operator> <name>limit</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>remove_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>master_id</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>trim_strategy</name> <operator>==</operator> <name>TRIM_STRATEGY_MAXLEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>remove_node</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>entries</name> <operator>&gt;=</operator> <name>maxlen</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>master_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>last_id</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lpGetEdgeStreamID</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>master_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>remove_node</name> <operator>=</operator> <call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_id</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>remove_node</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"&gt;="</literal></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>-=</operator> <name>entries</name></expr>;</expr_stmt>
<expr_stmt><expr><name>deleted</name> <operator>+=</operator> <name>entries</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>approx</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>deleted_from_lp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>master_fields_count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>master_fields_count</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pcopy</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>flags</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>to_skip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>ms_delta</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>seq_delta</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>currid</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>trim_strategy</name> <operator>==</operator> <name>TRIM_STRATEGY_MINID</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>currid</name><operator>.</operator><name>ms</name></name> <operator>=</operator> <name><name>master_id</name><operator>.</operator><name>ms</name></name> <operator>+</operator> <name>ms_delta</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>currid</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <name><name>master_id</name><operator>.</operator><name>seq</name></name> <operator>+</operator> <name>seq_delta</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stop</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>trim_strategy</name> <operator>==</operator> <name>TRIM_STRATEGY_MAXLEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>stop</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;=</operator> <name>maxlen</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>stop</name> <operator>=</operator> <call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>currid</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>stop</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>to_skip</name> <operator>=</operator> <name>master_fields_count</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>to_skip</name> <operator>=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>to_skip</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<while>while<condition>(<expr><name>to_skip</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_DELETED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>intptr_t</name></type> <name>delta</name> <init>= <expr><name>p</name> <operator>-</operator> <name>lp</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>STREAM_ITEM_FLAG_DELETED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcopy</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>deleted_from_lp</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>lp</name> <operator>+</operator> <name>delta</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>deleted</name> <operator>+=</operator> <name>deleted_from_lp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>,<argument><expr><name>entries</name><operator>-</operator><name>deleted_from_lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>marked_deleted</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>,<argument><expr><name>marked_deleted</name><operator>+</operator><name>deleted_from_lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>entries</name> <operator>-=</operator> <name>deleted_from_lp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>marked_deleted</name> <operator>+=</operator> <name>deleted_from_lp</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>entries</name> <operator>+</operator> <name>marked_deleted</name> <operator>&gt;</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <name>marked_deleted</name> <operator>&gt;</operator> <name>entries</name><operator>/</operator><literal type="number">2</literal></expr>)</condition> <block>{<block_content>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></while>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>deleted</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>streamTrimByLength</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>long</name></type> <name>maxlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>approx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>streamAddTrimArgs</name></type> <name>args</name> <init>= <expr><block>{
<expr><operator>.</operator><name>trim_strategy</name> <operator>=</operator> <name>TRIM_STRATEGY_MAXLEN</name></expr>,
<expr><operator>.</operator><name>approx_trim</name> <operator>=</operator> <name>approx</name></expr>,
<expr><operator>.</operator><name>limit</name> <operator>=</operator> <name>approx</name> <operator>?</operator> <literal type="number">100</literal> <operator>*</operator> <name><name>server</name><operator>.</operator><name>stream_node_max_entries</name></name> <operator>:</operator> <literal type="number">0</literal></expr>,
<expr><operator>.</operator><name>maxlen</name> <operator>=</operator> <name>maxlen</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>streamTrim</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int64_t</name></type> <name>streamTrimByID</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamID</name></type> <name>minid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>approx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>streamAddTrimArgs</name></type> <name>args</name> <init>= <expr><block>{
<expr><operator>.</operator><name>trim_strategy</name> <operator>=</operator> <name>TRIM_STRATEGY_MINID</name></expr>,
<expr><operator>.</operator><name>approx_trim</name> <operator>=</operator> <name>approx</name></expr>,
<expr><operator>.</operator><name>limit</name> <operator>=</operator> <name>approx</name> <operator>?</operator> <literal type="number">100</literal> <operator>*</operator> <name><name>server</name><operator>.</operator><name>stream_node_max_entries</name></name> <operator>:</operator> <literal type="number">0</literal></expr>,
<expr><operator>.</operator><name>minid</name> <operator>=</operator> <name>minid</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>streamTrim</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>streamParseAddOrTrimArgsOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>streamAddTrimArgs</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xadd</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>args</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>limit_given</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>moreargs</name> <init>= <expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>i</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>xadd</name> <operator>&amp;&amp;</operator> <name><name>opt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <name><name>opt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"maxlen"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>trim_strategy</name></name> <operator>!=</operator> <name>TRIM_STRATEGY_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"syntax error, MAXLEN and MINID options at the same time are not compatible"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>approx_trim</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>moreargs</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>approx_trim</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>moreargs</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>maxlen</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The MAXLEN argument must be &gt;= 0."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>trim_strategy</name></name> <operator>=</operator> <name>TRIM_STRATEGY_MAXLEN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>trim_strategy_arg_idx</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"minid"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>trim_strategy</name></name> <operator>!=</operator> <name>TRIM_STRATEGY_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"syntax error, MAXLEN and MINID options at the same time are not compatible"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>approx_trim</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>moreargs</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>approx_trim</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>moreargs</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <name><name>next</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>minid</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>trim_strategy</name></name> <operator>=</operator> <name>TRIM_STRATEGY_MINID</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>trim_strategy_arg_idx</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"limit"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>limit</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>limit</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The LIMIT argument must be &gt;= 0."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>limit_given</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>xadd</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"nomkstream"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>no_mkstream</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>xadd</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>seq_given</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>id_given</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>limit</name></name> <operator>&amp;&amp;</operator> <name><name>args</name><operator>-&gt;</operator><name>trim_strategy</name></name> <operator>==</operator> <name>TRIM_STRATEGY_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"syntax error, LIMIT cannot be used without specifying a trimming strategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xadd</name> <operator>&amp;&amp;</operator> <name><name>args</name><operator>-&gt;</operator><name>trim_strategy</name></name> <operator>==</operator> <name>TRIM_STRATEGY_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"syntax error, XTRIM must be called with a trimming strategy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name><name>server</name><operator>.</operator><name>master</name></name> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>CLIENT_ID_AOF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>limit_given</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>args</name><operator>-&gt;</operator><name>approx_trim</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"syntax error, LIMIT cannot be used without the special ~ option"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>approx_trim</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <literal type="number">100</literal> <operator>*</operator> <name><name>server</name><operator>.</operator><name>stream_node_max_entries</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>limit</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <literal type="number">10000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>limit</name></name> <operator>&gt;</operator> <literal type="number">1000000</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>limit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamIteratorStart</name><parameter_list>(<parameter><decl><type><name>streamIterator</name> <modifier>*</modifier></type><name>si</name></decl></parameter>, <parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rev</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>start</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name></name></expr></argument>,<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name></name></expr></argument>,<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rev</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>start</name><operator>-&gt;</operator><name>ms</name></name> <operator>||</operator> <name><name>start</name><operator>-&gt;</operator><name>seq</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><literal type="string">"&lt;="</literal></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>si</name><operator>-&gt;</operator><name>start_key</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>raxEOF</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>end</name><operator>-&gt;</operator><name>ms</name></name> <operator>||</operator> <name><name>end</name><operator>-&gt;</operator><name>seq</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><literal type="string">"&lt;="</literal></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>si</name><operator>-&gt;</operator><name>end_key</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>raxEOF</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>stream</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>rev</name></name> <operator>=</operator> <name>rev</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>streamIteratorGetID</name><parameter_list>(<parameter><decl><type><name>streamIterator</name> <modifier>*</modifier></type><name>si</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>numfields</name></decl></parameter>)</parameter_list> <block>{<block_content>
<while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>si</name><operator>-&gt;</operator><name>rev</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>rev</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>raxPrev</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key_len</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>master_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpFirst</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_count</name></name> <operator>=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_start</name></name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>uint64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>si</name><operator>-&gt;</operator><name>master_fields_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpLast</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>lp_count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>lp_count</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>lp_count</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lp_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<while>while<condition>(<expr><name>lp_count</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_flags</name></name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>flags</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>id</name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>master_id</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>+=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>+=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>numfields</name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>master_fields_count</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>numfields</name> <operator>=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><operator>*</operator><name>numfields</name><operator>&gt;=</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_DELETED</name><operator>)</operator></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_ptr</name></name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>master_fields_start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_DELETED</name><operator>)</operator></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name></name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_ptr</name></name> <operator>=</operator> <name><name>si</name><operator>-&gt;</operator><name>master_fields_start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>to_discard</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name><operator>)</operator></expr> ?</condition><then>
<expr><operator>*</operator><name>numfields</name></expr> </then><else>: <expr><operator>*</operator><name>numfields</name><operator>*</operator><literal type="number">2</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int64_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>to_discard</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name></type> <name>prev_times</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>prev_times</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while<condition>(<expr><name>prev_times</name><operator>--</operator></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpPrev</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></while>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamIteratorGetField</name><parameter_list>(<parameter><decl><type><name>streamIterator</name> <modifier>*</modifier></type><name>si</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fieldptr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>valueptr</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>fieldlen</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>valuelen</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>entry_flags</name></name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>fieldptr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_ptr</name></name></expr></argument>,<argument><expr><name>fieldlen</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>field_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_ptr</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>master_fields_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>fieldptr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>,<argument><expr><name>fieldlen</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>field_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>valueptr</name> <operator>=</operator> <call><name>lpGet</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>,<argument><expr><name>valuelen</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>value_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_ele</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamIteratorRemoveEntry</name><parameter_list>(<parameter><decl><type><name>streamIterator</name> <modifier>*</modifier></type><name>si</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>current</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>aux</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>flags</name> <init>= <expr><call><name>lpGetInteger</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>lp_flags</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>STREAM_ITEM_FLAG_DELETED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>lp_flags</name></name></expr></argument>,<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>lpFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>aux</name> <operator>=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>aux</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>lpFree</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>stream</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>,<argument><expr><name>aux</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lpNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>aux</name> <operator>=</operator> <call><name>lpGetInteger</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>lpReplaceInteger</name><argument_list>(<argument><expr><name>lp</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>,<argument><expr><name>aux</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>lp</name></name> <operator>!=</operator> <name>lp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>stream</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>lp</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>stream</name><operator>-&gt;</operator><name>length</name></name><operator>--</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>start_key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>*</operator><name>current</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>*</operator><name>current</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>end_key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>streamIteratorStop</name><argument_list>(<argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamIteratorStart</name><argument_list>(<argument><expr><name>si</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>,<argument><expr><name><name>si</name><operator>-&gt;</operator><name>rev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamIteratorStop</name><parameter_list>(<parameter><decl><type><name>streamIterator</name> <modifier>*</modifier></type><name>si</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>si</name><operator>-&gt;</operator><name>ri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>streamDeleteItem</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamIterator</name></type> <name>si</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamIteratorStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>myid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>numfields</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamIteratorGetID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>myid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>numfields</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>streamIteratorRemoveEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>myid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>deleted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>streamIteratorStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>deleted</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamLastValidID</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>maxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>streamIterator</name></type> <name>si</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamIteratorStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>numfields</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>streamIteratorGetID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><name>maxid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>numfields</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"Corrupt stream, length is %llu, but no max id"</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>streamIteratorStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>addReplyStreamID</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>sds</name></type> <name>replyid</name> <init>= <expr><call><name>sdscatfmt</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"%U-%U"</literal></expr></argument>,<argument><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name></expr></argument>,<argument><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>addReplyBulkSds</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>replyid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setDeferredReplyStreamID</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dr</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>sds</name></type> <name>replyid</name> <init>= <expr><call><name>sdscatfmt</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"%U-%U"</literal></expr></argument>,<argument><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name></expr></argument>,<argument><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>setDeferredReplyBulkSds</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dr</name></expr></argument>, <argument><expr><name>replyid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>robj</name> <modifier>*</modifier></type><name>createObjectFromStreamID</name><parameter_list>(<parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>, <argument><expr><call><name>sdscatfmt</name><argument_list>(<argument><expr><call><name>sdsempty</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><literal type="string">"%U-%U"</literal></expr></argument>,
<argument><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name></expr></argument>,<argument><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamPropagateXCLAIM</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>groupname</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name><name>argv</name><index>[<expr><literal type="number">14</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>xclaim</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>groupname</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObject</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>integers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>time</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>retrycount</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>force</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>justid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>lastid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>createObjectFromStreamID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alsoPropagate</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><literal type="number">14</literal></expr></argument>,<argument><expr><name>PROPAGATE_AOF</name><operator>|</operator><name>PROPAGATE_REPL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamPropagateGroupID</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>groupname</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>xgroup</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>setid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>groupname</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>createObjectFromStreamID</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alsoPropagate</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>,<argument><expr><name>PROPAGATE_AOF</name><operator>|</operator><name>PROPAGATE_REPL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamPropagateConsumerCreation</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>groupname</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>consumername</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>xgroup</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>shared</name><operator>.</operator><name>createconsumer</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>groupname</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>createObject</name><argument_list>(<argument><expr><name>OBJ_STRING</name></expr></argument>,<argument><expr><call><name>sdsdup</name><argument_list>(<argument><expr><name>consumername</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>alsoPropagate</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>argv</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>,<argument><expr><name>PROPAGATE_AOF</name><operator>|</operator><name>PROPAGATE_REPL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_RWR_NOACK</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_RWR_RAWENTRIES</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STREAM_RWR_HISTORY</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<function><type><name>size_t</name></type> <name>streamReplyWithRange</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rev</name></decl></parameter>, <parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>streamPropInfo</name> <modifier>*</modifier></type><name>spi</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylen_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamIterator</name></type> <name>si</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>numfields</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>propagate_last_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>noack</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>STREAM_RWR_NOACK</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>group</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_RWR_HISTORY</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>streamReplyWithRangeFromConsumerPEL</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>start</name></expr></argument>,<argument><expr><name>end</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,
<argument><expr><name>consumer</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_RWR_RAWENTRIES</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>arraylen_ptr</name> <operator>=</operator> <call><name>addReplyDeferredLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>streamIteratorStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>start</name></expr></argument>,<argument><expr><name>end</name></expr></argument>,<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><call><name>streamIteratorGetID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>numfields</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>group</name> <operator>&amp;&amp;</operator> <call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>last_id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>noack</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>propagate_last_id</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>numfields</name><operator>*</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><name>numfields</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>key_len</name></decl>, <decl><type ref="prev"/><name>value_len</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamIteratorGetField</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>key_len</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>value_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>value</name></expr></argument>,<argument><expr><name>value_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>group</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>noack</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><call><name>streamCreateNACK</name><argument_list>(<argument><expr><name>consumer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>group_inserted</name> <init>=
<expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>nack</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>consumer_inserted</name> <init>=
<expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>nack</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>group_inserted</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>streamFreeNACK</name><argument_list>(<argument><expr><name>nack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nack</name> <operator>=</operator> <call><name>raxFind</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>nack</name> <operator>!=</operator> <name>raxNotFound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>=</operator> <name>consumer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>nack</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>group_inserted</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>consumer_inserted</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>serverPanic</name><argument_list>(<argument><expr><literal type="string">"NACK half-created. Should not be possible."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>spi</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>idarg</name> <init>= <expr><call><name>createObjectFromStreamID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamPropagateXCLAIM</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>spi</name><operator>-&gt;</operator><name>keyname</name></name></expr></argument>,<argument><expr><name>group</name></expr></argument>,<argument><expr><name><name>spi</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>,<argument><expr><name>idarg</name></expr></argument>,<argument><expr><name>nack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>idarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>arraylen</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>==</operator> <name>arraylen</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>spi</name> <operator>&amp;&amp;</operator> <name>propagate_last_id</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>streamPropagateGroupID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>spi</name><operator>-&gt;</operator><name>keyname</name></name></expr></argument>,<argument><expr><name>group</name></expr></argument>,<argument><expr><name><name>spi</name><operator>-&gt;</operator><name>groupname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>streamIteratorStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>arraylen_ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>setDeferredArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylen_ptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>arraylen</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>size_t</name></type> <name>streamReplyWithRangeFromConsumerPEL</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>startkey</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>endkey</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>,<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>endkey</name></expr></argument>,<argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylen_ptr</name> <init>= <expr><call><name>addReplyDeferredLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"&gt;="</literal></expr></argument>,<argument><expr><name>startkey</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>startkey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>count</name> <operator>||</operator> <name>arraylen</name> <operator>&lt;</operator> <name>count</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name>end</name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>thisid</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>thisid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>thisid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>thisid</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>STREAM_RWR_RAWENTRIES</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>thisid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyNullArray</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>arraylen</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setDeferredArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylen_ptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>arraylen</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>robj</name> <modifier>*</modifier></type><name>streamTypeLookupWriteOrCreate</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no_create</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>no_create</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyNull</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createStreamObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>o</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>streamGenericParseIDOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>missing_seq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>strict</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>seq_given</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>strict</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>seq_given</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>seq_given</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
<return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>ms</name></decl>, <decl><type ref="prev"/><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dot</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dot</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>dot</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>string2ull</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>ms</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>invalid</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dot</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>seqlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>dot</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>seq_given</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>seqlen</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>dot</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>seq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>seq_given</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>string2ull</name><argument_list>(<argument><expr><name>dot</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<goto>goto <name>invalid</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>seq</name> <operator>=</operator> <name>missing_seq</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>ms</name></name> <operator>=</operator> <name>ms</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>id</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <name>seq</name></expr>;</expr_stmt>
<return>return <expr><name>C_OK</name></expr>;</return>
<label><name>invalid</name>:</label>
<if_stmt><if>if <condition>(<expr><name>c</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Invalid stream ID specified as stream "</literal>
<literal type="string">"command argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>C_ERR</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>streamParseID</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>streamGenericParseIDOrReply</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>streamParseIDOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>missing_seq</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>streamGenericParseIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><name>missing_seq</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>streamParseStrictIDOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>missing_seq</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>seq_given</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>streamGenericParseIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><name>missing_seq</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>seq_given</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>streamParseIntervalIDOrReply</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>exclude</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>missing_seq</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>sdslen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>invalid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>exclude</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>exclude</name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'('</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>exclude</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>exclude</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>createStringObject</name><argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>,<argument><expr><name>len</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>invalid</name> <operator>=</operator> <operator>(</operator><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>t</name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><name>missing_seq</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>invalid</name> <operator>=</operator> <operator>(</operator><call><name>streamParseIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>id</name></expr></argument>,<argument><expr><name>missing_seq</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>invalid</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>C_ERR</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>C_OK</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamRewriteApproxSpecifier</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>rewriteClientCommandArgument</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>special_equals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamRewriteTrimArgument</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>trim_strategy</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>trim_strategy</name> <operator>==</operator> <name>TRIM_STRATEGY_MAXLEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>createStringObjectFromLongLong</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>streamID</name></type> <name>first_id</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamGetEdgeID</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>first_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>createObjectFromStreamID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>first_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>rewriteClientCommandArgument</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>idx</name></expr></argument>,<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xaddCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>streamAddTrimArgs</name></type> <name>parsed_args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idpos</name> <init>= <expr><call><name>streamParseAddOrTrimArgsOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed_args</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>idpos</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>field_pos</name> <init>= <expr><name>idpos</name><operator>+</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <name>field_pos</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>field_pos</name><operator>)</operator> <operator>%</operator> <literal type="number">2</literal><operator>)</operator> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorArity</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parsed_args</name><operator>.</operator><name>id_given</name></name> <operator>&amp;&amp;</operator> <name><name>parsed_args</name><operator>.</operator><name>seq_given</name></name> <operator>&amp;&amp;</operator>
<name><name>parsed_args</name><operator>.</operator><name>id</name><operator>.</operator><name>ms</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>parsed_args</name><operator>.</operator><name>id</name><operator>.</operator><name>seq</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The ID specified in XADD must be greater than 0-0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>streamTypeLookupWriteOrCreate</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>parsed_args</name><operator>.</operator><name>no_mkstream</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>last_id</name><operator>.</operator><name>ms</name></name> <operator>==</operator> <name>UINT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>last_id</name><operator>.</operator><name>seq</name></name> <operator>==</operator> <name>UINT64_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The stream has exhausted the last possible ID, "</literal>
<literal type="string">"unable to add more items"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamAppendItem</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><name>field_pos</name></expr></argument>,<argument><expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>field_pos</name><operator>)</operator><operator>/</operator><literal type="number">2</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><ternary><condition><expr><name><name>parsed_args</name><operator>.</operator><name>id_given</name></name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>parsed_args</name><operator>.</operator><name>id</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,<argument><expr><name><name>parsed_args</name><operator>.</operator><name>seq_given</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EDOM</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The ID specified in XADD is equal or smaller than "</literal>
<literal type="string">"the target stream top item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Elements are too large to be stored"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xadd"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parsed_args</name><operator>.</operator><name>trim_strategy</name></name> <operator>!=</operator> <name>TRIM_STRATEGY_NONE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>streamTrim</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed_args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xtrim"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parsed_args</name><operator>.</operator><name>approx_trim</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>streamRewriteApproxSpecifier</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>parsed_args</name><operator>.</operator><name>trim_strategy_arg_idx</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamRewriteTrimArgument</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name><name>parsed_args</name><operator>.</operator><name>trim_strategy</name></name></expr></argument>,<argument><expr><name><name>parsed_args</name><operator>.</operator><name>trim_strategy_arg_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>parsed_args</name><operator>.</operator><name>id_given</name></name> <operator>||</operator> <operator>!</operator><name><name>parsed_args</name><operator>.</operator><name>seq_given</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>idarg</name> <init>= <expr><call><name>createObjectFromStreamID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>rewriteClientCommandArgument</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>idpos</name></expr></argument>, <argument><expr><name>idarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>idarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>signalKeyAsReady</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xrangeGenericCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rev</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>startid</name></decl>, <decl><type ref="prev"/><name>endid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>count</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>startarg</name> <init>= <expr><ternary><condition><expr><name>rev</name></expr> ?</condition><then> <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>endarg</name> <init>= <expr><ternary><condition><expr><name>rev</name></expr> ?</condition><then> <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>startex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>endex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamParseIntervalIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>startarg</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startex</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>startex</name> <operator>&amp;&amp;</operator> <call><name>streamIncrID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"invalid start ID for the interval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamParseIntervalIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>endarg</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endex</name></expr></argument>,<argument><expr><name>UINT64_MAX</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>endex</name> <operator>&amp;&amp;</operator> <call><name>streamDecrID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"invalid end ID for the interval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>additional</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>j</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"COUNT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>additional</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>count</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>emptyarray</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyNullArray</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><name>rev</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xrangeCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>xrangeGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xrevrangeCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>xrangeGenericCommand</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xlenCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XREAD_BLOCKED_DEFAULT_COUNT</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>xreadCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>timeout</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>streams_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>streams_arg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>noack</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name><name>static_ids</name><index>[<expr><name>STREAMID_STATIC_VECTOR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name> <modifier>*</modifier></type><name>ids</name> <init>= <expr><name>static_ids</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier><modifier>*</modifier></type><name>groups</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>xreadgroup</name> <init>= <expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>groupname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>consumername</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>moreargs</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>i</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="string">"BLOCK"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_SCRIPT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"%s command is not allowed with BLOCK option from scripts"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getTimeoutFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>,
<argument><expr><name>UNIT_MILLISECONDS</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="string">"COUNT"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>count</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="string">"STREAMS"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>streams_arg</name> <operator>=</operator> <name>i</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>streams_count</name> <operator>=</operator> <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><name>streams_arg</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>streams_count</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unbalanced XREAD list of streams: "</literal>
<literal type="string">"for each stream key an ID or '$' must be "</literal>
<literal type="string">"specified."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>streams_count</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="string">"GROUP"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xreadgroup</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The GROUP option is only supported by "</literal>
<literal type="string">"XREADGROUP. You called XREAD instead."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>groupname</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>consumername</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>o</name></expr></argument>,<argument><expr><literal type="string">"NOACK"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xreadgroup</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The NOACK option is only supported by "</literal>
<literal type="string">"XREADGROUP. You called XREAD instead."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>noack</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>streams_arg</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>xreadgroup</name> <operator>&amp;&amp;</operator> <name>groupname</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Missing GROUP option for XREADGROUP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>streams_count</name> <operator>&gt;</operator> <name>STREAMID_STATIC_VECTOR_LEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ids</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>streams_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>groupname</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>groups</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamCG</name><operator>*</operator></expr></argument>)</argument_list></sizeof><operator>*</operator><name>streams_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>streams_arg</name> <operator>+</operator> <name>streams_count</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>id_idx</name> <init>= <expr><name>i</name> <operator>-</operator> <name>streams_arg</name> <operator>-</operator> <name>streams_count</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>-</operator><name>streams_count</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>groupname</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<operator>(</operator><name>group</name> <operator>=</operator> <call><name>streamLookupCG</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>groupname</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"-NOGROUP No such key '%s' or consumer "</literal>
<literal type="string">"group '%s' in XREADGROUP with GROUP "</literal>
<literal type="string">"option"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>groupname</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>groups</name><index>[<expr><name>id_idx</name></expr>]</index></name> <operator>=</operator> <name>group</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>xreadgroup</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The $ ID is meaningless in the context of "</literal>
<literal type="string">"XREADGROUP: you want to read the history of "</literal>
<literal type="string">"this consumer by specifying a proper ID, or "</literal>
<literal type="string">"use the &gt; ID to get new messages. The $ ID would "</literal>
<literal type="string">"just return an empty result set."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ids</name><index>[<expr><name>id_idx</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ids</name><index>[<expr><name>id_idx</name></expr>]</index></name><operator>.</operator><name>ms</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ids</name><index>[<expr><name>id_idx</name></expr>]</index></name><operator>.</operator><name>seq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xreadgroup</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The &gt; ID can be specified only when calling "</literal>
<literal type="string">"XREADGROUP using the GROUP &lt;group&gt; "</literal>
<literal type="string">"&lt;consumer&gt; option."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ids</name><index>[<expr><name>id_idx</name></expr>]</index></name><operator>.</operator><name>ms</name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ids</name><index>[<expr><name>id_idx</name></expr>]</index></name><operator>.</operator><name>seq</name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name>ids</name><operator>+</operator><name>id_idx</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>size_t</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylen_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>streams_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>streams_arg</name><operator>+</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name> <modifier>*</modifier></type><name>gt</name> <init>= <expr><name>ids</name><operator>+</operator><name>i</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>serve_synchronously</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>serve_history</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>groups</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>gt</name><operator>-&gt;</operator><name>ms</name></name> <operator>!=</operator> <name>UINT64_MAX</name> <operator>||</operator>
<name><name>gt</name><operator>-&gt;</operator><name>seq</name></name> <operator>!=</operator> <name>UINT64_MAX</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>serve_synchronously</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>serve_history</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamID</name></type> <name>maxid</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>last</name> <init>= <expr><operator>&amp;</operator><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>last_id</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamLastValidID</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>maxid</name></expr></argument>, <argument><expr><name>last</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>serve_synchronously</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>gt</name> <operator>=</operator> <operator>*</operator><name>last</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamID</name></type> <name>maxid</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamLastValidID</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>maxid</name></expr></argument>, <argument><expr><name>gt</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>serve_synchronously</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>serve_synchronously</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>arraylen</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>arraylen</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>arraylen_ptr</name> <operator>=</operator> <call><name>addReplyDeferredLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>start</name> <init>= <expr><operator>*</operator><name>gt</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamIncrID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>resp</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyBulk</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>streams_arg</name><operator>+</operator><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamPropInfo</name></type> <name>spi</name> <init>= <expr><block>{<expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name><operator>+</operator><name>streams_arg</name></expr>]</index></name></expr>,<expr><name>groupname</name></expr>}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>groups</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>consumer</name> <operator>=</operator> <call><name>streamLookupConsumer</name><argument_list>(<argument><expr><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>consumername</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>SLC_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>consumer</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>consumer</name> <operator>=</operator> <call><name>streamCreateConsumer</name><argument_list>(<argument><expr><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>consumername</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,
<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>streams_arg</name><operator>+</operator><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>SCC_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>noack</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>streamPropagateConsumerCreation</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>spi</name><operator>.</operator><name>keyname</name></name></expr></argument>,
<argument><expr><name><name>spi</name><operator>.</operator><name>groupname</name></name></expr></argument>,
<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>noack</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>STREAM_RWR_NOACK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>serve_history</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>STREAM_RWR_HISTORY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>groups</name></expr> ?</condition><then> <expr><name><name>groups</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>,
<argument><expr><name>consumer</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>spi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>groups</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>arraylen</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>resp</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setDeferredArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylen_ptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setDeferredMapLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylen_ptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>CLIENT_DENY_BLOCKING</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyNullArray</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>blockForKeys</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BLOCKED_STREAM</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name><operator>+</operator><name>streams_arg</name></expr></argument>, <argument><expr><name>streams_count</name></expr></argument>,
<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>timeout</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_count</name></name> <operator>=</operator> <ternary><condition><expr><name>count</name></expr> ?</condition><then> <expr><name>count</name></expr> </then><else>: <expr><name>XREAD_BLOCKED_DEFAULT_COUNT</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>groupname</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>groupname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>incrRefCount</name><argument_list>(<argument><expr><name>consumername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_group</name></name> <operator>=</operator> <name>groupname</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_consumer</name></name> <operator>=</operator> <name>consumername</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_group_noack</name></name> <operator>=</operator> <name>noack</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_group</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>bpop</name><operator>.</operator><name>xread_consumer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyNullArray</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>preventCommandPropagation</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ids</name> <operator>!=</operator> <name>static_ids</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>groups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>streamNACK</name> <modifier>*</modifier></type><name>streamCreateNACK</name><parameter_list>(<parameter><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>nack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>=</operator> <name>consumer</name></expr>;</expr_stmt>
<return>return <expr><name>nack</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamFreeNACK</name><parameter_list>(<parameter><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>na</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>na</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamFreeConsumer</name><parameter_list>(<parameter><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>sc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>raxFree</name><argument_list>(<argument><expr><name><name>sc</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sdsfree</name><argument_list>(<argument><expr><name><name>sc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>sc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>streamCG</name> <modifier>*</modifier></type><name>streamCreateCG</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>namelen</name></decl></parameter>, <parameter><decl><type><name>streamID</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>raxFind</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr></argument>,<argument><expr><name>namelen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>raxNotFound</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>cg</name><operator>-&gt;</operator><name>pel</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cg</name><operator>-&gt;</operator><name>last_id</name></name> <operator>=</operator> <operator>*</operator><name>id</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr></argument>,<argument><expr><name>namelen</name></expr></argument>,<argument><expr><name>cg</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>cg</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamFreeCG</name><parameter_list>(<parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>raxFreeWithCallback</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>streamFreeNACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxFreeWithCallback</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>,<argument><expr><operator>(</operator><call><call><name>void</name><argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator><name>streamFreeConsumer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>streamCG</name> <modifier>*</modifier></type><name>streamLookupCG</name><parameter_list>(<parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>groupname</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><call><name>raxFind</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>groupname</name></expr></argument>,
<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>groupname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><ternary><condition><expr><operator>(</operator><name>cg</name> <operator>==</operator> <name>raxNotFound</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>cg</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>streamConsumer</name> <modifier>*</modifier></type><name>streamCreateConsumer</name><parameter_list>(<parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dbid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>notify</name> <init>= <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCC_NO_NOTIFY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dirty</name> <init>= <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SCC_NO_DIRTIFY</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>consumer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>success</name> <init>= <expr><call><name>raxTryInsert</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr></argument>,
<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>consumer</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>success</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>consumer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>sdsdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name> <operator>=</operator> <call><name>raxNew</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>consumer</name><operator>-&gt;</operator><name>seen_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dirty</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>notify</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xgroup-createconsumer"</literal></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>consumer</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>streamConsumer</name> <modifier>*</modifier></type><name>streamLookupConsumer</name><parameter_list>(<parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name></decl></parameter>, <parameter><decl><type><name>sds</name></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cg</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>refresh</name> <init>= <expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SLC_NO_REFRESH</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><call><name>raxFind</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>name</name></expr></argument>,
<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>consumer</name> <operator>==</operator> <name>raxNotFound</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>refresh</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name><name>consumer</name><operator>-&gt;</operator><name>seen_time</name></name> <operator>=</operator> <call><name>mstime</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>consumer</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>streamDelConsumer</name><parameter_list>(<parameter><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name></decl></parameter>, <parameter><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamFreeNACK</name><argument_list>(<argument><expr><name>nack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamFreeConsumer</name><argument_list>(<argument><expr><name>consumer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xgroupCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>grpname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mkstream</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"CREATE"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"MKSTREAM"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>mkstream</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>grpname</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>lookupKeyWrite</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>grpname</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>mkstream</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,
<argument><expr><literal type="string">"The XGROUP subcommand requires the key to exist. "</literal>
<literal type="string">"Note that for CREATE you may want to use the MKSTREAM "</literal>
<literal type="string">"option to create an empty stream automatically."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>cg</name> <operator>=</operator> <call><name>streamLookupCG</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name>grpname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"SETID"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"CREATECONSUMER"</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"DELCONSUMER"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"-NOGROUP No such consumer group '%s' "</literal>
<literal type="string">"for key name '%s'"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>grpname</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"HELP"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"CREATE &lt;key&gt; &lt;groupname&gt; &lt;id|$&gt; [option]"</literal></expr>,
<expr><literal type="string">" Create a new consumer group. Options are:"</literal></expr>,
<expr><literal type="string">" * MKSTREAM"</literal></expr>,
<expr><literal type="string">" Create the empty stream if it does not exist."</literal></expr>,
<expr><literal type="string">"CREATECONSUMER &lt;key&gt; &lt;groupname&gt; &lt;consumer&gt;"</literal></expr>,
<expr><literal type="string">" Create a new consumer in the specified group."</literal></expr>,
<expr><literal type="string">"DELCONSUMER &lt;key&gt; &lt;groupname&gt; &lt;consumer&gt;"</literal></expr>,
<expr><literal type="string">" Remove the specified consumer."</literal></expr>,
<expr><literal type="string">"DESTROY &lt;key&gt; &lt;groupname&gt;"</literal></expr>,
<expr><literal type="string">" Remove the specified group."</literal></expr>,
<expr><literal type="string">"SETID &lt;key&gt; &lt;groupname&gt; &lt;id|$&gt;"</literal></expr>,
<expr><literal type="string">" Set the current group ID."</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>addReplyHelp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>help</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"CREATE"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">6</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>id</name><operator>.</operator><name>ms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>id</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name>mkstream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>o</name> <operator>=</operator> <call><name>createStreamObject</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dbAdd</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><call><name>streamCreateCG</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name>grpname</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>grpname</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xgroup-create"</literal></expr></argument>,
<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"-BUSYGROUP Consumer Group name already exists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"SETID"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>streamParseIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>cg</name><operator>-&gt;</operator><name>last_id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xgroup-setid"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"DESTROY"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cg</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>,<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator><name>grpname</name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name>grpname</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamFreeCG</name><argument_list>(<argument><expr><name>cg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>cone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xgroup-destroy"</literal></expr></argument>,
<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>signalKeyAsReady</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"CREATECONSUMER"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>created</name> <init>= <expr><call><name>streamCreateConsumer</name><argument_list>(<argument><expr><name>cg</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>SCC_DEFAULT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><name>created</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"DELCONSUMER"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>pending</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><call><name>streamLookupConsumer</name><argument_list>(<argument><expr><name>cg</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><name>SLC_NO_REFRESH</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>consumer</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pending</name> <operator>=</operator> <call><name>raxSize</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamDelConsumer</name><argument_list>(<argument><expr><name>cg</name></expr></argument>,<argument><expr><name>consumer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xgroup-delconsumer"</literal></expr></argument>,
<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>pending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xsetidCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nokeyerr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamID</name></type> <name>maxid</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamLastValidID</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>maxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>maxid</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"The ID specified in XSETID is smaller than the "</literal>
<literal type="string">"target stream top item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>last_id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>ok</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xsetid"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xackCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>streamLookupCG</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>group</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name><name>static_ids</name><index>[<expr><name>STREAMID_STATIC_VECTOR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name> <modifier>*</modifier></type><name>ids</name> <init>= <expr><name>static_ids</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>id_count</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>id_count</name> <operator>&gt;</operator> <name>STREAMID_STATIC_VECTOR_LEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ids</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>id_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>ids</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>int</name></type> <name>acknowledged</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>ids</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><call><name>raxFind</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>nack</name> <operator>!=</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamFreeNACK</name><argument_list>(<argument><expr><name>nack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>acknowledged</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>acknowledged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
<if_stmt><if>if <condition>(<expr><name>ids</name> <operator>!=</operator> <name>static_ids</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xpendingCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>justinfo</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>groupname</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>consumername</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>startid</name></decl>, <decl><type ref="prev"/><name>endid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>minidle</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>startex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>endex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&lt;</operator> <literal type="number">6</literal> <operator>||</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;</operator> <literal type="number">9</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&gt;=</operator> <literal type="number">6</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>startidx</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"IDLE"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minidle</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&lt;</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>startidx</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>startidx</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>count</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamParseIntervalIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>startidx</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startex</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>startex</name> <operator>&amp;&amp;</operator> <call><name>streamIncrID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"invalid start ID for the interval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamParseIntervalIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>startidx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endex</name></expr></argument>,<argument><expr><name>UINT64_MAX</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>endex</name> <operator>&amp;&amp;</operator> <call><name>streamDecrID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"invalid end ID for the interval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>startidx</name><operator>+</operator><literal type="number">3</literal> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>consumername</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>startidx</name><operator>+</operator><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<operator>(</operator><name>group</name> <operator>=</operator> <call><name>streamLookupCG</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>groupname</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"-NOGROUP No such key '%s' or consumer "</literal>
<literal type="string">"group '%s'"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>groupname</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>justinfo</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyNull</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyNull</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyNullArray</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"$"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>group</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylen_ptr</name> <init>= <expr><call><name>addReplyDeferredLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arraylen</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>setDeferredArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylen_ptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>consumername</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>consumer</name> <operator>=</operator> <call><name>streamLookupConsumer</name><argument_list>(<argument><expr><name>group</name></expr></argument>,<argument><expr><name><name>consumername</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name>SLC_NO_REFRESH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>consumer</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>rax</name> <modifier>*</modifier></type><name>pel</name> <init>= <expr><ternary><condition><expr><name>consumer</name></expr> ?</condition><then> <expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr> </then><else>: <expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>startkey</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>endkey</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mstime_t</name></type> <name>now</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>endkey</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name>pel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"&gt;="</literal></expr></argument>,<argument><expr><name>startkey</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>startkey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylen_ptr</name> <init>= <expr><call><name>addReplyDeferredLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>count</name> <operator>&amp;&amp;</operator> <call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name>endkey</name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>minidle</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>mstime_t</name></type> <name>this_idle</name> <init>= <expr><name>now</name> <operator>-</operator> <name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>this_idle</name> <operator>&lt;</operator> <name>minidle</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>arraylen</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>mstime_t</name></type> <name>elapsed</name> <init>= <expr><name>now</name> <operator>-</operator> <name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>elapsed</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>elapsed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>elapsed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setDeferredArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylen_ptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xclaimCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>minidle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>retrycount</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mstime_t</name></type> <name>deliverytime</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>force</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>justid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>streamLookupCG</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>group</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"-NOGROUP No such key '%s' or "</literal>
<literal type="string">"consumer group '%s'"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,
<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>minidle</name></expr></argument>,
<argument><expr><literal type="string">"Invalid min-idle-time argument for XCLAIM"</literal></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>minidle</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>minidle</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name><name>static_ids</name><index>[<expr><name>STREAMID_STATIC_VECTOR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name> <modifier>*</modifier></type><name>ids</name> <init>= <expr><name>static_ids</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>id_count</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>id_count</name> <operator>&gt;</operator> <name>STREAMID_STATIC_VECTOR_LEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ids</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>id_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">5</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>ids</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">5</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>int</name></type> <name>last_id_arg</name> <init>= <expr><name>j</name><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mstime_t</name></type> <name>now</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>last_id</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>,<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>propagate_last_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>moreargs</name> <init>= <expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>j</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"FORCE"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>force</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"JUSTID"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>justid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"IDLE"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>deliverytime</name></expr></argument>,
<argument><expr><literal type="string">"Invalid IDLE option argument for XCLAIM"</literal></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>deliverytime</name> <operator>=</operator> <name>now</name> <operator>-</operator> <name>deliverytime</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"TIME"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>deliverytime</name></expr></argument>,
<argument><expr><literal type="string">"Invalid TIME option argument for XCLAIM"</literal></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"RETRYCOUNT"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>retrycount</name></expr></argument>,
<argument><expr><literal type="string">"Invalid RETRYCOUNT option argument for XCLAIM"</literal></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"LASTID"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>last_id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"Unrecognized XCLAIM option '%s'"</literal></expr></argument>,<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>streamCompareID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>last_id</name></name> <operator>=</operator> <name>last_id</name></expr>;</expr_stmt>
<expr_stmt><expr><name>propagate_last_id</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>deliverytime</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>deliverytime</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>deliverytime</name></expr></argument> &gt;</argument_list></name> <name>now</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>deliverytime</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>deliverytime</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylenptr</name> <init>= <expr><call><name>addReplyDeferredLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>name</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>last_id_arg</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>streamID</name></type> <name>id</name> <init>= <expr><name><name>ids</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">5</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><call><name>raxFind</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>force</name> <operator>&amp;&amp;</operator> <name>nack</name> <operator>==</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamIterator</name></type> <name>myiterator</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamIteratorStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myiterator</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>numfields</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>item_id</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamIteratorGetID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myiterator</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>item_id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>numfields</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>streamIteratorStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myiterator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nack</name> <operator>=</operator> <call><name>streamCreateNACK</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>nack</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nack</name> <operator>!=</operator> <name>raxNotFound</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>&amp;&amp;</operator> <name>minidle</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>mstime_t</name></type> <name>this_idle</name> <init>= <expr><name>now</name> <operator>-</operator> <name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>this_idle</name> <operator>&lt;</operator> <name>minidle</name></expr>)</condition><block type="pseudo"><block_content> <continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>consumer</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>consumer</name> <operator>=</operator> <call><name>streamLookupConsumer</name><argument_list>(<argument><expr><name>group</name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name>SLC_DEFAULT</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>consumer</name> <operator>=</operator> <call><name>streamCreateConsumer</name><argument_list>(<argument><expr><name>group</name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>SCC_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>!=</operator> <name>consumer</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name> <operator>=</operator> <name>deliverytime</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>retrycount</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name> <operator>=</operator> <name>retrycount</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>justid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>!=</operator> <name>consumer</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name>buf</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><name>nack</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>=</operator> <name>consumer</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>justid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>emitted</name> <init>= <expr><call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>STREAM_RWR_RAWENTRIES</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>emitted</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReplyNull</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>arraylen</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamPropagateXCLAIM</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>group</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><name>nack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>propagate_last_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>propagate_last_id</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>streamPropagateGroupID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>group</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>setDeferredArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylenptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>preventCommandPropagation</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
<if_stmt><if>if <condition>(<expr><name>ids</name> <operator>!=</operator> <name>static_ids</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xautoclaimCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>group</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyRead</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>minidle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>startid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>startex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>justid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>minidle</name></expr></argument>,<argument><expr><literal type="string">"Invalid min-idle-time argument for XAUTOCLAIM"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>minidle</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>minidle</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamParseIntervalIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startex</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>startex</name> <operator>&amp;&amp;</operator> <call><name>streamIncrID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyError</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"invalid start ID for the interval"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>moreargs</name> <init>= <expr><operator>(</operator><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>j</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"COUNT"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>moreargs</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>getRangeLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>LONG_MAX</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>count</name></expr></argument>,<argument><expr><literal type="string">"COUNT must be &gt; 0"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"JUSTID"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>justid</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorObject</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>syntaxerr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>o</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>streamLookupCG</name><argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>group</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"-NOGROUP No such key '%s' or consumer group '%s'"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,
<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>attempts</name> <init>= <expr><name>count</name><operator>*</operator><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>endidptr</name> <init>= <expr><call><name>addReplyDeferredLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arraylenptr</name> <init>= <expr><call><name>addReplyDeferredLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>startkey</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamEncodeID</name><argument_list>(<argument><expr><name>startkey</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>startid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>group</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"&gt;="</literal></expr></argument>,<argument><expr><name>startkey</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>startkey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>arraylen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mstime_t</name></type> <name>now</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sds</name></type> <name>name</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>attempts</name><operator>--</operator> <operator>&amp;&amp;</operator> <name>count</name> <operator>&amp;&amp;</operator> <call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>minidle</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>mstime_t</name></type> <name>this_idle</name> <init>= <expr><name>now</name> <operator>-</operator> <name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>this_idle</name> <operator>&lt;</operator> <name>minidle</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>consumer</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>consumer</name> <operator>=</operator> <call><name>streamLookupConsumer</name><argument_list>(<argument><expr><name>group</name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name>SLC_DEFAULT</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>consumer</name> <operator>=</operator> <call><name>streamCreateConsumer</name><argument_list>(<argument><expr><name>group</name></expr></argument>,<argument><expr><name>name</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>,<argument><expr><name>SCC_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>!=</operator> <name>consumer</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>raxRemove</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>justid</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>!=</operator> <name>consumer</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>raxInsert</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>,<argument><expr><name>nack</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name> <operator>=</operator> <name>consumer</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>justid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>emitted</name> <init>=
<expr><call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>STREAM_RWR_RAWENTRIES</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>emitted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>addReplyNull</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>arraylen</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name><operator>--</operator></expr>;</expr_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>idstr</name> <init>= <expr><call><name>createObjectFromStreamID</name><argument_list>(<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamPropagateXCLAIM</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name>group</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><name>idstr</name></expr></argument>,<argument><expr><name>nack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>decrRefCount</name><argument_list>(<argument><expr><name>idstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>endid</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>raxEOF</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>endid</name><operator>.</operator><name>ms</name></name> <operator>=</operator> <name><name>endid</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setDeferredArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arraylenptr</name></expr></argument>,<argument><expr><name>arraylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setDeferredReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>endidptr</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>endid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>preventCommandPropagation</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xdelCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name><name>static_ids</name><index>[<expr><name>STREAMID_STATIC_VECTOR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name> <modifier>*</modifier></type><name>ids</name> <init>= <expr><name>static_ids</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>id_count</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>id_count</name> <operator>&gt;</operator> <name>STREAMID_STATIC_VECTOR_LEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ids</name> <operator>=</operator> <call><name>zmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>streamID</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>id_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>streamParseStrictIDOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>ids</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>C_OK</name></expr>)</condition><block type="pseudo"><block_content> <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>int</name></type> <name>deleted</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>deleted</name> <operator>+=</operator> <call><name>streamDeleteItem</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>ids</name><index>[<expr><name>j</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xdel"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>deleted</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
<if_stmt><if>if <condition>(<expr><name>ids</name> <operator>!=</operator> <name>static_ids</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>zfree</name><argument_list>(<argument><expr><name>ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xtrimCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamAddTrimArgs</name></type> <name>parsed_args</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>streamParseAddOrTrimArgsOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed_args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>o</name> <operator>=</operator> <call><name>lookupKeyWriteOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>czero</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>deleted</name> <init>= <expr><call><name>streamTrim</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parsed_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>deleted</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>notifyKeyspaceEvent</name><argument_list>(<argument><expr><name>NOTIFY_STREAM</name></expr></argument>,<argument><expr><literal type="string">"xtrim"</literal></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>parsed_args</name><operator>.</operator><name>approx_trim</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>streamRewriteApproxSpecifier</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>parsed_args</name><operator>.</operator><name>trim_strategy_arg_idx</name></name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamRewriteTrimArgument</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name><name>parsed_args</name><operator>.</operator><name>trim_strategy</name></name></expr></argument>,<argument><expr><name><name>parsed_args</name><operator>.</operator><name>trim_strategy_arg_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>signalModifiedKey</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>db</name></name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>server</name><operator>.</operator><name>dirty</name></name> <operator>+=</operator> <name>deleted</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xinfoReplyWithStreamInfo</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>full</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>count</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier><modifier>*</modifier></type><name>optv</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argv</name></name> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>optc</name> <init>= <expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>-</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>optc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>full</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>optc</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>optc</name> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>optv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"full"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>optc</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>optv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>getLongLongFromObjectOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>optv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>count</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>C_ERR</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>addReplyMapLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><name>full</name></expr> ?</condition><then> <expr><literal type="number">6</literal></expr> </then><else>: <expr><literal type="number">7</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"radix-tree-keys"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"radix-tree-nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>rax</name><operator>-&gt;</operator><name>numnodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"last-generated-id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>s</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>full</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"groups"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><ternary><condition><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr> ?</condition><then> <expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>emitted</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>start</name><operator>.</operator><name>ms</name></name> <operator>=</operator> <name><name>start</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>end</name><operator>.</operator><name>ms</name></name> <operator>=</operator> <name><name>end</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <name>UINT64_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"first-entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>emitted</name> <operator>=</operator> <call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>STREAM_RWR_RAWENTRIES</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>emitted</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReplyNull</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"last-entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>emitted</name> <operator>=</operator> <call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>end</name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>STREAM_RWR_RAWENTRIES</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>emitted</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name>addReplyNull</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"entries"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamReplyWithRange</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"groups"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri_cgroups</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cgroups</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cgroups</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cgroups</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><name><name>ri_cgroups</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>addReplyMapLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ri_cgroups</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri_cgroups</name><operator>.</operator><name>key_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"last-delivered-id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>cg</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"pel-count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"pending"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>arraylen_cg_pel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arrayptr_cg_pel</name> <init>= <expr><call><name>addReplyDeferredLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri_cg_pel</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cg_pel</name></expr></argument>,<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cg_pel</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cg_pel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>count</name> <operator>||</operator> <name>arraylen_cg_pel</name> <operator>&lt;</operator> <name>count</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><name><name>ri_cg_pel</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri_cg_pel</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>serverAssert</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arraylen_cg_pel</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>setDeferredArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arrayptr_cg_pel</name></expr></argument>,<argument><expr><name>arraylen_cg_pel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cg_pel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"consumers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri_consumers</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_consumers</name></expr></argument>,<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_consumers</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_consumers</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name><name>ri_consumers</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>addReplyMapLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"seen-time"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>seen_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"pel-count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"pending"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>arraylen_cpel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>arrayptr_cpel</name> <init>= <expr><call><name>addReplyDeferredLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri_cpel</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cpel</name></expr></argument>,<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cpel</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cpel</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>count</name> <operator>||</operator> <name>arraylen_cpel</name> <operator>&lt;</operator> <name>count</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamNACK</name> <modifier>*</modifier></type><name>nack</name> <init>= <expr><name><name>ri_cpel</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>streamID</name></type> <name>id</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>streamDecodeID</name><argument_list>(<argument><expr><name><name>ri_cpel</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>nack</name><operator>-&gt;</operator><name>delivery_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>arraylen_cpel</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>setDeferredArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>arrayptr_cpel</name></expr></argument>,<argument><expr><name>arraylen_cpel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cpel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_consumers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_cgroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>xinfoCommand</name><parameter_list>(<parameter><decl><type><name>client</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>stream</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>,<argument><expr><literal type="string">"HELP"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"CONSUMERS &lt;key&gt; &lt;groupname&gt;"</literal></expr>,
<expr><literal type="string">" Show consumers of &lt;groupname&gt;."</literal></expr>,
<expr><literal type="string">"GROUPS &lt;key&gt;"</literal></expr>,
<expr><literal type="string">" Show the stream consumer groups."</literal></expr>,
<expr><literal type="string">"STREAM &lt;key&gt; [FULL [COUNT &lt;count&gt;]"</literal></expr>,
<expr><literal type="string">" Show information about the stream."</literal></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>addReplyHelp</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>help</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>opt</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>robj</name> <modifier>*</modifier></type><name>o</name> <init>= <expr><call><name>lookupKeyReadOrReply</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>key</name></expr></argument>,<argument><expr><name><name>shared</name><operator>.</operator><name>nokeyerr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>o</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>checkType</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>o</name></expr></argument>,<argument><expr><name>OBJ_STREAM</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>o</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"CONSUMERS"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><call><name>streamLookupCG</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>cg</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyErrorFormat</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"-NOGROUP No such consumer group '%s' "</literal>
<literal type="string">"for key name '%s'"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>c</name><operator>-&gt;</operator><name>argv</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>-&gt;</operator><name>ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name><name>key</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>mstime_t</name></type> <name>now</name> <init>= <expr><call><name>mstime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamConsumer</name> <modifier>*</modifier></type><name>consumer</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mstime_t</name></type> <name>idle</name> <init>= <expr><name>now</name> <operator>-</operator> <name><name>consumer</name><operator>-&gt;</operator><name>seen_time</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>idle</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>idle</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyMapLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,<argument><expr><call><name>sdslen</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"pending"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>consumer</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"idle"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>idle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"GROUPS"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>c</name><operator>-&gt;</operator><name>argc</name></name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>addReplyArrayLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>raxIterator</name></type> <name>ri</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>raxStart</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><name><name>s</name><operator>-&gt;</operator><name>cgroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raxSeek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>,<argument><expr><literal type="string">"^"</literal></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while<condition>(<expr><call><name>raxNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>streamCG</name> <modifier>*</modifier></type><name>cg</name> <init>= <expr><name><name>ri</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>addReplyMapLen</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCBuffer</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key</name></name></expr></argument>,<argument><expr><name><name>ri</name><operator>.</operator><name>key_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"consumers"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>consumers</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"pending"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyLongLong</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><call><name>raxSize</name><argument_list>(<argument><expr><name><name>cg</name><operator>-&gt;</operator><name>pel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyBulkCString</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><literal type="string">"last-delivered-id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>addReplyStreamID</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><operator>&amp;</operator><name><name>cg</name><operator>-&gt;</operator><name>last_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>raxStop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><name>opt</name></expr></argument>,<argument><expr><literal type="string">"STREAM"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xinfoReplyWithStreamInfo</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>addReplySubcommandSyntaxError</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>streamValidateListpackIntegrity</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>deep</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>valid_record</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateIntegrity</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>deep</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>lpValidateFirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>entry_count</name> <init>= <expr><call><name>lpGetIntegerIfValid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valid_record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid_record</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>deleted_count</name> <init>= <expr><call><name>lpGetIntegerIfValid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valid_record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid_record</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>master_fields</name> <init>= <expr><call><name>lpGetIntegerIfValid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valid_record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid_record</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>master_fields</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>int64_t</name></type> <name>zero</name> <init>= <expr><call><name>lpGetIntegerIfValid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valid_record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid_record</name> <operator>||</operator> <name>zero</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>entry_count</name> <operator>+=</operator> <name>deleted_count</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>entry_count</name><operator>--</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>fields</name> <init>= <expr><name>master_fields</name></expr></init></decl>, <decl><type ref="prev"/><name>extra_fields</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>flags</name> <init>= <expr><call><name>lpGetIntegerIfValid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valid_record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid_record</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lpGetIntegerIfValid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valid_record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid_record</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>lpGetIntegerIfValid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valid_record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid_record</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>STREAM_ITEM_FLAG_SAMEFIELDS</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>fields</name> <operator>=</operator> <call><name>lpGetIntegerIfValid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valid_record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid_record</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>fields</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>extra_fields</name> <operator>+=</operator> <name>fields</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><decl><type><name>int64_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>fields</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<decl_stmt><decl><type><name>int64_t</name></type> <name>lp_count</name> <init>= <expr><call><name>lpGetIntegerIfValid</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>valid_record</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid_record</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>lp_count</name> <operator>!=</operator> <name>fields</name> <operator>+</operator> <name>extra_fields</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt> <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lpValidateNext</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>next</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
</unit>
