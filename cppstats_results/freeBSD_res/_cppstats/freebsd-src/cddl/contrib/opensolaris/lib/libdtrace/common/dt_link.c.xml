<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/results/freeBSD_res/_cppstats/freebsd-src/cddl/contrib/opensolaris/lib/libdtrace/common/dt_link.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;elf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gelf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libelf.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_impl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_provider.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_program.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_string.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESHDR_NULL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESHDR_SHSTRTAB</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESHDR_DOF</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESHDR_STRTAB</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESHDR_SYMTAB</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESHDR_REL</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ESHDR_NUM</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PWRITE_SCN</name><parameter_list>(<parameter><type><name>index</name></type></parameter>, <parameter><type><name>data</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(lseek64(fd, (off64_t)elf_file.shdr[(index)].sh_offset, SEEK_SET) != (off64_t)elf_file.shdr[(index)].sh_offset || dt_write(dtp, fd, (data), elf_file.shdr[(index)].sh_size) != elf_file.shdr[(index)].sh_size)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>DTRACE_SHSTRTAB32</name><index>[]</index></name> <init>= <expr><literal type="string">"\0"</literal>
<literal type="string">".shstrtab\0"</literal>
<literal type="string">".SUNW_dof\0"</literal>
<literal type="string">".strtab\0"</literal>
<literal type="string">".symtab\0"</literal>
<literal type="string">".rel.SUNW_dof"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>DTRACE_SHSTRTAB64</name><index>[]</index></name> <init>= <expr><literal type="string">"\0"</literal>
<literal type="string">".shstrtab\0"</literal>
<literal type="string">".SUNW_dof\0"</literal>
<literal type="string">".strtab\0"</literal>
<literal type="string">".symtab\0"</literal>
<literal type="string">".rela.SUNW_dof"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>DOFSTR</name><index>[]</index></name> <init>= <expr><literal type="string">"__SUNW_dof"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>DOFLAZYSTR</name><index>[]</index></name> <init>= <expr><literal type="string">"___SUNW_dof"</literal></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <name>dt_link_pair</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>dt_link_pair</name></name> <modifier>*</modifier></type><name>dlp_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>dlp_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>dlp_sym</name></decl>;</decl_stmt>
}</block></struct></type> <name>dt_link_pair_t</name>;</typedef>
<typedef>typedef <type><struct>struct <name>dof_elf32</name> <block>{
<decl_stmt><decl><type><name>uint32_t</name></type> <name>de_nrel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf32_Rel</name> <modifier>*</modifier></type><name>de_rel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>de_nsym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf32_Sym</name> <modifier>*</modifier></type><name>de_sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>de_strlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>de_strtab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>de_global</name></decl>;</decl_stmt>
}</block></struct></type> <name>dof_elf32_t</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>prepare_elf32</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dof_hdr_t</name> <modifier>*</modifier></type><name>dof</name></decl></parameter>, <parameter><decl><type><name>dof_elf32_t</name> <modifier>*</modifier></type><name>dep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dof_sec_t</name> <modifier>*</modifier></type><name>dofs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dof_relohdr_t</name> <modifier>*</modifier></type><name>dofrh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dof_relodesc_t</name> <modifier>*</modifier></type><name>dofr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strtab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>nrel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>strtabsz</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf32_Sym</name> <modifier>*</modifier></type><name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf32_Rel</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
<expr_stmt><expr><name>dofs</name> <operator>=</operator> <operator>(</operator><name>dof_sec_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>dof</name><operator>-&gt;</operator><name>dofh_secoff</name></name><operator>)</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dof</name><operator>-&gt;</operator><name>dofh_secnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dofs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dofs_type</name> <operator>!=</operator> <name>DOF_SECT_URELHDR</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dofrh</name> <operator>=</operator> <operator>(</operator><name>dof_relohdr_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>dofs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dofs_offset</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>dofs</name><index>[<expr><name><name>dofrh</name><operator>-&gt;</operator><name>dofr_strtab</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>strtab</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>strtab</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>strtabsz</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>dofs</name><index>[<expr><name><name>dofrh</name><operator>-&gt;</operator><name>dofr_relsec</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dofr</name> <operator>=</operator> <operator>(</operator><name>dof_relodesc_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_size</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_entsize</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strlen</name></name> <operator>=</operator> <name>strtabsz</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_nrel</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_nsym</name></name> <operator>=</operator> <name>count</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_lazyload</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strlen</name></name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>DOFLAZYSTR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_nsym</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strlen</name></name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>DOFSTR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_nsym</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dep</name><operator>-&gt;</operator><name>de_rel</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_nrel</name></name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_rel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dep</name><operator>-&gt;</operator><name>de_sym</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_nsym</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>Elf32_Sym</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dep</name><operator>-&gt;</operator><name>de_strtab</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strlen</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_sym</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>strtabsz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strtab</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_rel</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sym</name> <operator>=</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_sym</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_global</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>Elf32_Sym</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sym</name><operator>++</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dof</name><operator>-&gt;</operator><name>dofh_secnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dofs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dofs_type</name> <operator>!=</operator> <name>DOF_SECT_URELHDR</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dofrh</name> <operator>=</operator> <operator>(</operator><name>dof_relohdr_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>dofs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dofs_offset</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>dofs</name><index>[<expr><name><name>dofrh</name><operator>-&gt;</operator><name>dofr_strtab</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>strtab</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>strtab</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strtab</name></name> <operator>+</operator> <name>strtabsz</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>dofs_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> <operator>=</operator> <name>strtabsz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>strtabsz</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>dofs</name><index>[<expr><name><name>dofrh</name><operator>-&gt;</operator><name>dofr_relsec</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dofr</name> <operator>=</operator> <operator>(</operator><name>dof_relodesc_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nrel</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_size</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_entsize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>dofs</name><index>[<expr><name><name>dofrh</name><operator>-&gt;</operator><name>dofr_tgtsec</name></name></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nrel</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__aarch64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_offset</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name> <operator>+</operator>
<name><name>dofr</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dofr_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_info</name></name> <operator>=</operator> <call><name>ELF32_R_INFO</name><argument_list>(<argument><expr><name>count</name> <operator>+</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_global</name></name></expr></argument>,
<argument><expr><name>R_ARM_REL32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__arm__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%s(%d): arm not implemented\n"</literal></expr></argument>,
<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__i386</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__amd64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_offset</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name> <operator>+</operator>
<name><name>dofr</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dofr_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_info</name></name> <operator>=</operator> <call><name>ELF32_R_INFO</name><argument_list>(<argument><expr><name>count</name> <operator>+</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_global</name></name></expr></argument>,
<argument><expr><name>R_386_PC32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__mips__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%s(%d): MIPS not implemented\n"</literal></expr></argument>,
<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__powerpc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_offset</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name> <operator>+</operator>
<name><name>dofr</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dofr_offset</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_info</name></name> <operator>=</operator> <call><name>ELF32_R_INFO</name><argument_list>(<argument><expr><name>count</name> <operator>+</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_global</name></name></expr></argument>,
<argument><expr><name>R_PPC_REL32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__riscv</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%s(%d): RISC-V not implemented\n"</literal></expr></argument>,
<argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> unknown ISA</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_name</name></name> <operator>=</operator> <name>base</name> <operator>+</operator> <name><name>dofr</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dofr_name</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name> <operator>=</operator> <call><name>ELF32_ST_INFO</name><argument_list>(<argument><expr><name>STB_GLOBAL</name></expr></argument>, <argument><expr><name>STT_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_other</name></name> <operator>=</operator> <call><name>ELF32_ST_VISIBILITY</name><argument_list>(<argument><expr><name>STV_HIDDEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name> <operator>=</operator> <name>SHN_UNDEF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rel</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>sym</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_name</name></name> <operator>=</operator> <name>strtabsz</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name> <operator>=</operator> <name><name>dof</name><operator>-&gt;</operator><name>dofh_filesz</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name> <operator>=</operator> <call><name>ELF32_ST_INFO</name><argument_list>(<argument><expr><name>STB_GLOBAL</name></expr></argument>, <argument><expr><name>STT_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_other</name></name> <operator>=</operator> <call><name>ELF32_ST_VISIBILITY</name><argument_list>(<argument><expr><name>STV_HIDDEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name> <operator>=</operator> <name>ESHDR_DOF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sym</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_lazyload</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>DOFLAZYSTR</name></expr></argument>, <argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strtab</name></name> <operator>+</operator> <name>strtabsz</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>DOFLAZYSTR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>strtabsz</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>DOFLAZYSTR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>DOFSTR</name></expr></argument>, <argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strtab</name></name> <operator>+</operator> <name>strtabsz</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>DOFSTR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>strtabsz</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>DOFSTR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>count</name> <operator>==</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_nrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>strtabsz</name> <operator>==</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_strlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<typedef>typedef <type><struct>struct <name>dof_elf64</name> <block>{
<decl_stmt><decl><type><name>uint32_t</name></type> <name>de_nrel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Rela</name> <modifier>*</modifier></type><name>de_rel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>de_nsym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Sym</name> <modifier>*</modifier></type><name>de_sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>de_strlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>de_strtab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>de_global</name></decl>;</decl_stmt>
}</block></struct></type> <name>dof_elf64_t</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>prepare_elf64</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dof_hdr_t</name> <modifier>*</modifier></type><name>dof</name></decl></parameter>, <parameter><decl><type><name>dof_elf64_t</name> <modifier>*</modifier></type><name>dep</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dof_sec_t</name> <modifier>*</modifier></type><name>dofs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dof_relohdr_t</name> <modifier>*</modifier></type><name>dofrh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dof_relodesc_t</name> <modifier>*</modifier></type><name>dofr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strtab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>nrel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>strtabsz</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Sym</name> <modifier>*</modifier></type><name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Rela</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
<expr_stmt><expr><name>dofs</name> <operator>=</operator> <operator>(</operator><name>dof_sec_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>dof</name><operator>-&gt;</operator><name>dofh_secoff</name></name><operator>)</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dof</name><operator>-&gt;</operator><name>dofh_secnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dofs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dofs_type</name> <operator>!=</operator> <name>DOF_SECT_URELHDR</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dofrh</name> <operator>=</operator> <operator>(</operator><name>dof_relohdr_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>dofs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dofs_offset</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>dofs</name><index>[<expr><name><name>dofrh</name><operator>-&gt;</operator><name>dofr_strtab</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>strtab</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>strtab</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>strtabsz</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>dofs</name><index>[<expr><name><name>dofrh</name><operator>-&gt;</operator><name>dofr_relsec</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dofr</name> <operator>=</operator> <operator>(</operator><name>dof_relodesc_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_size</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_entsize</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strlen</name></name> <operator>=</operator> <name>strtabsz</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_nrel</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_nsym</name></name> <operator>=</operator> <name>count</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_lazyload</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strlen</name></name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>DOFLAZYSTR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_nsym</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strlen</name></name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>DOFSTR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_nsym</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dep</name><operator>-&gt;</operator><name>de_rel</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_nrel</name></name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_rel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dep</name><operator>-&gt;</operator><name>de_sym</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_nsym</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>Elf64_Sym</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dep</name><operator>-&gt;</operator><name>de_strtab</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strlen</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_sym</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>strtabsz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strtab</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>rel</name> <operator>=</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_rel</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sym</name> <operator>=</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_sym</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>de_global</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>Elf64_Sym</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sym</name><operator>++</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>dof</name><operator>-&gt;</operator><name>dofh_secnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dofs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dofs_type</name> <operator>!=</operator> <name>DOF_SECT_URELHDR</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dofrh</name> <operator>=</operator> <operator>(</operator><name>dof_relohdr_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>dofs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dofs_offset</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>dofs</name><index>[<expr><name><name>dofrh</name><operator>-&gt;</operator><name>dofr_strtab</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>strtab</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>strtab</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strtab</name></name> <operator>+</operator> <name>strtabsz</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>dofs_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> <operator>=</operator> <name>strtabsz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>strtabsz</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>dofs</name><index>[<expr><name><name>dofrh</name><operator>-&gt;</operator><name>dofr_relsec</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dofr</name> <operator>=</operator> <operator>(</operator><name>dof_relodesc_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dof</name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nrel</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_size</name></name> <operator>/</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_entsize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>&amp;</operator><name><name>dofs</name><index>[<expr><name><name>dofrh</name><operator>-&gt;</operator><name>dofr_tgtsec</name></name></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nrel</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__aarch64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_offset</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name> <operator>+</operator>
<name><name>dofr</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dofr_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_info</name></name> <operator>=</operator> <call><name>ELF64_R_INFO</name><argument_list>(<argument><expr><name>count</name> <operator>+</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_global</name></name></expr></argument>,
<argument><expr><name>R_AARCH64_PREL64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__arm__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__mips__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__powerpc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_offset</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name> <operator>+</operator>
<name><name>dofr</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dofr_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_info</name></name> <operator>=</operator> <call><name>ELF64_R_INFO</name><argument_list>(<argument><expr><name>count</name> <operator>+</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_global</name></name></expr></argument>,
<argument><expr><name>R_PPC64_REL64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__riscv</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__i386</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__amd64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_offset</name></name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>dofs_offset</name></name> <operator>+</operator>
<name><name>dofr</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dofr_offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_info</name></name> <operator>=</operator> <call><name>ELF64_R_INFO</name><argument_list>(<argument><expr><name>count</name> <operator>+</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_global</name></name></expr></argument>,
<argument><expr><name>R_X86_64_PC64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> unknown ISA</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_name</name></name> <operator>=</operator> <name>base</name> <operator>+</operator> <name><name>dofr</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>dofr_name</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name> <operator>=</operator> <call><name>GELF_ST_INFO</name><argument_list>(<argument><expr><name>STB_GLOBAL</name></expr></argument>, <argument><expr><name>STT_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_other</name></name> <operator>=</operator> <call><name>ELF64_ST_VISIBILITY</name><argument_list>(<argument><expr><name>STV_HIDDEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name> <operator>=</operator> <name>SHN_UNDEF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rel</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>sym</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></for>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_name</name></name> <operator>=</operator> <name>strtabsz</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name> <operator>=</operator> <name><name>dof</name><operator>-&gt;</operator><name>dofh_filesz</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name> <operator>=</operator> <call><name>GELF_ST_INFO</name><argument_list>(<argument><expr><name>STB_GLOBAL</name></expr></argument>, <argument><expr><name>STT_OBJECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_other</name></name> <operator>=</operator> <call><name>ELF64_ST_VISIBILITY</name><argument_list>(<argument><expr><name>STV_HIDDEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name> <operator>=</operator> <name>ESHDR_DOF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sym</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_lazyload</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>DOFLAZYSTR</name></expr></argument>, <argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strtab</name></name> <operator>+</operator> <name>strtabsz</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>DOFLAZYSTR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>strtabsz</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>DOFLAZYSTR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>DOFSTR</name></expr></argument>, <argument><expr><name><name>dep</name><operator>-&gt;</operator><name>de_strtab</name></name> <operator>+</operator> <name>strtabsz</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>DOFSTR</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>strtabsz</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>DOFSTR</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>count</name> <operator>==</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_nrel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>strtabsz</name> <operator>==</operator> <name><name>dep</name><operator>-&gt;</operator><name>de_strlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dump_elf32</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dof_hdr_t</name> <modifier>*</modifier></type><name>dof</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<struct>struct <block>{
<decl_stmt><decl><type><name>Elf32_Ehdr</name></type> <name>ehdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf32_Shdr</name></type> <name><name>shdr</name><index>[<expr><name>ESHDR_NUM</name></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>elf_file</name></decl>;</struct>
<decl_stmt><decl><type><name>Elf32_Shdr</name> <modifier>*</modifier></type><name>shp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf32_Off</name></type> <name>off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dof_elf32_t</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>nshdr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>prepare_elf32</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dof</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nshdr</name> <operator>=</operator> <ternary><condition><expr><name><name>de</name><operator>.</operator><name>de_nrel</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ESHDR_SYMTAB</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>ESHDR_NUM</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elf_file</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>elf_file</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_MAG0</name></expr>]</index></name> <operator>=</operator> <name>ELFMAG0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_MAG1</name></expr>]</index></name> <operator>=</operator> <name>ELFMAG1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_MAG2</name></expr>]</index></name> <operator>=</operator> <name>ELFMAG2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_MAG3</name></expr>]</index></name> <operator>=</operator> <name>ELFMAG3</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_VERSION</name></expr>]</index></name> <operator>=</operator> <name>EV_CURRENT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name> <operator>=</operator> <name>ELFCLASS32</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTE_ORDER</name> <operator>==</operator> <name>_BIG_ENDIAN</name></expr></cpp:if>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name> <operator>=</operator> <name>ELFDATA2MSB</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name> <operator>=</operator> <name>ELFDATA2LSB</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_OSABI</name></expr>]</index></name> <operator>=</operator> <name>ELFOSABI_FREEBSD</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name> <operator>=</operator> <name>ET_REL</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__arm__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_ARM</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__mips__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_MIPS</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__powerpc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_PPC</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__i386</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__amd64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_386</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__aarch64__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_AARCH64</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_version</name></name> <operator>=</operator> <name>EV_CURRENT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf32_Ehdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ehsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf32_Ehdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_phentsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf32_Phdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_shentsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf32_Shdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name> <operator>=</operator> <name>nshdr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_shstrndx</name></name> <operator>=</operator> <name>ESHDR_SHSTRTAB</name></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>elf_file</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nshdr</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf32_Shdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>shp</name> <operator>=</operator> <operator>&amp;</operator><name><name>elf_file</name><operator>.</operator><name>shdr</name><index>[<expr><name>ESHDR_SHSTRTAB</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>=</operator> <name>SHT_STRTAB</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>DTRACE_SHSTRTAB32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_addralign</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>+</operator> <name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>shp</name> <operator>=</operator> <operator>&amp;</operator><name><name>elf_file</name><operator>.</operator><name>shdr</name><index>[<expr><name>ESHDR_DOF</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>=</operator> <name>SHF_ALLOC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>=</operator> <name>SHT_SUNW_dof</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>=</operator> <name><name>dof</name><operator>-&gt;</operator><name>dofh_filesz</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_addralign</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>+</operator> <name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>shp</name> <operator>=</operator> <operator>&amp;</operator><name><name>elf_file</name><operator>.</operator><name>shdr</name><index>[<expr><name>ESHDR_STRTAB</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>=</operator> <literal type="number">21</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>=</operator> <name>SHF_ALLOC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>=</operator> <name>SHT_STRTAB</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>=</operator> <name><name>de</name><operator>.</operator><name>de_strlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_addralign</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>+</operator> <name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>shp</name> <operator>=</operator> <operator>&amp;</operator><name><name>elf_file</name><operator>.</operator><name>shdr</name><index>[<expr><name>ESHDR_SYMTAB</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>=</operator> <literal type="number">29</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>=</operator> <name>SHF_ALLOC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>=</operator> <name>SHT_SYMTAB</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_entsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf32_Sym</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_link</name></name> <operator>=</operator> <name>ESHDR_STRTAB</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_info</name></name> <operator>=</operator> <name><name>de</name><operator>.</operator><name>de_global</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>=</operator> <name><name>de</name><operator>.</operator><name>de_nsym</name></name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf32_Sym</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_addralign</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>+</operator> <name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>de</name><operator>.</operator><name>de_nrel</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_write</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elf_file</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>elf_file</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>elf_file</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_SHSTRTAB</name></expr></argument>, <argument><expr><name>DTRACE_SHSTRTAB32</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_STRTAB</name></expr></argument>, <argument><expr><name><name>de</name><operator>.</operator><name>de_strtab</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_SYMTAB</name></expr></argument>, <argument><expr><name><name>de</name><operator>.</operator><name>de_sym</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_DOF</name></expr></argument>, <argument><expr><name>dof</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>shp</name> <operator>=</operator> <operator>&amp;</operator><name><name>elf_file</name><operator>.</operator><name>shdr</name><index>[<expr><name>ESHDR_REL</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>=</operator> <name>SHF_ALLOC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>=</operator> <name>SHT_REL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_entsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>de</name><operator>.</operator><name>de_rel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_link</name></name> <operator>=</operator> <name>ESHDR_SYMTAB</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_info</name></name> <operator>=</operator> <name>ESHDR_DOF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>=</operator> <name><name>de</name><operator>.</operator><name>de_nrel</name></name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>de</name><operator>.</operator><name>de_rel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_addralign</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_write</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elf_file</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>elf_file</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>elf_file</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_SHSTRTAB</name></expr></argument>, <argument><expr><name>DTRACE_SHSTRTAB32</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_STRTAB</name></expr></argument>, <argument><expr><name><name>de</name><operator>.</operator><name>de_strtab</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_SYMTAB</name></expr></argument>, <argument><expr><name><name>de</name><operator>.</operator><name>de_sym</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_REL</name></expr></argument>, <argument><expr><name><name>de</name><operator>.</operator><name>de_rel</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_DOF</name></expr></argument>, <argument><expr><name>dof</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>de</name><operator>.</operator><name>de_strtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>de</name><operator>.</operator><name>de_sym</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>de</name><operator>.</operator><name>de_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dump_elf64</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dof_hdr_t</name> <modifier>*</modifier></type><name>dof</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<struct>struct <block>{
<decl_stmt><decl><type><name>Elf64_Ehdr</name></type> <name>ehdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Shdr</name></type> <name><name>shdr</name><index>[<expr><name>ESHDR_NUM</name></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>elf_file</name></decl>;</struct>
<decl_stmt><decl><type><name>Elf64_Shdr</name> <modifier>*</modifier></type><name>shp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Off</name></type> <name>off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dof_elf64_t</name></type> <name>de</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>nshdr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>prepare_elf64</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dof</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>de</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>nshdr</name> <operator>=</operator> <ternary><condition><expr><name><name>de</name><operator>.</operator><name>de_nrel</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ESHDR_SYMTAB</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>ESHDR_NUM</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elf_file</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>elf_file</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_MAG0</name></expr>]</index></name> <operator>=</operator> <name>ELFMAG0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_MAG1</name></expr>]</index></name> <operator>=</operator> <name>ELFMAG1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_MAG2</name></expr>]</index></name> <operator>=</operator> <name>ELFMAG2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_MAG3</name></expr>]</index></name> <operator>=</operator> <name>ELFMAG3</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_VERSION</name></expr>]</index></name> <operator>=</operator> <name>EV_CURRENT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name> <operator>=</operator> <name>ELFCLASS64</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BYTE_ORDER</name> <operator>==</operator> <name>_BIG_ENDIAN</name></expr></cpp:if>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name> <operator>=</operator> <name>ELFDATA2MSB</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name> <operator>=</operator> <name>ELFDATA2LSB</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_OSABI</name></expr>]</index></name> <operator>=</operator> <name>ELFOSABI_FREEBSD</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name> <operator>=</operator> <name>ET_REL</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__arm__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_ARM</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__mips__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_MIPS</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__powerpc64__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_CALL_ELF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_CALL_ELF</name> <operator>==</operator> <literal type="number">2</literal></expr></cpp:if>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_flags</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_PPC64</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__i386</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__amd64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_AMD64</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__aarch64__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_AARCH64</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_version</name></name> <operator>=</operator> <name>EV_CURRENT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf64_Ehdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_ehsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf64_Ehdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_phentsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf64_Phdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_shentsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf64_Shdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name> <operator>=</operator> <name>nshdr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>elf_file</name><operator>.</operator><name>ehdr</name><operator>.</operator><name>e_shstrndx</name></name> <operator>=</operator> <name>ESHDR_SHSTRTAB</name></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>elf_file</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>nshdr</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf64_Shdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>shp</name> <operator>=</operator> <operator>&amp;</operator><name><name>elf_file</name><operator>.</operator><name>shdr</name><index>[<expr><name>ESHDR_SHSTRTAB</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>=</operator> <name>SHT_STRTAB</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>DTRACE_SHSTRTAB64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_addralign</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>+</operator> <name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>shp</name> <operator>=</operator> <operator>&amp;</operator><name><name>elf_file</name><operator>.</operator><name>shdr</name><index>[<expr><name>ESHDR_DOF</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>=</operator> <name>SHF_ALLOC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>=</operator> <name>SHT_SUNW_dof</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>=</operator> <name><name>dof</name><operator>-&gt;</operator><name>dofh_filesz</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_addralign</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>+</operator> <name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>shp</name> <operator>=</operator> <operator>&amp;</operator><name><name>elf_file</name><operator>.</operator><name>shdr</name><index>[<expr><name>ESHDR_STRTAB</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>=</operator> <literal type="number">21</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>=</operator> <name>SHF_ALLOC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>=</operator> <name>SHT_STRTAB</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>=</operator> <name><name>de</name><operator>.</operator><name>de_strlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_addralign</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>+</operator> <name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>shp</name> <operator>=</operator> <operator>&amp;</operator><name><name>elf_file</name><operator>.</operator><name>shdr</name><index>[<expr><name>ESHDR_SYMTAB</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>=</operator> <literal type="number">29</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>=</operator> <name>SHF_ALLOC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>=</operator> <name>SHT_SYMTAB</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_entsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf64_Sym</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_link</name></name> <operator>=</operator> <name>ESHDR_STRTAB</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_info</name></name> <operator>=</operator> <name><name>de</name><operator>.</operator><name>de_global</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>=</operator> <name><name>de</name><operator>.</operator><name>de_nsym</name></name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf64_Sym</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_addralign</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>roundup2</name><argument_list>(<argument><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>+</operator> <name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>de</name><operator>.</operator><name>de_nrel</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_write</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elf_file</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>elf_file</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>elf_file</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_SHSTRTAB</name></expr></argument>, <argument><expr><name>DTRACE_SHSTRTAB64</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_STRTAB</name></expr></argument>, <argument><expr><name><name>de</name><operator>.</operator><name>de_strtab</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_SYMTAB</name></expr></argument>, <argument><expr><name><name>de</name><operator>.</operator><name>de_sym</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_DOF</name></expr></argument>, <argument><expr><name>dof</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>shp</name> <operator>=</operator> <operator>&amp;</operator><name><name>elf_file</name><operator>.</operator><name>shdr</name><index>[<expr><name>ESHDR_REL</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_flags</name></name> <operator>=</operator> <name>SHF_ALLOC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>=</operator> <name>SHT_RELA</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_entsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>de</name><operator>.</operator><name>de_rel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_link</name></name> <operator>=</operator> <name>ESHDR_SYMTAB</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_info</name></name> <operator>=</operator> <name>ESHDR_DOF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>=</operator> <name><name>de</name><operator>.</operator><name>de_nrel</name></name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>de</name><operator>.</operator><name>de_rel</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shp</name><operator>-&gt;</operator><name>sh_addralign</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_write</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elf_file</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>elf_file</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>elf_file</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_SHSTRTAB</name></expr></argument>, <argument><expr><name>DTRACE_SHSTRTAB64</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_STRTAB</name></expr></argument>, <argument><expr><name><name>de</name><operator>.</operator><name>de_strtab</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_SYMTAB</name></expr></argument>, <argument><expr><name><name>de</name><operator>.</operator><name>de_sym</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_REL</name></expr></argument>, <argument><expr><name><name>de</name><operator>.</operator><name>de_rel</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>PWRITE_SCN</name><argument_list>(<argument><expr><name>ESHDR_DOF</name></expr></argument>, <argument><expr><name>dof</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>de</name><operator>.</operator><name>de_strtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>de</name><operator>.</operator><name>de_sym</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>de</name><operator>.</operator><name>de_rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_symtab_lookup</name><parameter_list>(<parameter><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data_sym</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>end</name></decl></parameter>, <parameter><decl><type><name>uintptr_t</name></type> <name>addr</name></decl></parameter>,
<parameter><decl><type><name>uint_t</name></type> <name>shn</name></decl></parameter>, <parameter><decl><type><name>GElf_Sym</name> <modifier>*</modifier></type><name>sym</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>uses_funcdesc</name></decl></parameter>, <parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf64_Addr</name></type> <name>symval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>opd_scn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>opd_desc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>end</name> <operator>&amp;&amp;</operator> <call><name>gelf_getsym</name><argument_list>(<argument><expr><name>data_sym</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>GELF_ST_TYPE</name><argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STT_FUNC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>symval</name> <operator>=</operator> <name><name>sym</name><operator>-&gt;</operator><name>st_value</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>uses_funcdesc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>opd_scn</name> <operator>=</operator> <call><name>elf_getscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>opd_desc</name> <operator>=</operator> <call><name>elf_rawdata</name><argument_list>(<argument><expr><name>opd_scn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>symval</name> <operator>=</operator>
<operator>*</operator><operator>(</operator><name>uint64_t</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>opd_desc</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>+</operator> <name>symval</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>uses_funcdesc</name> <operator>||</operator> <name>shn</name> <operator>==</operator> <name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
<name>symval</name> <operator>&lt;=</operator> <name>addr</name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name>symval</name> <operator>+</operator> <name><name>sym</name><operator>-&gt;</operator><name>st_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__aarch64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_NOP</name></cpp:macro> <cpp:value>0xd503201f</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_RET</name></cpp:macro> <cpp:value>0xd65f03c0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_CALL26</name></cpp:macro> <cpp:value>0x94000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_JUMP26</name></cpp:macro> <cpp:value>0x14000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_REL_NONE</name></cpp:macro> <cpp:value>R_AARCH64_NONE</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_modtext</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isenabled</name></decl></parameter>, <parameter><decl><type><name>GElf_Rela</name> <modifier>*</modifier></type><name>rela</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rela</name><operator>-&gt;</operator><name>r_offset</name></name> <operator>&amp;</operator> <operator>(</operator><sizeof>sizeof <argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>GELF_R_TYPE</name><argument_list>(<argument><expr><name><name>rela</name><operator>-&gt;</operator><name>r_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_AARCH64_CALL26</name> <operator>&amp;&amp;</operator>
<call><name>GELF_R_TYPE</name><argument_list>(<argument><expr><name><name>rela</name><operator>-&gt;</operator><name>r_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_AARCH64_JUMP26</name> <operator>&amp;&amp;</operator>
<call><name>GELF_R_TYPE</name><argument_list>(<argument><expr><name><name>rela</name><operator>-&gt;</operator><name>r_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_AARCH64_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ip</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>p</name> <operator>+</operator> <name><name>rela</name><operator>-&gt;</operator><name>r_offset</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_NOP</name> <operator>||</operator> <name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_RET</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>DT_OP_CALL26</name> <operator>&amp;&amp;</operator> <name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>DT_OP_JUMP26</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"found %x instead of a call or jmp instruction at "</literal>
<literal type="string">"%llx\n"</literal></expr></argument>, <argument><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name><name>rela</name><operator>-&gt;</operator><name>r_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_CALL26</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_NOP</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_RET</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__arm__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_REL_NONE</name></cpp:macro> <cpp:value>R_ARM_NONE</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_modtext</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isenabled</name></decl></parameter>, <parameter><decl><type><name>GElf_Rela</name> <modifier>*</modifier></type><name>rela</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%s(%d): arm not implemented\n"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>,
<argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__mips__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_REL_NONE</name></cpp:macro> <cpp:value>R_MIPS_NONE</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_modtext</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isenabled</name></decl></parameter>, <parameter><decl><type><name>GElf_Rela</name> <modifier>*</modifier></type><name>rela</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%s(%d): MIPS not implemented\n"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>,
<argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__powerpc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_XOR_R3</name></cpp:macro> <cpp:value>0x7c631a78</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_NOP</name></cpp:macro> <cpp:value>0x60000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_BLR</name></cpp:macro> <cpp:value>0x4e800020</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_IS_BRANCH</name><parameter_list>(<parameter><type><name>inst</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((inst &amp; 0xfc000000) == 0x48000000)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_IS_BL</name><parameter_list>(<parameter><type><name>inst</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(DT_IS_BRANCH(inst) &amp;&amp; (inst &amp; 0x01))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_REL_NONE</name></cpp:macro> <cpp:value>R_PPC_NONE</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_modtext</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isenabled</name></decl></parameter>, <parameter><decl><type><name>GElf_Rela</name> <modifier>*</modifier></type><name>rela</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>rela</name><operator>-&gt;</operator><name>r_offset</name></name> <operator>&amp;</operator> <operator>(</operator><sizeof>sizeof <argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ip</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>p</name> <operator>+</operator> <name><name>rela</name><operator>-&gt;</operator><name>r_offset</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>GELF_R_TYPE</name><argument_list>(<argument><expr><name><name>rela</name><operator>-&gt;</operator><name>r_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_PPC_REL24</name> <operator>&amp;&amp;</operator>
<call><name>GELF_R_TYPE</name><argument_list>(<argument><expr><name><name>rela</name><operator>-&gt;</operator><name>r_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_PPC_PLTREL24</name> <operator>&amp;&amp;</operator>
<call><name>GELF_R_TYPE</name><argument_list>(<argument><expr><name><name>rela</name><operator>-&gt;</operator><name>r_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_PPC_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>isenabled</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_XOR_R3</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>off</name><operator>)</operator> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_NOP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>off</name><operator>)</operator> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DT_IS_BRANCH</name><argument_list>(<argument><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"found %x instead of a branch instruction at %llx\n"</literal></expr></argument>,
<argument><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name><name>rela</name><operator>-&gt;</operator><name>r_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>isenabled</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>DT_IS_BL</name><argument_list>(<argument><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"tail call to is-enabled probe at %llx\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name><name>rela</name><operator>-&gt;</operator><name>r_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_XOR_R3</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>off</name><operator>)</operator> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>DT_IS_BL</name><argument_list>(<argument><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_NOP</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_BLR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__riscv</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_REL_NONE</name></cpp:macro> <cpp:value>R_RISCV_NONE</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_modtext</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isenabled</name></decl></parameter>, <parameter><decl><type><name>GElf_Rela</name> <modifier>*</modifier></type><name>rela</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s:%s(%d): RISC-V implementation required\n"</literal></expr></argument>, <argument><expr><name>__FUNCTION__</name></expr></argument>,
<argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__i386</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__amd64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_NOP</name></cpp:macro> <cpp:value>0x90</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_RET</name></cpp:macro> <cpp:value>0xc3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_CALL</name></cpp:macro> <cpp:value>0xe8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_JMP32</name></cpp:macro> <cpp:value>0xe9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_REX_RAX</name></cpp:macro> <cpp:value>0x48</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_XOR_EAX_0</name></cpp:macro> <cpp:value>0x33</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_OP_XOR_EAX_1</name></cpp:macro> <cpp:value>0xc0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_REL_NONE</name></cpp:macro> <cpp:value>R_386_NONE</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_modtext</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isenabled</name></decl></parameter>, <parameter><decl><type><name>GElf_Rela</name> <modifier>*</modifier></type><name>rela</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>off</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>ip</name> <init>= <expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>p</name> <operator>+</operator> <name><name>rela</name><operator>-&gt;</operator><name>r_offset</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>ret</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>off</name><operator>)</operator> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>GELF_R_TYPE</name><argument_list>(<argument><expr><name><name>rela</name><operator>-&gt;</operator><name>r_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_386_PC32</name> <operator>&amp;&amp;</operator>
<call><name>GELF_R_TYPE</name><argument_list>(<argument><expr><name><name>rela</name><operator>-&gt;</operator><name>r_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_386_PLT32</name> <operator>&amp;&amp;</operator>
<call><name>GELF_R_TYPE</name><argument_list>(<argument><expr><name><name>rela</name><operator>-&gt;</operator><name>r_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_386_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isenabled</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_NOP</name> <operator>||</operator> <name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_RET</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>ip</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_NOP</name> <operator>&amp;&amp;</operator> <name><name>ip</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_NOP</name> <operator>&amp;&amp;</operator>
<name><name>ip</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_NOP</name> <operator>&amp;&amp;</operator> <name><name>ip</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_NOP</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_oflags</name></name> <operator>&amp;</operator> <name>DTRACE_O_LP64</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_REX_RAX</name> <operator>&amp;&amp;</operator>
<name><name>ip</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_XOR_EAX_0</name> <operator>&amp;&amp;</operator> <name><name>ip</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_XOR_EAX_1</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>ip</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_NOP</name> <operator>||</operator> <name><name>ip</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_RET</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>ip</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_NOP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>off</name><operator>)</operator> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_XOR_EAX_0</name> <operator>&amp;&amp;</operator> <name><name>ip</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_XOR_EAX_1</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>ip</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_NOP</name> <operator>||</operator> <name><name>ip</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_RET</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>ip</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_NOP</name> <operator>&amp;&amp;</operator> <name><name>ip</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_NOP</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>off</name><operator>)</operator> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>DT_OP_CALL</name> <operator>&amp;&amp;</operator> <name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>DT_OP_JMP32</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"found %x instead of a call or jmp instruction at "</literal>
<literal type="string">"%llx\n"</literal></expr></argument>, <argument><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name><name>rela</name><operator>-&gt;</operator><name>r_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>DT_OP_JMP32</name><operator>)</operator></expr> ?</condition><then> <expr><name>DT_OP_RET</name></expr> </then><else>: <expr><name>DT_OP_NOP</name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isenabled</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_NOP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_NOP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_NOP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_NOP</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_oflags</name></name> <operator>&amp;</operator> <name>DTRACE_O_LP64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_REX_RAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_XOR_EAX_0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_XOR_EAX_1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_NOP</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>off</name><operator>)</operator> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_XOR_EAX_0</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_XOR_EAX_1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_NOP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ip</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>DT_OP_NOP</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>off</name><operator>)</operator> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> unknown ISA</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_link_error</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>dt_link_pair_t</name> <modifier>*</modifier></type><name>bufs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_link_pair_t</name> <modifier>*</modifier></type><name>pair</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_set_errmsg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>elf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_end</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>(</operator><name>pair</name> <operator>=</operator> <name>bufs</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bufs</name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>dlp_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>dlp_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>dlp_sym</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>hash_obj</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>h</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>realpath</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>h</name> <operator>=</operator> <literal type="number">2166136261u</literal></expr><operator>,</operator> <expr><name>obj</name> <operator>=</operator> <operator>&amp;</operator><name><name>path</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>obj</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>obj</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>h</name> <operator>=</operator> <operator>(</operator><name>h</name> <operator>^</operator> <operator>*</operator><name>obj</name><operator>)</operator> <operator>*</operator> <literal type="number">16777619</literal></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>h</name> <operator>&amp;=</operator> <literal type="number">0x7fffffff</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>h</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>process_obj</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>eprobesp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>dt_prefix</name><index>[]</index></name> <init>= <expr><literal type="string">"__dtrace"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>dt_enabled</name><index>[]</index></name> <init>= <expr><literal type="string">"enabled"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>dt_symprefix</name><index>[]</index></name> <init>= <expr><literal type="string">"$dtrace"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>dt_symfmt</name><index>[]</index></name> <init>= <expr><literal type="string">"%s%u.%s"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>dt_weaksymfmt</name><index>[]</index></name> <init>= <expr><literal type="string">"%s.%s"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>probename</name><index>[<expr><name>DTRACE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>ndx</name></decl>, <decl><type ref="prev"/><name>eprobe</name></decl>, <decl><type ref="prev"/><name>uses_funcdesc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>mod</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf</name> <modifier>*</modifier></type><name>elf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Ehdr</name></type> <name>ehdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Scn</name> <modifier>*</modifier></type><name>scn_rel</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>scn_sym</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>scn_str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>scn_tgt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf_Data</name> <modifier>*</modifier></type><name>data_rel</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data_sym</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data_str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>data_tgt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Shdr</name></type> <name>shdr_rel</name></decl>, <decl><type ref="prev"/><name>shdr_sym</name></decl>, <decl><type ref="prev"/><name>shdr_str</name></decl>, <decl><type ref="prev"/><name>shdr_tgt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>rsym</name></decl>, <decl><type ref="prev"/><name>fsym</name></decl>, <decl><type ref="prev"/><name>dsym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Rela</name></type> <name>rela</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>pname</name><index>[<expr><name>DTRACE_PROVNAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_provider_t</name> <modifier>*</modifier></type><name>pvp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_probe_t</name> <modifier>*</modifier></type><name>prp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>off</name></decl>, <decl><type ref="prev"/><name>eclass</name></decl>, <decl><type ref="prev"/><name>emachine1</name></decl>, <decl><type ref="prev"/><name>emachine2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>symsize</name></decl>, <decl><type ref="prev"/><name>osym</name></decl>, <decl><type ref="prev"/><name>nsym</name></decl>, <decl><type ref="prev"/><name>isym</name></decl>, <decl><type ref="prev"/><name>istr</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>objkey</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_link_pair_t</name> <modifier>*</modifier></type><name>pair</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bufs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_strtab_t</name> <modifier>*</modifier></type><name>strtab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open64</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>,
<argument><expr><literal type="string">"failed to open %s: %s"</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>elf</name> <operator>=</operator> <call><name>elf_begin</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ELF_C_RDWR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>,
<argument><expr><literal type="string">"failed to process %s: %s"</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><call><name>elf_errmsg</name><argument_list>(<argument><expr><call><name>elf_errno</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>elf_kind</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ELF_K_ELF</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>ELF_K_AR</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>, <argument><expr><literal type="string">"archives are not "</literal>
<literal type="string">"permitted; use the contents of the archive instead: %s"</literal></expr></argument>,
<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<default>default:</default>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>,
<argument><expr><literal type="string">"invalid file type: %s"</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getehdr</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ehdr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>, <argument><expr><literal type="string">"corrupt file: %s"</literal></expr></argument>,
<argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_oflags</name></name> <operator>&amp;</operator> <name>DTRACE_O_LP64</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>eclass</name> <operator>=</operator> <name>ELFCLASS64</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__mips__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>emachine1</name> <operator>=</operator> <name>emachine2</name> <operator>=</operator> <name>EM_MIPS</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__powerpc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>emachine1</name> <operator>=</operator> <name>emachine2</name> <operator>=</operator> <name>EM_PPC64</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_CALL_ELF</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>_CALL_ELF</name> <operator>==</operator> <literal type="number">1</literal></expr></cpp:if>
<expr_stmt><expr><name>uses_funcdesc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__i386</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__amd64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>emachine1</name> <operator>=</operator> <name>emachine2</name> <operator>=</operator> <name>EM_AMD64</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__aarch64__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>emachine1</name> <operator>=</operator> <name>emachine2</name> <operator>=</operator> <name>EM_AARCH64</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>symsize</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf64_Sym</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>eclass</name> <operator>=</operator> <name>ELFCLASS32</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__arm__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>emachine1</name> <operator>=</operator> <name>emachine2</name> <operator>=</operator> <name>EM_ARM</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__mips__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>emachine1</name> <operator>=</operator> <name>emachine2</name> <operator>=</operator> <name>EM_MIPS</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__powerpc__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>emachine1</name> <operator>=</operator> <name>emachine2</name> <operator>=</operator> <name>EM_PPC</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__i386</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__amd64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<expr_stmt><expr><name>emachine1</name> <operator>=</operator> <name>emachine2</name> <operator>=</operator> <name>EM_386</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>symsize</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>Elf32_Sym</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name> <operator>!=</operator> <name>eclass</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>,
<argument><expr><literal type="string">"incorrect ELF class for object file: %s"</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>!=</operator> <name>emachine1</name> <operator>&amp;&amp;</operator> <name><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>!=</operator> <name>emachine2</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>,
<argument><expr><literal type="string">"incorrect ELF machine type for object file: %s"</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>objkey</name> <operator>=</operator> <call><name>hash_obj</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>,
<argument><expr><literal type="string">"failed to generate unique key for object file: %s"</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>scn_rel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>scn_rel</name> <operator>=</operator> <call><name>elf_nextscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>scn_rel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getshdr</name><argument_list>(<argument><expr><name>scn_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shdr_rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>shdr_rel</name><operator>.</operator><name>sh_type</name></name> <operator>!=</operator> <name>SHT_RELA</name> <operator>&amp;&amp;</operator> <name><name>shdr_rel</name><operator>.</operator><name>sh_type</name></name> <operator>!=</operator> <name>SHT_REL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>data_rel</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name>scn_rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>scn_sym</name> <operator>=</operator> <call><name>elf_getscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name><name>shdr_rel</name><operator>.</operator><name>sh_link</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>gelf_getshdr</name><argument_list>(<argument><expr><name>scn_sym</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shdr_sym</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<operator>(</operator><name>data_sym</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name>scn_sym</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>scn_str</name> <operator>=</operator> <call><name>elf_getscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name><name>shdr_sym</name><operator>.</operator><name>sh_link</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>gelf_getshdr</name><argument_list>(<argument><expr><name>scn_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shdr_str</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<operator>(</operator><name>data_str</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name>scn_str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>scn_tgt</name> <operator>=</operator> <call><name>elf_getscn</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name><name>shdr_rel</name><operator>.</operator><name>sh_info</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<call><name>gelf_getshdr</name><argument_list>(<argument><expr><name>scn_tgt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shdr_tgt</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<operator>(</operator><name>data_tgt</name> <operator>=</operator> <call><name>elf_getdata</name><argument_list>(<argument><expr><name>scn_tgt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>strtab</name> <operator>=</operator> <call><name>dt_strtab_create</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nsym</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>isym</name> <operator>=</operator> <name><name>data_sym</name><operator>-&gt;</operator><name>d_size</name></name> <operator>/</operator> <name>symsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>istr</name> <operator>=</operator> <name><name>data_str</name><operator>-&gt;</operator><name>d_size</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>shdr_rel</name><operator>.</operator><name>sh_size</name></name> <operator>/</operator> <name><name>shdr_rel</name><operator>.</operator><name>sh_entsize</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>shdr_rel</name><operator>.</operator><name>sh_type</name></name> <operator>==</operator> <name>SHT_RELA</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getrela</name><argument_list>(<argument><expr><name>data_rel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rela</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>GElf_Rel</name></type> <name>rel</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getrel</name><argument_list>(<argument><expr><name>data_rel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>rela</name><operator>.</operator><name>r_offset</name></name> <operator>=</operator> <name><name>rel</name><operator>.</operator><name>r_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rela</name><operator>.</operator><name>r_info</name></name> <operator>=</operator> <name><name>rel</name><operator>.</operator><name>r_info</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rela</name><operator>.</operator><name>r_addend</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getsym</name><argument_list>(<argument><expr><name>data_sym</name></expr></argument>, <argument><expr><call><name>GELF_R_SYM</name><argument_list>(<argument><expr><name><name>rela</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>&amp;</operator><name>rsym</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_strtab_destroy</name><argument_list>(<argument><expr><name>strtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>data_str</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>+</operator> <name><name>rsym</name><operator>.</operator><name>st_name</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dt_prefix</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_prefix</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_symtab_lookup</name><argument_list>(<argument><expr><name>data_sym</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>isym</name></expr></argument>, <argument><expr><name><name>rela</name><operator>.</operator><name>r_offset</name></name></expr></argument>,
<argument><expr><name><name>shdr_rel</name><operator>.</operator><name>sh_info</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsym</name></expr></argument>, <argument><expr><name>uses_funcdesc</name></expr></argument>,
<argument><expr><name>elf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_strtab_destroy</name><argument_list>(<argument><expr><name>strtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fsym</name><operator>.</operator><name>st_name</name></name> <operator>&gt;</operator> <name><name>data_str</name><operator>-&gt;</operator><name>d_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_strtab_destroy</name><argument_list>(<argument><expr><name>strtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>data_str</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>+</operator> <name><name>fsym</name><operator>.</operator><name>st_name</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>GELF_ST_TYPE</name><argument_list>(<argument><expr><name><name>fsym</name><operator>.</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STT_FUNC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_strtab_destroy</name><argument_list>(<argument><expr><name>strtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>,
<argument><expr><literal type="string">"expected %s to be of type function"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>GELF_ST_BIND</name><argument_list>(<argument><expr><name><name>fsym</name><operator>.</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STB_WEAK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dt_weaksymfmt</name></expr></argument>,
<argument><expr><name>dt_symprefix</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dt_symfmt</name></expr></argument>, <argument><expr><name>dt_symprefix</name></expr></argument>,
<argument><expr><name>objkey</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_strtab_destroy</name><argument_list>(<argument><expr><name>strtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>GELF_ST_BIND</name><argument_list>(<argument><expr><name><name>fsym</name><operator>.</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STB_WEAK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>dt_weaksymfmt</name></expr></argument>,
<argument><expr><name>dt_symprefix</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>dt_symfmt</name></expr></argument>, <argument><expr><name>dt_symprefix</name></expr></argument>,
<argument><expr><name>objkey</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_strtab_index</name><argument_list>(<argument><expr><name>strtab</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>GELF_R_TYPE</name><argument_list>(<argument><expr><name><name>rela</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DT_REL_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nsym</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_strtab_insert</name><argument_list>(<argument><expr><name>strtab</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>osym</name> <operator>=</operator> <name>isym</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nsym</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>dt_strtab_size</name><argument_list>(<argument><expr><name>strtab</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>dt_strtab_index</name><argument_list>(<argument><expr><name>strtab</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_strtab_destroy</name><argument_list>(<argument><expr><name>strtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pair</name> <operator>=</operator> <call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>pair</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pair</name><operator>-&gt;</operator><name>dlp_str</name></name> <operator>=</operator> <call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>data_str</name><operator>-&gt;</operator><name>d_size</name></name> <operator>+</operator>
<name>len</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pair</name><operator>-&gt;</operator><name>dlp_sym</name></name> <operator>=</operator> <call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>data_sym</name><operator>-&gt;</operator><name>d_size</name></name> <operator>+</operator>
<name>nsym</name> <operator>*</operator> <name>symsize</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>dlp_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>dlp_next</name></name> <operator>=</operator> <name>bufs</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bufs</name> <operator>=</operator> <name>pair</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name><name>data_str</name><operator>-&gt;</operator><name>d_buf</name></name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>dlp_str</name></name></expr></argument>, <argument><expr><name><name>data_str</name><operator>-&gt;</operator><name>d_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>data_str</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data_str</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>dlp_str</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>dlp_str</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data_str</name><operator>-&gt;</operator><name>d_size</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_flagdata</name><argument_list>(<argument><expr><name>data_str</name></expr></argument>, <argument><expr><name>ELF_C_SET</name></expr></argument>, <argument><expr><name>ELF_F_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shdr_str</name><operator>.</operator><name>sh_size</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>gelf_update_shdr</name><argument_list>(<argument><expr><name>scn_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shdr_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name><name>data_sym</name><operator>-&gt;</operator><name>d_buf</name></name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>dlp_sym</name></name></expr></argument>, <argument><expr><name><name>data_sym</name><operator>-&gt;</operator><name>d_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name><name>data_sym</name><operator>-&gt;</operator><name>d_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data_sym</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>dlp_sym</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>dlp_sym</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data_sym</name><operator>-&gt;</operator><name>d_size</name></name> <operator>+=</operator> <name>nsym</name> <operator>*</operator> <name>symsize</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_flagdata</name><argument_list>(<argument><expr><name>data_sym</name></expr></argument>, <argument><expr><name>ELF_C_SET</name></expr></argument>, <argument><expr><name>ELF_F_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>shdr_sym</name><operator>.</operator><name>sh_size</name></name> <operator>+=</operator> <name>nsym</name> <operator>*</operator> <name>symsize</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>gelf_update_shdr</name><argument_list>(<argument><expr><name>scn_sym</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shdr_sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nsym</name> <operator>+=</operator> <name>isym</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>dt_strtab_empty</name><argument_list>(<argument><expr><name>strtab</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_strtab_destroy</name><argument_list>(<argument><expr><name>strtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>shdr_rel</name><operator>.</operator><name>sh_size</name></name> <operator>/</operator> <name><name>shdr_rel</name><operator>.</operator><name>sh_entsize</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>shdr_rel</name><operator>.</operator><name>sh_type</name></name> <operator>==</operator> <name>SHT_RELA</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getrela</name><argument_list>(<argument><expr><name>data_rel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rela</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>GElf_Rel</name></type> <name>rel</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getrel</name><argument_list>(<argument><expr><name>data_rel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rel</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>rela</name><operator>.</operator><name>r_offset</name></name> <operator>=</operator> <name><name>rel</name><operator>.</operator><name>r_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rela</name><operator>.</operator><name>r_info</name></name> <operator>=</operator> <name><name>rel</name><operator>.</operator><name>r_info</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rela</name><operator>.</operator><name>r_addend</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>ndx</name> <operator>=</operator> <call><name>GELF_R_SYM</name><argument_list>(<argument><expr><name><name>rela</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>gelf_getsym</name><argument_list>(<argument><expr><name>data_sym</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rsym</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<name><name>rsym</name><operator>.</operator><name>st_name</name></name> <operator>&gt;</operator> <name><name>data_str</name><operator>-&gt;</operator><name>d_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>data_str</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>+</operator> <name><name>rsym</name><operator>.</operator><name>st_name</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dt_prefix</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_prefix</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>s</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>dt_prefix</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dt_enabled</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_enabled</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>dt_enabled</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>eprobe</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>eprobesp</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"is-enabled probe\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>eprobe</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"normal probe\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name><operator>++</operator> <operator>!=</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"___"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<name>p</name> <operator>-</operator> <name>s</name> <operator>&gt;=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>pname</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pname</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pname</name><index>[<expr><name>p</name> <operator>-</operator> <name>s</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_symtab_lookup</name><argument_list>(<argument><expr><name>data_sym</name></expr></argument>, <argument><expr><name>osym</name></expr></argument>, <argument><expr><name>isym</name></expr></argument>,
<argument><expr><name><name>rela</name><operator>.</operator><name>r_offset</name></name></expr></argument>, <argument><expr><name><name>shdr_rel</name><operator>.</operator><name>sh_info</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsym</name></expr></argument>,
<argument><expr><name>uses_funcdesc</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fsym</name><operator>.</operator><name>st_name</name></name> <operator>&gt;</operator> <name><name>data_str</name><operator>-&gt;</operator><name>d_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>data_str</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>+</operator> <name><name>fsym</name><operator>.</operator><name>st_name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>strstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>dt_symprefix</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>dt_symtab_lookup</name><argument_list>(<argument><expr><name>data_sym</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>osym</name></expr></argument>,
<argument><expr><name><name>rela</name><operator>.</operator><name>r_offset</name></name></expr></argument>, <argument><expr><name><name>shdr_rel</name><operator>.</operator><name>sh_info</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsym</name></expr></argument>,
<argument><expr><name>uses_funcdesc</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>u_int</name></type> <name>bind</name></decl>;</decl_stmt>
<expr_stmt><expr><name>bind</name> <operator>=</operator> <ternary><condition><expr><call><name>GELF_ST_BIND</name><argument_list>(<argument><expr><name><name>fsym</name><operator>.</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STB_WEAK</name></expr> ?</condition><then>
<expr><name>STB_WEAK</name></expr> </then><else>: <expr><name>STB_GLOBAL</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>data_str</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>+</operator> <name><name>fsym</name><operator>.</operator><name>st_name</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>GELF_R_TYPE</name><argument_list>(<argument><expr><name><name>rela</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>DT_REL_NONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dsym</name> <operator>=</operator> <name>fsym</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsym</name><operator>.</operator><name>st_name</name></name> <operator>=</operator> <name>istr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsym</name><operator>.</operator><name>st_info</name></name> <operator>=</operator> <call><name>GELF_ST_INFO</name><argument_list>(<argument><expr><name>bind</name></expr></argument>,
<argument><expr><name>STT_FUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsym</name><operator>.</operator><name>st_other</name></name> <operator>=</operator>
<call><name>GELF_ST_VISIBILITY</name><argument_list>(<argument><expr><name>STV_HIDDEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>gelf_update_sym</name><argument_list>(<argument><expr><name>data_sym</name></expr></argument>, <argument><expr><name>isym</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>dsym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>isym</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>isym</name> <operator>&lt;=</operator> <name>nsym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>data_str</name><operator>-&gt;</operator><name>d_buf</name></name> <operator>+</operator> <name>istr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bind</name> <operator>==</operator> <name>STB_WEAK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>istr</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>r</name></expr></argument>,
<argument><expr><name>dt_weaksymfmt</name></expr></argument>, <argument><expr><name>dt_symprefix</name></expr></argument>,
<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>istr</name> <operator>+=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>dt_symfmt</name></expr></argument>,
<argument><expr><name>dt_symprefix</name></expr></argument>, <argument><expr><name>objkey</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>istr</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bind</name> <operator>==</operator> <name>STB_WEAK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>asprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>,
<argument><expr><name>dt_weaksymfmt</name></expr></argument>, <argument><expr><name>dt_symprefix</name></expr></argument>,
<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>asprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>r</name></expr></argument>, <argument><expr><name>dt_symfmt</name></expr></argument>,
<argument><expr><name>dt_symprefix</name></expr></argument>, <argument><expr><name>objkey</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pvp</name> <operator>=</operator> <call><name>dt_provider_lookup</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>,
<argument><expr><literal type="string">"no such provider %s"</literal></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>probename</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>probename</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;=</operator>
<sizeof>sizeof <argument_list>(<argument><expr><name>probename</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>,
<argument><expr><literal type="string">"invalid probe name %s"</literal></expr></argument>, <argument><expr><name>probename</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strhyphenate</name><argument_list>(<argument><expr><name>probename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>prp</name> <operator>=</operator> <call><name>dt_probe_lookup</name><argument_list>(<argument><expr><name>pvp</name></expr></argument>, <argument><expr><name>probename</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>,
<argument><expr><literal type="string">"no such probe %s"</literal></expr></argument>, <argument><expr><name>probename</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>fsym</name><operator>.</operator><name>st_value</name></name> <operator>&lt;=</operator> <name><name>rela</name><operator>.</operator><name>r_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>rela</name><operator>.</operator><name>r_offset</name></name> <operator>-</operator> <name><name>fsym</name><operator>.</operator><name>st_value</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_modtext</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>data_tgt</name><operator>-&gt;</operator><name>d_buf</name></name></expr></argument>, <argument><expr><name>eprobe</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>rela</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>off</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_probe_define</name><argument_list>(<argument><expr><name>pvp</name></expr></argument>, <argument><expr><name>prp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>eprobe</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>,
<argument><expr><literal type="string">"failed to allocate space for probe"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>shdr_rel</name><operator>.</operator><name>sh_type</name></name> <operator>==</operator> <name>SHT_RELA</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rela</name><operator>.</operator><name>r_info</name></name> <operator>=</operator> <call><name>GELF_R_INFO</name><argument_list>(
<argument><expr><call><name>GELF_R_SYM</name><argument_list>(<argument><expr><name><name>rela</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>DT_REL_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>gelf_update_rela</name><argument_list>(<argument><expr><name>data_rel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rela</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>GElf_Rel</name></type> <name>rel</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>rel</name><operator>.</operator><name>r_offset</name></name> <operator>=</operator> <name><name>rela</name><operator>.</operator><name>r_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rel</name><operator>.</operator><name>r_info</name></name> <operator>=</operator> <call><name>GELF_R_INFO</name><argument_list>(
<argument><expr><call><name>GELF_R_SYM</name><argument_list>(<argument><expr><name><name>rela</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>DT_REL_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>gelf_update_rel</name><argument_list>(<argument><expr><name>data_rel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>mod</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_flagdata</name><argument_list>(<argument><expr><name>data_tgt</name></expr></argument>, <argument><expr><name>ELF_C_SET</name></expr></argument>, <argument><expr><name>ELF_F_DIRTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rsym</name><operator>.</operator><name>st_shndx</name></name> <operator>!=</operator> <name>SHN_ABS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rsym</name><operator>.</operator><name>st_shndx</name></name> <operator>=</operator> <name>SHN_ABS</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>gelf_update_sym</name><argument_list>(<argument><expr><name>data_sym</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rsym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>mod</name> <operator>&amp;&amp;</operator> <call><name>elf_update</name><argument_list>(<argument><expr><name>elf</name></expr></argument>, <argument><expr><name>ELF_C_WRITE</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>elf_end</name><argument_list>(<argument><expr><name>elf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>pair</name> <operator>=</operator> <name>bufs</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bufs</name> <operator>=</operator> <name><name>pair</name><operator>-&gt;</operator><name>dlp_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>dlp_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>pair</name><operator>-&gt;</operator><name>dlp_sym</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
<label><name>err</name>:</label>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>elf</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>,
<argument><expr><literal type="string">"an error was encountered while processing %s"</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dtrace_program_link</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dtrace_prog_t</name> <modifier>*</modifier></type><name>pgp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>dflags</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>objc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>objv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>tfile</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>drti</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dof_hdr_t</name> <modifier>*</modifier></type><name>dof</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>status</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>cur</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>, <decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>eprobes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>pgp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><literal type="string">"%s -o %s -r"</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ld_path</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>objc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ld_path</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>objc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>cur</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name> <operator>+</operator> <name>cur</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>cur</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"failed to run %s: %s"</literal></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ld_path</name></name></expr></argument>,
<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"failed to link %s: %s failed due to signal %d"</literal></expr></argument>,
<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ld_path</name></name></expr></argument>, <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"failed to link %s: %s exited with status %d\n"</literal></expr></argument>,
<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ld_path</name></name></expr></argument>, <argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>objc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>unlink</name><argument_list>(<argument><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>objc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>process_obj</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>objv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eprobes</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>eprobes</name> <operator>&amp;&amp;</operator> <name><name>pgp</name><operator>-&gt;</operator><name>dp_dofversion</name></name> <operator>&lt;</operator> <name>DOF_VERSION_2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>pgp</name><operator>-&gt;</operator><name>dp_dofversion</name></name> <operator>=</operator> <name>DOF_VERSION_2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dof</name> <operator>=</operator> <call><name>dtrace_dof_create</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pgp</name></expr></argument>, <argument><expr><name>dflags</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tfile</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tfile</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.XXXXXX"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>mkostemp</name><argument_list>(<argument><expr><name>tfile</name></expr></argument>, <argument><expr><name>O_CLOEXEC</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"failed to create temporary file %s: %s"</literal></expr></argument>,
<argument><expr><name>tfile</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_linktype</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_LTYP_DOF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dt_write</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>dof</name></expr></argument>, <argument><expr><name><name>dof</name><operator>-&gt;</operator><name>dofh_filesz</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>dof</name><operator>-&gt;</operator><name>dofh_filesz</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"failed to write %s: %s"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_LTYP_ELF</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"invalid link type %u\n"</literal></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_linktype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_oflags</name></name> <operator>&amp;</operator> <name>DTRACE_O_LP64</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dump_elf64</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dof</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dump_elf32</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dof</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"failed to write %s: %s"</literal></expr></argument>, <argument><expr><name>tfile</name></expr></argument>,
<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lazyload</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><literal type="string">"%s -o %s -r %s %s"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_dirpath_t</name> <modifier>*</modifier></type><name>dp</name> <init>= <expr><call><name>dt_list_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lib_path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>drti</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>drti</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s/drti.o"</literal></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>dir_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ld_path</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>tfile</name></expr></argument>,
<argument><expr><name>drti</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ld_path</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>tfile</name></expr></argument>,
<argument><expr><name>drti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"failed to run %s: %s"</literal></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ld_path</name></name></expr></argument>,
<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"failed to link %s: %s failed due to signal %d"</literal></expr></argument>,
<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ld_path</name></name></expr></argument>, <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"failed to link %s: %s exited with status %d\n"</literal></expr></argument>,
<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ld_path</name></name></expr></argument>, <argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>asprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"%s --localize-hidden %s"</literal></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_objcopy_path</name></name></expr></argument>,
<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>=</operator> <call><name>system</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"failed to run %s: %s"</literal></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_objcopy_path</name></name></expr></argument>,
<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"failed to link %s: %s failed due to signal %d"</literal></expr></argument>,
<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_objcopy_path</name></name></expr></argument>, <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"failed to link %s: %s exited with status %d\n"</literal></expr></argument>,
<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_objcopy_path</name></name></expr></argument>, <argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>tfile</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>dt_link_error</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><literal type="string">"failed to rename %s to %s: %s"</literal></expr></argument>, <argument><expr><name>tfile</name></expr></argument>, <argument><expr><name>file</name></expr></argument>,
<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>dtrace_dof_destroy</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_lazyload</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>tfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
