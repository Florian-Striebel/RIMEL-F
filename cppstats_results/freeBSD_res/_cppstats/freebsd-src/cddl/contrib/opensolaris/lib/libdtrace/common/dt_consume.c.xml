<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/results/freeBSD_res/_cppstats/freebsd-src/cddl/contrib/opensolaris/lib/libdtrace/common/dt_consume.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;alloca.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_impl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_pq.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libproc_compat.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DT_MASK_LO</name></cpp:macro> <cpp:value>0x00000000FFFFFFFFULL</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>long</name> <name>double</name></type>
<name>dt_fabsl</name><parameter_list>(<parameter><decl><type><name>long</name> <name>double</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><name>x</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>x</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_ndigits</name><parameter_list>(<parameter><decl><type><name>long</name> <name>long</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rval</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>long</name></type> <name>cmp</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <ternary><condition><expr><name>val</name> <operator>==</operator> <name>INT64_MIN</name></expr> ?</condition><then> <expr><name>INT64_MAX</name></expr> </then><else>: <expr><operator>-</operator><name>val</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>rval</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><name>val</name> <operator>&gt;</operator> <name>cmp</name> <operator>&amp;&amp;</operator> <name>cmp</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rval</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>cmp</name> <operator>*=</operator> <literal type="number">10</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><ternary><condition><expr><name>rval</name> <operator>&lt;</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><name>rval</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_gt_128</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_ge_128</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_le_128</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_shift_128</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>mask</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>-</operator><name>b</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&gt;=</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>b</name> <operator>-</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mask</name> <operator>=</operator> <literal type="number">1LL</literal> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <name>b</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>mask</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <name>b</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;=</operator> <name>b</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&gt;=</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <operator>(</operator><name>b</name> <operator>-</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;=</operator> <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mask</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><literal type="number">64</literal> <operator>-</operator> <name>b</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>mask</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;=</operator> <name>b</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_nbits_128</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nbits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>tmp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>zero</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_shift_128</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>dt_gt_128</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>zero</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_shift_128</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nbits</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><name>nbits</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_subtract_128</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>minuend</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>subtrahend</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>difference</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>result</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>minuend</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>subtrahend</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>minuend</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>subtrahend</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator>
<operator>(</operator><ternary><condition><expr><name><name>minuend</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>subtrahend</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>difference</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>difference</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>result</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_add_128</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>addend1</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>addend2</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>sum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>result</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>addend1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>addend2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>addend1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>addend2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator>
<operator>(</operator><ternary><condition><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>addend1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <name><name>addend2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>result</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_multiply_128</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>factor1</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>factor2</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>product</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>hi1</name></decl>, <decl><type ref="prev"/><name>hi2</name></decl>, <decl><type ref="prev"/><name>lo1</name></decl>, <decl><type ref="prev"/><name>lo2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>tmp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>hi1</name> <operator>=</operator> <name>factor1</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hi2</name> <operator>=</operator> <name>factor2</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>lo1</name> <operator>=</operator> <name>factor1</name> <operator>&amp;</operator> <name>DT_MASK_LO</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lo2</name> <operator>=</operator> <name>factor2</name> <operator>&amp;</operator> <name>DT_MASK_LO</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>product</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>lo1</name> <operator>*</operator> <name>lo2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>product</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>hi1</name> <operator>*</operator> <name>hi2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>hi1</name> <operator>*</operator> <name>lo2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_shift_128</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_add_128</name><argument_list>(<argument><expr><name>product</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>product</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>hi2</name> <operator>*</operator> <name>lo1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tmp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_shift_128</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_add_128</name><argument_list>(<argument><expr><name>product</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>product</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_divide_128</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>dividend</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>divisor</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>quotient</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>result</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>remainder</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>subtrahend</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>divisor_128</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>mask</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>log</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>divisor</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>divisor_128</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>divisor</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>divisor_128</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>remainder</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>dividend</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>remainder</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>dividend</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>subtrahend</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>divisor</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>subtrahend</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>divisor</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>log</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>divisor</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>dt_shift_128</name><argument_list>(<argument><expr><name>subtrahend</name></expr></argument>, <argument><expr><literal type="number">128</literal> <operator>-</operator> <name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_shift_128</name><argument_list>(<argument><expr><name>mask</name></expr></argument>, <argument><expr><literal type="number">128</literal> <operator>-</operator> <name>log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>dt_ge_128</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>, <argument><expr><name>divisor_128</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_ge_128</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>, <argument><expr><name>subtrahend</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_subtract_128</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>, <argument><expr><name>subtrahend</name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <name><name>mask</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name><name>mask</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_shift_128</name><argument_list>(<argument><expr><name>subtrahend</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_shift_128</name><argument_list>(<argument><expr><name>mask</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name><name>quotient</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>quotient</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>result</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>dt_sqrt_128</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>square</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>result</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>diff</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>one</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>next_pair</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>next_try</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>bit_pairs</name></decl>, <decl><type ref="prev"/><name>pair_shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>bit_pairs</name> <operator>=</operator> <call><name>dt_nbits_128</name><argument_list>(<argument><expr><name>square</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pair_shift</name> <operator>=</operator> <name>bit_pairs</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>bit_pairs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>next_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>square</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>next_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>square</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_shift_128</name><argument_list>(<argument><expr><name>next_pair</name></expr></argument>, <argument><expr><operator>-</operator><name>pair_shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>next_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>next_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_shift_128</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_add_128</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>next_pair</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>next_try</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>next_try</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>result</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_shift_128</name><argument_list>(<argument><expr><name>next_try</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_add_128</name><argument_list>(<argument><expr><name>next_try</name></expr></argument>, <argument><expr><name>one</name></expr></argument>, <argument><expr><name>next_try</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_le_128</name><argument_list>(<argument><expr><name>next_try</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_subtract_128</name><argument_list>(<argument><expr><name>diff</name></expr></argument>, <argument><expr><name>next_try</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_shift_128</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_add_128</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>one</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>dt_shift_128</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>pair_shift</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>result</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name><name>result</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>uint64_t</name></type>
<name>dt_stddev</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>normal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>avg_of_squares</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>square_of_avg</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>norm_avg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>diff</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_divide_128</name><argument_list>(<argument><expr><name>data</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>normal</name></expr></argument>, <argument><expr><name>avg_of_squares</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_divide_128</name><argument_list>(<argument><expr><name>avg_of_squares</name></expr></argument>, <argument><expr><name>normal</name></expr></argument>, <argument><expr><name>avg_of_squares</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_divide_128</name><argument_list>(<argument><expr><name>avg_of_squares</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>avg_of_squares</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>norm_avg</name> <operator>=</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>normal</name> <operator>/</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>norm_avg</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>norm_avg</name> <operator>=</operator> <operator>-</operator><name>norm_avg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_multiply_128</name><argument_list>(<argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>norm_avg</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><name>norm_avg</name></expr></argument>, <argument><expr><name>square_of_avg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_subtract_128</name><argument_list>(<argument><expr><name>avg_of_squares</name></expr></argument>, <argument><expr><name>square_of_avg</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_sqrt_128</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_flowindent</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dtrace_probedata_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>dtrace_epid_t</name></type> <name>last</name></decl></parameter>,
<parameter><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_probedesc_t</name> <modifier>*</modifier></type><name>pd</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>dtpda_pdesc</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>npd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_eprobedesc_t</name> <modifier>*</modifier></type><name>epd</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>dtpda_edesc</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nepd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name><name>pd</name><operator>-&gt;</operator><name>dtpd_provider</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>pd</name><operator>-&gt;</operator><name>dtpd_name</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_flowkind_t</name></type> <name>flow</name> <init>= <expr><name>DTRACEFLOW_NONE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>e_str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="string">" -&gt; "</literal></expr>, <expr><literal type="string">" =&gt; "</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>r_str</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="string">" &lt;- "</literal></expr>, <expr><literal type="string">" &lt;= "</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><literal type="string">"entry"</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ret</name> <init>= <expr><literal type="string">"return"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>entlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>retlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_epid_t</name></type> <name>next</name></decl>, <decl><type ref="prev"/><name>id</name> <init>= <expr><name><name>epd</name><operator>-&gt;</operator><name>dtepd_epid</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rval</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>entlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>retlen</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>entlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>retlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sub</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>sub</name><index>[<expr><name>entlen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>sub</name> <operator>==</operator> <name>n</name> <operator>||</operator> <name><name>sub</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flow</name> <operator>=</operator> <name>DTRACEFLOW_ENTRY</name></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>e_str</name><index>[<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"syscall"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>sub</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>sub</name><index>[<expr><name>retlen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>sub</name> <operator>==</operator> <name>n</name> <operator>||</operator> <name><name>sub</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>flow</name> <operator>=</operator> <name>DTRACEFLOW_RETURN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>r_str</name><index>[<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"syscall"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flow</name> <operator>==</operator> <name>DTRACEFLOW_ENTRY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>last</name> <operator>!=</operator> <name>DTRACE_EPIDNONE</name> <operator>&amp;&amp;</operator> <name>id</name> <operator>!=</operator> <name>last</name> <operator>&amp;&amp;</operator>
<name><name>pd</name><operator>-&gt;</operator><name>dtpd_id</name></name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_pdesc</name><index>[<expr><name>last</name></expr>]</index></name><operator>-&gt;</operator><name>dtpd_id</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flow</name> <operator>=</operator> <name>DTRACEFLOW_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flow</name> <operator>==</operator> <name>DTRACEFLOW_RETURN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>offs</name> <operator>+=</operator> <name><name>epd</name><operator>-&gt;</operator><name>dtepd_size</name></name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>offs</name> <operator>&gt;=</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_size</name></name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>+</operator> <name>offs</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>next</name> <operator>==</operator> <name>DTRACE_EPIDNONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>offs</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block> while <condition>(<expr><name>next</name> <operator>==</operator> <name>DTRACE_EPIDNONE</name></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rval</name> <operator>=</operator> <call><name>dt_epid_lookup</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nepd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>npd</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>rval</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>next</name> <operator>!=</operator> <name>id</name> <operator>&amp;&amp;</operator> <name><name>npd</name><operator>-&gt;</operator><name>dtpd_id</name></name> <operator>==</operator> <name><name>pd</name><operator>-&gt;</operator><name>dtpd_id</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flow</name> <operator>=</operator> <name>DTRACEFLOW_NONE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<label><name>out</name>:</label>
<if_stmt><if>if <condition>(<expr><name>flow</name> <operator>==</operator> <name>DTRACEFLOW_ENTRY</name> <operator>||</operator> <name>flow</name> <operator>==</operator> <name>DTRACEFLOW_RETURN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>dtpda_prefix</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>dtpda_prefix</name></name> <operator>=</operator> <literal type="string">"| "</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flow</name> <operator>==</operator> <name>DTRACEFLOW_RETURN</name> <operator>&amp;&amp;</operator> <name><name>data</name><operator>-&gt;</operator><name>dtpda_indent</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>dtpda_indent</name></name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>dtpda_flow</name></name> <operator>=</operator> <name>flow</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_nullprobe</name><parameter_list>()</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>DTRACE_CONSUME_THIS</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_nullrec</name><parameter_list>()</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>DTRACE_CONSUME_NEXT</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_quantize_total</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>double</name> <modifier>*</modifier></type><name>total</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>val</name> <init>= <expr><call><name>dt_fabsl</name><argument_list>(<argument><expr><operator>(</operator><name>long</name> <name>double</name><operator>)</operator><name>datum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_AGGZOOM</name></expr>]</index></name> <operator>==</operator> <name>DTRACEOPT_UNSET</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>total</name> <operator>+=</operator> <name>val</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>val</name> <operator>*=</operator> <literal type="number">1</literal> <operator>/</operator> <name>DTRACE_AGGZOOM_MAX</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>total</name> <operator>&lt;</operator> <name>val</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>total</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_print_quanthdr</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n%*s %41s %-9s\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>width</name></expr> ?</condition><then> <expr><name>width</name></expr> </then><else>: <expr><literal type="number">16</literal></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>width</name></expr> ?</condition><then> <expr><literal type="string">"key"</literal></expr> </then><else>: <expr><literal type="string">"value"</literal></expr></else></ternary></expr></argument>,
<argument><expr><literal type="string">"------------- Distribution -------------"</literal></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_print_quanthdr_packed</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier></type><name>aggdata</name></decl></parameter>, <parameter><decl><type><name>dtrace_actkind_t</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>min</name> <init>= <expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_minbin</name></name></expr></init></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_maxbin</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>minwidth</name></decl>, <decl><type ref="prev"/><name>maxwidth</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>action</name> <operator>==</operator> <name>DTRACEAGG_QUANTIZE</name> <operator>||</operator> <name>action</name> <operator>==</operator> <name>DTRACEAGG_LQUANTIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <name>DTRACEAGG_QUANTIZE</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>min</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>min</name> <operator>!=</operator> <name>DTRACE_QUANTIZE_ZEROBUCKET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>min</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <name>DTRACE_QUANTIZE_NBUCKETS</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>minwidth</name> <operator>=</operator> <call><name>dt_ndigits</name><argument_list>(<argument><expr><call><name>DTRACE_QUANTIZE_BUCKETVAL</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>maxwidth</name> <operator>=</operator> <call><name>dt_ndigits</name><argument_list>(<argument><expr><call><name>DTRACE_QUANTIZE_BUCKETVAL</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>maxwidth</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>minwidth</name> <operator>=</operator> <name>maxwidth</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n%*s %*s ."</literal></expr></argument>,
<argument><expr><name>width</name></expr></argument>, <argument><expr><ternary><condition><expr><name>width</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"key"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>minwidth</name></expr></argument>, <argument><expr><literal type="string">"min"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>min</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">". %*s | count\n"</literal></expr></argument>, <argument><expr><operator>-</operator><name>maxwidth</name></expr></argument>, <argument><expr><literal type="string">"max"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DTRACE_AGGUTF8_FULL</name></cpp:macro> <cpp:value>0x2588</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DTRACE_AGGUTF8_BASE</name></cpp:macro> <cpp:value>0x258f</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DTRACE_AGGUTF8_LEVELS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DTRACE_AGGUTF8_BYTE0</name><parameter_list>(<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0xe0 | ((val) &gt;&gt; 12))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DTRACE_AGGUTF8_BYTE1</name><parameter_list>(<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0x80 | (((val) &gt;&gt; 6) &amp; 0x3f))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DTRACE_AGGUTF8_BYTE2</name><parameter_list>(<parameter><type><name>val</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0x80 | ((val) &amp; 0x3f))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_print_quantline_utf8</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>val</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>normal</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>double</name></type> <name>total</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint_t</name></type> <name>len</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>whole</name></decl>, <decl><type ref="prev"/><name>partial</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>f</name> <init>= <expr><operator>(</operator><call><name>dt_fabsl</name><argument_list>(<argument><expr><operator>(</operator><name>long</name> <name>double</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>len</name><operator>)</operator> <operator>/</operator> <name>total</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spaces</name> <init>= <expr><literal type="string">" "</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>whole</name> <operator>=</operator> <operator>(</operator><name>uint_t</name><operator>)</operator><name>f</name></expr>;</expr_stmt>
<expr_stmt><expr><name>partial</name> <operator>=</operator> <operator>(</operator><name>uint_t</name><operator>)</operator><operator>(</operator><operator>(</operator><name>f</name> <operator>-</operator> <operator>(</operator><name>long</name> <name>double</name><operator>)</operator><operator>(</operator><name>uint_t</name><operator>)</operator><name>f</name><operator>)</operator> <operator>*</operator>
<operator>(</operator><name>long</name> <name>double</name><operator>)</operator><name>DTRACE_AGGUTF8_LEVELS</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"|"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>whole</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%c%c%c"</literal></expr></argument>,
<argument><expr><call><name>DTRACE_AGGUTF8_BYTE0</name><argument_list>(<argument><expr><name>DTRACE_AGGUTF8_FULL</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>DTRACE_AGGUTF8_BYTE1</name><argument_list>(<argument><expr><name>DTRACE_AGGUTF8_FULL</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>DTRACE_AGGUTF8_BYTE2</name><argument_list>(<argument><expr><name>DTRACE_AGGUTF8_FULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>partial</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>partial</name> <operator>=</operator> <name>DTRACE_AGGUTF8_BASE</name> <operator>-</operator> <operator>(</operator><name>partial</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%c%c%c"</literal></expr></argument>,
<argument><expr><call><name>DTRACE_AGGUTF8_BYTE0</name><argument_list>(<argument><expr><name>partial</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>DTRACE_AGGUTF8_BYTE1</name><argument_list>(<argument><expr><name>partial</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>DTRACE_AGGUTF8_BYTE2</name><argument_list>(<argument><expr><name>partial</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s %-9lld\n"</literal></expr></argument>, <argument><expr><name>spaces</name> <operator>+</operator> <name>i</name></expr></argument>,
<argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>val</name> <operator>/</operator> <name>normal</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_print_quantline</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>int64_t</name></type> <name>val</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>normal</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>double</name></type> <name>total</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>positives</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>negatives</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>depth</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ats</name> <init>= <expr><literal type="string">"@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spaces</name> <init>= <expr><literal type="string">" "</literal></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ats</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>spaces</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>total</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>positives</name> <operator>||</operator> <name>negatives</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>val</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>negatives</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>val</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>positives</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>val</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>total</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>negatives</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>positives</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_encoding</name></name> <operator>==</operator> <name>DT_ENCODING_UTF8</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_print_quantline_utf8</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>val</name></expr></argument>,
<argument><expr><name>normal</name></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>(</operator><call><name>dt_fabsl</name><argument_list>(<argument><expr><operator>(</operator><name>long</name> <name>double</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>len</name><operator>)</operator> <operator>/</operator> <name>total</name></expr>;</expr_stmt>
<expr_stmt><expr><name>depth</name> <operator>=</operator> <operator>(</operator><name>uint_t</name><operator>)</operator><operator>(</operator><name>f</name> <operator>+</operator> <literal type="number">0.5</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"|%s%s %-9lld\n"</literal></expr></argument>, <argument><expr><name>ats</name> <operator>+</operator> <name>len</name> <operator>-</operator> <name>depth</name></expr></argument>,
<argument><expr><name>spaces</name> <operator>+</operator> <name>depth</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>val</name> <operator>/</operator> <name>normal</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>positives</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>(</operator><call><name>dt_fabsl</name><argument_list>(<argument><expr><operator>(</operator><name>long</name> <name>double</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>len</name><operator>)</operator> <operator>/</operator> <name>total</name></expr>;</expr_stmt>
<expr_stmt><expr><name>depth</name> <operator>=</operator> <operator>(</operator><name>uint_t</name><operator>)</operator><operator>(</operator><name>f</name> <operator>+</operator> <literal type="number">0.5</literal><operator>)</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s%s| %-9lld\n"</literal></expr></argument>, <argument><expr><name>spaces</name> <operator>+</operator> <name>depth</name></expr></argument>,
<argument><expr><name>ats</name> <operator>+</operator> <name>len</name> <operator>-</operator> <name>depth</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>val</name> <operator>/</operator> <name>normal</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ats</name> <operator>=</operator> <operator>&amp;</operator><name><name>ats</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>spaces</name> <operator>=</operator> <operator>&amp;</operator><name><name>spaces</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>(</operator><call><name>dt_fabsl</name><argument_list>(<argument><expr><operator>(</operator><name>long</name> <name>double</name><operator>)</operator><name>val</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>len</name><operator>)</operator> <operator>/</operator> <name>total</name></expr>;</expr_stmt>
<expr_stmt><expr><name>depth</name> <operator>=</operator> <operator>(</operator><name>uint_t</name><operator>)</operator><operator>(</operator><name>f</name> <operator>+</operator> <literal type="number">0.5</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s%s|%*s %-9lld\n"</literal></expr></argument>, <argument><expr><name>spaces</name> <operator>+</operator> <name>depth</name></expr></argument>,
<argument><expr><name>ats</name> <operator>+</operator> <name>len</name> <operator>-</operator> <name>depth</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>val</name> <operator>/</operator> <name>normal</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%20s|%s%s %-9lld\n"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
<argument><expr><name>ats</name> <operator>+</operator> <name>len</name> <operator>-</operator> <name>depth</name></expr></argument>, <argument><expr><name>spaces</name> <operator>+</operator> <name>depth</name></expr></argument>,
<argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>val</name> <operator>/</operator> <name>normal</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DTRACE_AGGPACK_BASE</name></cpp:macro> <cpp:value>0x2581</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DTRACE_AGGPACK_LEVELS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_print_packed</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>,
<parameter><decl><type><name>long</name> <name>double</name></type> <name>datum</name></decl></parameter>, <parameter><decl><type><name>long</name> <name>double</name></type> <name>total</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>boolean_t</name></type> <name>utf8_checked</name> <init>= <expr><name>B_FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>boolean_t</name></type> <name>utf8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ascii</name> <init>= <expr><literal type="string">"__xxxxXX"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>neg</name> <init>= <expr><literal type="string">"vvvvVV"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>val</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>utf8_checked</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>term</name></decl>;</decl_stmt>
<expr_stmt><expr><name>utf8_checked</name> <operator>=</operator> <name>B_TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_encoding</name></name> <operator>==</operator> <name>DT_ENCODING_ASCII</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>utf8</name> <operator>=</operator> <name>B_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_encoding</name></name> <operator>==</operator> <name>DT_ENCODING_UTF8</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>utf8</name> <operator>=</operator> <name>B_TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>term</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"TERM"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><literal type="string">"sun"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><literal type="string">"sun-color"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name>term</name></expr></argument>, <argument><expr><literal type="string">"dumb"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>utf8</name> <operator>=</operator> <name>B_FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>utf8</name> <operator>=</operator> <name>B_TRUE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>datum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>datum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>dt_fabsl</name><argument_list>(<argument><expr><name>datum</name> <operator>*</operator> <operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>/</operator> <name>total</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name><name>neg</name><index>[<expr><operator>(</operator><name>uint_t</name><operator>)</operator><operator>(</operator><name>val</name> <operator>+</operator> <literal type="number">0.5</literal><operator>)</operator></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>utf8</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>block</name> <init>= <expr><name>DTRACE_AGGPACK_BASE</name> <operator>+</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>datum</name> <operator>*</operator>
<operator>(</operator><name>DTRACE_AGGPACK_LEVELS</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>total</name><operator>)</operator> <operator>+</operator> <literal type="number">0.5</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%c%c%c"</literal></expr></argument>,
<argument><expr><call><name>DTRACE_AGGUTF8_BYTE0</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>DTRACE_AGGUTF8_BYTE1</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>DTRACE_AGGUTF8_BYTE2</name><argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>ascii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>datum</name> <operator>*</operator> <operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>/</operator> <name>total</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name><name>ascii</name><index>[<expr><operator>(</operator><name>uint_t</name><operator>)</operator><operator>(</operator><name>val</name> <operator>+</operator> <literal type="number">0.5</literal><operator>)</operator></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_print_quantize</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>normal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>addr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>first_bin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>last_bin</name> <init>= <expr><name>DTRACE_QUANTIZE_NBUCKETS</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>positives</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>negatives</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name>DTRACE_QUANTIZE_NBUCKETS</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_DMISMATCH</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>first_bin</name> <operator>&lt;</operator> <name>DTRACE_QUANTIZE_NBUCKETS</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>first_bin</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first_bin</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>first_bin</name> <operator>==</operator> <name>DTRACE_QUANTIZE_NBUCKETS</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>first_bin</name> <operator>=</operator> <name>DTRACE_QUANTIZE_ZEROBUCKET</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>last_bin</name> <operator>=</operator> <name>DTRACE_QUANTIZE_ZEROBUCKET</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>first_bin</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first_bin</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>last_bin</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>last_bin</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>last_bin</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>last_bin</name> <operator>&lt;</operator> <name>DTRACE_QUANTIZE_NBUCKETS</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>last_bin</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>first_bin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>last_bin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>positives</name> <operator>|=</operator> <operator>(</operator><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>negatives</name> <operator>|=</operator> <operator>(</operator><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_quantize_total</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_quanthdr</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>first_bin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>last_bin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%16lld "</literal></expr></argument>,
<argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><call><name>DTRACE_QUANTIZE_BUCKETVAL</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_quantline</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>normal</name></expr></argument>, <argument><expr><name>total</name></expr></argument>,
<argument><expr><name>positives</name></expr></argument>, <argument><expr><name>negatives</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_print_quantize_packed</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier></type><name>aggdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>addr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min</name> <init>= <expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_minbin</name></name></expr></init></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_maxbin</name></name></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>minval</name></decl>, <decl><type ref="prev"/><name>maxval</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name>DTRACE_QUANTIZE_NBUCKETS</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_DMISMATCH</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>min</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>min</name> <operator>!=</operator> <name>DTRACE_QUANTIZE_ZEROBUCKET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>min</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <name>DTRACE_QUANTIZE_NBUCKETS</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>minval</name> <operator>=</operator> <call><name>DTRACE_QUANTIZE_BUCKETVAL</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>maxval</name> <operator>=</operator> <call><name>DTRACE_QUANTIZE_BUCKETVAL</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %*lld :"</literal></expr></argument>, <argument><expr><call><name>dt_ndigits</name><argument_list>(<argument><expr><name>minval</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>minval</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>min</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>dt_quantize_total</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>+=</operator> <name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>min</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_packed</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">": %*lld | %lld\n"</literal></expr></argument>,
<argument><expr><operator>-</operator><call><name>dt_ndigits</name><argument_list>(<argument><expr><name>maxval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>maxval</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>count</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_print_lquantize</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>normal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>addr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>first_bin</name></decl>, <decl><type ref="prev"/><name>last_bin</name></decl>, <decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>step</name></decl>, <decl><type ref="prev"/><name>levels</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>positives</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>negatives</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_DMISMATCH</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>*</operator><name>data</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>DTRACE_LQUANTIZE_BASE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>DTRACE_LQUANTIZE_STEP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>levels</name> <operator>=</operator> <call><name>DTRACE_LQUANTIZE_LEVELS</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>first_bin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>last_bin</name> <operator>=</operator> <name>levels</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>levels</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_DMISMATCH</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>first_bin</name> <operator>&lt;=</operator> <name>levels</name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>first_bin</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first_bin</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>first_bin</name> <operator>&gt;</operator> <name>levels</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>first_bin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>last_bin</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>first_bin</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first_bin</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>last_bin</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>last_bin</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>last_bin</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>last_bin</name> <operator>&lt;</operator> <name>levels</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>last_bin</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>first_bin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>last_bin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>positives</name> <operator>|=</operator> <operator>(</operator><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>negatives</name> <operator>|=</operator> <operator>(</operator><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_quantize_total</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n%16s %41s %-9s\n"</literal></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>,
<argument><expr><literal type="string">"------------- Distribution -------------"</literal></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>first_bin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>last_bin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt; %d"</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%16s "</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>levels</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&gt;= %d"</literal></expr></argument>,
<argument><expr><name>base</name> <operator>+</operator> <operator>(</operator><name>levels</name> <operator>*</operator> <name>step</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%16s "</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%16d "</literal></expr></argument>,
<argument><expr><name>base</name> <operator>+</operator> <operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>dt_print_quantline</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>normal</name></expr></argument>,
<argument><expr><name>total</name></expr></argument>, <argument><expr><name>positives</name></expr></argument>, <argument><expr><name>negatives</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_print_lquantize_packed</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier></type><name>aggdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>addr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>, <decl><type ref="prev"/><name>base</name></decl>, <decl><type ref="prev"/><name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>step</name></decl>, <decl><type ref="prev"/><name>levels</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_DMISMATCH</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>*</operator><name>data</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>DTRACE_LQUANTIZE_BASE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>step</name> <operator>=</operator> <call><name>DTRACE_LQUANTIZE_STEP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>levels</name> <operator>=</operator> <call><name>DTRACE_LQUANTIZE_LEVELS</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>levels</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_DMISMATCH</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>min</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>max</name> <operator>=</operator> <name>levels</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>min</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt; %d"</literal></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%8s :"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%8d :"</literal></expr></argument>, <argument><expr><name>base</name> <operator>+</operator> <operator>(</operator><name>min</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>step</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>min</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>dt_quantize_total</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> <operator>+=</operator> <name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>min</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_packed</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>total</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&gt;= %d"</literal></expr></argument>, <argument><expr><name>base</name> <operator>+</operator> <operator>(</operator><name>levels</name> <operator>*</operator> <name>step</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">": %-8s | %lld\n"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>count</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_print_llquantize</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>addr</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>normal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>first_bin</name></decl>, <decl><type ref="prev"/><name>last_bin</name></decl>, <decl><type ref="prev"/><name>bin</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>order</name></decl>, <decl><type ref="prev"/><name>levels</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>factor</name></decl>, <decl><type ref="prev"/><name>low</name></decl>, <decl><type ref="prev"/><name>high</name></decl>, <decl><type ref="prev"/><name>nsteps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int64_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>addr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>value</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>next</name></decl>, <decl><type ref="prev"/><name>step</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>positives</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>negatives</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name> <name>double</name></type> <name>total</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_DMISMATCH</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>*</operator><name>data</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>-=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>factor</name> <operator>=</operator> <call><name>DTRACE_LLQUANTIZE_FACTOR</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>low</name> <operator>=</operator> <call><name>DTRACE_LLQUANTIZE_LOW</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>high</name> <operator>=</operator> <call><name>DTRACE_LLQUANTIZE_HIGH</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nsteps</name> <operator>=</operator> <call><name>DTRACE_LLQUANTIZE_NSTEP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>INT32_MAX</name> <operator>||</operator> <name><name>factor</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">2</literal> <operator>||</operator> <name>low</name> <operator>&gt;=</operator> <name>high</name> <operator>||</operator>
<name>nsteps</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>factor</name></expr></argument> &gt;</argument_list></name> <name>nsteps</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_DMISMATCH</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>levels</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>size</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name>first_bin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>last_bin</name> <operator>=</operator> <name>levels</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>first_bin</name> <operator>&lt;</operator> <name>levels</name> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>first_bin</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first_bin</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>first_bin</name> <operator>==</operator> <name>levels</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>first_bin</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>last_bin</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>first_bin</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first_bin</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>last_bin</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>last_bin</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>last_bin</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>last_bin</name> <operator>&lt;</operator> <name>levels</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>last_bin</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>first_bin</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>last_bin</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>positives</name> <operator>|=</operator> <operator>(</operator><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>negatives</name> <operator>|=</operator> <operator>(</operator><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_quantize_total</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n%16s %41s %-9s\n"</literal></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>,
<argument><expr><literal type="string">"------------- Distribution -------------"</literal></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>order</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>order</name> <operator>&lt;</operator> <name>low</name></expr>;</condition> <incr><expr><name>order</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>value</name> <operator>*=</operator> <name>factor</name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>value</name> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
<expr_stmt><expr><name>step</name> <operator>=</operator> <ternary><condition><expr><name>next</name> <operator>&gt;</operator> <name>nsteps</name></expr> ?</condition><then> <expr><name>next</name> <operator>/</operator> <name>nsteps</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>first_bin</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&lt; %lld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%16s "</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_quantline</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>normal</name></expr></argument>,
<argument><expr><name>total</name></expr></argument>, <argument><expr><name>positives</name></expr></argument>, <argument><expr><name>negatives</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><name>order</name> <operator>&lt;=</operator> <name>high</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>&gt;=</operator> <name>first_bin</name> <operator>&amp;&amp;</operator> <name>bin</name> <operator>&lt;=</operator> <name>last_bin</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%16lld "</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_quantline</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>bin</name></expr>]</index></name></expr></argument>,
<argument><expr><name>normal</name></expr></argument>, <argument><expr><name>total</name></expr></argument>, <argument><expr><name>positives</name></expr></argument>, <argument><expr><name>negatives</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>value</name> <operator>&lt;</operator> <name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bin</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>+=</operator> <name>step</name><operator>)</operator> <operator>!=</operator> <name>next</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name>value</name> <operator>*</operator> <name>factor</name></expr>;</expr_stmt>
<expr_stmt><expr><name>step</name> <operator>=</operator> <ternary><condition><expr><name>next</name> <operator>&gt;</operator> <name>nsteps</name></expr> ?</condition><then> <expr><name>next</name> <operator>/</operator> <name>nsteps</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>order</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>last_bin</name> <operator>&lt;</operator> <name>bin</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>last_bin</name> <operator>==</operator> <name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"&gt;= %lld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%16s "</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><call><name>dt_print_quantline</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>bin</name></expr>]</index></name></expr></argument>, <argument><expr><name>normal</name></expr></argument>,
<argument><expr><name>total</name></expr></argument>, <argument><expr><name>positives</name></expr></argument>, <argument><expr><name>negatives</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_print_average</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>caddr_t</name></type> <name>addr</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>normal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>addr</name></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %16lld"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then>
<expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><operator>(</operator><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>/</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name>normal</name> <operator>/</operator> <name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_print_stddev</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>caddr_t</name></type> <name>addr</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>normal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>addr</name></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %16llu"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then>
<expr><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name><operator>)</operator> <call><name>dt_stddev</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>normal</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_print_bytes</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>caddr_t</name></type> <name>addr</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>width</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quiet</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forceraw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>margin</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>addr</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>forceraw</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>raw</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_RAWBYTES</name></expr>]</index></name> <operator>!=</operator> <name>DTRACEOPT_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>raw</name>;</goto></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbytes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isprint</name><argument_list>(<argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isspace</name><argument_list>(<argument><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator>
<name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\b'</literal> <operator>||</operator> <name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\a'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nbytes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>c</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <name>nbytes</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>quiet</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %s%*s"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>width</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>nbytes</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>alloca</name><argument_list>(<argument><expr><name>nbytes</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name><index>[<expr><name>nbytes</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %-*s"</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<label><name>raw</name>:</label>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n%*s "</literal></expr></argument>, <argument><expr><name>margin</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %c"</literal></expr></argument>, <argument><expr><literal type="string">"0123456789abcdef"</literal><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" 0123456789abcdef\n"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbytes</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">16</literal></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s%5x:"</literal></expr></argument>, <argument><expr><name>margin</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name> <operator>+</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>nbytes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %02x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>uchar_t</name><operator>)</operator><name><name>c</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<while>while <condition>(<expr><name>j</name><operator>++</operator> <operator>%</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name> <operator>+</operator> <literal type="number">16</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name>nbytes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>c</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&lt;</operator> <literal type="char">' '</literal> <operator>||</operator> <name><name>c</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'~'</literal></expr> ?</condition><then> <expr><literal type="char">'.'</literal></expr> </then><else>: <expr><name><name>c</name><index>[<expr><name>j</name></expr>]</index></name></expr></else></ternary></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_print_stack</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>,
<parameter><decl><type><name>caddr_t</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_syminfo_t</name></type> <name>dts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>indent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>PATH_MAX</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>pc</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="string">"%s"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_STACKINDENT</name></expr>]</index></name> <operator>!=</operator> <name>DTRACEOPT_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>indent</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_STACKINDENT</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>indent</name> <operator>=</operator> <name>_dtrace_stkindent</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>depth</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_BADSTACKPC</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>pc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>indent</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_lookup_by_addr</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pc</name> <operator>&gt;</operator> <name><name>sym</name><operator>.</operator><name>st_value</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s`%s+0x%llx"</literal></expr></argument>,
<argument><expr><name><name>dts</name><operator>.</operator><name>dts_object</name></name></expr></argument>, <argument><expr><name><name>dts</name><operator>.</operator><name>dts_name</name></name></expr></argument>,
<argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><operator>(</operator><name>pc</name> <operator>-</operator> <name><name>sym</name><operator>.</operator><name>st_value</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s`%s"</literal></expr></argument>,
<argument><expr><name><name>dts</name><operator>.</operator><name>dts_object</name></name></expr></argument>, <argument><expr><name><name>dts</name><operator>.</operator><name>dts_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_lookup_by_addr</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s`0x%llx"</literal></expr></argument>,
<argument><expr><name><name>dts</name><operator>.</operator><name>dts_object</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"0x%llx"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_print_ustack</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>,
<parameter><decl><type><name>caddr_t</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>addr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>depth</name> <init>= <expr><call><name>DTRACE_USTACK_NFRAMES</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>strsize</name> <init>= <expr><call><name>DTRACE_USTACK_STRSIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strbase</name> <init>= <expr><name>addr</name> <operator>+</operator> <operator>(</operator><name>depth</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><ternary><condition><expr><name>strsize</name></expr> ?</condition><then> <expr><name>strbase</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>objname</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>c</name><index>[<expr><name>PATH_MAX</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ps_prochandle</name></name> <modifier>*</modifier></type><name>P</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>indent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pid</name> <operator>=</operator> <operator>(</operator><name>pid_t</name><operator>)</operator><operator>*</operator><name>pc</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="string">"%s"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_STACKINDENT</name></expr>]</index></name> <operator>!=</operator> <name>DTRACEOPT_UNSET</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>indent</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_STACKINDENT</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>indent</name> <operator>=</operator> <name>_dtrace_stkindent</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_vector</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>P</name> <operator>=</operator> <call><name>dt_proc_grab</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>PGRAB_RDONLY</name> <operator>|</operator> <name>PGRAB_FORCE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>P</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>P</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_proc_lock</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>depth</name> <operator>&amp;&amp;</operator> <name><name>pc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>prmap_t</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>indent</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>P</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>Plookup_by_addr</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name><name>pc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>Pobjname</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name><name>pc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>objname</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>sym</name><operator>.</operator><name>st_value</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"%s`%s+0x%llx"</literal></expr></argument>, <argument><expr><call><name>dt_basename</name><argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><operator>(</operator><name><name>pc</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name><name>sym</name><operator>.</operator><name>st_value</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"%s`%s"</literal></expr></argument>, <argument><expr><call><name>dt_basename</name><argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>str</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'@'</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>P</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>map</name> <operator>=</operator> <call><name>Paddr_to_map</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name><name>pc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<operator>(</operator><name><name>map</name><operator>-&gt;</operator><name>pr_mflags</name></name> <operator>&amp;</operator> <name>MA_WRITE</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>P</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>Pobjname</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name><name>pc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>objname</name></expr></argument>,
<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s`0x%llx"</literal></expr></argument>,
<argument><expr><call><name>dt_basename</name><argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name><name>pc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"0x%llx"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name><name>pc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>indent</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">" [ %s ]"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>str</name> <operator>-</operator> <name>strbase</name> <operator>&gt;=</operator> <name>strsize</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>P</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_proc_unlock</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_proc_release</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>err</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_print_usym</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>caddr_t</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>dtrace_actkind_t</name></type> <name>act</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>pid</name> <init>= <expr><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>pc</name> <init>= <expr><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name> <init>= <expr><literal type="string">" %-50s"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">256</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>DTRACEACT_USYM</name> <operator>&amp;&amp;</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_vector</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>ps_prochandle</name></name> <modifier>*</modifier></type><name>P</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>P</name> <operator>=</operator> <call><name>dt_proc_grab</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>,
<argument><expr><name>PGRAB_RDONLY</name> <operator>|</operator> <name>PGRAB_FORCE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>dt_proc_lock</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>Plookup_by_addr</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <name><name>sym</name><operator>.</operator><name>st_value</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_proc_unlock</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_proc_release</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>dtrace_uaddr2str</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <name>n</name></expr>)</condition>;</do>
<return>return <expr><operator>(</operator><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_print_umod</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>caddr_t</name></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>pid</name> <init>= <expr><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>pc</name> <init>= <expr><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>objname</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>c</name><index>[<expr><name>PATH_MAX</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ps_prochandle</name></name> <modifier>*</modifier></type><name>P</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="string">" %-50s"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_vector</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>P</name> <operator>=</operator> <call><name>dt_proc_grab</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>PGRAB_RDONLY</name> <operator>|</operator> <name>PGRAB_FORCE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>P</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>P</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_proc_lock</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>P</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>Pobjname</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>objname</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>dt_basename</name><argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"0x%llx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>P</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_proc_unlock</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_proc_release</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>err</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_print_sym</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>caddr_t</name></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>pc</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_syminfo_t</name></type> <name>dts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>PATH_MAX</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="string">" %-50s"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_lookup_by_addr</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s`%s"</literal></expr></argument>,
<argument><expr><name><name>dts</name><operator>.</operator><name>dts_object</name></name></expr></argument>, <argument><expr><name><name>dts</name><operator>.</operator><name>dts_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_lookup_by_addr</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s`0x%llx"</literal></expr></argument>,
<argument><expr><name><name>dts</name><operator>.</operator><name>dts_object</name></name></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"0x%llx"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_print_mod</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>caddr_t</name></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>pc</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_syminfo_t</name></type> <name>dts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><name>PATH_MAX</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>format</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>format</name> <operator>=</operator> <literal type="string">" %-50s"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_lookup_by_addr</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>dts</name><operator>.</operator><name>dts_object</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"0x%llx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_print_memory</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>caddr_t</name></type> <name>addr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>quiet</name> <init>= <expr><operator>(</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_QUIET</name></expr>]</index></name> <operator>!=</operator> <name>DTRACEOPT_UNSET</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name> <operator>*</operator><operator>)</operator> <name>addr</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><call><name>dt_print_bytes</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uintptr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>nbytes</name></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>, <argument><expr><name>quiet</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<typedef>typedef <type><struct>struct <name>dt_normal</name> <block>{
<decl_stmt><decl><type><name>dtrace_aggvarid_t</name></type> <name>dtnd_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>dtnd_normal</name></decl>;</decl_stmt>
}</block></struct></type> <name>dt_normal_t</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_normalize_agg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier></type><name>aggdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_normal_t</name> <modifier>*</modifier></type><name>normal</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_aggdesc_t</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_desc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_aggvarid_t</name></type> <name>id</name> <init>= <expr><name><name>normal</name><operator>-&gt;</operator><name>dtnd_id</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>dtagd_nrecs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>dtagd_varid</name></name> <operator>!=</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>dtrace_aggdata_t</name> <operator>*</operator><operator>)</operator><name>aggdata</name><operator>)</operator><operator>-&gt;</operator><name>dtada_normal</name> <operator>=</operator> <name><name>normal</name><operator>-&gt;</operator><name>dtnd_normal</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NORMALIZE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_normalize</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>caddr_t</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_normal_t</name></type> <name>normal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>caddr_t</name></type> <name>addr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>dtrace_aggvarid_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_BADNORMAL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>normal</name><operator>.</operator><name>dtnd_id</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>dtrace_aggvarid_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>rec</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_action</name></name> <operator>!=</operator> <name>DTRACEACT_LIBACT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_BADNORMAL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_arg</name></name> <operator>!=</operator> <name>DT_ACT_NORMALIZE</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_BADNORMAL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name><name>normal</name><operator>.</operator><name>dtnd_normal</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name><name>normal</name><operator>.</operator><name>dtnd_normal</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name><name>normal</name><operator>.</operator><name>dtnd_normal</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name><name>normal</name><operator>.</operator><name>dtnd_normal</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_BADNORMAL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dtrace_aggregate_walk</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dt_normalize_agg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_denormalize_agg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier></type><name>aggdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_aggdesc_t</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_desc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_aggvarid_t</name></type> <name>id</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>dtrace_aggvarid_t</name> <operator>*</operator><operator>)</operator><name>arg</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>dtagd_nrecs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>dtagd_varid</name></name> <operator>!=</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_DENORMALIZE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_clear_agg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier></type><name>aggdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_aggdesc_t</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_desc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_aggvarid_t</name></type> <name>id</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>dtrace_aggvarid_t</name> <operator>*</operator><operator>)</operator><name>arg</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>dtagd_nrecs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>dtagd_varid</name></name> <operator>!=</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_CLEAR</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<typedef>typedef <type><struct>struct <name>dt_trunc</name> <block>{
<decl_stmt><decl><type><name>dtrace_aggvarid_t</name></type> <name>dttd_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>dttd_remaining</name></decl>;</decl_stmt>
}</block></struct></type> <name>dt_trunc_t</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_trunc_agg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier></type><name>aggdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_trunc_t</name> <modifier>*</modifier></type><name>trunc</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_aggdesc_t</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_desc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_aggvarid_t</name></type> <name>id</name> <init>= <expr><name><name>trunc</name><operator>-&gt;</operator><name>dttd_id</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>dtagd_nrecs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>dtagd_varid</name></name> <operator>!=</operator> <name>id</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>trunc</name><operator>-&gt;</operator><name>dttd_remaining</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_REMOVE</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>trunc</name><operator>-&gt;</operator><name>dttd_remaining</name></name><operator>--</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>DTRACE_AGGWALK_NEXT</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_trunc</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>caddr_t</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_trunc_t</name></type> <name>trunc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>caddr_t</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>remaining</name></decl>;</decl_stmt>
<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>dtrace_aggregate_f</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>dtrace_aggvarid_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_BADTRUNC</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>trunc</name><operator>.</operator><name>dttd_id</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>dtrace_aggvarid_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>rec</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_action</name></name> <operator>!=</operator> <name>DTRACEACT_LIBACT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_BADTRUNC</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_arg</name></name> <operator>!=</operator> <name>DT_ACT_TRUNC</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_BADTRUNC</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>base</name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>remaining</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>int64_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>remaining</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>remaining</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>remaining</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>int8_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_BADNORMAL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>remaining</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>dtrace_aggregate_walk_valsorted</name></expr>;</expr_stmt>
<expr_stmt><expr><name>remaining</name> <operator>=</operator> <operator>-</operator><name>remaining</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>dtrace_aggregate_walk_valrevsorted</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>remaining</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>trunc</name><operator>.</operator><name>dttd_remaining</name></name> <operator>=</operator> <name>remaining</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>func</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dt_trunc_agg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>trunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_print_datum</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>,
<parameter><decl><type><name>caddr_t</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier></type><name>aggdata</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>normal</name></decl></parameter>, <parameter><decl><type><name>dt_print_aggdata_t</name> <modifier>*</modifier></type><name>pd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>, <decl><type ref="prev"/><name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_actkind_t</name></type> <name>act</name> <init>= <expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_action</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>boolean_t</name></type> <name>packed</name> <init>= <expr><name><name>pd</name><operator>-&gt;</operator><name>dtpa_agghist</name></name> <operator>||</operator> <name><name>pd</name><operator>-&gt;</operator><name>dtpa_aggpack</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_aggdesc_t</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_desc</name></name></expr></init></decl>;</decl_stmt>
<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>packedwidth</name></decl>;</decl_stmt>
}</block> <decl><modifier>*</modifier><name>fmt</name></decl>, <decl><type ref="prev"/><name><name>fmttab</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr> }</block></expr>,
<expr><block>{ <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">5</literal></expr> }</block></expr>,
<expr><block>{ <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">8</literal></expr> }</block></expr>,
<expr><block>{ <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>, <expr><literal type="number">16</literal></expr>, <expr><literal type="number">16</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><operator>-</operator><literal type="number">50</literal></expr>, <expr><literal type="number">16</literal></expr> }</block></expr>
}</block></expr></init></decl>;</struct>
<if_stmt><if>if <condition>(<expr><name>packed</name> <operator>&amp;&amp;</operator> <name><name>pd</name><operator>-&gt;</operator><name>dtpa_agghisthdr</name></name> <operator>!=</operator> <name><name>agg</name><operator>-&gt;</operator><name>dtagd_varid</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name>width</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>r</name> <operator>=</operator> <name>rec</name></expr>;</init> <condition><expr><operator>!</operator><call><name>DTRACEACT_ISAGG</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>dtrd_action</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>r</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<for>for <control>(<init><expr><name>fmt</name> <operator>=</operator> <name>fmttab</name></expr>;</init> <condition><expr><name><name>fmt</name><operator>-&gt;</operator><name>size</name></name> <operator>&amp;&amp;</operator>
<name><name>fmt</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <name><name>r</name><operator>-&gt;</operator><name>dtrd_size</name></name></expr>;</condition> <incr><expr><name>fmt</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
<expr_stmt><expr><name>width</name> <operator>+=</operator> <name><name>fmt</name><operator>-&gt;</operator><name>packedwidth</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>pd</name><operator>-&gt;</operator><name>dtpa_agghist</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_quanthdr</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_quanthdr_packed</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>,
<argument><expr><name>width</name></expr></argument>, <argument><expr><name>aggdata</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>dtrd_action</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>dtpa_agghisthdr</name></name> <operator>=</operator> <name><name>agg</name><operator>-&gt;</operator><name>dtagd_varid</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pd</name><operator>-&gt;</operator><name>dtpa_agghist</name></name> <operator>&amp;&amp;</operator> <call><name>DTRACEACT_ISAGG</name><argument_list>(<argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>positives</name> <init>= <expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_flags</name></name> <operator>&amp;</operator> <name>DTRACE_A_HASPOSITIVES</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>negatives</name> <init>= <expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_flags</name></name> <operator>&amp;</operator> <name>DTRACE_A_HASNEGATIVES</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int64_t</name></type> <name>val</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>act</name> <operator>==</operator> <name>DTRACEAGG_SUM</name> <operator>||</operator> <name>act</name> <operator>==</operator> <name>DTRACEAGG_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>long</name> <name>long</name><operator>)</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><call><name>dt_print_quantline</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>normal</name></expr></argument>,
<argument><expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_total</name></name></expr></argument>, <argument><expr><name>positives</name></expr></argument>, <argument><expr><name>negatives</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pd</name><operator>-&gt;</operator><name>dtpa_aggpack</name></name> <operator>&amp;&amp;</operator> <call><name>DTRACEACT_ISAGG</name><argument_list>(<argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>act</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DTRACEAGG_QUANTIZE</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_print_quantize_packed</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>aggdata</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<case>case <expr><name>DTRACEAGG_LQUANTIZE</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_print_lquantize_packed</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>aggdata</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>act</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DTRACEACT_STACK</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_print_stack</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>,
<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_arg</name></name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name> <operator>/</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_arg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<case>case <expr><name>DTRACEACT_USTACK</name></expr>:</case>
<case>case <expr><name>DTRACEACT_JSTACK</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_print_ustack</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_arg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<case>case <expr><name>DTRACEACT_USYM</name></expr>:</case>
<case>case <expr><name>DTRACEACT_UADDR</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_print_usym</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>act</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<case>case <expr><name>DTRACEACT_UMOD</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_print_umod</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<case>case <expr><name>DTRACEACT_SYM</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_print_sym</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<case>case <expr><name>DTRACEACT_MOD</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_print_mod</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<case>case <expr><name>DTRACEAGG_QUANTIZE</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_print_quantize</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>normal</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<case>case <expr><name>DTRACEAGG_LQUANTIZE</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_print_lquantize</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>normal</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<case>case <expr><name>DTRACEAGG_LLQUANTIZE</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_print_llquantize</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>normal</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<case>case <expr><name>DTRACEAGG_AVG</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_print_average</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>normal</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<case>case <expr><name>DTRACEAGG_STDDEV</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_print_stddev</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>normal</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<for>for <control>(<init><expr><name>fmt</name> <operator>=</operator> <name>fmttab</name></expr>;</init> <condition><expr><name><name>fmt</name><operator>-&gt;</operator><name>size</name></name> <operator>&amp;&amp;</operator> <name><name>fmt</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <name>size</name></expr>;</condition> <incr><expr><name>fmt</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
<expr_stmt><expr><name>width</name> <operator>=</operator> <ternary><condition><expr><name>packed</name></expr> ?</condition><then> <expr><name><name>fmt</name><operator>-&gt;</operator><name>packedwidth</name></name></expr> </then><else>: <expr><name><name>fmt</name><operator>-&gt;</operator><name>width</name></name></expr></else></ternary></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %*lld"</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>,
<argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator> <operator>/</operator> <name>normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %*d"</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator> <operator>/</operator>
<operator>(</operator><name>uint32_t</name><operator>)</operator><name>normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %*d"</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator> <operator>/</operator>
<operator>(</operator><name>uint32_t</name><operator>)</operator><name>normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %*d"</literal></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator> <operator>/</operator>
<operator>(</operator><name>uint32_t</name><operator>)</operator><name>normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_print_bytes</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><operator>(</operator><name>err</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_print_aggs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>aggsdata</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>naggvars</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>aggact</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_print_aggdata_t</name> <modifier>*</modifier></type><name>pd</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier></type><name>aggdata</name> <init>= <expr><name><name>aggsdata</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_aggdesc_t</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_desc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>pd</name><operator>-&gt;</operator><name>dtpa_fp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>pd</name><operator>-&gt;</operator><name>dtpa_dtp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_actkind_t</name></type> <name>act</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>caddr_t</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>dtpa_agghist</name></name> <operator>=</operator> <operator>(</operator><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_flags</name></name> <operator>&amp;</operator> <name>DTRACE_A_TOTAL</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pd</name><operator>-&gt;</operator><name>dtpa_aggpack</name></name> <operator>=</operator> <operator>(</operator><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_flags</name></name> <operator>&amp;</operator> <name>DTRACE_A_MINMAXBIN</name><operator>)</operator></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>agg</name><operator>-&gt;</operator><name>dtagd_nrecs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>&amp;</operator><name><name>agg</name><operator>-&gt;</operator><name>dtagd_rec</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>act</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_action</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>aggdata</name><operator>-&gt;</operator><name>dtada_data</name></name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>DTRACEACT_ISAGG</name><argument_list>(<argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>aggact</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_datum</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>,
<argument><expr><name>size</name></expr></argument>, <argument><expr><name>aggdata</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>pd</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_buffered_flush</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>aggdata</name></expr></argument>,
<argument><expr><name>DTRACE_BUFDATA_AGGKEY</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>aggact</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>naggvars</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>naggvars</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>normal</name></decl>;</decl_stmt>
<expr_stmt><expr><name>aggdata</name> <operator>=</operator> <name><name>aggsdata</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>agg</name> <operator>=</operator> <name><name>aggdata</name><operator>-&gt;</operator><name>dtada_desc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>&amp;</operator><name><name>agg</name><operator>-&gt;</operator><name>dtagd_rec</name><index>[<expr><name>aggact</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>act</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_action</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>aggdata</name><operator>-&gt;</operator><name>dtada_data</name></name> <operator>+</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>DTRACEACT_ISAGG</name><argument_list>(<argument><expr><name>act</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>normal</name> <operator>=</operator> <name><name>aggdata</name><operator>-&gt;</operator><name>dtada_normal</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_datum</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>,
<argument><expr><name>size</name></expr></argument>, <argument><expr><name>aggdata</name></expr></argument>, <argument><expr><name>normal</name></expr></argument>, <argument><expr><name>pd</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_buffered_flush</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>aggdata</name></expr></argument>,
<argument><expr><name>DTRACE_BUFDATA_AGGVAL</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pd</name><operator>-&gt;</operator><name>dtpa_allunprint</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>agg</name><operator>-&gt;</operator><name>dtagd_flags</name></name> <operator>|=</operator> <name>DTRACE_AGD_PRINTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pd</name><operator>-&gt;</operator><name>dtpa_agghist</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pd</name><operator>-&gt;</operator><name>dtpa_aggpack</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_buffered_flush</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>aggdata</name></expr></argument>,
<argument><expr><name>DTRACE_BUFDATA_AGGFORMAT</name> <operator>|</operator> <name>DTRACE_BUFDATA_AGGLAST</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_print_agg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_aggdata_t</name> <modifier>*</modifier></type><name>aggdata</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_print_aggdata_t</name> <modifier>*</modifier></type><name>pd</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_aggdesc_t</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><name><name>aggdata</name><operator>-&gt;</operator><name>dtada_desc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_aggvarid_t</name></type> <name>aggvarid</name> <init>= <expr><name><name>pd</name><operator>-&gt;</operator><name>dtpa_id</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>pd</name><operator>-&gt;</operator><name>dtpa_allunprint</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>dtagd_flags</name></name> <operator>&amp;</operator> <name>DTRACE_AGD_PRINTED</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>dtagd_nrecs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>aggvarid</name> <operator>!=</operator> <name><name>agg</name><operator>-&gt;</operator><name>dtagd_varid</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><call><name>dt_print_aggs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aggdata</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_setopt</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dtrace_probedata_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>option</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>rval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_setoptdata_t</name></type> <name>optdata</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>optdata</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>optdata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dtrace_getopt</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>option</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>optdata</name><operator>.</operator><name>dtsda_oldval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_setopt</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>option</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dtrace_getopt</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>option</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>optdata</name><operator>.</operator><name>dtsda_newval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>optdata</name><operator>.</operator><name>dtsda_probe</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>optdata</name><operator>.</operator><name>dtsda_option</name></name> <operator>=</operator> <name>option</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>optdata</name><operator>.</operator><name>dtsda_handle</name></name> <operator>=</operator> <name>dtp</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rval</name> <operator>=</operator> <call><name>dt_handle_setopt</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optdata</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>rval</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>errstr</name> <operator>=</operator> <call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>option</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>errstr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">80</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"couldn't set option \"%s\" to \"%s\": %s\n"</literal></expr></argument>,
<argument><expr><name>option</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rval</name> <operator>=</operator> <call><name>dt_handle_liberr</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>rval</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_consume_cpu</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cpu</name></decl></parameter>,
<parameter><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>boolean_t</name></type> <name>just_one</name></decl></parameter>,
<parameter><decl><type><name>dtrace_consume_probe_f</name> <modifier>*</modifier></type><name>efunc</name></decl></parameter>, <parameter><decl><type><name>dtrace_consume_rec_f</name> <modifier>*</modifier></type><name>rfunc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_epid_t</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>offs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flow</name> <init>= <expr><operator>(</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_FLOWINDENT</name></expr>]</index></name> <operator>!=</operator> <name>DTRACEOPT_UNSET</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quiet</name> <init>= <expr><operator>(</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_QUIET</name></expr>]</index></name> <operator>!=</operator> <name>DTRACEOPT_UNSET</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rval</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>tracememsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_probedata_t</name></type> <name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>drops</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>dtpda_handle</name></name> <operator>=</operator> <name>dtp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>dtpda_cpu</name></name> <operator>=</operator> <name>cpu</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>dtpda_flow</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_flow</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>dtpda_indent</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_indent</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>dtpda_prefix</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_prefix</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>offs</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name></expr>;</init> <condition><expr><name>offs</name> <operator>&lt;</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_size</name></name></expr>;</condition> <incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>dtrace_eprobedesc_t</name> <modifier>*</modifier></type><name>epd</name></decl>;</decl_stmt>
<expr_stmt><expr><name>id</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>+</operator> <name>offs</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>DTRACE_EPIDNONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>offs</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rval</name> <operator>=</operator> <call><name>dt_epid_lookup</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>dtpda_edesc</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>data</name><operator>.</operator><name>dtpda_pdesc</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>rval</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>epd</name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>dtpda_edesc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>dtpda_data</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>+</operator> <name>offs</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>dtpda_edesc</name><operator>-&gt;</operator><name>dtepd_uarg</name></name> <operator>!=</operator> <name>DT_ECB_DEFAULT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>dt_handle</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>==</operator> <name>DTRACE_CONSUME_NEXT</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nextepid</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>==</operator> <name>DTRACE_CONSUME_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flow</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_flowindent</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_last_epid</name></name></expr></argument>,
<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rval</name> <operator>=</operator> <call>(<modifier>*</modifier><name>efunc</name>)<argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flow</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>data</name><operator>.</operator><name>dtpda_flow</name></name> <operator>==</operator> <name>DTRACEFLOW_ENTRY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>dtpda_indent</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>==</operator> <name>DTRACE_CONSUME_NEXT</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nextepid</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>==</operator> <name>DTRACE_CONSUME_ABORT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_DIRABORT</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>!=</operator> <name>DTRACE_CONSUME_THIS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_BADRVAL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>epd</name><operator>-&gt;</operator><name>dtepd_nrecs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>caddr_t</name></type> <name>addr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>&amp;</operator><name><name>epd</name><operator>-&gt;</operator><name>dtepd_rec</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_actkind_t</name></type> <name>act</name> <init>= <expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_action</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>data</name><operator>.</operator><name>dtpda_data</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>+</operator> <name>offs</name> <operator>+</operator>
<name><name>rec</name><operator>-&gt;</operator><name>dtrd_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>dtpda_data</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>DTRACEACT_LIBACT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>arg</name> <init>= <expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_arg</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_aggvarid_t</name></type> <name>id</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_ACT_CLEAR</name></expr>:</case>
<expr_stmt><expr><name>id</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>dtrace_aggvarid_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dtrace_aggregate_walk</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name>dt_clear_agg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
<case>case <expr><name>DT_ACT_DENORMALIZE</name></expr>:</case>
<expr_stmt><expr><name>id</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>dtrace_aggvarid_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dtrace_aggregate_walk</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name>dt_denormalize_agg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
<case>case <expr><name>DT_ACT_FTRUNCATE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>ftruncate</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fseeko</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
<case>case <expr><name>DT_ACT_NORMALIZE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>epd</name><operator>-&gt;</operator><name>dtepd_nrecs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name>EDT_BADNORMAL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_normalize</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>+</operator> <name>offs</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
<case>case <expr><name>DT_ACT_SETOPT</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>opts</name> <init>= <expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>valrec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>valsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>caddr_t</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>epd</name><operator>-&gt;</operator><name>dtepd_nrecs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name>EDT_BADSETOPT</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>valrec</name> <operator>=</operator> <operator>&amp;</operator><name><name>epd</name><operator>-&gt;</operator><name>dtepd_rec</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>valsize</name> <operator>=</operator> <name><name>valrec</name><operator>-&gt;</operator><name>dtrd_size</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>valrec</name><operator>-&gt;</operator><name>dtrd_action</name></name> <operator>!=</operator> <name>act</name> <operator>||</operator>
<name><name>valrec</name><operator>-&gt;</operator><name>dtrd_arg</name></name> <operator>!=</operator> <name>arg</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name>EDT_BADSETOPT</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>valsize</name> <operator>&gt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>+</operator> <name>offs</name> <operator>+</operator>
<name><name>valrec</name><operator>-&gt;</operator><name>dtrd_offset</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">"1"</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>dt_setopt</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>flow</name> <operator>=</operator> <operator>(</operator><name><name>opts</name><index>[<expr><name>DTRACEOPT_FLOWINDENT</name></expr>]</index></name> <operator>!=</operator>
<name>DTRACEOPT_UNSET</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>quiet</name> <operator>=</operator> <operator>(</operator><name><name>opts</name><index>[<expr><name>DTRACEOPT_QUIET</name></expr>]</index></name> <operator>!=</operator>
<name>DTRACEOPT_UNSET</name><operator>)</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block>
<case>case <expr><name>DT_ACT_TRUNC</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>epd</name><operator>-&gt;</operator><name>dtepd_nrecs</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name>EDT_BADTRUNC</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_trunc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>+</operator> <name>offs</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
<default>default:</default>
<continue>continue;</continue>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>DTRACEACT_TRACEMEM_DYNSIZE</name> <operator>&amp;&amp;</operator>
<name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name> <operator>==</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tracememsize</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>rval</name> <operator>=</operator> <call>(<modifier>*</modifier><name>rfunc</name>)<argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>==</operator> <name>DTRACE_CONSUME_NEXT</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>==</operator> <name>DTRACE_CONSUME_ABORT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_DIRABORT</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>!=</operator> <name>DTRACE_CONSUME_THIS</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_BADRVAL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>DTRACEACT_STACK</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_arg</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_stack</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>,
<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name> <operator>/</operator> <name>depth</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<goto>goto <name>nextrec</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>DTRACEACT_USTACK</name> <operator>||</operator>
<name>act</name> <operator>==</operator> <name>DTRACEACT_JSTACK</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_ustack</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_arg</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<goto>goto <name>nextrec</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>DTRACEACT_SYM</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_sym</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<goto>goto <name>nextrec</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>DTRACEACT_MOD</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_mod</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<goto>goto <name>nextrec</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>DTRACEACT_USYM</name> <operator>||</operator> <name>act</name> <operator>==</operator> <name>DTRACEACT_UADDR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_usym</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>act</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<goto>goto <name>nextrec</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>DTRACEACT_UMOD</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_umod</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<goto>goto <name>nextrec</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>DTRACEACT_PRINTM</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_print_memory</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<goto>goto <name>nextrec</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>DTRACEACT_ISPRINTFLIKE</name><argument_list>(<argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>fmtdata</name></decl>;</decl_stmt>
<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>func</name>)<parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>dtrace_probedata_t</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>dtrace_recdesc_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint_t</name></type></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmtdata</name> <operator>=</operator> <call><name>dt_format_lookup</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_format</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nofmt</name>;</goto></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>act</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DTRACEACT_PRINTF</name></expr>:</case>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>dtrace_fprintf</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DTRACEACT_PRINTA</name></expr>:</case>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>dtrace_fprinta</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DTRACEACT_SYSTEM</name></expr>:</case>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>dtrace_system</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DTRACEACT_FREOPEN</name></expr>:</case>
<expr_stmt><expr><name>func</name> <operator>=</operator> <name>dtrace_freopen</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>fmtdata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>,
<argument><expr><name>rec</name></expr></argument>, <argument><expr><name><name>epd</name><operator>-&gt;</operator><name>dtepd_nrecs</name></name> <operator>-</operator> <name>i</name></expr></argument>,
<argument><expr><operator>(</operator><name>uchar_t</name> <operator>*</operator><operator>)</operator><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>+</operator> <name>offs</name></expr></argument>,
<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_size</name></name> <operator>-</operator> <name>offs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<goto>goto <name>nextrec</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>DTRACEACT_DIFEXPR</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strdata</name> <init>= <expr><call><name>dt_strdata_lookup</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_format</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>strdata</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>dtrace_print</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>strdata</name></expr></argument>,
<argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nextrec</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<label><name>nofmt</name>:</label>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>DTRACEACT_PRINTA</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dt_print_aggdata_t</name></type> <name>pd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_aggvarid_t</name> <modifier>*</modifier></type><name>aggvars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>naggvars</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><operator>(</operator><operator>(</operator><name><name>epd</name><operator>-&gt;</operator><name>dtepd_nrecs</name></name> <operator>-</operator> <name>i</name><operator>)</operator> <operator>*</operator>
<sizeof>sizeof <argument_list>(<argument><expr><name>dtrace_aggvarid_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>aggvars</name> <operator>=</operator> <call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>epd</name><operator>-&gt;</operator><name>dtepd_nrecs</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>nrec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>caddr_t</name></type> <name>naddr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>nrec</name> <operator>=</operator> <operator>&amp;</operator><name><name>epd</name><operator>-&gt;</operator><name>dtepd_rec</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nrec</name><operator>-&gt;</operator><name>dtrd_uarg</name></name> <operator>!=</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_uarg</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>nrec</name><operator>-&gt;</operator><name>dtrd_action</name></name> <operator>!=</operator> <name>act</name></expr>)</condition> <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name>EDT_BADAGG</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>naddr</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>+</operator> <name>offs</name> <operator>+</operator>
<name><name>nrec</name><operator>-&gt;</operator><name>dtrd_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>aggvars</name><index>[<expr><name>naggvars</name><operator>++</operator></expr>]</index></name> <operator>=</operator>
<operator>*</operator><operator>(</operator><operator>(</operator><name>dtrace_aggvarid_t</name> <operator>*</operator><operator>)</operator><name>naddr</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pd</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>pd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pd</name><operator>.</operator><name>dtpa_dtp</name></name> <operator>=</operator> <name>dtp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pd</name><operator>.</operator><name>dtpa_fp</name></name> <operator>=</operator> <name>fp</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>naggvars</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>naggvars</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>pd</name><operator>.</operator><name>dtpa_id</name></name> <operator>=</operator> <name><name>aggvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>aggvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>dtrace_aggregate_walk_sorted</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name>dt_print_agg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pd</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<goto>goto <name>nextrec</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>dtrace_aggregate_walk_joined</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>aggvars</name></expr></argument>,
<argument><expr><name>naggvars</name></expr></argument>, <argument><expr><name>dt_print_aggs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pd</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>aggvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>aggvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>nextrec</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>DTRACEACT_TRACEMEM</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tracememsize</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
<name>tracememsize</name> <operator>&gt;</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tracememsize</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>dt_print_bytes</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>,
<argument><expr><name>tracememsize</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">33</literal></expr></argument>, <argument><expr><name>quiet</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tracememsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<goto>goto <name>nextrec</name>;</goto>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>quiet</name></expr> ?</condition><then> <expr><literal type="string">"%lld"</literal></expr> </then><else>: <expr><literal type="string">" %16lld"</literal></expr></else></ternary></expr></argument>,
<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>long</name> <name>long</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><ternary><condition><expr><name>quiet</name></expr> ?</condition><then> <expr><literal type="string">"%d"</literal></expr> </then><else>: <expr><literal type="string">" %8d"</literal></expr></else></ternary></expr></argument>,
<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><ternary><condition><expr><name>quiet</name></expr> ?</condition><then> <expr><literal type="string">"%d"</literal></expr> </then><else>: <expr><literal type="string">" %5d"</literal></expr></else></ternary></expr></argument>,
<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><sizeof>sizeof <argument_list>(<argument><expr><name>uint8_t</name></expr></argument>)</argument_list></sizeof></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>dt_printf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><ternary><condition><expr><name>quiet</name></expr> ?</condition><then> <expr><literal type="string">"%d"</literal></expr> </then><else>: <expr><literal type="string">" %3d"</literal></expr></else></ternary></expr></argument>,
<argument><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>addr</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>dt_print_bytes</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>,
<argument><expr><name><name>rec</name><operator>-&gt;</operator><name>dtrd_size</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">33</literal></expr></argument>, <argument><expr><name>quiet</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<label><name>nextrec</name>:</label>
<if_stmt><if>if <condition>(<expr><call><name>dt_buffered_flush</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>rval</name> <operator>=</operator> <call>(<modifier>*</modifier><name>rfunc</name>)<argument_list>(<argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>nextepid</name>:</label>
<expr_stmt><expr><name>offs</name> <operator>+=</operator> <name><name>epd</name><operator>-&gt;</operator><name>dtepd_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_last_epid</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>just_one</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name> <operator>=</operator> <name>offs</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_flow</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>dtpda_flow</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_indent</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>dtpda_indent</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_prefix</name></name> <operator>=</operator> <name><name>data</name><operator>.</operator><name>dtpda_prefix</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>drops</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_drops</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_drops</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_handle_cpudrop</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>cpu</name></expr></argument>, <argument><expr><name>DTRACEDROP_PRINCIPAL</name></expr></argument>, <argument><expr><name>drops</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_realloc_buf</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>used</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_size</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>used</name> <operator>&lt;</operator> <name>cursize</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>misalign</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name> <operator>&amp;</operator> <operator>(</operator><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newdata</name> <init>= <expr><call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>used</name> <operator>+</operator> <name>misalign</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>newdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><name>newdata</name></expr></argument>, <argument><expr><name>misalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>+</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name></expr></argument>,
<argument><expr><name>newdata</name> <operator>+</operator> <name>misalign</name></expr></argument>, <argument><expr><name>used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name> <operator>=</operator> <name>misalign</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_size</name></name> <operator>=</operator> <name>used</name> <operator>+</operator> <name>misalign</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>=</operator> <name>newdata</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_unring_buf</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>misalign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newdata</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ndp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>misalign</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name> <operator>&amp;</operator> <operator>(</operator><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>newdata</name> <operator>=</operator> <name>ndp</name> <operator>=</operator> <call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_size</name></name> <operator>+</operator> <name>misalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>newdata</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>dtbd_size</name></name> <operator>&amp;</operator> <operator>(</operator><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><name>ndp</name></expr></argument>, <argument><expr><name>misalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ndp</name> <operator>+=</operator> <name>misalign</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>+</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name></expr></argument>, <argument><expr><name>ndp</name></expr></argument>,
<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_size</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ndp</name> <operator>+=</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_size</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name></expr></argument>, <argument><expr><name>ndp</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name> <operator>=</operator> <name>misalign</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>=</operator> <name>newdata</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_size</name></name> <operator>+=</operator> <name>misalign</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_put_buf</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_get_buf</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cpu</name></decl></parameter>, <parameter><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>bufp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_optval_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>dt_zalloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>, <decl><type ref="prev"/><name>rval</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dtrace_getopt</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><literal type="string">"bufsize"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>=</operator> <call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_free</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_cpu</name></name> <operator>=</operator> <name>cpu</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>dt_ioctl</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>DTRACEIOC_BUFSNAP</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if <condition>(<expr><call><name>dt_ioctl</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>DTRACEIOC_BUFSNAP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>dt_put_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>rval</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>dt_unring_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_put_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>error</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_realloc_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<typedef>typedef <type><struct>struct <name>dt_begin</name> <block>{
<decl_stmt><decl><type><name>dtrace_consume_probe_f</name> <modifier>*</modifier></type><name>dtbgn_probefunc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_consume_rec_f</name> <modifier>*</modifier></type><name>dtbgn_recfunc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>dtbgn_arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_handle_err_f</name> <modifier>*</modifier></type><name>dtbgn_errhdlr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>dtbgn_errarg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>dtbgn_beginonly</name></decl>;</decl_stmt>
}</block></struct></type> <name>dt_begin_t</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_consume_begin_probe</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_probedata_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_begin_t</name> <modifier>*</modifier></type><name>begin</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_probedesc_t</name> <modifier>*</modifier></type><name>pd</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>dtpda_pdesc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>dtpd_provider</name></name></expr></argument>, <argument><expr><literal type="string">"dtrace"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r2</name> <init>= <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>dtpd_name</name></name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>begin</name><operator>-&gt;</operator><name>dtbgn_beginonly</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>r1</name> <operator>&amp;&amp;</operator> <name>r2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_CONSUME_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>r1</name> <operator>&amp;&amp;</operator> <name>r2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_CONSUME_NEXT</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><call><name><name>begin</name><operator>-&gt;</operator><name>dtbgn_probefunc</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>begin</name><operator>-&gt;</operator><name>dtbgn_arg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_consume_begin_record</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_probedata_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>dtrace_recdesc_t</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_begin_t</name> <modifier>*</modifier></type><name>begin</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><call><name><name>begin</name><operator>-&gt;</operator><name>dtbgn_recfunc</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>rec</name></expr></argument>, <argument><expr><name><name>begin</name><operator>-&gt;</operator><name>dtbgn_arg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_consume_begin_error</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dtrace_errdata_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_begin_t</name> <modifier>*</modifier></type><name>begin</name> <init>= <expr><operator>(</operator><name>dt_begin_t</name> <operator>*</operator><operator>)</operator><name>arg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_probedesc_t</name> <modifier>*</modifier></type><name>pd</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>dteda_pdesc</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r1</name> <init>= <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>dtpd_provider</name></name></expr></argument>, <argument><expr><literal type="string">"dtrace"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>r2</name> <init>= <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pd</name><operator>-&gt;</operator><name>dtpd_name</name></name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>begin</name><operator>-&gt;</operator><name>dtbgn_beginonly</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>r1</name> <operator>&amp;&amp;</operator> <name>r2</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_HANDLE_OK</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>r1</name> <operator>&amp;&amp;</operator> <name>r2</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>DTRACE_HANDLE_OK</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><call><name><name>begin</name><operator>-&gt;</operator><name>dtbgn_errhdlr</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>begin</name><operator>-&gt;</operator><name>dtbgn_errarg</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dt_consume_begin</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>,
<parameter><decl><type><name>dtrace_consume_probe_f</name> <modifier>*</modifier></type><name>pf</name></decl></parameter>, <parameter><decl><type><name>dtrace_consume_rec_f</name> <modifier>*</modifier></type><name>rf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_begin_t</name></type> <name>begin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>processorid_t</name></type> <name>cpu</name> <init>= <expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_beganon</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rval</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>max_ncpus</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_beganon</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_get_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>cpu</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_stopped</name></name> <operator>||</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_cpu</name></name> <operator>!=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_endedon</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>dt_consume_cpu</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>cpu</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>,
<argument><expr><name>pf</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_put_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>rval</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>begin</name><operator>.</operator><name>dtbgn_probefunc</name></name> <operator>=</operator> <name>pf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>begin</name><operator>.</operator><name>dtbgn_recfunc</name></name> <operator>=</operator> <name>rf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>begin</name><operator>.</operator><name>dtbgn_arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>begin</name><operator>.</operator><name>dtbgn_beginonly</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>begin</name><operator>.</operator><name>dtbgn_errhdlr</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_errhdlr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>begin</name><operator>.</operator><name>dtbgn_errarg</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_errarg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errhdlr</name></name> <operator>=</operator> <name>dt_consume_begin_error</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errarg</name></name> <operator>=</operator> <operator>&amp;</operator><name>begin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>dt_consume_cpu</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>cpu</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>,
<argument><expr><name>dt_consume_begin_probe</name></expr></argument>, <argument><expr><name>dt_consume_begin_record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>begin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errhdlr</name></name> <operator>=</operator> <name><name>begin</name><operator>.</operator><name>dtbgn_errhdlr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errarg</name></name> <operator>=</operator> <name><name>begin</name><operator>.</operator><name>dtbgn_errarg</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_put_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>rval</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>max_ncpus</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_ncpus</name> <operator>=</operator> <call><name>dt_sysconf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>_SC_CPUID_MAX</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_ncpus</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>nbuf</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>cpu</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_get_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbuf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_put_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nbuf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>dt_consume_cpu</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>,
<argument><expr><name>pf</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_put_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_put_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>rval</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>begin</name><operator>.</operator><name>dtbgn_beginonly</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>begin</name><operator>.</operator><name>dtbgn_errhdlr</name></name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_errhdlr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>begin</name><operator>.</operator><name>dtbgn_errarg</name></name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_errarg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errhdlr</name></name> <operator>=</operator> <name>dt_consume_begin_error</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errarg</name></name> <operator>=</operator> <operator>&amp;</operator><name>begin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>dt_consume_cpu</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>cpu</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>,
<argument><expr><name>dt_consume_begin_probe</name></expr></argument>, <argument><expr><name>dt_consume_begin_record</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>begin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errhdlr</name></name> <operator>=</operator> <name><name>begin</name><operator>.</operator><name>dtbgn_errhdlr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errarg</name></name> <operator>=</operator> <name><name>begin</name><operator>.</operator><name>dtbgn_errarg</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>rval</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>uint64_t</name></type>
<name>dt_buf_oldest</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>elem</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>elem</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>offs</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_oldest</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>offs</name> <operator>&lt;</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_size</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dtrace_rechdr_t</name> <modifier>*</modifier></type><name>dtrh</name> <init>=
<expr><operator>(</operator><name>dtrace_rechdr_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>dtbd_data</name></name> <operator>+</operator> <name>offs</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtrh</name><operator>-&gt;</operator><name>dtrh_epid</name></name> <operator>==</operator> <name>DTRACE_EPIDNONE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>offs</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>dtrace_epid_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><operator>(</operator><call><name>DTRACE_RECORD_LOAD_TIMESTAMP</name><argument_list>(<argument><expr><name>dtrh</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>dtbd_timestamp</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dtrace_consume</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>,
<parameter><decl><type><name>dtrace_consume_probe_f</name> <modifier>*</modifier></type><name>pf</name></decl></parameter>, <parameter><decl><type><name>dtrace_consume_rec_f</name> <modifier>*</modifier></type><name>rf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_optval_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>max_ncpus</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_optval_t</name></type> <name>interval</name> <init>= <expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_SWITCHRATE</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hrtime_t</name></type> <name>now</name> <init>= <expr><call><name>gethrtime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_lastswitch</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>now</name> <operator>-</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_lastswitch</name></name> <operator>&lt;</operator> <name>interval</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_lastswitch</name></name> <operator>+=</operator> <name>interval</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_lastswitch</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_active</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>max_ncpus</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>max_ncpus</name> <operator>=</operator> <call><name>dt_sysconf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>_SC_CPUID_MAX</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pf</name> <operator>=</operator> <operator>(</operator><name>dtrace_consume_probe_f</name> <operator>*</operator><operator>)</operator><name>dt_nullprobe</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rf</name> <operator>=</operator> <operator>(</operator><name>dtrace_consume_rec_f</name> <operator>*</operator><operator>)</operator><name>dt_nullrec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_options</name><index>[<expr><name>DTRACEOPT_TEMPORAL</name></expr>]</index></name> <operator>==</operator> <name>DTRACEOPT_UNSET</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_active</name></name> <operator>&amp;&amp;</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_beganon</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>rval</name> <operator>=</operator> <call><name>dt_consume_begin</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pf</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>rval</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_ncpus</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_stopped</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_endedon</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_get_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_flow</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_indent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_prefix</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>dt_consume_cpu</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>, <argument><expr><name>pf</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_put_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>rval</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_stopped</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_get_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_endedon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>dt_consume_cpu</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_endedon</name></name></expr></argument>,
<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>, <argument><expr><name>pf</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_put_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>rval</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>drops</name> <init>= <expr><call><name>alloca</name><argument_list>(<argument><expr><name>max_ncpus</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>first_timestamp</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>cookie</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><name>drops</name></expr></argument>, <argument><expr><name>max_ncpus</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_bufq</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_bufq</name></name> <operator>=</operator> <call><name>dt_pq_init</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>max_ncpus</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>,
<argument><expr><name>dt_buf_oldest</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_bufq</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dtrace_getopt</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><literal type="string">"bufsize"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_ncpus</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_get_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>first_timestamp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first_timestamp</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_timestamp</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_timestamp</name></name> <operator>&gt;=</operator> <name>first_timestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_pq_insert</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_bufq</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>drops</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_drops</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_drops</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>dtrace_bufdesc_t</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>dt_pq_pop</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_bufq</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>timestamp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>dt_buf_oldest</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>timestamp</name> <operator>==</operator> <name><name>buf</name><operator>-&gt;</operator><name>dtbd_timestamp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_put_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>timestamp</name> <operator>==</operator> <name>first_timestamp</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>dtp</name><operator>-&gt;</operator><name>dt_stopped</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>timestamp</name> <operator>&gt;=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_last_timestamp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_last_timestamp</name></name> <operator>=</operator> <name>timestamp</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rval</name> <operator>=</operator> <call><name>dt_consume_cpu</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>,
<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_cpu</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>B_TRUE</name></expr></argument>, <argument><expr><name>pf</name></expr></argument>, <argument><expr><name>rf</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>rval</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_pq_insert</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_bufq</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_ncpus</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>drops</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><call><name>dt_handle_cpudrop</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr><name>DTRACEDROP_PRINCIPAL</name></expr></argument>, <argument><expr><name><name>drops</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>error</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<while>while <condition>(<expr><name>buf</name> <operator>=</operator> <call><name>dt_pq_walk</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_bufq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cookie</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_realloc_buf</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>dtbd_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function></block_content></block></function>
</unit>
