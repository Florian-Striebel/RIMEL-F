<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/results/freeBSD_res/_cppstats/freebsd-src/cddl/contrib/opensolaris/lib/libdtrace/common/dt_parser.c"><cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>ident</name> <cpp:literal>"%Z%%M% %I% %E% SMI"</cpp:literal></cpp:pragma>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysmacros.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>illumos</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;alloca.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_impl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_grammar.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_module.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_provider.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dt_as.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><name>dt_pcb_t</name> <modifier>*</modifier></type><name>yypcb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>yypragma</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>yyintprefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>yyintsuffix</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yyintdecimal</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>opstr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_TOK_COMMA</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">","</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_ELLIPSIS</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"..."</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_ASGN</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_ADD_EQ</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"+="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_SUB_EQ</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"-="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_MUL_EQ</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"*="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_DIV_EQ</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"/="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_MOD_EQ</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"%="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_AND_EQ</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&amp;="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_XOR_EQ</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"^="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_OR_EQ</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"|="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_LSH_EQ</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&lt;&lt;="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_RSH_EQ</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&gt;&gt;="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_QUESTION</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"?"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_COLON</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">":"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_LOR</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"||"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_LXOR</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"^^"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_LAND</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&amp;&amp;"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_BOR</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"|"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_XOR</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"^"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_BAND</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&amp;"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_EQU</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"=="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_NEQ</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"!="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_LT</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&lt;"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_LE</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&lt;="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_GT</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&gt;"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_GE</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&gt;="</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_LSH</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&lt;&lt;"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_RSH</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&gt;&gt;"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_ADD</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"+"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_SUB</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"-"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_MUL</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"*"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_DIV</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"/"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_MOD</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"%"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_LNEG</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"!"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_BNEG</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"~"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_ADDADD</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"++"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_PREINC</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"++"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_POSTINC</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"++"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_SUBSUB</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"--"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_PREDEC</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"--"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_POSTDEC</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"--"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_IPOS</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"+"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_INEG</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"-"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_DEREF</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"*"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_ADDROF</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&amp;"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_OFFSETOF</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"offsetof"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_SIZEOF</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"sizeof"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_STRINGOF</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"stringof"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_XLATE</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"xlate"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_LPAR</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"("</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_RPAR</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">")"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_LBRAC</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"["</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_RBRAC</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"]"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_PTR</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"-&gt;"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_DOT</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"."</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_STRING</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&lt;string&gt;"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_IDENT</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&lt;ident&gt;"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_TNAME</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&lt;type&gt;"</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_INT</name></expr>:</case> <return>return <expr><operator>(</operator><literal type="string">"&lt;int&gt;"</literal><operator>)</operator></expr>;</return>
<default>default:</default> <return>return <expr><operator>(</operator><literal type="string">"&lt;?&gt;"</literal><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_type_lookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>dtrace_typeinfo_t</name> <modifier>*</modifier></type><name>tip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>delimiters</name><index>[]</index></name> <init>= <expr><literal type="string">" \t\n\r\v\f*`"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>obj</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>s</name></expr><operator>,</operator> <expr><name>end</name> <operator>=</operator> <name>s</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name>q</name></expr></incr>)</control> <block>{<block_content>
<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>end</name> <operator>||</operator> <operator>(</operator><name>q</name> <operator>=</operator> <call><name>strpbrk</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>delimiters</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'`'</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>object</name> <init>= <expr><call><name>alloca</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>q</name> <operator>-</operator> <name>p</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>alloca</name><argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>end</name> <operator>-</operator> <name>s</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>q</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>object</name><index>[<expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>q</name> <operator>-</operator> <name>p</name><operator>)</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>s</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>q</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>type</name> <operator>+</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>s</name><operator>)</operator></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>q</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>q</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name>r</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>r</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>r</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name>EDT_BADSCOPE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>q</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'L'</literal> <operator>||</operator> <name><name>q</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'M'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name>EDT_BADSCOPE</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><call><name>dtrace_lookup_by_type</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>tip</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_idepth</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <name>DTRACE_OBJ_CDEFS</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>obj</name> <operator>=</operator> <name>DTRACE_OBJ_EVERY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><call><name>dtrace_lookup_by_type</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>tip</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_type_pointer</name><parameter_list>(<parameter><decl><type><name>dtrace_typeinfo_t</name> <modifier>*</modifier></type><name>tip</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>ctfp</name> <init>= <expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name> <init>= <expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>base</name> <init>= <expr><call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>bflags</name> <init>= <expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_flags</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_module_t</name> <modifier>*</modifier></type><name>dmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>ptr</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>ctf_type_pointer</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CTF_ERR</name> <operator>||</operator>
<operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>ctf_type_pointer</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_idepth</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dmp</name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_cdefs</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>dmp</name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ctfp</name> <operator>!=</operator> <name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name> <operator>&amp;&amp;</operator> <name>ctfp</name> <operator>!=</operator> <call><name>ctf_parent_file</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><name>type</name> <operator>=</operator> <call><name>ctf_add_type</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>, <argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ctferr</name></name> <operator>=</operator> <call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_CTF</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>ctf_add_pointer</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>, <argument><expr><name>CTF_ADD_ROOT</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>CTF_ERR</name> <operator>||</operator> <call><name>ctf_update</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ctferr</name></name> <operator>=</operator> <call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_CTF</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_object</name></name> <operator>=</operator> <name><name>dmp</name><operator>-&gt;</operator><name>dm_name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_ctfp</name></name> <operator>=</operator> <name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_type</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tip</name><operator>-&gt;</operator><name>dtt_flags</name></name> <operator>=</operator> <name>bflags</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>dt_type_name</name><parameter_list>(<parameter><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>ctfp</name></decl></parameter>, <parameter><decl><type><name>ctf_id_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ctfp</name> <operator>==</operator> <call><name>DT_FPTR_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <call><name>DT_FPTR_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"function pointer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ctfp</name> <operator>==</operator> <call><name>DT_FUNC_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <call><name>DT_FUNC_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ctfp</name> <operator>==</operator> <call><name>DT_DYN_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <call><name>DT_DYN_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"dynamic variable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>ctfp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"&lt;none&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>ctf_type_name</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"unknown"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>buf</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_type_promote</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>rp</name></decl></parameter>, <parameter><decl><type><name>ctf_file_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>ofp</name></decl></parameter>, <parameter><decl><type><name>ctf_id_t</name> <modifier>*</modifier></type><name>otype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>lfp</name> <init>= <expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>ltype</name> <init>= <expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>rfp</name> <init>= <expr><name><name>rp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>rtype</name> <init>= <expr><name><name>rp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>lbase</name> <init>= <expr><call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><name>ltype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>lkind</name> <init>= <expr><call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><name>lbase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>rbase</name> <init>= <expr><call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>rfp</name></expr></argument>, <argument><expr><name>rtype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>rkind</name> <init>= <expr><call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>rfp</name></expr></argument>, <argument><expr><name>rbase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_encoding_t</name></type> <name>le</name></decl>, <decl><type ref="prev"/><name>re</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>lrank</name></decl>, <decl><type ref="prev"/><name>rrank</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>lkind</name> <operator>==</operator> <name>CTF_K_INTEGER</name> <operator>||</operator> <name>lkind</name> <operator>==</operator> <name>CTF_K_ENUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rkind</name> <operator>==</operator> <name>CTF_K_INTEGER</name> <operator>||</operator> <name>rkind</name> <operator>==</operator> <name>CTF_K_ENUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lkind</name> <operator>==</operator> <name>CTF_K_ENUM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lfp</name> <operator>=</operator> <call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ltype</name> <operator>=</operator> <name>lbase</name> <operator>=</operator> <call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rkind</name> <operator>==</operator> <name>CTF_K_ENUM</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rfp</name> <operator>=</operator> <call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rtype</name> <operator>=</operator> <name>rbase</name> <operator>=</operator> <call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><name>lbase</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>le</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name><operator>-&gt;</operator><name>dt_ctferr</name></name> <operator>=</operator> <call><name>ctf_errno</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_CTF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name>rfp</name></expr></argument>, <argument><expr><name>rbase</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>re</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name><operator>-&gt;</operator><name>dt_ctferr</name></name> <operator>=</operator> <call><name>ctf_errno</name><argument_list>(<argument><expr><name>rfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_CTF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>lrank</name> <operator>=</operator> <name><name>le</name><operator>.</operator><name>cte_bits</name></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>le</name><operator>.</operator><name>cte_format</name></name> <operator>&amp;</operator> <name>CTF_INT_SIGNED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>rrank</name> <operator>=</operator> <name><name>re</name><operator>.</operator><name>cte_bits</name></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name><name>re</name><operator>.</operator><name>cte_format</name></name> <operator>&amp;</operator> <name>CTF_INT_SIGNED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lrank</name> <operator>==</operator> <name>rrank</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>lbase</name> <operator>-</operator> <name>rbase</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>return_rtype</name>;</goto></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<goto>goto <name>return_ltype</name>;</goto></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lrank</name> <operator>&gt;</operator> <name>rrank</name></expr>)</condition> <block>{<block_content>
<goto>goto <name>return_ltype</name>;</goto>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<goto>goto <name>return_rtype</name>;</goto></block_content></block></else></if_stmt>
<label><name>return_ltype</name>:</label>
<expr_stmt><expr><operator>*</operator><name>ofp</name> <operator>=</operator> <name>lfp</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>otype</name> <operator>=</operator> <name>ltype</name></expr>;</expr_stmt>
<return>return;</return>
<label><name>return_rtype</name>:</label>
<expr_stmt><expr><operator>*</operator><name>ofp</name> <operator>=</operator> <name>rfp</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>otype</name> <operator>=</operator> <name>rtype</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>dt_node_promote</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>rp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>dt_type_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>dt_node_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>n1</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n2</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>suffix</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>dtrace_syminfo_t</name> <modifier>*</modifier></type><name>dts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_NODE_INT</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"integer constant 0x%llx"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_STRING</name></expr>:</case>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>strchr2esc</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"string constant \"%s\""</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>s</name></expr> </then><else>: <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_IDENT</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"identifier %s"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_VAR</name></expr>:</case>
<case>case <expr><name>DT_NODE_FUNC</name></expr>:</case>
<case>case <expr><name>DT_NODE_AGG</name></expr>:</case>
<case>case <expr><name>DT_NODE_INLINE</name></expr>:</case>
<switch>switch <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_kind</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_IDENT_FUNC</name></expr>:</case>
<case>case <expr><name>DT_IDENT_AGGFUNC</name></expr>:</case>
<case>case <expr><name>DT_IDENT_ACTFUNC</name></expr>:</case>
<expr_stmt><expr><name>suffix</name> <operator>=</operator> <literal type="string">"( )"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_IDENT_AGG</name></expr>:</case>
<expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">"@"</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s %s%s%s"</literal></expr></argument>,
<argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_kind</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_SYM</name></expr>:</case>
<expr_stmt><expr><name>dts</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"symbol %s`%s"</literal></expr></argument>,
<argument><expr><name><name>dts</name><operator>-&gt;</operator><name>dts_object</name></name></expr></argument>, <argument><expr><name><name>dts</name><operator>-&gt;</operator><name>dts_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_TYPE</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"type %s"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_OP1</name></expr>:</case>
<case>case <expr><name>DT_NODE_OP2</name></expr>:</case>
<case>case <expr><name>DT_NODE_OP3</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"operator %s"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_DEXPR</name></expr>:</case>
<case>case <expr><name>DT_NODE_DFUNC</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_node_name</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"statement"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_PDESC</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_id</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
<argument><expr><literal type="string">"probe description %s:%s:%s:%s"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_provider</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_mod</name></name></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_func</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"probe description %u"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_CLAUSE</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"clause"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_MEMBER</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"member %s"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_XLATOR</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"translator &lt;%s&gt; (%s)"</literal></expr></argument>,
<argument><expr><call><name>dt_type_name</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_xlator</name><operator>-&gt;</operator><name>dx_dst_ctfp</name></name></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_xlator</name><operator>-&gt;</operator><name>dx_dst_type</name></name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_type_name</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_xlator</name><operator>-&gt;</operator><name>dx_src_ctfp</name></name></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_xlator</name><operator>-&gt;</operator><name>dx_src_type</name></name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_PROG</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"program"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"node &lt;%u&gt;"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><operator>(</operator><name>buf</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_xalloc</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name> <init>= <expr><call><name>dt_alloc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_node_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dnp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name> <operator>=</operator> <name>CTF_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>=</operator> <operator>(</operator><name>uchar_t</name><operator>)</operator><name>kind</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_line</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_reg</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_attr</name></name> <operator>=</operator> <name>_dtrace_defattr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_link</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_u</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_u</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_alloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name> <init>= <expr><call><name>dt_node_xalloc</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dnp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_line</name></name> <operator>=</operator> <name>yylineno</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_link</name></name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_list</name></name> <operator>=</operator> <name>dnp</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>dt_node_free</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uchar_t</name></type> <name>kind</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>=</operator> <name>DT_NODE_FREE</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_NODE_STRING</name></expr>:</case>
<case>case <expr><name>DT_NODE_IDENT</name></expr>:</case>
<case>case <expr><name>DT_NODE_TYPE</name></expr>:</case>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_VAR</name></expr>:</case>
<case>case <expr><name>DT_NODE_FUNC</name></expr>:</case>
<case>case <expr><name>DT_NODE_PROBE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_ORPHAN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_ident_destroy</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_list_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_OP1</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_child</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_child</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_child</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_OP3</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<case>case <expr><name>DT_NODE_OP2</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_DEXPR</name></expr>:</case>
<case>case <expr><name>DT_NODE_DFUNC</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_AGG</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_list_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggtup</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_PDESC</name></expr>:</case>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_spec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_spec</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_CLAUSE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pred</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pred</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_locals</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_idhash_destroy</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_locals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_list_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_pdescs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_list_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_acts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_MEMBER</name></expr>:</case>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membexpr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membexpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_PROVIDER</name></expr>:</case>
<expr_stmt><expr><call><name>dt_node_list_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_probes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_provname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_provname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_PROG</name></expr>:</case>
<expr_stmt><expr><call><name>dt_node_list_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>dt_node_attr_assign</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_attribute_t</name></type> <name>attr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_cflags</name></name> <operator>&amp;</operator> <name>DTRACE_C_EATTR</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>dt_attr_cmp</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_amin</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>a</name><index>[<expr><name>DTRACE_ATTR2STR_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>s</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_ATTR_MIN</name></expr></argument>, <argument><expr><literal type="string">"attributes for %s (%s) are less than "</literal>
<literal type="string">"predefined minimum\n"</literal></expr></argument>, <argument><expr><call><name>dt_node_name</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dtrace_attr2str</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_attr</name></name> <operator>=</operator> <name>attr</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>dt_node_type_assign</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>ctf_id_t</name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name>boolean_t</name></type> <name>user</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>base</name> <init>= <expr><call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>kind</name> <init>= <expr><call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_encoding_t</name></type> <name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;=</operator>
<operator>~</operator><operator>(</operator><name>DT_NF_SIGNED</name> <operator>|</operator> <name>DT_NF_REF</name> <operator>|</operator> <name>DT_NF_BITFIELD</name> <operator>|</operator> <name>DT_NF_USERLAND</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_INTEGER</name> <operator>&amp;&amp;</operator> <call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name><name>e</name><operator>.</operator><name>cte_bits</name></name> <operator>/</operator> <name>NBBY</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">8</literal> <operator>||</operator> <operator>(</operator><name><name>e</name><operator>.</operator><name>cte_bits</name></name> <operator>%</operator> <name>NBBY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>size</name> <operator>&amp;</operator> <operator>(</operator><name>size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_BITFIELD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>.</operator><name>cte_format</name></name> <operator>&amp;</operator> <name>CTF_INT_SIGNED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_SIGNED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_FLOAT</name> <operator>&amp;&amp;</operator> <call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>e</name><operator>.</operator><name>cte_bits</name></name> <operator>/</operator> <name>NBBY</name> <operator>&gt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_REF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_STRUCT</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>CTF_K_UNION</name> <operator>||</operator>
<name>kind</name> <operator>==</operator> <name>CTF_K_FORWARD</name> <operator>||</operator>
<name>kind</name> <operator>==</operator> <name>CTF_K_ARRAY</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>CTF_K_FUNCTION</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_REF</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>yypcb</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>fp</name> <operator>==</operator> <call><name>DT_DYN_CTFP</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name>type</name> <operator>==</operator> <call><name>DT_DYN_TYPE</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_REF</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>user</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_USERLAND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_COOKED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name> <operator>=</operator> <name>fp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>dt_node_type_propagate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <operator>~</operator><name>DT_NF_LVALUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>dn_ctfp</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>dn_type</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>dn_type</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>dt_node_type_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
<argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><call><name>dt_ident_resolve</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>di_kind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>buf</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"userland "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><name>len</name> <operator>&gt;</operator> <name>n</name></expr> ?</condition><then> <expr><name>len</name> <operator>-</operator> <name>n</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_type_name</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>buf</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><call><name>dt_type_name</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>size_t</name></type>
<name>dt_node_type_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_STRING</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_ident_size</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_K_FORWARD</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_K_POINTER</name> <operator>&amp;&amp;</operator>
<call><name>ctf_getmodel</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_MODEL_ILP32</name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>dtp</name><operator>-&gt;</operator><name>dt_conf</name><operator>.</operator><name>dtc_ctfmodel</name></name> <operator>==</operator> <name>CTF_MODEL_LP64</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">8</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><call><name>ctf_type_size</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_ident_t</name> <modifier>*</modifier></type>
<name>dt_node_resolve</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_NODE_VAR</name></expr>:</case>
<case>case <expr><name>DT_NODE_SYM</name></expr>:</case>
<case>case <expr><name>DT_NODE_FUNC</name></expr>:</case>
<case>case <expr><name>DT_NODE_AGG</name></expr>:</case>
<case>case <expr><name>DT_NODE_INLINE</name></expr>:</case>
<case>case <expr><name>DT_NODE_PROBE</name></expr>:</case>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <call><name>dt_ident_resolve</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>==</operator> <name>idkind</name></expr> ?</condition><then> <expr><name>idp</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <call><name>dt_ident_resolve</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>==</operator> <name>idkind</name></expr> ?</condition><then> <expr><name>idp</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>size_t</name></type>
<name>dt_node_sizeof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_syminfo_t</name> <modifier>*</modifier></type><name>sip</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_SYM</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>dt_node_type_size</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>sip</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_data</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_lookup_by_name</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>sip</name><operator>-&gt;</operator><name>dts_object</name></name></expr></argument>,
<argument><expr><name><name>sip</name><operator>-&gt;</operator><name>dts_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>sym</name><operator>.</operator><name>st_size</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_integer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_encoding_t</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>kind</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_INTEGER</name> <operator>&amp;&amp;</operator>
<call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_VOID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>kind</name> <operator>==</operator> <name>CTF_K_INTEGER</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>CTF_K_ENUM</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_float</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_encoding_t</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>kind</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>kind</name> <operator>==</operator> <name>CTF_K_FLOAT</name> <operator>&amp;&amp;</operator>
<call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator>
<name><name>e</name><operator>.</operator><name>cte_format</name></name> <operator>==</operator> <name>CTF_FP_SINGLE</name> <operator>||</operator> <name><name>e</name><operator>.</operator><name>cte_format</name></name> <operator>==</operator> <name>CTF_FP_DOUBLE</name> <operator>||</operator>
<name><name>e</name><operator>.</operator><name>cte_format</name></name> <operator>==</operator> <name>CTF_FP_LDOUBLE</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_scalar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_encoding_t</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>kind</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_INTEGER</name> <operator>&amp;&amp;</operator>
<call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_VOID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>kind</name> <operator>==</operator> <name>CTF_K_INTEGER</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>CTF_K_ENUM</name> <operator>||</operator>
<name>kind</name> <operator>==</operator> <name>CTF_K_POINTER</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_arith</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_encoding_t</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>kind</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_INTEGER</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_VOID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>kind</name> <operator>==</operator> <name>CTF_K_ENUM</name><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_vfptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_encoding_t</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>kind</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CTF_K_POINTER</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>ctf_type_reference</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>kind</name> <operator>==</operator> <name>CTF_K_FUNCTION</name> <operator>||</operator> <operator>(</operator><name>kind</name> <operator>==</operator> <name>CTF_K_INTEGER</name> <operator>&amp;&amp;</operator>
<call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_VOID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_dynamic</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_VAR</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_INLINE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>dt_idnode_t</name> <modifier>*</modifier></type><name>inp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_iarg</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>inp</name><operator>-&gt;</operator><name>din_root</name></name></expr> ?</condition><then> <expr><call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>din_root</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name> <operator>==</operator> <call><name>DT_DYN_CTFP</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name> <operator>==</operator> <call><name>DT_DYN_TYPE</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name> <operator>==</operator> <call><name>DT_STR_CTFP</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name> <operator>==</operator> <call><name>DT_STR_TYPE</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_stack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name> <operator>==</operator> <call><name>DT_STACK_CTFP</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name> <operator>==</operator> <call><name>DT_STACK_TYPE</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_symaddr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name> <operator>==</operator> <call><name>DT_SYMADDR_CTFP</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name> <operator>==</operator> <call><name>DT_SYMADDR_TYPE</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_usymaddr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name> <operator>==</operator> <call><name>DT_USYMADDR_CTFP</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name> <operator>==</operator> <call><name>DT_USYMADDR_TYPE</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_strcompat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_encoding_t</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_arinfo_t</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>kind</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_POINTER</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>base</name> <operator>=</operator> <call><name>ctf_type_reference</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CTF_ERR</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>base</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CTF_ERR</name> <operator>&amp;&amp;</operator>
<call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_CHAR</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_ARRAY</name> <operator>&amp;&amp;</operator> <call><name>ctf_array_info</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>base</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ctr_contents</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>CTF_ERR</name> <operator>&amp;&amp;</operator>
<call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_CHAR</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_pointer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>kind</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>kind</name> <operator>==</operator> <name>CTF_K_POINTER</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>CTF_K_ARRAY</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_void</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_encoding_t</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_stack</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_symaddr</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>dt_node_is_usymaddr</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_K_INTEGER</name> <operator>&amp;&amp;</operator>
<call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_VOID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_ptrcompat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>rp</name></decl></parameter>,
<parameter><decl><type><name>ctf_file_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>fpp</name></decl></parameter>, <parameter><decl><type><name>ctf_id_t</name> <modifier>*</modifier></type><name>tp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>lfp</name> <init>= <expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>rfp</name> <init>= <expr><name><name>rp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>lbase</name> <init>= <expr><name>CTF_ERR</name></expr></init></decl>, <decl><type ref="prev"/><name>rbase</name> <init>= <expr><name>CTF_ERR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>lref</name> <init>= <expr><name>CTF_ERR</name></expr></init></decl>, <decl><type ref="prev"/><name>rref</name> <init>= <expr><name>CTF_ERR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lp_is_void</name></decl>, <decl><type ref="prev"/><name>rp_is_void</name></decl>, <decl><type ref="prev"/><name>lp_is_int</name></decl>, <decl><type ref="prev"/><name>rp_is_int</name></decl>, <decl><type ref="prev"/><name>compat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>lkind</name></decl>, <decl><type ref="prev"/><name>rkind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_encoding_t</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_arinfo_t</name></type> <name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>lp_is_int</name> <operator>=</operator> <call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp_is_int</name> <operator>=</operator> <call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lp_is_int</name> <operator>&amp;&amp;</operator> <name>rp_is_int</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>lp_is_int</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_INT</name> <operator>||</operator> <name><name>lp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rp_is_int</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>rp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_INT</name> <operator>||</operator> <name><name>rp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>lp_is_int</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>rp_is_int</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator>
<operator>(</operator><name><name>lp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name><operator>)</operator> <operator>^</operator> <operator>(</operator><name><name>rp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lp_is_int</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lbase</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lkind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><name>lbase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lkind</name> <operator>==</operator> <name>CTF_K_POINTER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lref</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>,
<argument><expr><call><name>ctf_type_reference</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><name>lbase</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lkind</name> <operator>==</operator> <name>CTF_K_ARRAY</name> <operator>&amp;&amp;</operator>
<call><name>ctf_array_info</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><name>lbase</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lref</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ctr_contents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rp_is_int</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rbase</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>rfp</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rkind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>rfp</name></expr></argument>, <argument><expr><name>rbase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rkind</name> <operator>==</operator> <name>CTF_K_POINTER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rref</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>rfp</name></expr></argument>,
<argument><expr><call><name>ctf_type_reference</name><argument_list>(<argument><expr><name>rfp</name></expr></argument>, <argument><expr><name>rbase</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rkind</name> <operator>==</operator> <name>CTF_K_ARRAY</name> <operator>&amp;&amp;</operator>
<call><name>ctf_array_info</name><argument_list>(<argument><expr><name>rfp</name></expr></argument>, <argument><expr><name>rbase</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rref</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>rfp</name></expr></argument>, <argument><expr><name><name>r</name><operator>.</operator><name>ctr_contents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>lp_is_int</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>lbase</name> <operator>=</operator> <name>rbase</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lkind</name> <operator>=</operator> <name>rkind</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lref</name> <operator>=</operator> <name>rref</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lfp</name> <operator>=</operator> <name>rfp</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>rp_is_int</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rbase</name> <operator>=</operator> <name>lbase</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rkind</name> <operator>=</operator> <name>lkind</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rref</name> <operator>=</operator> <name>lref</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rfp</name> <operator>=</operator> <name>lfp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>lp_is_void</name> <operator>=</operator> <call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><name>lref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_VOID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp_is_void</name> <operator>=</operator> <call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name>rfp</name></expr></argument>, <argument><expr><name>rref</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_VOID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>compat</name> <operator>=</operator> <operator>(</operator><name>lkind</name> <operator>==</operator> <name>CTF_K_POINTER</name> <operator>||</operator> <name>lkind</name> <operator>==</operator> <name>CTF_K_ARRAY</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>rkind</name> <operator>==</operator> <name>CTF_K_POINTER</name> <operator>||</operator> <name>rkind</name> <operator>==</operator> <name>CTF_K_ARRAY</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>lp_is_void</name> <operator>||</operator> <name>rp_is_void</name> <operator>||</operator> <call><name>ctf_type_compat</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><name>lref</name></expr></argument>, <argument><expr><name>rfp</name></expr></argument>, <argument><expr><name>rref</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>compat</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fpp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>fpp</name> <operator>=</operator> <ternary><condition><expr><name>rp_is_void</name></expr> ?</condition><then> <expr><name>lfp</name></expr> </then><else>: <expr><name>rfp</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>tp</name> <operator>=</operator> <ternary><condition><expr><name>rp_is_void</name></expr> ?</condition><then> <expr><name>lbase</name></expr> </then><else>: <expr><name>rbase</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>compat</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_argcompat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>lfp</name> <init>= <expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>rfp</name> <init>= <expr><name><name>rp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_strcompat</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>dt_node_is_strcompat</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_stack</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>dt_node_is_stack</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_symaddr</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>dt_node_is_symaddr</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_usymaddr</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>dt_node_is_usymaddr</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CTF_K_FUNCTION</name></expr>:</case>
<case>case <expr><name>CTF_K_STRUCT</name></expr>:</case>
<case>case <expr><name>CTF_K_UNION</name></expr>:</case>
<return>return <expr><operator>(</operator><call><name>ctf_type_compat</name><argument_list>(<argument><expr><name>lfp</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>, <argument><expr><name>rfp</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<default>default:</default>
<return>return <expr><operator>(</operator><call><name>dt_node_is_ptrcompat</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_posconst</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_INT</name> <operator>&amp;&amp;</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator>
<operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_SIGNED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_is_actfunc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_FUNC</name> <operator>&amp;&amp;</operator>
<name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>==</operator> <name>DT_IDENT_ACTFUNC</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_int</name><parameter_list>(<parameter><decl><type><name>uintmax_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name> <init>= <expr><call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_INT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>yyintdecimal</name> <operator>|</operator> <operator>(</operator><name><name>yyintsuffix</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'u'</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>=</operator> <name>DT_TOK_INT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>yyintsuffix</name></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'U'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'L'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ints</name></name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ints</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>n</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_ints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>did_limit</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>did_ctfp</name></expr></argument>,
<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ints</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>did_type</name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>yyintprefix</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'+'</literal></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_node_op1</name><argument_list>(<argument><expr><name>DT_TOK_IPOS</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<case>case <expr><literal type="char">'-'</literal></expr>:</case>
<return>return <expr><operator>(</operator><call><name>dt_node_op1</name><argument_list>(<argument><expr><name>DT_TOK_INEG</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
<default>default:</default>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_INT_OFLOW</name></expr></argument>, <argument><expr><literal type="string">"integer constant 0x%llx cannot be represented "</literal>
<literal type="string">"in any built-in integral type\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_string</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>string</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>=</operator> <name>DT_TOK_STRING</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>DT_STR_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_STR_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_ident</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_idstack_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_globals</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>idp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_INLINE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dt_idnode_t</name> <modifier>*</modifier></type><name>inp</name> <init>= <expr><name><name>idp</name><operator>-&gt;</operator><name>di_iarg</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>inp</name><operator>-&gt;</operator><name>din_root</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<name><name>inp</name><operator>-&gt;</operator><name>din_root</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_INT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_INT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>=</operator> <name>DT_TOK_INT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name><name>inp</name><operator>-&gt;</operator><name>din_root</name><operator>-&gt;</operator><name>dn_value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_propagate</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>din_root</name></name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_IDENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>=</operator> <ternary><condition><expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal></expr> ?</condition><then> <expr><name>DT_TOK_AGG</name></expr> </then><else>: <expr><name>DT_TOK_IDENT</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_type</name><parameter_list>(<parameter><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_typeinfo_t</name></type> <name>dtt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ddp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ddp</name> <operator>=</operator> <call><name>dt_decl_pop_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_decl_type</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_decl_free</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>=</operator> <name>DT_TOK_IDENT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_cdefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name> <operator>||</operator>
<name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>_dtrace_defattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>_dtrace_typattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_vatype</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name> <init>= <expr><call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_TYPE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>=</operator> <name>DT_TOK_IDENT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name><operator>-&gt;</operator><name>dt_cdefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name> <operator>=</operator> <name>CTF_ERR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_attr</name></name> <operator>=</operator> <name>_dtrace_defattr</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_decl</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name> <init>= <expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_dclass_t</name></type> <name>class</name> <init>= <expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_class</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><call><name>dt_decl_top</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_module_t</name> <modifier>*</modifier></type><name>dmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_typeinfo_t</name></type> <name>dtt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n1</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n2</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_decl_type</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtt</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>!=</operator> <name>CTF_K_STRUCT</name> <operator>&amp;&amp;</operator>
<name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>!=</operator> <name>CTF_K_UNION</name> <operator>&amp;&amp;</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>!=</operator> <name>CTF_K_ENUM</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_USELESS</name></expr></argument>, <argument><expr><literal type="string">"useless declaration\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"type %s added as id %ld\n"</literal></expr></argument>, <argument><expr><call><name>dt_type_name</name><argument_list>(
<argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_ctfp</name></name></expr></argument>, <argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_type</name></name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_SCOPE</name></expr></argument>, <argument><expr><literal type="string">"D scoping operator may not be used in "</literal>
<literal type="string">"a declaration name (%s)\n"</literal></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_idepth</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dmp</name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_cdefs</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>dmp</name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_K_FUNCTION</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>class</name> <operator>==</operator> <name>DT_DC_DEFAULT</name> <operator>||</operator> <name>class</name> <operator>==</operator> <name>DT_DC_STATIC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>class</name> <operator>=</operator> <name>DT_DC_EXTERN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>class</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_DC_AUTO</name></expr>:</case>
<case>case <expr><name>DT_DC_REGISTER</name></expr>:</case>
<case>case <expr><name>DT_DC_STATIC</name></expr>:</case>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_BADCLASS</name></expr></argument>, <argument><expr><literal type="string">"specified storage class not "</literal>
<literal type="string">"appropriate in D\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>DT_DC_EXTERN</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>dtrace_typeinfo_t</name></type> <name>ott</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_syminfo_t</name></type> <name>dts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>exists</name> <init>= <expr><call><name>dtrace_lookup_by_name</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_name</name></name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>exists</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>dtrace_symbol_type</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ott</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>ctf_type_cmp</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>,
<argument><expr><name><name>ott</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>ott</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_IDRED</name></expr></argument>, <argument><expr><literal type="string">"identifier redeclared: %s`%s\n"</literal>
<literal type="string">"\t current: %s\n\tprevious: %s\n"</literal></expr></argument>,
<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_name</name></name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>,
<argument><expr><call><name>dt_type_name</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>,
<argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_type_name</name><argument_list>(<argument><expr><name><name>ott</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>ott</name><operator>.</operator><name>dtt_type</name></name></expr></argument>,
<argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>exists</name> <operator>&amp;&amp;</operator> <call><name>dt_module_extern</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>dmp</name></expr></argument>,
<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtt</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>,
<argument><expr><literal type="string">"failed to extern %s: %s\n"</literal></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>,
<argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"extern %s`%s type=&lt;%s&gt;\n"</literal></expr></argument>,
<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_name</name></name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>,
<argument><expr><call><name>dt_type_name</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>,
<argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>DT_DC_TYPEDEF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dt_idstack_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_globals</name></name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_IDRED</name></expr></argument>, <argument><expr><literal type="string">"global variable identifier "</literal>
<literal type="string">"redeclared: %s\n"</literal></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_lookup_by_name</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>,
<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_IDRED</name></expr></argument>,
<argument><expr><literal type="string">"typedef redeclared: %s\n"</literal></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name> <operator>!=</operator> <name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name> <operator>&amp;&amp;</operator>
<name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name> <operator>!=</operator> <call><name>ctf_parent_file</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name> <operator>=</operator> <call><name>ctf_add_type</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>,
<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name> <operator>=</operator> <name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name> <operator>==</operator> <name>CTF_ERR</name> <operator>||</operator>
<call><name>ctf_update</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to copy typedef %s "</literal>
<literal type="string">"source type: %s\n"</literal></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>,
<argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_add_typedef</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>,
<argument><expr><name>CTF_ADD_ROOT</name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>CTF_ERR</name> <operator>||</operator> <call><name>ctf_update</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to typedef %s: %s\n"</literal></expr></argument>,
<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>, <argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>dmp</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"typedef %s added as id %ld\n"</literal></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default> <block>{<block_content>
<decl_stmt><decl><type><name>ctf_encoding_t</name></type> <name>cte</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_idhash_t</name> <modifier>*</modifier></type><name>dhp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name></type> <name>idn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>assc</name></decl>, <decl><type ref="prev"/><name>idkind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>id</name></decl>, <decl><type ref="prev"/><name>kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ushort_t</name></type> <name>idflags</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>class</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_DC_THIS</name></expr>:</case>
<expr_stmt><expr><name>dhp</name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_locals</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idflags</name> <operator>=</operator> <name>DT_IDFLG_LOCAL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <call><name>dt_idhash_lookup</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_DC_SELF</name></expr>:</case>
<expr_stmt><expr><name>dhp</name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_tls</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idflags</name> <operator>=</operator> <name>DT_IDFLG_TLS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <call><name>dt_idhash_lookup</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>dhp</name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idflags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <call><name>dt_idstack_lookup</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_globals</name></name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_ARRAY</name> <operator>&amp;&amp;</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_ARRNULL</name></expr></argument>,
<argument><expr><literal type="string">"array declaration requires array dimension or "</literal>
<literal type="string">"tuple signature: %s\n"</literal></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>idp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>idp</name><operator>-&gt;</operator><name>di_gen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_IDRED</name></expr></argument>, <argument><expr><literal type="string">"built-in identifier "</literal>
<literal type="string">"redeclared: %s\n"</literal></expr></argument>, <argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_lookup_by_type</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>DTRACE_OBJ_CDEFS</name></expr></argument>,
<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>dtrace_lookup_by_type</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>DTRACE_OBJ_DDEFS</name></expr></argument>,
<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_IDRED</name></expr></argument>, <argument><expr><literal type="string">"typedef identifier "</literal>
<literal type="string">"redeclared: %s\n"</literal></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>assc</name> <operator>=</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_ARRAY</name> <operator>&amp;&amp;</operator>
<name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_TYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idkind</name> <operator>=</operator> <ternary><condition><expr><name>assc</name></expr> ?</condition><then> <expr><name>DT_IDENT_ARRAY</name></expr> </then><else>: <expr><name>DT_IDENT_SCALAR</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idn</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_node_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>idp</name><operator>-&gt;</operator><name>di_type</name></name> <operator>!=</operator> <name>CTF_ERR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idn</name></expr></argument>, <argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_ctfp</name></name></expr></argument>, <argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_type</name></name></expr></argument>,
<argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>idp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_ident_cook</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idn</name></expr></argument>, <argument><expr><name>idp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>assc</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>class</name> <operator>==</operator> <name>DT_DC_THIS</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_LOCASSC</name></expr></argument>, <argument><expr><literal type="string">"associative arrays "</literal>
<literal type="string">"may not be declared as local variables:"</literal>
<literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_decl_type</name><argument_list>(<argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtt</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>idp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>!=</operator> <name>idkind</name> <operator>||</operator>
<call><name>ctf_type_cmp</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>,
<argument><expr><name><name>idn</name><operator>.</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>idn</name><operator>.</operator><name>dn_type</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_IDRED</name></expr></argument>, <argument><expr><literal type="string">"identifier redeclared: %s\n"</literal>
<literal type="string">"\t current: %s %s\n\tprevious: %s %s\n"</literal></expr></argument>,
<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>, <argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name>idkind</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_type_name</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>,
<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idn</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>idp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>assc</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>dt_idsig_t</name> <modifier>*</modifier></type><name>isp</name> <init>= <expr><name><name>idp</name><operator>-&gt;</operator><name>di_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name> <init>= <expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init> <condition><expr><name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr><operator>,</operator> <expr><name>argc</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>pnp</name> <init>= <expr><operator>&amp;</operator><name><name>isp</name><operator>-&gt;</operator><name>dis_args</name><index>[<expr><name>argc</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;=</operator> <name><name>isp</name><operator>-&gt;</operator><name>dis_argc</name></name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_cmp</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>,
<argument><expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_IDRED</name></expr></argument>,
<argument><expr><literal type="string">"identifier redeclared: %s\n"</literal>
<literal type="string">"\t current: %s, key #%d of type %s\n"</literal>
<literal type="string">"\tprevious: %s, key #%d of type %s\n"</literal></expr></argument>,
<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>,
<argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name>idkind</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>pnp</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>isp</name><operator>-&gt;</operator><name>dis_argc</name></name> <operator>!=</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_IDRED</name></expr></argument>,
<argument><expr><literal type="string">"identifier redeclared: %s\n"</literal>
<literal type="string">"\t current: %s of %s, tuple length %d\n"</literal>
<literal type="string">"\tprevious: %s of %s, tuple length %d\n"</literal></expr></argument>,
<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>, <argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name>idkind</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_type_name</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>,
<argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>argc</name></expr></argument>,
<argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idn</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>isp</name><operator>-&gt;</operator><name>dis_argc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>idp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CTF_K_INTEGER</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>cte</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_VOID</name><argument_list>(<argument><expr><name>cte</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_VOIDOBJ</name></expr></argument>, <argument><expr><literal type="string">"cannot have "</literal>
<literal type="string">"void object: %s\n"</literal></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>CTF_K_STRUCT</name></expr>:</case>
<case>case <expr><name>CTF_K_UNION</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_size</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<case>case <expr><name>CTF_K_FORWARD</name></expr>:</case>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_INCOMPLETE</name></expr></argument>,
<argument><expr><literal type="string">"incomplete struct/union/enum %s: %s\n"</literal></expr></argument>,
<argument><expr><call><name>dt_type_name</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>,
<argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><call><name>dt_idhash_nextid</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_ID_OFLOW</name></expr></argument>, <argument><expr><literal type="string">"cannot create %s: limit "</literal>
<literal type="string">"on number of %s variables exceeded\n"</literal></expr></argument>,
<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>, <argument><expr><call><name>dt_idhash_name</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"declare %s %s variable %s, id=%u\n"</literal></expr></argument>,
<argument><expr><call><name>dt_idhash_name</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name>idkind</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <call><name>dt_idhash_insert</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>, <argument><expr><name>idkind</name></expr></argument>,
<argument><expr><name>idflags</name> <operator>|</operator> <name>DT_IDFLG_WRITE</name> <operator>|</operator> <name>DT_IDFLG_DECL</name></expr></argument>, <argument><expr><name>id</name></expr></argument>,
<argument><expr><name>_dtrace_defattr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>assc</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>dt_idops_assc</name></expr> </then><else>:
<expr><operator>&amp;</operator><name>dt_idops_thaw</name></expr></else></ternary></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_ident_type_assign</name><argument_list>(<argument><expr><name>idp</name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>assc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_attr</name></name> <operator>=</operator>
<call><name>dt_ident_cook</name><argument_list>(<argument><expr><operator>&amp;</operator><name>idn</name></expr></argument>, <argument><expr><name>idp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_func</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_IDENT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_FUNC_IDENT</name></expr></argument>,
<argument><expr><literal type="string">"function designator is not of function type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <call><name>dt_idstack_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_globals</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_FUNC_UNDEF</name></expr></argument>,
<argument><expr><literal type="string">"undefined function name: %s\n"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>!=</operator> <name>DT_IDENT_FUNC</name> <operator>&amp;&amp;</operator>
<name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>!=</operator> <name>DT_IDENT_AGGFUNC</name> <operator>&amp;&amp;</operator>
<name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>!=</operator> <name>DT_IDENT_ACTFUNC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_FUNC_IDKIND</name></expr></argument>, <argument><expr><literal type="string">"%s '%s' may not be referenced as a "</literal>
<literal type="string">"function\n"</literal></expr></argument>, <argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>=</operator> <name>DT_NODE_FUNC</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>DT_NF_COOKED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name> <operator>=</operator> <name>idp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_offsetof</name><parameter_list>(<parameter><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_typeinfo_t</name></type> <name>dtt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name></type> <name>dn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_membinfo_t</name></type> <name>ctm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>kind</name></decl>;</decl_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>alloca</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_decl_type</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_decl_free</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>!=</operator> <name>CTF_K_STRUCT</name> <operator>&amp;&amp;</operator> <name>kind</name> <operator>!=</operator> <name>CTF_K_UNION</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OFFSETOF_TYPE</name></expr></argument>,
<argument><expr><literal type="string">"offsetof operand must be a struct or union type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_member_info</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctm</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"failed to determine offset of %s: %s\n"</literal></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>ctf_errmsg</name><argument_list>(<argument><expr><call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dn</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dn</name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>ctm</name><operator>.</operator><name>ctm_type</name></name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dn</name><operator>.</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_BITFIELD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OFFSETOF_BITFIELD</name></expr></argument>,
<argument><expr><literal type="string">"cannot take offset of a bit-field: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><call><name>dt_node_int</name><argument_list>(<argument><expr><name><name>ctm</name><operator>.</operator><name>ctm_offset</name></name> <operator>/</operator> <name>NBBY</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_op1</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_INT</name></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_TOK_INEG</name></expr>:</case>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <operator>-</operator><name><name>cp</name><operator>-&gt;</operator><name>dn_value</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_SIGNED</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">0ULL</literal> <operator>&gt;&gt;</operator>
<operator>(</operator><literal type="number">64</literal> <operator>-</operator> <call><name>dt_node_type_size</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>NBBY</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<case>case <expr><name>DT_TOK_IPOS</name></expr>:</case>
<return>return <expr><operator>(</operator><name>cp</name><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_BNEG</name></expr>:</case>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <operator>~</operator><name><name>cp</name><operator>-&gt;</operator><name>dn_value</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>cp</name><operator>)</operator></expr>;</return>
<case>case <expr><name>DT_TOK_LNEG</name></expr>:</case>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <operator>!</operator><name><name>cp</name><operator>-&gt;</operator><name>dn_value</name></name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>cp</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DT_TOK_SIZEOF</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_STRING</name> <operator>||</operator> <name><name>cp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_TYPE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>dt_node_type_size</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_SIZEOF_TYPE</name></expr></argument>, <argument><expr><literal type="string">"cannot apply sizeof to an "</literal>
<literal type="string">"operand of unknown size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>,
<argument><expr><call><name>ctf_lookup_by_name</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>, <argument><expr><literal type="string">"size_t"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>=</operator> <name>DT_NODE_INT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>=</operator> <name>DT_TOK_INT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>cp</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_OP1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>USHRT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>=</operator> <operator>(</operator><name>ushort_t</name><operator>)</operator><name>op</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_child</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_cast</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>srcsize</name> <init>= <expr><call><name>dt_node_type_size</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>dstsize</name> <init>= <expr><call><name>dt_node_type_size</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>dstsize</name> <operator>&lt;</operator> <name>srcsize</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>dstsize</name><operator>)</operator> <operator>*</operator> <name>NBBY</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&lt;&lt;=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&gt;&gt;=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dstsize</name> <operator>&gt;</operator> <name>srcsize</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><operator>(</operator><sizeof>sizeof <argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>srcsize</name><operator>)</operator> <operator>*</operator> <name>NBBY</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><operator>(</operator><name>dstsize</name> <operator>-</operator> <name>srcsize</name><operator>)</operator> <operator>*</operator> <name>NBBY</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&lt;&lt;=</operator> <name>n</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_SIGNED</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name><name>rp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&gt;&gt;</operator> <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&gt;&gt;=</operator> <name>n</name> <operator>-</operator> <name>s</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>&gt;&gt;=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_op2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_INT</name> <operator>&amp;&amp;</operator> <name><name>rp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>op</name> <operator>==</operator> <name>DT_TOK_MOD</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>DT_TOK_DIV</name> <operator>||</operator>
<name>op</name> <operator>==</operator> <name>DT_TOK_MOD_EQ</name> <operator>||</operator> <name>op</name> <operator>==</operator> <name>DT_TOK_DIV_EQ</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DIV_ZERO</name></expr></argument>, <argument><expr><literal type="string">"expression contains division by zero\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_INT</name> <operator>&amp;&amp;</operator> <name><name>rp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_INT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>l</name> <init>= <expr><name><name>lp</name><operator>-&gt;</operator><name>dn_value</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uintmax_t</name></type> <name>r</name> <init>= <expr><name><name>rp</name><operator>-&gt;</operator><name>dn_value</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_int</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_TOK_LOR</name></expr>:</case>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>||</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_LXOR</name></expr>:</case>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <operator>(</operator><name>l</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>^</operator> <operator>(</operator><name>r</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_LAND</name></expr>:</case>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>&amp;&amp;</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_BOR</name></expr>:</case>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>|</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_XOR</name></expr>:</case>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>^</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_BAND</name></expr>:</case>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>&amp;</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_EQU</name></expr>:</case>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>==</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_NEQ</name></expr>:</case>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>!=</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_LT</name></expr>:</case>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_SIGNED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>l</name> <operator>&lt;</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>r</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>&lt;</operator> <name>r</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_LE</name></expr>:</case>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_SIGNED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>l</name> <operator>&lt;=</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>r</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>&lt;=</operator> <name>r</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_GT</name></expr>:</case>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_SIGNED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>l</name> <operator>&gt;</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>r</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>&gt;</operator> <name>r</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_GE</name></expr>:</case>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_SIGNED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>l</name> <operator>&gt;=</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>r</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>&gt;=</operator> <name>r</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_LSH</name></expr>:</case>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>&lt;&lt;</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_propagate</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>rp</name></expr></argument>,
<argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_RSH</name></expr>:</case>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>&gt;&gt;</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_propagate</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>rp</name></expr></argument>,
<argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_ADD</name></expr>:</case>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>+</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_SUB</name></expr>:</case>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>-</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_MUL</name></expr>:</case>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>*</operator> <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_DIV</name></expr>:</case>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_SIGNED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>l</name> <operator>/</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>r</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>/</operator> <name>r</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_MOD</name></expr>:</case>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_SIGNED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>l</name> <operator>%</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>r</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <name>l</name> <operator>%</operator> <name>r</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DT_TOK_LPAR</name> <operator>&amp;&amp;</operator> <name><name>rp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_INT</name> <operator>&amp;&amp;</operator>
<call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_cast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_propagate</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>rp</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_OP2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>op</name> <operator>&lt;=</operator> <name>USHRT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>=</operator> <operator>(</operator><name>ushort_t</name><operator>)</operator><name>op</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <name>lp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_op3</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_INT</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><ternary><condition><expr><name><name>expr</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>lp</name></expr> </then><else>: <expr><name>rp</name></expr></else></ternary><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_OP3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>=</operator> <name>DT_TOK_QUESTION</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <name>lp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_statement</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_AGG</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>expr</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_FUNC</name> <operator>&amp;&amp;</operator>
<name><name>expr</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>==</operator> <name>DT_IDENT_ACTFUNC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_DFUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_DEXPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_if</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>pred</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>acts</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>else_acts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name> <init>= <expr><call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_IF</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_conditional</name></name> <operator>=</operator> <name>pred</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_body</name></name> <operator>=</operator> <name>acts</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_alternate_body</name></name> <operator>=</operator> <name>else_acts</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_pdesc_by_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>spec</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_PDESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_spec</name></name> <operator>=</operator> <name>spec</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dtrace_probedesc_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_xstr2desc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pspec</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_spec</name></name></expr></argument>,
<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_sargc</name></name></expr></argument>, <argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_sargv</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_PDESC_INVAL</name></expr></argument>, <argument><expr><literal type="string">"invalid probe description \"%s\": %s\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_spec</name></name></expr></argument>, <argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_spec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_spec</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_pdesc_by_id</name><parameter_list>(<parameter><decl><type><name>uintmax_t</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>names</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"providers"</literal></expr>, <expr><literal type="string">"modules"</literal></expr>, <expr><literal type="string">"functions"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name> <init>= <expr><call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_PDESC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dtrace_probedesc_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>id</name> <operator>&gt;</operator> <name>UINT_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_PDESC_INVAL</name></expr></argument>, <argument><expr><literal type="string">"identifier %llu exceeds maximum "</literal>
<literal type="string">"probe id\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pspec</name></name> <operator>!=</operator> <name>DTRACE_PROBESPEC_NAME</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_PDESC_INVAL</name></expr></argument>, <argument><expr><literal type="string">"probe identifier %llu not permitted "</literal>
<literal type="string">"when specifying %s\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name>id</name></expr></argument>,
<argument><expr><name><name>names</name><index>[<expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pspec</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_id2desc</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><operator>(</operator><name>dtrace_id_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_PDESC_INVAL</name></expr></argument>, <argument><expr><literal type="string">"invalid probe identifier %llu: %s\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name>id</name></expr></argument>, <argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_clause</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>pdescs</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>pred</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>acts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name> <init>= <expr><call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_CLAUSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pdescs</name></name> <operator>=</operator> <name>pdescs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pred</name></name> <operator>=</operator> <name>pred</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_acts</name></name> <operator>=</operator> <name>acts</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_inline</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_scope_t</name> <modifier>*</modifier></type><name>dsp</name> <init>= <expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_dstack</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name> <init>= <expr><call><name>dt_decl_top</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_typeinfo_t</name></type> <name>dtt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rdp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_idnode_t</name> <modifier>*</modifier></type><name>inp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_decl_type</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtt</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_class</name></name> <operator>!=</operator> <name>DT_DC_DEFAULT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_BADCLASS</name></expr></argument>, <argument><expr><literal type="string">"specified storage class not "</literal>
<literal type="string">"appropriate for inline declaration\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_USELESS</name></expr></argument>, <argument><expr><literal type="string">"inline declaration requires a name\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_idstack_lookup</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_globals</name></name></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_IDRED</name></expr></argument>, <argument><expr><literal type="string">"identifier redefined: %s\n\t current: "</literal>
<literal type="string">"inline definition\n\tprevious: %s %s\n"</literal></expr></argument>,
<argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name><name>idp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_INLINE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"inline"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_ARRAY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_ARRNULL</name></expr></argument>, <argument><expr><literal type="string">"inline declaration requires "</literal>
<literal type="string">"array tuple signature: %s\n"</literal></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_TYPE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_ARRNULL</name></expr></argument>, <argument><expr><literal type="string">"inline declaration cannot be "</literal>
<literal type="string">"of scalar array type: %s\n"</literal></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_decl_type</name><argument_list>(<argument><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_next</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtt</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_INLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>_dtrace_defattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_void</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_VOIDOBJ</name></expr></argument>,
<argument><expr><literal type="string">"cannot declare void inline: %s\n"</literal></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><call><name>ctf_type_resolve</name><argument_list>(
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_K_FORWARD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DECL_INCOMPLETE</name></expr></argument>,
<argument><expr><literal type="string">"incomplete struct/union/enum %s: %s\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>inp</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_idnode_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><name>inp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_idnode_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name> <operator>=</operator> <call><name>dt_ident_create</name><argument_list>(<argument><expr><name><name>dsp</name><operator>-&gt;</operator><name>ds_ident</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_ARRAY</name></expr> ?</condition><then> <expr><name>DT_IDENT_ARRAY</name></expr> </then><else>: <expr><name>DT_IDENT_SCALAR</name></expr></else></ternary></expr></argument>,
<argument><expr><name>DT_IDFLG_INLINE</name> <operator>|</operator> <name>DT_IDFLG_REF</name> <operator>|</operator> <name>DT_IDFLG_DECL</name> <operator>|</operator> <name>DT_IDFLG_ORPHAN</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>_dtrace_defattr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dt_idops_inline</name></expr></argument>, <argument><expr><name>inp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_ARRAY</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dt_idnode_t</name> <modifier>*</modifier></type><name>pinp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>pidp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>pnp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>pnp</name> <operator>=</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name></expr>;</init> <condition><expr><name>pnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>pnp</name> <operator>=</operator> <name><name>pnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>inp</name><operator>-&gt;</operator><name>din_hash</name></name> <operator>=</operator> <call><name>dt_idhash_create</name><argument_list>(<argument><expr><literal type="string">"inline args"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>inp</name><operator>-&gt;</operator><name>din_argv</name></name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_ident_t</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>inp</name><operator>-&gt;</operator><name>din_hash</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>inp</name><operator>-&gt;</operator><name>din_argv</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>pnp</name> <operator>=</operator> <name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name></expr>;</init>
<condition><expr><name>pnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>pnp</name> <operator>=</operator> <name><name>pnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pinp</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_idnode_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pidp</name> <operator>=</operator> <call><name>dt_idhash_insert</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>din_hash</name></name></expr></argument>, <argument><expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>,
<argument><expr><name>DT_IDENT_SCALAR</name></expr></argument>, <argument><expr><name>DT_IDFLG_DECL</name> <operator>|</operator> <name>DT_IDFLG_INLINE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>_dtrace_defattr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dt_idops_inline</name></expr></argument>,
<argument><expr><name>pinp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pidp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pinp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>inp</name><operator>-&gt;</operator><name>din_argv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pidp</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><name>pinp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_idnode_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_ident_type_assign</name><argument_list>(<argument><expr><name>pidp</name></expr></argument>, <argument><expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>dt_idstack_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_globals</name></name></expr></argument>, <argument><expr><name><name>inp</name><operator>-&gt;</operator><name>din_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ddp</name><operator>-&gt;</operator><name>dd_kind</name></name> <operator>==</operator> <name>CTF_K_ARRAY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_idstack_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_globals</name></name></expr></argument>, <argument><expr><name><name>inp</name><operator>-&gt;</operator><name>din_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rdp</name> <operator>=</operator> <call><name>dt_ident_resolve</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_VAR</name> <operator>||</operator> <name><name>expr</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_SYM</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rdp</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>dn_ident</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>rdp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>rdp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>|=</operator> <operator>(</operator><name><name>rdp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator>
<operator>(</operator><name>DT_IDFLG_WRITE</name> <operator>|</operator> <name>DT_IDFLG_USER</name> <operator>|</operator> <name>DT_IDFLG_PRIM</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_attr</name></name> <operator>=</operator> <call><name>dt_attr_min</name><argument_list>(<argument><expr><name>_dtrace_defattr</name></expr></argument>, <argument><expr><name><name>expr</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_ident_type_assign</name><argument_list>(<argument><expr><name>idp</name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_ident_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>idp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ddp</name><operator>-&gt;</operator><name>dd_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>inp</name><operator>-&gt;</operator><name>din_list</name></name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>inp</name><operator>-&gt;</operator><name>din_root</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_decl_free</name><argument_list>(<argument><expr><call><name>dt_decl_pop</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yybegin</name><argument_list>(<argument><expr><name>YYS_CLAUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_idhash_xinsert</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>, <argument><expr><name>idp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_node_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_member</name><parameter_list>(<parameter><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_typeinfo_t</name></type> <name>dtt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>ddp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>dt_decl_type</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_decl_free</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membname</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membexpr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ddp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>,
<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_xlator</name><parameter_list>(<parameter><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>ddp</name></decl></parameter>, <parameter><decl><type><name>dt_decl_t</name> <modifier>*</modifier></type><name>sdp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>members</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_typeinfo_t</name></type> <name>src</name></decl>, <decl><type ref="prev"/><name>dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name></type> <name>sn</name></decl>, <decl><type ref="prev"/><name>dn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_xlator_t</name> <modifier>*</modifier></type><name>dxp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>edst</name></decl>, <decl><type ref="prev"/><name>esrc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n1</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n2</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>edst</name> <operator>=</operator> <call><name>dt_decl_type</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_decl_free</name><argument_list>(<argument><expr><name>ddp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>esrc</name> <operator>=</operator> <call><name>dt_decl_type</name><argument_list>(<argument><expr><name>sdp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_decl_free</name><argument_list>(<argument><expr><name>sdp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>edst</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>esrc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sn</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>sn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sn</name></expr></argument>, <argument><expr><name><name>src</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>.</operator><name>dtt_type</name></name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bzero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dn</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dn</name></expr></argument>, <argument><expr><name><name>dst</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dst</name><operator>.</operator><name>dtt_type</name></name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_xlator_lookup</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dn</name></expr></argument>, <argument><expr><name>DT_XLATE_EXACT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_XLATE_REDECL</name></expr></argument>,
<argument><expr><literal type="string">"translator from %s to %s has already been declared\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sn</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dn</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>dst</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>,
<argument><expr><call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name><name>dst</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dst</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_FORWARD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_XLATE_SOU</name></expr></argument>, <argument><expr><literal type="string">"incomplete struct/union/enum %s\n"</literal></expr></argument>,
<argument><expr><call><name>dt_type_name</name><argument_list>(<argument><expr><name><name>dst</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dst</name><operator>.</operator><name>dtt_type</name></name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>!=</operator> <name>CTF_K_STRUCT</name> <operator>&amp;&amp;</operator> <name>kind</name> <operator>!=</operator> <name>CTF_K_UNION</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_XLATE_SOU</name></expr></argument>,
<argument><expr><literal type="string">"translator output type must be a struct or union\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dxp</name> <operator>=</operator> <call><name>dt_xlator_create</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>members</name></expr></argument>, <argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yybegin</name><argument_list>(<argument><expr><name>YYS_CLAUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dxp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_XLATOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_xlator</name></name> <operator>=</operator> <name>dxp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_members</name></name> <operator>=</operator> <name>members</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_node_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_probe</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>protoc</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>nargs</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>xargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nargc</name></decl>, <decl><type ref="prev"/><name>xargc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>alloca</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"::%s"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strhyphenate</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_PROV_BADNAME</name></expr></argument>, <argument><expr><literal type="string">"probe name may not "</literal>
<literal type="string">"contain scoping operator: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal> <operator>&gt;=</operator> <name>DTRACE_NAMELEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_PROV_BADNAME</name></expr></argument>, <argument><expr><literal type="string">"probe name may not exceed %d "</literal>
<literal type="string">"characters: %s\n"</literal></expr></argument>, <argument><expr><name>DTRACE_NAMELEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_PROBE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name> <operator>=</operator> <call><name>dt_ident_create</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>DT_IDENT_PROBE</name></expr></argument>,
<argument><expr><name>DT_IDFLG_ORPHAN</name></expr></argument>, <argument><expr><name>DTRACE_IDNONE</name></expr></argument>, <argument><expr><name>_dtrace_defattr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>dt_idops_probe</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nargc</name> <operator>=</operator> <call><name>dt_decl_prototype</name><argument_list>(<argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
<argument><expr><literal type="string">"probe input"</literal></expr></argument>, <argument><expr><name>DT_DP_VOID</name> <operator>|</operator> <name>DT_DP_ANON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>xargc</name> <operator>=</operator> <call><name>dt_decl_prototype</name><argument_list>(<argument><expr><name>xargs</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>,
<argument><expr><literal type="string">"probe output"</literal></expr></argument>, <argument><expr><name>DT_DP_VOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nargc</name> <operator>&gt;</operator> <name>UINT8_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_PROV_PRARGLEN</name></expr></argument>, <argument><expr><literal type="string">"probe %s input prototype exceeds %u "</literal>
<literal type="string">"parameters: %d params used\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>UINT8_MAX</name></expr></argument>, <argument><expr><name>nargc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>xargc</name> <operator>&gt;</operator> <name>UINT8_MAX</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_PROV_PRARGLEN</name></expr></argument>, <argument><expr><literal type="string">"probe %s output prototype exceeds %u "</literal>
<literal type="string">"parameters: %d params used\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>UINT8_MAX</name></expr></argument>, <argument><expr><name>xargc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>dt_probe_create</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>, <argument><expr><name>protoc</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>nargc</name></expr></argument>, <argument><expr><name>xargs</name></expr></argument>, <argument><expr><name>xargc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_provider</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>probes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name> <init>= <expr><call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_PROVIDER</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>lnp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_provname</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_probes</name></name> <operator>=</operator> <name>probes</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_PROV_BADNAME</name></expr></argument>, <argument><expr><literal type="string">"provider name may not "</literal>
<literal type="string">"contain scoping operator: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <name>DTRACE_PROVNAMELEN</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_PROV_BADNAME</name></expr></argument>, <argument><expr><literal type="string">"provider name may not exceed %d "</literal>
<literal type="string">"characters: %s\n"</literal></expr></argument>, <argument><expr><name>DTRACE_PROVNAMELEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_PROV_BADNAME</name></expr></argument>, <argument><expr><literal type="string">"provider name may not "</literal>
<literal type="string">"end with a digit: %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_provider</name></name> <operator>=</operator> <call><name>dt_provider_lookup</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_provred</name></name> <operator>=</operator> <name>B_TRUE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_provider</name></name> <operator>=</operator> <call><name>dt_provider_create</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_provider</name><operator>-&gt;</operator><name>pv_flags</name></name> <operator>|=</operator> <name>DT_PROVIDER_INTF</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<for>for <control>(<init><expr><name>lnp</name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_list</name></name></expr>;</init> <condition><expr><name><name>lnp</name><operator>-&gt;</operator><name>dn_link</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>lnp</name> <operator>=</operator> <name><name>lnp</name><operator>-&gt;</operator><name>dn_link</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
<expr_stmt><expr><name><name>lnp</name><operator>-&gt;</operator><name>dn_link</name></name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_provider</name><operator>-&gt;</operator><name>pv_nodes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_provider</name><operator>-&gt;</operator><name>pv_nodes</name></name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yybegin</name><argument_list>(<argument><expr><name>YYS_CLAUSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_program</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>lnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name> <init>= <expr><call><name>dt_node_alloc</name><argument_list>(<argument><expr><name>DT_NODE_PROG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>=</operator> <name>lnp</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_xcook_ident</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dt_idhash_t</name> <modifier>*</modifier></type><name>dhp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idkind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>create</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sname</name> <init>= <expr><call><name>dt_idhash_name</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>uref</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_attribute_t</name></type> <name>attr</name> <init>= <expr><name>_dtrace_defattr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_syminfo_t</name></type> <name>dts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GElf_Sym</name></type> <name>sym</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>scope</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mark</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uchar_t</name></type> <name>dnkind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>name</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&gt;</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'`'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>uref</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>name</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>+</operator> <name>uref</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>scope</name> <operator>=</operator> <ternary><condition><expr><name>uref</name></expr> ?</condition><then> <expr><name>DTRACE_OBJ_UMODS</name></expr> </then><else>: <expr><name>DTRACE_OBJ_KMODS</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>scope</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>name</name><operator>++</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dnkind</name> <operator>=</operator> <name>DT_NODE_VAR</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>idkind</name> <operator>==</operator> <name>DT_IDENT_AGG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>scope</name> <operator>=</operator> <name>DTRACE_OBJ_EXEC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>dnkind</name> <operator>=</operator> <name>DT_NODE_AGG</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>scope</name> <operator>=</operator> <name>DTRACE_OBJ_EXEC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dnkind</name> <operator>=</operator> <name>DT_NODE_VAR</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_set_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>EDT_NOVAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mark</name> <operator>=</operator> <ternary><condition><expr><name>uref</name></expr> ?</condition><then> <expr><literal type="string">"``"</literal></expr> </then><else>: <expr><literal type="string">"`"</literal></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>DTRACE_OBJ_EXEC</name> <operator>&amp;&amp;</operator> <operator>(</operator>
<operator>(</operator><name>dhp</name> <operator>!=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_idhash_lookup</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>dhp</name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_idstack_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_globals</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>!=</operator> <name>idkind</name> <operator>&amp;&amp;</operator> <name>dhp</name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_IDENT_BADREF</name></expr></argument>, <argument><expr><literal type="string">"%s '%s' may not be referenced "</literal>
<literal type="string">"as %s\n"</literal></expr></argument>, <argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name>idkind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>!=</operator> <name>DT_IDENT_ARRAY</name> <operator>&amp;&amp;</operator>
<name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>!=</operator> <name>DT_IDENT_AGG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>dt_ident_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>idp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>DT_DYN_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_DYN_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>idp</name><operator>-&gt;</operator><name>di_attr</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>=</operator> <name>dnkind</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name> <operator>=</operator> <name>idp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_LVALUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>idp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_WRITE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_WRITABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dhp</name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name> <operator>&amp;&amp;</operator> <name>scope</name> <operator>!=</operator> <name>DTRACE_OBJ_EXEC</name> <operator>&amp;&amp;</operator>
<call><name>dtrace_lookup_by_name</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dts</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dt_module_t</name> <modifier>*</modifier></type><name>mp</name> <init>= <expr><call><name>dt_module_lookup_by_name</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name><name>dts</name><operator>.</operator><name>dts_object</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>umod</name> <init>= <expr><operator>(</operator><name><name>mp</name><operator>-&gt;</operator><name>dm_flags</name></name> <operator>&amp;</operator> <name>DT_DM_KERNEL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>kunames</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"kernel"</literal></expr>, <expr><literal type="string">"user"</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_typeinfo_t</name></type> <name>dtt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_syminfo_t</name> <modifier>*</modifier></type><name>sip</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>uref</name> <operator>^</operator> <name>umod</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_SYM_BADREF</name></expr></argument>, <argument><expr><literal type="string">"%s module '%s' symbol '%s' may "</literal>
<literal type="string">"not be referenced as a %s symbol\n"</literal></expr></argument>, <argument><expr><name><name>kunames</name><index>[<expr><name>umod</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>dts</name><operator>.</operator><name>dts_object</name></name></expr></argument>, <argument><expr><name><name>dts</name><operator>.</operator><name>dts_name</name></name></expr></argument>, <argument><expr><name><name>kunames</name><index>[<expr><name>uref</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dtrace_symbol_type</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sym</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtt</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errno</name></name> <operator>==</operator> <name>EDT_DATAMODEL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_SYM_MODEL</name></expr></argument>, <argument><expr><literal type="string">"cannot use %s symbol "</literal>
<literal type="string">"%s%s%s in a %s D program\n"</literal></expr></argument>,
<argument><expr><call><name>dt_module_modelname</name><argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>dts</name><operator>.</operator><name>dts_object</name></name></expr></argument>, <argument><expr><name>mark</name></expr></argument>, <argument><expr><name><name>dts</name><operator>.</operator><name>dts_name</name></name></expr></argument>,
<argument><expr><call><name>dt_module_modelname</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_SYM_NOTYPES</name></expr></argument>,
<argument><expr><literal type="string">"no symbolic type information is available for "</literal>
<literal type="string">"%s%s%s: %s\n"</literal></expr></argument>, <argument><expr><name><name>dts</name><operator>.</operator><name>dts_object</name></name></expr></argument>, <argument><expr><name>mark</name></expr></argument>, <argument><expr><name><name>dts</name><operator>.</operator><name>dts_name</name></name></expr></argument>,
<argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <call><name>dt_ident_create</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>DT_IDENT_SYMBOL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name>_dtrace_symattr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dt_idops_thaw</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>mp</name><operator>-&gt;</operator><name>dm_flags</name></name> <operator>&amp;</operator> <name>DT_DM_PRIMARY</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>|=</operator> <name>DT_IDFLG_PRIM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_next</name></name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_externs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_externs</name></name> <operator>=</operator> <name>idp</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sip</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dtrace_syminfo_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dts</name></expr></argument>, <argument><expr><name>sip</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dtrace_syminfo_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_data</name></name> <operator>=</operator> <name>sip</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_ctfp</name></name> <operator>=</operator> <name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_type</name></name> <operator>=</operator> <name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>=</operator> <name>DT_NODE_SYM</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name> <operator>=</operator> <name>idp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_LVALUE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>,
<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>_dtrace_symattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>uref</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>idp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>|=</operator> <name>DT_IDFLG_USER</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_USERLAND</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>scope</name> <operator>==</operator> <name>DTRACE_OBJ_EXEC</name> <operator>&amp;&amp;</operator> <name>create</name> <operator>==</operator> <name>B_TRUE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint_t</name></type> <name>flags</name> <init>= <expr><name>DT_IDFLG_WRITE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>id</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_idhash_nextid</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>id</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_ID_OFLOW</name></expr></argument>, <argument><expr><literal type="string">"cannot create %s: limit on number "</literal>
<literal type="string">"of %s variables exceeded\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dhp</name> <operator>==</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_locals</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>DT_IDFLG_LOCAL</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>dhp</name> <operator>==</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_tls</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>DT_IDFLG_TLS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"create %s %s variable %s, id=%u\n"</literal></expr></argument>,
<argument><expr><name>sname</name></expr></argument>, <argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name>idkind</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idkind</name> <operator>==</operator> <name>DT_IDENT_ARRAY</name> <operator>||</operator> <name>idkind</name> <operator>==</operator> <name>DT_IDENT_AGG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <call><name>dt_idhash_insert</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><name>idkind</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>_dtrace_defattr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>dt_idops_assc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <call><name>dt_idhash_insert</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><name>idkind</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>_dtrace_defattr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><operator>&amp;</operator><name>dt_idops_thaw</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>idp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>!=</operator> <name>DT_IDENT_ARRAY</name> <operator>&amp;&amp;</operator>
<name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>!=</operator> <name>DT_IDENT_AGG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>dt_ident_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>idp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>DT_DYN_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_DYN_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>attr</name> <operator>=</operator> <name><name>idp</name><operator>-&gt;</operator><name>di_attr</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>=</operator> <name>dnkind</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name> <operator>=</operator> <name>idp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_LVALUE</name> <operator>|</operator> <name>DT_NF_WRITABLE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>scope</name> <operator>!=</operator> <name>DTRACE_OBJ_EXEC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_IDENT_UNDEF</name></expr></argument>, <argument><expr><literal type="string">"failed to resolve %s%s%s: %s\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><name>mark</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_IDENT_UNDEF</name></expr></argument>, <argument><expr><literal type="string">"failed to resolve %s: %s\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><call><name>dtrace_errmsg</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><call><name>dtrace_errno</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_ident</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_AGG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_xcook_ident</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_aggs</name></name></expr></argument>, <argument><expr><name>DT_IDENT_AGG</name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_xcook_ident</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>, <argument><expr><name>DT_IDENT_SCALAR</name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><operator>(</operator><call><name>dt_node_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>idflags</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_var</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idflags</name> <operator>&amp;</operator> <name>DT_IDFLG_REF</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>dt_ident_unref</name><argument_list>(<argument><expr><name>idp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_VAR_UNDEF</name></expr></argument>,
<argument><expr><literal type="string">"%s%s has not yet been declared or assigned\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name><name>idp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_LOCAL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"this-&gt;"</literal></expr> </then><else>:
<expr><ternary><condition><expr><operator>(</operator><name><name>idp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_TLS</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"self-&gt;"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></else></ternary></expr></argument>,
<argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>dt_ident_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>idp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_func</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>dt_ident_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_op1</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_child</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_typeinfo_t</name></type> <name>dtt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_encoding_t</name></type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_arinfo_t</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>, <decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>kind</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_PREINC</name> <operator>||</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_POSTINC</name> <operator>||</operator>
<name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_PREDEC</name> <operator>||</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_POSTDEC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>idflags</name> <operator>=</operator> <name>DT_IDFLG_REF</name> <operator>|</operator> <name>DT_IDFLG_MOD</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>idflags</name> <operator>=</operator> <name>DT_IDFLG_REF</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_IDENT</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>idflags</name> <operator>&amp;</operator> <name>DT_IDFLG_MOD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_xcook_ident</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>, <argument><expr><name>DT_IDENT_SCALAR</name></expr></argument>, <argument><expr><name>B_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_child</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_VAR</name> <operator>&amp;&amp;</operator> <call><name>dt_ident_unref</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_type_lookup</name><argument_list>(<argument><expr><literal type="string">"int64_t"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtt</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_TYPE_ERR</name></expr></argument>, <argument><expr><literal type="string">"failed to lookup int64_t\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_ident_type_assign</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>,
<argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_VAR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>|=</operator> <name>idflags</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_TOK_DEREF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_node_resolve</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>DT_IDENT_XLPTR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dt_xlator_t</name> <modifier>*</modifier></type><name>dxp</name> <init>= <expr><name><name>idp</name><operator>-&gt;</operator><name>di_data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>dxp</name><operator>-&gt;</operator><name>dx_souid</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_ctfp</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_type</name></name></expr></argument>,
<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_ARRAY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ctf_array_info</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ctferr</name></name> <operator>=</operator> <call><name>ctf_errno</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_CTF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>r</name><operator>.</operator><name>ctr_contents</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_POINTER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_reference</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DEREF_NONPTR</name></expr></argument>,
<argument><expr><literal type="string">"cannot dereference non-pointer type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_INTEGER</name> <operator>&amp;&amp;</operator> <call><name>ctf_type_encoding</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>,
<argument><expr><name>base</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IS_VOID</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DEREF_VOID</name></expr></argument>,
<argument><expr><literal type="string">"cannot dereference pointer to void\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_FUNCTION</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_DEREF_FUNC</name></expr></argument>,
<argument><expr><literal type="string">"cannot dereference pointer to function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>!=</operator> <name>CTF_K_ARRAY</name> <operator>||</operator> <call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_LVALUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_WRITABLE</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_OP2</name> <operator>&amp;&amp;</operator> <name><name>cp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_ADD</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>dn_left</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_WRITABLE</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_WRITABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>kind</name> <operator>==</operator> <name>CTF_K_POINTER</name> <operator>||</operator> <operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_REF</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_USERLAND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_IPOS</name></expr>:</case>
<case>case <expr><name>DT_TOK_INEG</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_arith</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_ARITH</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires an operand "</literal>
<literal type="string">"of arithmetic type\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_propagate</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_BNEG</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_INT</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires an operand of "</literal>
<literal type="string">"integral type\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_propagate</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_LNEG</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_SCALAR</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires an operand "</literal>
<literal type="string">"of scalar type\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_ADDROF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_VAR</name> <operator>||</operator> <name><name>cp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_AGG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_ADDROF_VAR</name></expr></argument>,
<argument><expr><literal type="string">"cannot take address of dynamic variable\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_ADDROF_VAR</name></expr></argument>,
<argument><expr><literal type="string">"cannot take address of dynamic object\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_LVALUE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_ADDROF_LVAL</name></expr></argument>,
<argument><expr><literal type="string">"unacceptable operand for unary &amp; operator\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_BITFIELD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_ADDROF_BITFIELD</name></expr></argument>,
<argument><expr><literal type="string">"cannot take address of bit-field\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>dtt</name> <operator>=</operator> <operator>(</operator><name>dtrace_typeinfo_t</name><operator>)</operator><block>{
<expr><operator>.</operator><name>dtt_ctfp</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr>,
<expr><operator>.</operator><name>dtt_type</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>dn_type</name></name></expr>,
}</block></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_type_pointer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dtt</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_TYPE_ERR</name></expr></argument>, <argument><expr><literal type="string">"cannot find type for \"&amp;\": %s*\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>,
<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_SIZEOF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_BITFIELD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_SIZEOF_BITFIELD</name></expr></argument>,
<argument><expr><literal type="string">"cannot apply sizeof to a bit-field\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_sizeof</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_SIZEOF_TYPE</name></expr></argument>, <argument><expr><literal type="string">"cannot apply sizeof to an "</literal>
<literal type="string">"operand of unknown size\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>,
<argument><expr><call><name>ctf_lookup_by_name</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr></argument>, <argument><expr><literal type="string">"size_t"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_STRINGOF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>dt_node_is_pointer</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>dt_node_is_strcompat</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_STRINGOF_TYPE</name></expr></argument>,
<argument><expr><literal type="string">"cannot apply stringof to a value of type %s\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>DT_STR_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_STR_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_PREINC</name></expr>:</case>
<case>case <expr><name>DT_TOK_POSTINC</name></expr>:</case>
<case>case <expr><name>DT_TOK_PREDEC</name></expr>:</case>
<case>case <expr><name>DT_TOK_POSTDEC</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_SCALAR</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires operand of "</literal>
<literal type="string">"scalar type\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_vfptr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_VFPTR</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires an operand "</literal>
<literal type="string">"of known size\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_LVALUE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_LVAL</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires modifiable "</literal>
<literal type="string">"lvalue as an operand\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_WRITABLE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_WRITE</name></expr></argument>, <argument><expr><literal type="string">"operator %s can only be applied "</literal>
<literal type="string">"to a writable variable\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_propagate</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"invalid unary op %s\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_assign_common</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>rp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_INT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_cast</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>lp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_LVALUE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_LVAL</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires modifiable "</literal>
<literal type="string">"lvalue as an operand\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>lp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_WRITABLE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_WRITE</name></expr></argument>, <argument><expr><literal type="string">"operator %s can only be applied "</literal>
<literal type="string">"to a writable variable\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_propagate</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_op2</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>rp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>op</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_membinfo_t</name></type> <name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>ctfp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>kind</name></decl>, <decl><type ref="prev"/><name>val</name></decl>, <decl><type ref="prev"/><name>uref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>idp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n1</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n2</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DT_TOK_LBRAC</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_IDENT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dt_idhash_t</name> <modifier>*</modifier></type><name>dhp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>idkind</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_AGG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dhp</name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_aggs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <call><name>dt_idhash_lookup</name><argument_list>(<argument><expr><name>dhp</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idkind</name> <operator>=</operator> <name>DT_IDENT_AGG</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>dhp</name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <call><name>dt_idstack_lookup</name><argument_list>(
<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_globals</name></name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idkind</name> <operator>=</operator> <name>DT_IDENT_ARRAY</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>idp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>dt_ident_unref</name><argument_list>(<argument><expr><name>idp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_xcook_ident</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>dhp</name></expr></argument>, <argument><expr><name>idkind</name></expr></argument>, <argument><expr><name>B_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_xcook_ident</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>dhp</name></expr></argument>, <argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_VAR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>==</operator> <name>DT_IDENT_ARRAY</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_args</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>op</name> <operator>=</operator> <name>DT_TOK_ADD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>dt_ident_unref</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>op</name> <operator>=</operator> <name>DT_TOK_ADD</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_AGG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>op</name> <operator>=</operator> <name>DT_TOK_ADD</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_TOK_BAND</name></expr>:</case>
<case>case <expr><name>DT_TOK_XOR</name></expr>:</case>
<case>case <expr><name>DT_TOK_BOR</name></expr>:</case>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_INT</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires operands of "</literal>
<literal type="string">"integral type\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_LSH</name></expr>:</case>
<case>case <expr><name>DT_TOK_RSH</name></expr>:</case>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_INT</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires operands of "</literal>
<literal type="string">"integral type\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_propagate</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_MOD</name></expr>:</case>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_INT</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires operands of "</literal>
<literal type="string">"integral type\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_MUL</name></expr>:</case>
<case>case <expr><name>DT_TOK_DIV</name></expr>:</case>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_arith</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>dt_node_is_arith</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_ARITH</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires operands of "</literal>
<literal type="string">"arithmetic type\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_LAND</name></expr>:</case>
<case>case <expr><name>DT_TOK_LXOR</name></expr>:</case>
<case>case <expr><name>DT_TOK_LOR</name></expr>:</case>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_SCALAR</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires operands "</literal>
<literal type="string">"of scalar type\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_LT</name></expr>:</case>
<case>case <expr><name>DT_TOK_LE</name></expr>:</case>
<case>case <expr><name>DT_TOK_GT</name></expr>:</case>
<case>case <expr><name>DT_TOK_GE</name></expr>:</case>
<case>case <expr><name>DT_TOK_EQU</name></expr>:</case>
<case>case <expr><name>DT_TOK_NEQ</name></expr>:</case>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>,
<argument><expr><call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_ENUM</name> <operator>&amp;&amp;</operator> <name><name>rp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_IDENT</name> <operator>&amp;&amp;</operator>
<call><name>strchr</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>ctf_enum_value</name><argument_list>(
<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_idstack_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_globals</name></name></expr></argument>,
<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_IDENT_AMBIG</name></expr></argument>,
<argument><expr><literal type="string">"ambiguous use of operator %s: %s is "</literal>
<literal type="string">"both a %s enum tag and a global %s\n"</literal></expr></argument>,
<argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>=</operator> <name>DT_NODE_INT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_COOKED</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>=</operator> <name>DT_TOK_INT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_value</name></name> <operator>=</operator> <operator>(</operator><name>intmax_t</name><operator>)</operator><name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>,
<argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>_dtrace_symattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_compat</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>,
<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>dt_node_is_strcompat</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>dt_node_is_strcompat</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>dt_node_is_ptrcompat</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_INCOMPAT</name></expr></argument>, <argument><expr><literal type="string">"operands have "</literal>
<literal type="string">"incompatible types: \"%s\" %s \"%s\"\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>DT_INT_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_INT_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_ADD</name></expr>:</case>
<case>case <expr><name>DT_TOK_SUB</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lp_is_ptr</name></decl>, <decl><type ref="prev"/><name>lp_is_int</name></decl>, <decl><type ref="prev"/><name>rp_is_ptr</name></decl>, <decl><type ref="prev"/><name>rp_is_int</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp_is_ptr</name> <operator>=</operator> <call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name>dt_node_is_pointer</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>dt_node_is_vfptr</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>lp_is_int</name> <operator>=</operator> <call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp_is_ptr</name> <operator>=</operator> <call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call> <operator>||</operator>
<operator>(</operator><call><name>dt_node_is_pointer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>dt_node_is_vfptr</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>rp_is_int</name> <operator>=</operator> <call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lp_is_int</name> <operator>&amp;&amp;</operator> <name>rp_is_int</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_type_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctfp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>uref</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lp_is_ptr</name> <operator>&amp;&amp;</operator> <name>rp_is_int</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>uref</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lp_is_int</name> <operator>&amp;&amp;</operator> <name>rp_is_ptr</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>==</operator> <name>DT_TOK_ADD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>dn_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>uref</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lp_is_ptr</name> <operator>&amp;&amp;</operator> <name>rp_is_ptr</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>==</operator> <name>DT_TOK_SUB</name> <operator>&amp;&amp;</operator>
<call><name>dt_node_is_ptrcompat</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_ddefs</name><operator>-&gt;</operator><name>dm_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_lookup_by_name</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><literal type="string">"ptrdiff_t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>uref</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_INCOMPAT</name></expr></argument>, <argument><expr><literal type="string">"operands have incompatible "</literal>
<literal type="string">"types: \"%s\" %s \"%s\"\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>uref</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_USERLAND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>DT_TOK_OR_EQ</name></expr>:</case>
<case>case <expr><name>DT_TOK_XOR_EQ</name></expr>:</case>
<case>case <expr><name>DT_TOK_AND_EQ</name></expr>:</case>
<case>case <expr><name>DT_TOK_LSH_EQ</name></expr>:</case>
<case>case <expr><name>DT_TOK_RSH_EQ</name></expr>:</case>
<case>case <expr><name>DT_TOK_MOD_EQ</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_IDENT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_xcook_ident</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>,
<argument><expr><name>DT_IDENT_SCALAR</name></expr></argument>, <argument><expr><name>B_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator>
<call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name> <operator>|</operator> <name>DT_IDFLG_MOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator>
<call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name> <operator>|</operator> <name>DT_IDFLG_MOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_INT</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires operands of "</literal>
<literal type="string">"integral type\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>asgn_common</name>;</goto>
<case>case <expr><name>DT_TOK_MUL_EQ</name></expr>:</case>
<case>case <expr><name>DT_TOK_DIV_EQ</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_IDENT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_xcook_ident</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>,
<argument><expr><name>DT_IDENT_SCALAR</name></expr></argument>, <argument><expr><name>B_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator>
<call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name> <operator>|</operator> <name>DT_IDFLG_MOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator>
<call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name> <operator>|</operator> <name>DT_IDFLG_MOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_arith</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>dt_node_is_arith</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_ARITH</name></expr></argument>, <argument><expr><literal type="string">"operator %s requires operands of "</literal>
<literal type="string">"arithmetic type\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>asgn_common</name>;</goto>
<case>case <expr><name>DT_TOK_ASGN</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_IDENT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_AGG</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_xcook_ident</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_aggs</name></name></expr></argument>,
<argument><expr><name>DT_IDENT_AGG</name></expr></argument>, <argument><expr><name>B_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>dt_xcook_ident</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>,
<argument><expr><name>DT_IDENT_SCALAR</name></expr></argument>, <argument><expr><name>B_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_AGG</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aname</name> <init>= <expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>oid</name> <init>= <expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_iarg</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_FUNC</name> <operator>||</operator>
<name><name>rp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>!=</operator> <name>DT_IDENT_AGGFUNC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_AGG_FUNC</name></expr></argument>,
<argument><expr><literal type="string">"@%s must be assigned the result of "</literal>
<literal type="string">"an aggregating function\n"</literal></expr></argument>, <argument><expr><name>aname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>oid</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>oid</name> <operator>!=</operator> <name><name>rp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_AGG_REDEF</name></expr></argument>,
<argument><expr><literal type="string">"aggregation redefined: @%s\n\t "</literal>
<literal type="string">"current: @%s = %s( )\n\tprevious: @%s = "</literal>
<literal type="string">"%s( ) : line %d\n"</literal></expr></argument>, <argument><expr><name>aname</name></expr></argument>, <argument><expr><name>aname</name></expr></argument>,
<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>aname</name></expr></argument>, <argument><expr><name><name>oid</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>,
<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>oid</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_iarg</name></name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_aggfun</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_LVAL</name></expr></argument>, <argument><expr><literal type="string">"operator = requires "</literal>
<literal type="string">"modifiable lvalue as an operand\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_aggfun</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDFLG_MOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>lp</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_node_resolve</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDENT_XLSOU</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <name><name>idp</name><operator>-&gt;</operator><name>di_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>idp</name><operator>-&gt;</operator><name>di_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>uref</name> <operator>=</operator> <name><name>idp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_USER</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>dn_type</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>uref</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_VAR</name> <operator>&amp;&amp;</operator>
<call><name>dt_ident_unref</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_ident_type_assign</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>, <argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>uref</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_USERLAND</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>|=</operator> <name>DT_IDFLG_USER</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_VAR</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>|=</operator> <name>DT_IDFLG_MOD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>,
<argument><expr><call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_ARRAY</name> <operator>||</operator> <name>kind</name> <operator>==</operator> <name>CTF_K_FUNCTION</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_ARRFUN</name></expr></argument>, <argument><expr><literal type="string">"operator %s may not be "</literal>
<literal type="string">"applied to operand of type \"%s\"\n"</literal></expr></argument>,
<argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>idp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>==</operator> <name>DT_IDENT_XLSOU</name> <operator>&amp;&amp;</operator>
<call><name>ctf_type_compat</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>, <argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>asgn_common</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_argcompat</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>asgn_common</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_INCOMPAT</name></expr></argument>,
<argument><expr><literal type="string">"operands have incompatible types: \"%s\" %s \"%s\"\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>DT_TOK_ADD_EQ</name></expr>:</case>
<case>case <expr><name>DT_TOK_SUB_EQ</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_IDENT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_xcook_ident</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_globals</name></name></expr></argument>,
<argument><expr><name>DT_IDENT_SCALAR</name></expr></argument>, <argument><expr><name>B_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator>
<call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name> <operator>|</operator> <name>DT_IDFLG_MOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator>
<call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name> <operator>|</operator> <name>DT_IDFLG_MOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_INCOMPAT</name></expr></argument>, <argument><expr><literal type="string">"operands have "</literal>
<literal type="string">"incompatible types: \"%s\" %s \"%s\"\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_pointer</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>dt_node_is_vfptr</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_VFPTR</name></expr></argument>,
<argument><expr><literal type="string">"operator %s requires left-hand scalar "</literal>
<literal type="string">"operand of known size\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>dt_node_is_ptrcompat</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_INCOMPAT</name></expr></argument>, <argument><expr><literal type="string">"operands have "</literal>
<literal type="string">"incompatible types: \"%s\" %s \"%s\"\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<label><name>asgn_common</name>:</label>
<expr_stmt><expr><call><name>dt_assign_common</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_PTR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_IDENT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dt_idhash_t</name> <modifier>*</modifier></type><name>dhp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><literal type="string">"self"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dhp</name> <operator>=</operator> <name><name>dtp</name><operator>-&gt;</operator><name>dt_tls</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><literal type="string">"this"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>dhp</name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_locals</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dhp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_VAR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_xcook_ident</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dhp</name></expr></argument>,
<argument><expr><name>DT_IDENT_SCALAR</name></expr></argument>, <argument><expr><name>B_TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>idflags</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>idflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>rp</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<case>case <expr><name>DT_TOK_DOT</name></expr>:</case>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>!=</operator> <name>DT_NODE_IDENT</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_IDENT</name></expr></argument>, <argument><expr><literal type="string">"operator %s must be followed by "</literal>
<literal type="string">"an identifier\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_node_resolve</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDENT_XLSOU</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
<operator>(</operator><name>idp</name> <operator>=</operator> <call><name>dt_node_resolve</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDENT_XLPTR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dt_xlator_t</name> <modifier>*</modifier></type><name>dxp</name> <init>= <expr><name><name>idp</name><operator>-&gt;</operator><name>di_data</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_xlator_member</name><argument_list>(<argument><expr><name>dxp</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_XLATE_NOCONV</name></expr></argument>,
<argument><expr><literal type="string">"translator does not define conversion "</literal>
<literal type="string">"for member: %s\n"</literal></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <name><name>idp</name><operator>-&gt;</operator><name>di_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>uref</name> <operator>=</operator> <name><name>idp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_USER</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>uref</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DT_TOK_PTR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>!=</operator> <name>CTF_K_POINTER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_PTR</name></expr></argument>, <argument><expr><literal type="string">"operator %s must be "</literal>
<literal type="string">"applied to a pointer\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_reference</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><name>kind</name> <operator>==</operator> <name>CTF_K_FORWARD</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><call><name>ctf_type_name</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_typeinfo_t</name></type> <name>dtt</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>dt_type_lookup</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dtt</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name> <operator>!=</operator> <name>ctfp</name> <operator>||</operator> <name><name>dtt</name><operator>.</operator><name>dtt_type</name></name> <operator>!=</operator> <name>type</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <name><name>dtt</name><operator>.</operator><name>dtt_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name><name>dtt</name><operator>.</operator><name>dtt_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_INCOMPLETE</name></expr></argument>,
<argument><expr><literal type="string">"operator %s cannot be applied to a "</literal>
<literal type="string">"forward declaration: no %s definition "</literal>
<literal type="string">"is available\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>!=</operator> <name>CTF_K_STRUCT</name> <operator>&amp;&amp;</operator> <name>kind</name> <operator>!=</operator> <name>CTF_K_UNION</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DT_TOK_PTR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_SOU</name></expr></argument>, <argument><expr><literal type="string">"operator -&gt; cannot be "</literal>
<literal type="string">"applied to pointer to type \"%s\"; must "</literal>
<literal type="string">"be applied to a struct or union pointer\n"</literal></expr></argument>,
<argument><expr><call><name>ctf_type_name</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_SOU</name></expr></argument>, <argument><expr><literal type="string">"operator %s cannot be "</literal>
<literal type="string">"applied to type \"%s\"; must be applied "</literal>
<literal type="string">"to a struct or union\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>ctf_type_name</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_member_info</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_TYPE_MEMBER</name></expr></argument>,
<argument><expr><literal type="string">"%s is not a member of %s\n"</literal></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>,
<argument><expr><call><name>ctf_type_name</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name><name>m</name><operator>.</operator><name>ctm_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>kind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name><name>m</name><operator>.</operator><name>ctm_type</name></name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DT_TOK_PTR</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>kind</name> <operator>!=</operator> <name>CTF_K_ARRAY</name> <operator>||</operator>
<call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_LVALUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <name>DT_TOK_DOT</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_LVALUE</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>kind</name> <operator>!=</operator> <name>CTF_K_ARRAY</name> <operator>||</operator> <call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_LVALUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_WRITABLE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_WRITABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>uref</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>kind</name> <operator>==</operator> <name>CTF_K_POINTER</name> <operator>||</operator>
<operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_REF</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_USERLAND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_TOK_LBRAC</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>lnp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_AGG</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>dn_aggtup</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_AGG_MDIM</name></expr></argument>, <argument><expr><literal type="string">"improper attempt to "</literal>
<literal type="string">"reference @%s as a multi-dimensional "</literal>
<literal type="string">"array\n"</literal></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_aggtup</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>lp</name><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>idp</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>==</operator> <name>DT_IDENT_SCALAR</name> <operator>&amp;&amp;</operator> <call><name>dt_ident_unref</name><argument_list>(<argument><expr><name>idp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>idp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>DT_IDFLG_LOCAL</name> <operator>|</operator> <name>DT_IDFLG_TLS</name><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>idp</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_LOCAL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_ARR_LOCAL</name></expr></argument>,
<argument><expr><literal type="string">"local variables may not be used as "</literal>
<literal type="string">"associative arrays: %s\n"</literal></expr></argument>, <argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"morph variable %s (id %u) from scalar to "</literal>
<literal type="string">"array\n"</literal></expr></argument>, <argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_ident_morph</name><argument_list>(<argument><expr><name>idp</name></expr></argument>, <argument><expr><name>DT_IDENT_ARRAY</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>dt_idops_assc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name> <operator>!=</operator> <name>DT_IDENT_ARRAY</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_IDENT_BADREF</name></expr></argument>, <argument><expr><literal type="string">"%s '%s' may not be referenced "</literal>
<literal type="string">"as %s\n"</literal></expr></argument>, <argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_kind</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>idp</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><call><name>dt_idkind_name</name><argument_list>(<argument><expr><name>DT_IDENT_ARRAY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_args</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_link</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>dt_node_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_link</name></name> <operator>=</operator> <name>lnp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_node_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>idflags</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block>
<case>case <expr><name>DT_TOK_XLATE</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>dt_xlator_t</name> <modifier>*</modifier></type><name>dxp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dxp</name> <operator>=</operator> <call><name>dt_xlator_lookup</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_XLATE_FUZZY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dxp</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_XLATE_NONE</name></expr></argument>,
<argument><expr><literal type="string">"cannot translate from \"%s\" to \"%s\"\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name> <operator>=</operator> <call><name>dt_xlator_ident</name><argument_list>(<argument><expr><name>dxp</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>DT_DYN_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_DYN_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>DT_TOK_LPAR</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>ltype</name></decl>, <decl><type ref="prev"/><name>rtype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>lkind</name></decl>, <decl><type ref="prev"/><name>rkind</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ltype</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lkind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name>ltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rtype</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rkind</name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name>rtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_compat</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>,
<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>rkind</name> <operator>==</operator> <name>CTF_K_FUNCTION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>dt_node_is_void</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>lkind</name> <operator>==</operator> <name>CTF_K_POINTER</name> <operator>&amp;&amp;</operator> <call><name>dt_node_is_pointer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>dt_node_is_pointer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>dt_node_is_strcompat</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_CAST_INVAL</name></expr></argument>,
<argument><expr><literal type="string">"invalid cast expression: \"%s\" to \"%s\"\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_propagate</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lkind</name> <operator>==</operator> <name>CTF_K_POINTER</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_WRITABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>DT_TOK_COMMA</name></expr>:</case>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_DYN</name></expr></argument>, <argument><expr><literal type="string">"operator %s operands "</literal>
<literal type="string">"cannot be of dynamic type\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_actfunc</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>dt_node_is_actfunc</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_ACT</name></expr></argument>, <argument><expr><literal type="string">"operator %s operands "</literal>
<literal type="string">"cannot be actions\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_propagate</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_UNKNOWN</name></expr></argument>, <argument><expr><literal type="string">"invalid binary op %s\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_LBRAC</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>==</operator> <name>DT_TOK_ADD</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>pnp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>rp</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_ARR_BADREF</name></expr></argument>,
<argument><expr><literal type="string">"cannot access %s as an associative array\n"</literal></expr></argument>,
<argument><expr><call><name>dt_node_name</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>=</operator> <name>DT_TOK_ADD</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pnp</name> <operator>=</operator> <call><name>dt_node_op1</name><argument_list>(<argument><expr><name>DT_TOK_DEREF</name></expr></argument>, <argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_list</name></name> <operator>==</operator> <name>pnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_list</name></name> <operator>=</operator> <name><name>pnp</name><operator>-&gt;</operator><name>dn_link</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_link</name></name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_link</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_link</name></name> <operator>=</operator> <name>pnp</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>dt_node_cook</name><argument_list>(<argument><expr><name>pnp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_op3</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>lp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>ctfp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>type</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_SCALAR</name></expr></argument>,
<argument><expr><literal type="string">"operator ?: expression must be of scalar type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>dt_node_is_dynamic</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_DYN</name></expr></argument>,
<argument><expr><literal type="string">"operator ?: operands cannot be of dynamic type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_compat</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>,
<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>dn_type</name></name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>dt_node_is_integer</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_type_promote</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctfp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>dt_node_is_strcompat</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>dt_node_is_strcompat</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>dt_node_is_string</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ctfp</name> <operator>=</operator> <call><name>DT_STR_CTFP</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>DT_STR_TYPE</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>dt_node_is_ptrcompat</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>rp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctfp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_INCOMPAT</name></expr></argument>,
<argument><expr><literal type="string">"operator ?: operands must have compatible types\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_actfunc</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>dt_node_is_actfunc</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_OP_ACT</name></expr></argument>, <argument><expr><literal type="string">"action cannot be "</literal>
<literal type="string">"used in a conditional context\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>ctfp</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>,
<argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_statement</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>idflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_aggregation</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name></name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>dt_ident_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggtup</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>DT_DYN_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_DYN_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_clause</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>err</name></decl>, <decl><type ref="prev"/><name>tries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jmp_buf</name></type> <name>ojb</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pinfo</name><operator>.</operator><name>dtp_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctxattr</name></name> <operator>=</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_pinfo</name><operator>.</operator><name>dtp_attr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>ojb</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>jmp_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pred</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>err</name> <operator>=</operator> <call><name>setjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>ojb</name></expr></argument>, <argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>jmp_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tries</name><operator>++</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>err</name> <operator>!=</operator> <name>EDT_COMPILER</name> <operator>||</operator> <operator>(</operator>
<name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name><operator>-&gt;</operator><name>dt_errtag</name></name> <operator>!=</operator> <call><name>dt_errtag</name><argument_list>(<argument><expr><name>D_IDENT_UNDEF</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name><operator>-&gt;</operator><name>dt_errtag</name></name> <operator>!=</operator> <call><name>dt_errtag</name><argument_list>(<argument><expr><name>D_VAR_UNDEF</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tries</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>yylabel</name><argument_list>(<argument><expr><literal type="string">"action list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>dt_node_list_cook</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_acts</name></name></expr></argument>, <argument><expr><name>idflags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>bcopy</name><argument_list>(<argument><expr><name>ojb</name></expr></argument>, <argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>jmp_buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yylabel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pred</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>yylabel</name><argument_list>(<argument><expr><literal type="string">"predicate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pred</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pred</name></name></expr></argument>, <argument><expr><name>idflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>dt_attr_min</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pred</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dt_node_is_scalar</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pred</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_PRED_SCALAR</name></expr></argument>,
<argument><expr><literal type="string">"predicate result must be of scalar type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>yylabel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>tries</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>yylabel</name><argument_list>(<argument><expr><literal type="string">"action list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>,
<argument><expr><call><name>dt_node_list_cook</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_acts</name></name></expr></argument>, <argument><expr><name>idflags</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yylabel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_inline</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_idnode_t</name> <modifier>*</modifier></type><name>inp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_iarg</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_ident_t</name> <modifier>*</modifier></type><name>rdp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n1</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n2</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_INLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>din_root</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rdp</name> <operator>=</operator> <call><name>dt_node_resolve</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>din_root</name></name></expr></argument>, <argument><expr><name>DT_IDENT_XLSOU</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>||</operator>
<operator>(</operator><name>rdp</name> <operator>=</operator> <call><name>dt_node_resolve</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>din_root</name></name></expr></argument>, <argument><expr><name>DT_IDENT_XLPTR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>lctfp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>ltype</name> <init>= <expr><call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>lctfp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_xlator_t</name> <modifier>*</modifier></type><name>dxp</name> <init>= <expr><name><name>rdp</name><operator>-&gt;</operator><name>di_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_file_t</name> <modifier>*</modifier></type><name>rctfp</name> <init>= <expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_dst_ctfp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_id_t</name></type> <name>rtype</name> <init>= <expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_dst_base</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_kind</name><argument_list>(<argument><expr><name>lctfp</name></expr></argument>, <argument><expr><name>ltype</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_K_POINTER</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>ltype</name> <operator>=</operator> <call><name>ctf_type_reference</name><argument_list>(<argument><expr><name>lctfp</name></expr></argument>, <argument><expr><name>ltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ltype</name> <operator>=</operator> <call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name>lctfp</name></expr></argument>, <argument><expr><name>ltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_compat</name><argument_list>(<argument><expr><name>lctfp</name></expr></argument>, <argument><expr><name>ltype</name></expr></argument>, <argument><expr><name>rctfp</name></expr></argument>, <argument><expr><name>rtype</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_OP_INCOMPAT</name></expr></argument>,
<argument><expr><literal type="string">"inline %s definition uses incompatible types: "</literal>
<literal type="string">"\"%s\" = \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>,
<argument><expr><call><name>dt_type_name</name><argument_list>(<argument><expr><name>lctfp</name></expr></argument>, <argument><expr><name>ltype</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_type_name</name><argument_list>(<argument><expr><name>rctfp</name></expr></argument>, <argument><expr><name>rtype</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>dt_node_is_argcompat</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>inp</name><operator>-&gt;</operator><name>din_root</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_OP_INCOMPAT</name></expr></argument>,
<argument><expr><literal type="string">"inline %s definition uses incompatible types: "</literal>
<literal type="string">"\"%s\" = \"%s\"\n"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>din_root</name></name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_member</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membexpr</name></name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membexpr</name></name></expr></argument>, <argument><expr><name>idflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membexpr</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_xlator</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_xlator_t</name> <modifier>*</modifier></type><name>dxp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_xlator</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>mnp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n1</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n2</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dtrace_attribute_t</name></type> <name>attr</name> <init>= <expr><name>_dtrace_maxattr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ctf_membinfo_t</name></type> <name>ctm</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>dt_idstack_push</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_globals</name></name></expr></argument>, <argument><expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_locals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>mnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_members</name></name></expr>;</init> <condition><expr><name>mnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>mnp</name> <operator>=</operator> <name><name>mnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ctf_member_info</name><argument_list>(<argument><expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_dst_ctfp</name></name></expr></argument>, <argument><expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_dst_type</name></name></expr></argument>,
<argument><expr><name><name>mnp</name><operator>-&gt;</operator><name>dn_membname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctm</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CTF_ERR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_XLATE_MEMB</name></expr></argument>,
<argument><expr><literal type="string">"translator member %s is not a member of %s\n"</literal></expr></argument>,
<argument><expr><name><name>mnp</name><operator>-&gt;</operator><name>dn_membname</name></name></expr></argument>, <argument><expr><call><name>ctf_type_name</name><argument_list>(<argument><expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_dst_ctfp</name></name></expr></argument>,
<argument><expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_dst_type</name></name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>mnp</name></expr></argument>, <argument><expr><name>DT_IDFLG_REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>mnp</name></expr></argument>, <argument><expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_dst_ctfp</name></name></expr></argument>, <argument><expr><name><name>ctm</name><operator>.</operator><name>ctm_type</name></name></expr></argument>,
<argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>dt_attr_min</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name><name>mnp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_argcompat</name><argument_list>(<argument><expr><name>mnp</name></expr></argument>, <argument><expr><name><name>mnp</name><operator>-&gt;</operator><name>dn_membexpr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>xyerror</name><argument_list>(<argument><expr><name>D_XLATE_INCOMPAT</name></expr></argument>,
<argument><expr><literal type="string">"translator member %s definition uses "</literal>
<literal type="string">"incompatible types: \"%s\" = \"%s\"\n"</literal></expr></argument>,
<argument><expr><name><name>mnp</name><operator>-&gt;</operator><name>dn_membname</name></name></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>mnp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name><name>mnp</name><operator>-&gt;</operator><name>dn_membexpr</name></name></expr></argument>,
<argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>dt_idstack_pop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_globals</name></name></expr></argument>, <argument><expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_locals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_souid</name><operator>.</operator><name>di_attr</name></name> <operator>=</operator> <name>attr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_ptrid</name><operator>.</operator><name>di_attr</name></name> <operator>=</operator> <name>attr</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_type_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><call><name>DT_DYN_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DT_DYN_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>B_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_attr_assign</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>_dtrace_defattr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_node_provider_cmp_argv</name><parameter_list>(<parameter><decl><type><name>dt_provider_t</name> <modifier>*</modifier></type><name>pvp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>pnp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>kind</name></decl></parameter>,
<parameter><decl><type><name>uint_t</name></type> <name>old_argc</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>old_argv</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>new_argc</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>new_argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_probe_t</name> <modifier>*</modifier></type><name>prp</name> <init>= <expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n1</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n2</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>old_argc</name> <operator>!=</operator> <name>new_argc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>pnp</name></expr></argument>, <argument><expr><name>D_PROV_INCOMPAT</name></expr></argument>,
<argument><expr><literal type="string">"probe %s:%s %s prototype mismatch:\n"</literal>
<literal type="string">"\t current: %u arg%s\n\tprevious: %u arg%s\n"</literal></expr></argument>,
<argument><expr><name><name>pvp</name><operator>-&gt;</operator><name>pv_desc</name><operator>.</operator><name>dtvd_name</name></name></expr></argument>, <argument><expr><name><name>prp</name><operator>-&gt;</operator><name>pr_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>,
<argument><expr><name>new_argc</name></expr></argument>, <argument><expr><ternary><condition><expr><name>new_argc</name> <operator>!=</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><name>old_argc</name></expr></argument>, <argument><expr><ternary><condition><expr><name>old_argc</name> <operator>!=</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="string">"s"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>old_argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator>
<expr><name>old_argv</name> <operator>=</operator> <name><name>old_argv</name><operator>-&gt;</operator><name>dn_list</name></name></expr><operator>,</operator> <expr><name>new_argv</name> <operator>=</operator> <name><name>new_argv</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_cmp</name><argument_list>(<argument><expr><name><name>old_argv</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>old_argv</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>,
<argument><expr><name><name>new_argv</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>new_argv</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>pnp</name></expr></argument>, <argument><expr><name>D_PROV_INCOMPAT</name></expr></argument>,
<argument><expr><literal type="string">"probe %s:%s %s prototype argument #%u mismatch:\n"</literal>
<literal type="string">"\t current: %s\n\tprevious: %s\n"</literal></expr></argument>,
<argument><expr><name><name>pvp</name><operator>-&gt;</operator><name>pv_desc</name><operator>.</operator><name>dtvd_name</name></name></expr></argument>, <argument><expr><name><name>prp</name><operator>-&gt;</operator><name>pr_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>new_argv</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>old_argv</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_node_provider_cmp</name><parameter_list>(<parameter><decl><type><name>dt_provider_t</name> <modifier>*</modifier></type><name>pvp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>pnp</name></decl></parameter>,
<parameter><decl><type><name>dt_probe_t</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>dt_probe_t</name> <modifier>*</modifier></type><name>new</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>dt_node_provider_cmp_argv</name><argument_list>(<argument><expr><name>pvp</name></expr></argument>, <argument><expr><name>pnp</name></expr></argument>, <argument><expr><literal type="string">"output"</literal></expr></argument>,
<argument><expr><name><name>old</name><operator>-&gt;</operator><name>pr_xargc</name></name></expr></argument>, <argument><expr><name><name>old</name><operator>-&gt;</operator><name>pr_xargs</name></name></expr></argument>, <argument><expr><name><name>new</name><operator>-&gt;</operator><name>pr_xargc</name></name></expr></argument>, <argument><expr><name><name>new</name><operator>-&gt;</operator><name>pr_xargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>old</name><operator>-&gt;</operator><name>pr_nargs</name></name> <operator>!=</operator> <name><name>old</name><operator>-&gt;</operator><name>pr_xargs</name></name> <operator>&amp;&amp;</operator> <name><name>new</name><operator>-&gt;</operator><name>pr_nargs</name></name> <operator>!=</operator> <name><name>new</name><operator>-&gt;</operator><name>pr_xargs</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_provider_cmp_argv</name><argument_list>(<argument><expr><name>pvp</name></expr></argument>, <argument><expr><name>pnp</name></expr></argument>, <argument><expr><literal type="string">"input"</literal></expr></argument>,
<argument><expr><name><name>old</name><operator>-&gt;</operator><name>pr_nargc</name></name></expr></argument>, <argument><expr><name><name>old</name><operator>-&gt;</operator><name>pr_nargs</name></name></expr></argument>, <argument><expr><name><name>new</name><operator>-&gt;</operator><name>pr_nargc</name></name></expr></argument>, <argument><expr><name><name>new</name><operator>-&gt;</operator><name>pr_nargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>old</name><operator>-&gt;</operator><name>pr_nargs</name></name> <operator>==</operator> <name><name>old</name><operator>-&gt;</operator><name>pr_xargs</name></name> <operator>&amp;&amp;</operator> <name><name>new</name><operator>-&gt;</operator><name>pr_nargs</name></name> <operator>!=</operator> <name><name>new</name><operator>-&gt;</operator><name>pr_xargs</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>pvp</name><operator>-&gt;</operator><name>pv_flags</name></name> <operator>&amp;</operator> <name>DT_PROVIDER_IMPL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>pnp</name></expr></argument>, <argument><expr><name>D_PROV_INCOMPAT</name></expr></argument>,
<argument><expr><literal type="string">"provider interface mismatch: %s\n"</literal>
<literal type="string">"\t current: probe %s:%s has an output prototype\n"</literal>
<literal type="string">"\tprevious: probe %s:%s has no output prototype\n"</literal></expr></argument>,
<argument><expr><name><name>pvp</name><operator>-&gt;</operator><name>pv_desc</name><operator>.</operator><name>dtvd_name</name></name></expr></argument>, <argument><expr><name><name>pvp</name><operator>-&gt;</operator><name>pv_desc</name><operator>.</operator><name>dtvd_name</name></name></expr></argument>,
<argument><expr><name><name>new</name><operator>-&gt;</operator><name>pr_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name><name>pvp</name><operator>-&gt;</operator><name>pv_desc</name><operator>.</operator><name>dtvd_name</name></name></expr></argument>,
<argument><expr><name><name>old</name><operator>-&gt;</operator><name>pr_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>old</name><operator>-&gt;</operator><name>pr_ident</name><operator>-&gt;</operator><name>di_gen</name></name> <operator>==</operator> <name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name><operator>-&gt;</operator><name>dt_gen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>old</name><operator>-&gt;</operator><name>pr_ident</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>|=</operator> <name>DT_IDFLG_ORPHAN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_idhash_delete</name><argument_list>(<argument><expr><name><name>pvp</name><operator>-&gt;</operator><name>pv_probes</name></name></expr></argument>, <argument><expr><name><name>old</name><operator>-&gt;</operator><name>pr_ident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_probe_declare</name><argument_list>(<argument><expr><name>pvp</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dt_cook_probe</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dt_provider_t</name> <modifier>*</modifier></type><name>pvp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_probe_t</name> <modifier>*</modifier></type><name>prp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_xlator_t</name> <modifier>*</modifier></type><name>dxp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n1</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>n2</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>prp</name><operator>-&gt;</operator><name>pr_nargs</name></name> <operator>==</operator> <name><name>prp</name><operator>-&gt;</operator><name>pr_xargs</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>prp</name><operator>-&gt;</operator><name>pr_xargc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>xnp</name> <init>= <expr><name><name>prp</name><operator>-&gt;</operator><name>pr_xargv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>nnp</name> <init>= <expr><name><name>prp</name><operator>-&gt;</operator><name>pr_nargv</name><index>[<expr><name><name>prp</name><operator>-&gt;</operator><name>pr_mapping</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dxp</name> <operator>=</operator> <call><name>dt_xlator_lookup</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>,
<argument><expr><name>nnp</name></expr></argument>, <argument><expr><name>xnp</name></expr></argument>, <argument><expr><name>DT_XLATE_FUZZY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>dt_provider_xref</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>, <argument><expr><name>pvp</name></expr></argument>, <argument><expr><name><name>dxp</name><operator>-&gt;</operator><name>dx_id</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_NOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dt_node_is_argcompat</name><argument_list>(<argument><expr><name>nnp</name></expr></argument>, <argument><expr><name>xnp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>D_PROV_PRXLATOR</name></expr></argument>, <argument><expr><literal type="string">"translator for %s:%s output "</literal>
<literal type="string">"argument #%u from %s to %s is not defined\n"</literal></expr></argument>,
<argument><expr><name><name>pvp</name><operator>-&gt;</operator><name>pv_desc</name><operator>.</operator><name>dtvd_name</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>nnp</name></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>dt_node_type_name</name><argument_list>(<argument><expr><name>xnp</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_provider</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_provider_t</name> <modifier>*</modifier></type><name>pvp</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_provider</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>pnp</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>pnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_probes</name></name></expr>;</init> <condition><expr><name>pnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>pnp</name> <operator>=</operator> <name><name>pnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>probename</name> <init>= <expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_probe_t</name> <modifier>*</modifier></type><name>prp</name> <init>= <expr><call><name>dt_probe_lookup</name><argument_list>(<argument><expr><name>pvp</name></expr></argument>, <argument><expr><name>probename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_PROBE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>prp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_provred</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_provider_cmp</name><argument_list>(<argument><expr><name>pvp</name></expr></argument>, <argument><expr><name>pnp</name></expr></argument>,
<argument><expr><name>prp</name></expr></argument>, <argument><expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>prp</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_provred</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>pnp</name></expr></argument>, <argument><expr><name>D_PROV_INCOMPAT</name></expr></argument>,
<argument><expr><literal type="string">"provider interface mismatch: %s\n"</literal>
<literal type="string">"\t current: probe %s:%s defined\n"</literal>
<literal type="string">"\tprevious: probe %s:%s not defined\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_provname</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_provname</name></name></expr></argument>,
<argument><expr><name>probename</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_provname</name></name></expr></argument>, <argument><expr><name>probename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>prp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dnerror</name><argument_list>(<argument><expr><name>pnp</name></expr></argument>, <argument><expr><name>D_PROV_PRDUP</name></expr></argument>, <argument><expr><literal type="string">"probe redeclared: %s:%s\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_provname</name></name></expr></argument>, <argument><expr><name>probename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_probe_declare</name><argument_list>(<argument><expr><name>pvp</name></expr></argument>, <argument><expr><name><name>pnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>dt_cook_probe</name><argument_list>(<argument><expr><name>pnp</name></expr></argument>, <argument><expr><name>pvp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_cook_none</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function_decl><type><specifier>static</specifier> <name>dt_node_t</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dt_cook_funcs</name><index>[]</index>)<parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint_t</name></type></decl></parameter>)</parameter_list> <init>= <expr><block>{
<expr><name>dt_cook_none</name></expr></block></expr></init><operator>,</operator>
dt_cook_none<operator>,</operator>
dt_cook_none<operator>,</operator>
dt_cook_ident<operator>,</operator>
dt_cook_var<operator>,</operator>
dt_cook_none<operator>,</operator>
dt_cook_none<operator>,</operator>
dt_cook_func<operator>,</operator>
dt_cook_op1<operator>,</operator>
dt_cook_op2<operator>,</operator>
dt_cook_op3<operator>,</operator>
dt_cook_statement<operator>,</operator>
dt_cook_statement<operator>,</operator>
dt_cook_aggregation<operator>,</operator>
dt_cook_none<operator>,</operator>
dt_cook_clause<operator>,</operator>
dt_cook_inline<operator>,</operator>
dt_cook_member<operator>,</operator>
dt_cook_xlator<operator>,</operator>
dt_cook_none<operator>,</operator>
dt_cook_provider<operator>,</operator>
dt_cook_none<operator>,</operator>
dt_cook_none<operator>,</operator></function_decl>
};
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_cook</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>oldlineno</name> <init>= <expr><name>yylineno</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>yylineno</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_line</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>&lt;</operator>
<sizeof>sizeof <argument_list>(<argument><expr><name>dt_cook_funcs</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>dt_cook_funcs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <name><name>dt_cook_funcs</name><index>[<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name></expr>]</index></name><operator>(</operator><name>dnp</name><operator>,</operator> <name>idflags</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>|=</operator> <name>DT_NF_COOKED</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_VAR</name> <operator>||</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name> <operator>==</operator> <name>DT_NODE_AGG</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>|=</operator> <name>idflags</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>yylineno</name> <operator>=</operator> <name>oldlineno</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>dnp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>dtrace_attribute_t</name></type>
<name>dt_node_list_cook</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>pnp</name></decl></parameter>, <parameter><decl><type><name>uint_t</name></type> <name>idflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dtrace_attribute_t</name></type> <name>attr</name> <init>= <expr><name>_dtrace_defattr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nnp</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>dnp</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>pnp</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>*</operator><name>pnp</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</init> <condition><expr><name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dnp</name> <operator>=</operator> <name>nnp</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>nnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>dnp</name> <operator>=</operator> <operator>*</operator><name>pnp</name> <operator>=</operator> <call><name>dt_node_cook</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>, <argument><expr><name>idflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>dt_attr_min</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>=</operator> <name>nnp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pnp</name> <operator>=</operator> <operator>&amp;</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><operator>(</operator><name>attr</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>dt_node_list_free</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>pnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nnp</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>dnp</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>pnp</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>*</operator><name>pnp</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</init> <condition><expr><name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dnp</name> <operator>=</operator> <name>nnp</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>nnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>pnp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>pnp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>dt_node_link_free</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>pnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nnp</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>dnp</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>pnp</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>*</operator><name>pnp</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</init> <condition><expr><name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dnp</name> <operator>=</operator> <name>nnp</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>nnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_link</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_free</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<for>for <control>(<init><expr><name>dnp</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>pnp</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>*</operator><name>pnp</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</init> <condition><expr><name>dnp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dnp</name> <operator>=</operator> <name>nnp</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>nnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_link</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>pnp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>pnp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>dt_node_t</name> <modifier>*</modifier></type>
<name>dt_node_link</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>rp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>lp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>rp</name><operator>)</operator></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>rp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>lp</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>dnp</name> <operator>=</operator> <name>lp</name></expr>;</init> <condition><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>dnp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
<expr_stmt><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>lp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>dt_node_diftype</name><parameter_list>(<parameter><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dtrace_diftype_t</name> <modifier>*</modifier></type><name>tp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name> <operator>==</operator> <call><name>DT_STR_CTFP</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name> <operator>==</operator> <call><name>DT_STR_TYPE</name><argument_list>(<argument><expr><name>dtp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>dtdt_kind</name></name> <operator>=</operator> <name>DIF_TYPE_STRING</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>dtdt_ckind</name></name> <operator>=</operator> <name>CTF_K_UNKNOWN</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>dtdt_kind</name></name> <operator>=</operator> <name>DIF_TYPE_CTF</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>dtdt_ckind</name></name> <operator>=</operator> <call><name>ctf_type_kind</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>,
<argument><expr><call><name>ctf_type_resolve</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>dtdt_flags</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_REF</name><operator>)</operator></expr> ?</condition><then>
<expr><ternary><condition><expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name><operator>)</operator></expr> ?</condition><then> <expr><name>DIF_TF_BYUREF</name></expr> </then><else>:
<expr><name>DIF_TF_BYREF</name></expr></else></ternary></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>dtdt_pad</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>dtdt_size</name></name> <operator>=</operator> <call><name>ctf_type_size</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>dt_printd</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_NODE_INT</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"0x%llx"</literal></expr></argument>, <argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_SIGNED</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"u"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_STRING</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>escd</name> <init>= <expr><call><name>strchr2esc</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><name>escd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>escd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>DT_NODE_IDENT</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_VAR</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_LOCAL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"this-&gt;"</literal></expr> </then><else>:
<expr><ternary><condition><expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_TLS</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"self-&gt;"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></else></ternary></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_SYM</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>dtrace_syminfo_t</name> <modifier>*</modifier></type><name>dts</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s`%s"</literal></expr></argument>, <argument><expr><name><name>dts</name><operator>-&gt;</operator><name>dts_object</name></name></expr></argument>, <argument><expr><name><name>dts</name><operator>-&gt;</operator><name>dts_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block>
<case>case <expr><name>DT_NODE_FUNC</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_OP1</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s("</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_child</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_OP2</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_LPAR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_PTR</name> <operator>||</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_DOT</name> <operator>||</operator>
<name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_LBRAC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" %s "</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_LBRAC</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>ln</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>dn_list</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_OP3</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" ? "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" : "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_DEXPR</name></expr>:</case>
<case>case <expr><name>DT_NODE_DFUNC</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">";\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_PDESC</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s:%s:%s:%s"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_provider</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_mod</name></name></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_func</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_CLAUSE</name></expr>:</case>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_pdescs</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pred</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pred</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"/\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"{\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_acts</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_IF</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*sif ("</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_conditional</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">") {\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_body</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_alternate_body</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s}\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s} else {\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_alternate_body</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_printd</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s}\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"/* bad node %p, kind %d */\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>dnp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>dt_node_printr</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>n</name><index>[<expr><name>DT_TYPE_NAMELEN</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>buf</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>a</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>dtrace_syminfo_t</name> <modifier>*</modifier></type><name>dts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>dt_idnode_t</name> <modifier>*</modifier></type><name>inp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dt_attr_str</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_attr</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name> <operator>!=</operator> <name>CTF_ERR</name> <operator>&amp;&amp;</operator>
<call><name>ctf_type_name</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctfp</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFSIZ</name></expr></argument>, <argument><expr><literal type="string">"type=&lt;%s&gt; attr=%s flags="</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFSIZ</name></expr></argument>, <argument><expr><literal type="string">"type=&lt;%ld&gt; attr=%s flags="</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_type</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>n</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_SIGNED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">",SIGN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_COOKED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">",COOK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_REF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">",REF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_LVALUE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">",LVAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_WRITABLE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">",WRITE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_BITFIELD</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">",BITF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_flags</name></name> <operator>&amp;</operator> <name>DT_NF_USERLAND</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">",USER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<switch>switch <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_NODE_FREE</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"FREE &lt;node %p&gt;\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>dnp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_INT</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"INT 0x%llx (%s)\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>u_longlong_t</name><operator>)</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_value</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_STRING</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"STRING \"%s\" (%s)\n"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_IDENT</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"IDENT %s (%s)\n"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_VAR</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"VARIABLE %s%s (%s)\n"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_LOCAL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"this-&gt;"</literal></expr> </then><else>:
<expr><ternary><condition><expr><operator>(</operator><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_flags</name></name> <operator>&amp;</operator> <name>DT_IDFLG_TLS</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"self-&gt;"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></else></ternary></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s[\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s,\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s]\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_SYM</name></expr>:</case>
<expr_stmt><expr><name>dts</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"SYMBOL %s`%s (%s)\n"</literal></expr></argument>,
<argument><expr><name><name>dts</name><operator>-&gt;</operator><name>dts_object</name></name></expr></argument>, <argument><expr><name><name>dts</name><operator>-&gt;</operator><name>dts_name</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_TYPE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"TYPE (%s) %s\n"</literal></expr></argument>,
<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"TYPE (%s)\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_FUNC</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"FUNC %s (%s)\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_args</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s,\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<break>break;</break>
<case>case <expr><name>DT_NODE_OP1</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"OP1 %s (%s)\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_child</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_OP2</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"OP2 %s (%s)\n"</literal></expr></argument>, <argument><expr><call><name>opstr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_op</name></name> <operator>==</operator> <name>DT_TOK_LBRAC</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>ln</name> <init>= <expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>ln</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>ln</name><operator>-&gt;</operator><name>dn_list</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ln</name> <operator>=</operator> <name><name>ln</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_OP3</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"OP3 (%s)\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s?\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_left</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s:\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_right</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_DEXPR</name></expr>:</case>
<case>case <expr><name>DT_NODE_DFUNC</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"D EXPRESSION attr=%s\n"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_expr</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_AGG</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"AGGREGATE @%s attr=%s [\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_aggtup</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s,\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s] = "</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s]\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_aggfun</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s)\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_PDESC</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"PDESC %s:%s:%s:%s [%u]\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_provider</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_mod</name></name></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_func</name></name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_name</name></name></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_desc</name><operator>-&gt;</operator><name>dtpd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_CLAUSE</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"CLAUSE attr=%s\n"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_pdescs</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*sCTXATTR %s\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
<argument><expr><call><name>dt_attr_str</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ctxattr</name></name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pred</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*sPREDICATE /\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_pred</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*s/\n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_acts</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_INLINE</name></expr>:</case>
<expr_stmt><expr><name>inp</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_iarg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"INLINE %s (%s)\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>inp</name><operator>-&gt;</operator><name>din_root</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_MEMBER</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"MEMBER %s (%s)\n"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membname</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membexpr</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_membexpr</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_XLATOR</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"XLATOR (%s)"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_name</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_xlator</name><operator>-&gt;</operator><name>dx_src_ctfp</name></name></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_xlator</name><operator>-&gt;</operator><name>dx_src_type</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" from &lt;%s&gt;"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ctf_type_name</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_xlator</name><operator>-&gt;</operator><name>dx_dst_ctfp</name></name></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_xlator</name><operator>-&gt;</operator><name>dx_dst_type</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">" to &lt;%s&gt;"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_members</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<break>break;</break>
<case>case <expr><name>DT_NODE_PROBE</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"PROBE %s\n"</literal></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_ident</name><operator>-&gt;</operator><name>di_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>DT_NODE_PROVIDER</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"PROVIDER %s (%s)\n"</literal></expr></argument>,
<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_provname</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_provred</name></name></expr> ?</condition><then> <expr><literal type="string">"redecl"</literal></expr> </then><else>: <expr><literal type="string">"decl"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_probes</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<break>break;</break>
<case>case <expr><name>DT_NODE_PROG</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"PROGRAM attr=%s\n"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_list</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<break>break;</break>
<case>case <expr><name>DT_NODE_IF</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"IF attr=%s CONDITION:\n"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_conditional</name></name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*sIF BODY: \n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_body</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_alternate_body</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%*sIF ELSE: \n"</literal></expr></argument>, <argument><expr><name>depth</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_alternate_body</name></name></expr>;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>arg</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>dn_list</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dt_node_printr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"&lt;bad node %p, kind %d&gt;\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>dnp</name></expr></argument>, <argument><expr><name><name>dnp</name><operator>-&gt;</operator><name>dn_kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>dt_node_root</name><parameter_list>(<parameter><decl><type><name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_root</name></name> <operator>=</operator> <name>dnp</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>dnerror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dt_errtag_t</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>oldlineno</name> <init>= <expr><name>yylineno</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<expr_stmt><expr><name>yylineno</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_line</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xyvwarn</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yylineno</name> <operator>=</operator> <name>oldlineno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>dnwarn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>dt_node_t</name> <modifier>*</modifier></type><name>dnp</name></decl></parameter>, <parameter><decl><type><name>dt_errtag_t</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>oldlineno</name> <init>= <expr><name>yylineno</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<expr_stmt><expr><name>yylineno</name> <operator>=</operator> <name><name>dnp</name><operator>-&gt;</operator><name>dn_line</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xyvwarn</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yylineno</name> <operator>=</operator> <name>oldlineno</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>xyerror</name><parameter_list>(<parameter><decl><type><name>dt_errtag_t</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xyvwarn</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>xywarn</name><parameter_list>(<parameter><decl><type><name>dt_errtag_t</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>xyvwarn</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>xyvwarn</name><parameter_list>(<parameter><decl><type><name>dt_errtag_t</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>yypcb</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_set_errmsg</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>, <argument><expr><call><name>dt_errtag</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_region</name></name></expr></argument>,
<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_filetag</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_fileptr</name></name></expr> ?</condition><then> <expr><name>yylineno</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>yyerror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yyvwarn</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_jmpbuf</name></name></expr></argument>, <argument><expr><name>EDT_COMPILER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>yywarn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yyvwarn</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>yyvwarn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>yypcb</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>dt_set_errmsg</name><argument_list>(<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></argument>, <argument><expr><call><name>dt_errtag</name><argument_list>(<argument><expr><name>D_SYNTAX</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_region</name></name></expr></argument>,
<argument><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_filetag</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_fileptr</name></name></expr> ?</condition><then> <expr><name>yylineno</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>dtrace_hdl_t</name> <modifier>*</modifier></type><name>dtp</name> <init>= <expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_hdl</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errmsg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errmsg</name></name> <operator>+</operator> <name>len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>dtp</name><operator>-&gt;</operator><name>dt_errmsg</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>len</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name><name>yytext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">" near end of input"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>yytext</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">" near end of line"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>yytext</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">" near \"%s\""</literal></expr></argument>, <argument><expr><name>yytext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>yylabel</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>dt_dprintf</name><argument_list>(<argument><expr><literal type="string">"set label to &lt;%s&gt;\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>label</name></expr> ?</condition><then> <expr><name>label</name></expr> </then><else>: <expr><literal type="string">"NULL"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yypcb</name><operator>-&gt;</operator><name>pcb_region</name></name> <operator>=</operator> <name>label</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>int</name></type>
<name>yywrap</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
