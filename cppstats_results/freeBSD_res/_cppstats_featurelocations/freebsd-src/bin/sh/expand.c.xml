<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/bin/sh/expand.c">



































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>lint</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static char sccsid[] = "@(#)expand.c 8.5 (Berkeley) 5/15/95";
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/cdefs.h&gt;</cpp:file></cpp:include>
<expr_stmt><expr><call><name>__FBSDID</name><argument_list>(<argument><expr><literal type="string">"$FreeBSD$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wchar.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wctype.h&gt;</cpp:file></cpp:include>






<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"shell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"expand.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"syntax.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jobs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"options.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"input.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"output.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"memalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mystring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"arith.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"show.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"builtins.h"</cpp:file></cpp:include>

<enum>enum <name>wordstate</name> <block>{ <decl><name>WORD_IDLE</name></decl>, <decl><name>WORD_WS_DELIMITED</name></decl>, <decl><name>WORD_QUOTEMARK</name></decl> }</block>;</enum>

<struct>struct <name>worddest</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>arglist</name></name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>wordstate</name></name></type> <name>state</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>expdest</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier><modifier>*</modifier></type><parameter><decl><type><specifier>restrict</specifier></type></decl></parameter></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>exptilde</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expari</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier><modifier>*</modifier></type><parameter><decl><type><specifier>restrict</specifier></type></decl></parameter></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expbackq</name><parameter_list>(<parameter><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subevalvar_trim</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier><modifier>*</modifier></type><parameter><decl><type><specifier>restrict</specifier></type></decl></parameter></decl></parameter>,
<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>subevalvar_misc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier><modifier>*</modifier></type><parameter><decl><type><specifier>restrict</specifier></type></decl></parameter></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>evalvar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier><modifier>*</modifier></type><parameter><decl><type><specifier>restrict</specifier></type></decl></parameter></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>varisset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>strtodest</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reprocess</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>varvalue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expandmeta</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arglist</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>expmeta</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arglist</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>expsortcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>patmatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cvtnum</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>collate_range_cmp</name><parameter_list>(<parameter><decl><type><name>wchar_t</name></type></decl></parameter>, <parameter><decl><type><name>wchar_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>
<name>emptyarglist</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arglist</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>smallarg</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>capacity</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>smallarg</name></name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>list</name><operator>-&gt;</operator><name>smallarg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>appendarglist</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arglist</name></name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newargs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newcapacity</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>count</name></name> <operator>&gt;=</operator> <name><name>list</name><operator>-&gt;</operator><name>capacity</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>newcapacity</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>capacity</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>newcapacity</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newcapacity</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>newcapacity</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>/</operator> <operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>newargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Too many entries in arglist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>stalloc</name><argument_list>(<argument><expr><name>newcapacity</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>newargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>newargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>newargs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>capacity</name></name> <operator>=</operator> <name>newcapacity</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>args</name><index>[<expr><name><name>list</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>collate_range_cmp</name><parameter_list>(<parameter><decl><type><name>wchar_t</name></type> <name>c1</name></decl></parameter>, <parameter><decl><type><name>wchar_t</name></type> <name>c2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>wchar_t</name></type> <name><name>s1</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>s2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>s1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>L</name><literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>L</name><literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>wcscoll</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>stputs_quotes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>syntax</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CHECKSTRSPACE</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>syntax</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><operator>*</operator><name>data</name></expr>]</index></name> <operator>==</operator> <name>CCTL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLESC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><operator>*</operator><name>data</name><operator>++</operator></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STPUTS_QUOTES</name><parameter_list>(<parameter><type><name>data</name></type></parameter>, <parameter><type><name>syntax</name></type></parameter>, <parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>p = stputs_quotes((data), syntax, p)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>nextword</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>is_ws</name></decl>;</decl_stmt>

<expr_stmt><expr><name>is_ws</name> <operator>=</operator> <name>c</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <call><name>stackblock</name><argument_list>()</argument_list></call> <operator>||</operator> <operator>(</operator><ternary><condition><expr><name>is_ws</name></expr> ?</condition><then> <expr><name><name>dst</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>WORD_QUOTEMARK</name></expr> </then><else>:
<expr><name><name>dst</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>WORD_WS_DELIMITED</name></expr></else></ternary><operator>)</operator> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STPUTC</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>EXP_GLOB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>expandmeta</name><argument_list>(<argument><expr><call><name>grabstackstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>dst</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>appendarglist</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><call><name>grabstackstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <ternary><condition><expr><name>is_ws</name></expr> ?</condition><then> <expr><name>WORD_WS_DELIMITED</name></expr> </then><else>: <expr><name>WORD_IDLE</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name>is_ws</name> <operator>&amp;&amp;</operator> <name><name>dst</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>WORD_WS_DELIMITED</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WORD_IDLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>appendarglist</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>list</name><operator>-&gt;</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STARTSTACKSTR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXTWORD</name><parameter_list>(<parameter><type><name>c</name></type></parameter>, <parameter><type><name>flag</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>dstlist</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>p = nextword(c, flag, p, dstlist)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>stputs_split</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>syntax</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ifs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ifs</name> <operator>=</operator> <ternary><condition><expr><call><name>ifsset</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>ifsval</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">" \t\n"</literal></expr></else></ternary></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CHECKSTRSPACE</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>data</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>ifs</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEXTWORD</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>EXP_GLOB</name> <operator>&amp;&amp;</operator> <name><name>syntax</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name>c</name></expr>]</index></name> <operator>==</operator> <name>CCTL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLESC</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STPUTS_SPLIT</name><parameter_list>(<parameter><type><name>data</name></type></parameter>, <parameter><type><name>syntax</name></type></parameter>, <parameter><type><name>flag</name></type></parameter>, <parameter><type><name>p</name></type></parameter>, <parameter><type><name>dst</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>p = stputs_split((data), syntax, flag, p, dst)</cpp:value></cpp:define>













<function><type><name>void</name></type>
<name>expandarg</name><parameter_list>(<parameter><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arglist</name></name> <modifier>*</modifier></type><name>arglist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>worddest</name></name></type> <name>exparg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier></type><name>argbackq</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flag</name> <operator>&amp;=</operator> <operator>~</operator><name>EXP_GLOB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>argbackq</name> <operator>=</operator> <name><name>arg</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>backquote</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exparg</name><operator>.</operator><name>list</name></name> <operator>=</operator> <name>arglist</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>exparg</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>WORD_IDLE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STARTSTACKSTR</name><argument_list>(<argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>argstr</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>text</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argbackq</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exparg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>arglist</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STACKSTRNUL</name><argument_list>(<argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>EXP_SPLIT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>expdest</name> <operator>!=</operator> <call><name>stackblock</name><argument_list>()</argument_list></call> <operator>||</operator>
<name><name>exparg</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>WORD_QUOTEMARK</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>STPUTC</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>EXP_SPLIT</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>EXP_GLOB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>expandmeta</name><argument_list>(<argument><expr><call><name>grabstackstr</name><argument_list>(<argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>exparg</name><operator>.</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>appendarglist</name><argument_list>(<argument><expr><name><name>exparg</name><operator>.</operator><name>list</name></name></expr></argument>, <argument><expr><call><name>grabstackstr</name><argument_list>(<argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>EXP_SPLIT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>appendarglist</name><argument_list>(<argument><expr><name>arglist</name></expr></argument>, <argument><expr><call><name>grabstackstr</name><argument_list>(<argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>argstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier><modifier>*</modifier><specifier>restrict</specifier></type> <name>argbackq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quotes</name> <init>= <expr><name>flag</name> <operator>&amp;</operator> <operator>(</operator><name>EXP_GLOB</name> <operator>|</operator> <name>EXP_CASE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>firsteq</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>split_lit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lit_quoted</name></decl>;</decl_stmt>

<expr_stmt><expr><name>split_lit</name> <operator>=</operator> <name>flag</name> <operator>&amp;</operator> <name>EXP_SPLIT_LIT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lit_quoted</name> <operator>=</operator> <name>flag</name> <operator>&amp;</operator> <name>EXP_LIT_QUOTED</name></expr>;</expr_stmt>
<expr_stmt><expr><name>flag</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>EXP_SPLIT_LIT</name> <operator>|</operator> <name>EXP_LIT_QUOTED</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'~'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flag</name> <operator>&amp;</operator> <operator>(</operator><name>EXP_TILDE</name> <operator>|</operator> <name>EXP_VARTILDE</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>exptilde</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>CHECKSTRSPACE</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
<return>return <expr><operator>(</operator><name>p</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
<case>case <expr><name>CTLENDVAR</name></expr>:</case>
<case>case <expr><name>CTLENDARI</name></expr>:</case>
<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
<case>case <expr><name>CTLQUOTEMARK</name></expr>:</case>
<expr_stmt><expr><name>lit_quoted</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>CTLVAR</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <name>VSQUOTE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>EXP_SPLIT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>expdest</name> <operator>==</operator> <call><name>stackblock</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WORD_QUOTEMARK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>CTLQUOTEEND</name></expr>:</case>
<expr_stmt><expr><name>lit_quoted</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CTLESC</name></expr>:</case>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>split_lit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>lit_quoted</name> <operator>&amp;&amp;</operator>
<call><name>strchr</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>ifsset</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>ifsval</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">" \t\n"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEXTWORD</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>quotes</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLESC</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CTLVAR</name></expr>:</case>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>evalvar</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>argbackq</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CTLBACKQ</name></expr>:</case>
<case>case <expr><name>CTLBACKQ</name><operator>|</operator><name>CTLQUOTE</name></expr>:</case>
<expr_stmt><expr><call><name>expbackq</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>argbackq</name><operator>)</operator><operator>-&gt;</operator><name>n</name></name></expr></argument>, <argument><expr><name>c</name> <operator>&amp;</operator> <name>CTLQUOTE</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>argbackq</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>argbackq</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CTLARI</name></expr>:</case>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>expari</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>argbackq</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">':'</literal></expr>:</case>
<case>case <expr><literal type="char">'='</literal></expr>:</case>




<if_stmt><if>if <condition>(<expr><name>split_lit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>lit_quoted</name> <operator>&amp;&amp;</operator>
<call><name>strchr</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>ifsset</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>ifsval</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">" \t\n"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEXTWORD</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>EXP_VARTILDE</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'~'</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>c</name> <operator>!=</operator> <literal type="char">'='</literal> <operator>||</operator> <name>firsteq</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>firsteq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>exptilde</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>split_lit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>lit_quoted</name> <operator>&amp;&amp;</operator>
<call><name>strchr</name><argument_list>(<argument><expr><ternary><condition><expr><call><name>ifsset</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>ifsval</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">" \t\n"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEXTWORD</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>exptilde</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>startp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>user</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pw</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>home</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<switch>switch<condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CTLESC</name></expr>:</case>
<case>case <expr><name>CTLVAR</name></expr>:</case>
<case>case <expr><name>CTLBACKQ</name></expr>:</case>
<case>case <expr><name>CTLBACKQ</name> <operator>|</operator> <name>CTLQUOTE</name></expr>:</case>
<case>case <expr><name>CTLARI</name></expr>:</case>
<case>case <expr><name>CTLENDARI</name></expr>:</case>
<case>case <expr><name>CTLQUOTEMARK</name></expr>:</case>
<return>return <expr><operator>(</operator><name>startp</name><operator>)</operator></expr>;</return>
<case>case <expr><literal type="char">':'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flag</name> <operator>&amp;</operator> <name>EXP_VARTILDE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
<case>case <expr><literal type="char">'/'</literal></expr>:</case>
<case>case <expr><name>CTLENDVAR</name></expr>:</case>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>startp</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STPUTBIN</name><argument_list>(<argument><expr><name>startp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STACKSTRNUL</name><argument_list>(<argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>user</name> <operator>=</operator> <name>expdest</name> <operator>-</operator> <name>len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>user</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>home</name> <operator>=</operator> <call><name>lookupvar</name><argument_list>(<argument><expr><literal type="string">"HOME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>pw</name> <operator>=</operator> <call><name>getpwnam</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>home</name> <operator>=</operator> <ternary><condition><expr><name>pw</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>pw</name><operator>-&gt;</operator><name>pw_dir</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>STADJUST</name><argument_list>(<argument><expr><operator>-</operator><name>len</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>home</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>home</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>startp</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>strtodest</name><argument_list>(<argument><expr><name>home</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>VSNORMAL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>p</name><operator>)</operator></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>expari</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier><modifier>*</modifier><specifier>restrict</specifier></type> <name>argbackq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>arith_t</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>begoff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quoted</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>adj</name></decl>;</decl_stmt>

<expr_stmt><expr><name>quoted</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator> <operator>==</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>begoff</name> <operator>=</operator> <name>expdest</name> <operator>-</operator> <call><name>stackblock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>argstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>argbackq</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STPUTC</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>stackblock</name><argument_list>()</argument_list></call> <operator>+</operator> <name>begoff</name></expr>;</expr_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>grabstackstr</name><argument_list>(<argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>arith</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ungrabstackstr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>stackblock</name><argument_list>()</argument_list></call> <operator>+</operator> <name>begoff</name></expr>;</expr_stmt>
<expr_stmt><expr><name>adj</name> <operator>=</operator> <name>start</name> <operator>-</operator> <name>expdest</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STADJUST</name><argument_list>(<argument><expr><name>adj</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECKSTRSPACE</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>DIGITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fmtstr</name><argument_list>(<argument><expr><name>expdest</name></expr></argument>, <argument><expr><call><name>DIGITS</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ARITH_FORMAT_STR</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>adj</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STADJUST</name><argument_list>(<argument><expr><name>adj</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>quoted</name></expr> ?</condition><then>
<expr><name><name>result</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>begoff</name></expr></argument> &gt;</argument_list></name> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>flag</name> <operator>&amp;</operator> <operator>(</operator><name>EXP_GLOB</name> <operator>|</operator> <name>EXP_CASE</name><operator>)</operator></expr> </then><else>:
<expr><name>flag</name> <operator>&amp;</operator> <name>EXP_SPLIT</name></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>reprocess</name><argument_list>(<argument><expr><name>expdest</name> <operator>-</operator> <name>adj</name> <operator>-</operator> <call><name>stackblock</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>VSNORMAL</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>,
<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>expbackq</name><parameter_list>(<parameter><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quoted</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>backcmd</name></name></type> <name>in</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name> <init>= <expr><name>expdest</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>lastc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>syntax</name> <init>= <expr><ternary><condition><expr><name>quoted</name></expr>?</condition><then> <expr><name>DQSYNTAX</name></expr> </then><else>: <expr><name>BASESYNTAX</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quotes</name> <init>= <expr><name>flag</name> <operator>&amp;</operator> <operator>(</operator><name>EXP_GLOB</name> <operator>|</operator> <name>EXP_CASE</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nnl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ifs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>startloc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>INTOFF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>grabstackstr</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>evalbackcmd</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ungrabstackstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>in</name><operator>.</operator><name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>startloc</name> <operator>=</operator> <name>dest</name> <operator>-</operator> <call><name>stackblock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nnl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>quoted</name> <operator>&amp;&amp;</operator> <name>flag</name> <operator>&amp;</operator> <name>EXP_SPLIT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ifs</name> <operator>=</operator> <ternary><condition><expr><call><name>ifsset</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>ifsval</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><literal type="string">" \t\n"</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ifs</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>in</name><operator>.</operator><name>nleft</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>in</name><operator>.</operator><name>fd</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>(</operator><name>i</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>in</name><operator>.</operator><name>fd</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></while>
<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"expbackq: read returns %d\n"</literal><operator>,</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>in</name><operator>.</operator><name>nleft</name></name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>lastc</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lastc</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nnl</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lastc</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>NEXTWORD</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nnl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>ifs</name></expr></argument>, <argument><expr><name>lastc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>lastc</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nnl</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NEXTWORD</name><argument_list>(<argument><expr><name>lastc</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>CHECKSTRSPACE</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>quotes</name> <operator>&amp;&amp;</operator> <name><name>syntax</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name>lastc</name></expr>]</index></name> <operator>==</operator> <name>CCTL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLESC</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>lastc</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<while>while <condition>(<expr><name>dest</name> <operator>&gt;</operator> <call><name>stackblock</name><argument_list>()</argument_list></call> <operator>+</operator> <name>startloc</name> <operator>&amp;&amp;</operator> <call><name>STTOPC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STUNPUTC</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name><name>in</name><operator>.</operator><name>fd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>in</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>in</name><operator>.</operator><name>buf</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name><name>in</name><operator>.</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>in</name><operator>.</operator><name>jp</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>grabstackstr</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>exitstatus</name> <operator>=</operator> <call><name>waitforjob</name><argument_list>(<argument><expr><name><name>in</name><operator>.</operator><name>jp</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ungrabstackstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"expbackq: done\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>expdest</name> <operator>=</operator> <name>dest</name></expr>;</expr_stmt>
<expr_stmt><expr><name>INTON</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>recordleft</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>loc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>startp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>amount</name></decl>;</decl_stmt>

<expr_stmt><expr><name>amount</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>str</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>loc</name> <operator>-</operator> <name>startp</name><operator>)</operator><operator>)</operator> <operator>-</operator> <name>expdest</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STADJUST</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>loc</name> <operator>!=</operator> <name>str</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>startp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>loc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>subevalvar_trim</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier><modifier>*</modifier><specifier>restrict</specifier></type> <name>argbackq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>strloc</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>subtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startloc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>startp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>loc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>amount</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>argstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>argbackq</name></expr></argument>, <argument><expr><name>EXP_CASE</name> <operator>|</operator> <name>EXP_TILDE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STACKSTRNUL</name><argument_list>(<argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>startp</name> <operator>=</operator> <call><name>stackblock</name><argument_list>()</argument_list></call> <operator>+</operator> <name>startloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>stackblock</name><argument_list>()</argument_list></call> <operator>+</operator> <name>strloc</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>subtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VSTRIMLEFT</name></expr>:</case>
<for>for <control>(<init><expr><name>loc</name> <operator>=</operator> <name>startp</name></expr>;</init> <condition><expr><name>loc</name> <operator>&lt;</operator> <name>str</name></expr>;</condition> <incr><expr><name>loc</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>loc</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>loc</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>patmatch</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>loc</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>recordleft</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>loc</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></for>
<break>break;</break>

<case>case <expr><name>VSTRIMLEFTMAX</name></expr>:</case>
<for>for <control>(<init><expr><name>loc</name> <operator>=</operator> <name>str</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>loc</name> <operator>&gt;=</operator> <name>startp</name></expr>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>loc</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>loc</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>patmatch</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>loc</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>recordleft</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>loc</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>loc</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<break>break;</break>

<case>case <expr><name>VSTRIMRIGHT</name></expr>:</case>
<for>for <control>(<init><expr><name>loc</name> <operator>=</operator> <name>str</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>loc</name> <operator>&gt;=</operator> <name>startp</name></expr>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>patmatch</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>amount</name> <operator>=</operator> <name>loc</name> <operator>-</operator> <name>expdest</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STADJUST</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>loc</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></for>
<break>break;</break>

<case>case <expr><name>VSTRIMRIGHTMAX</name></expr>:</case>
<for>for <control>(<init><expr><name>loc</name> <operator>=</operator> <name>startp</name></expr>;</init> <condition><expr><name>loc</name> <operator>&lt;</operator> <name>str</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>loc</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>patmatch</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>amount</name> <operator>=</operator> <name>loc</name> <operator>-</operator> <name>expdest</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STADJUST</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<break>break;</break>


<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><name>amount</name> <operator>=</operator> <operator>(</operator><name>expdest</name> <operator>-</operator> <call><name>stackblock</name><argument_list>()</argument_list></call> <operator>-</operator> <name>strloc</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STADJUST</name><argument_list>(<argument><expr><operator>-</operator><name>amount</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>subevalvar_misc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier><modifier>*</modifier><specifier>restrict</specifier></type> <name>argbackq</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startloc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>startp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>amount</name></decl>;</decl_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>argstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>argbackq</name></expr></argument>, <argument><expr><name>EXP_TILDE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STACKSTRNUL</name><argument_list>(<argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>startp</name> <operator>=</operator> <call><name>stackblock</name><argument_list>()</argument_list></call> <operator>+</operator> <name>startloc</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>subtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VSASSIGN</name></expr>:</case>
<expr_stmt><expr><call><name>setvar</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>amount</name> <operator>=</operator> <name>startp</name> <operator>-</operator> <name>expdest</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STADJUST</name><argument_list>(<argument><expr><name>amount</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>end</name></expr>;</return>

<case>case <expr><name>VSQUESTION</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>CTLENDVAR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>outfmt</name><argument_list>(<argument><expr><name>out2</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>startp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%.*s: parameter %snot set"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>var</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
<argument><expr><name>var</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>varflags</name> <operator>&amp;</operator> <name>VSNUL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"null or "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>evalvar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier><modifier>*</modifier><specifier>restrict</specifier></type> <name>argbackq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>subtype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>varflags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>patloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>set</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>special</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>startloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>varlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>varlenb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">21</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>varflags</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>subtype</name> <operator>=</operator> <name>varflags</name> <operator>&amp;</operator> <name>VSTYPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>var</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>special</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>is_name</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>special</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>varflags</name> <operator>&amp;</operator> <name>VSLINENO</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>set</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>special</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>special</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>set</name> <operator>=</operator> <call><name>varisset</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>varflags</name> <operator>&amp;</operator> <name>VSNUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>bltinlookup</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><operator>(</operator><name>varflags</name> <operator>&amp;</operator> <name>VSNUL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>set</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>set</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>varlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>startloc</name> <operator>=</operator> <name>expdest</name> <operator>-</operator> <call><name>stackblock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>set</name> <operator>&amp;&amp;</operator> <name>uflag</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>var</name> <operator>!=</operator> <literal type="char">'@'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>var</name> <operator>!=</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>subtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VSNORMAL</name></expr>:</case>
<case>case <expr><name>VSTRIMLEFT</name></expr>:</case>
<case>case <expr><name>VSTRIMLEFTMAX</name></expr>:</case>
<case>case <expr><name>VSTRIMRIGHT</name></expr>:</case>
<case>case <expr><name>VSTRIMRIGHTMAX</name></expr>:</case>
<case>case <expr><name>VSLENGTH</name></expr>:</case>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"%.*s: parameter not set"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>var</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>set</name> <operator>&amp;&amp;</operator> <name>subtype</name> <operator>!=</operator> <name>VSPLUS</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>special</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>varflags</name> <operator>&amp;</operator> <name>VSLINENO</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>-</operator> <name>var</name> <operator>&gt;</operator> <operator>(</operator><name>ptrdiff_t</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>var</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>p</name> <operator>-</operator> <name>var</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strtodest</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>,
<argument><expr><name>varflags</name> <operator>&amp;</operator> <name>VSQUOTE</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>varvalue</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>varflags</name> <operator>&amp;</operator> <name>VSQUOTE</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>,
<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>subtype</name> <operator>==</operator> <name>VSLENGTH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>varlenb</name> <operator>=</operator> <name>expdest</name> <operator>-</operator> <call><name>stackblock</name><argument_list>()</argument_list></call> <operator>-</operator> <name>startloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>varlen</name> <operator>=</operator> <name>varlenb</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>localeisutf8</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>stackblock</name><argument_list>()</argument_list></call> <operator>+</operator> <name>startloc</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition><expr><name>val</name> <operator>!=</operator> <name>expdest</name></expr>;</condition> <incr><expr><name>val</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>val</name> <operator>&amp;</operator> <literal type="number">0xC0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>varlen</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>STADJUST</name><argument_list>(<argument><expr><operator>-</operator><name>varlenb</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>subtype</name> <operator>==</operator> <name>VSLENGTH</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init>;</init><condition><expr><operator>*</operator><name>val</name></expr>;</condition> <incr><expr><name>val</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>localeisutf8</name> <operator>||</operator>
<operator>(</operator><operator>*</operator><name>val</name> <operator>&amp;</operator> <literal type="number">0xC0</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>varlen</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strtodest</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>,
<argument><expr><name>varflags</name> <operator>&amp;</operator> <name>VSQUOTE</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>subtype</name> <operator>==</operator> <name>VSPLUS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>set</name> <operator>=</operator> <operator>!</operator> <name>set</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>subtype</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>VSLENGTH</name></expr>:</case>
<expr_stmt><expr><call><name>cvtnum</name><argument_list>(<argument><expr><name>varlen</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strtodest</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>VSNORMAL</name></expr></argument>, <argument><expr><name>varflags</name> <operator>&amp;</operator> <name>VSQUOTE</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>VSNORMAL</name></expr>:</case>
<return>return <expr><name>p</name></expr>;</return>

<case>case <expr><name>VSPLUS</name></expr>:</case>
<case>case <expr><name>VSMINUS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>set</name></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>argstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>argbackq</name></expr></argument>,
<argument><expr><name>flag</name> <operator>|</operator> <operator>(</operator><ternary><condition><expr><name>flag</name> <operator>&amp;</operator> <name>EXP_SPLIT</name></expr> ?</condition><then> <expr><name>EXP_SPLIT_LIT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
<operator>(</operator><ternary><condition><expr><name>varflags</name> <operator>&amp;</operator> <name>VSQUOTE</name></expr> ?</condition><then> <expr><name>EXP_LIT_QUOTED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>VSTRIMLEFT</name></expr>:</case>
<case>case <expr><name>VSTRIMLEFTMAX</name></expr>:</case>
<case>case <expr><name>VSTRIMRIGHT</name></expr>:</case>
<case>case <expr><name>VSTRIMRIGHTMAX</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>set</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>




<expr_stmt><expr><call><name>STPUTC</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>patloc</name> <operator>=</operator> <name>expdest</name> <operator>-</operator> <call><name>stackblock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>subevalvar_trim</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>argbackq</name></expr></argument>, <argument><expr><name>patloc</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>startloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reprocess</name><argument_list>(<argument><expr><name>startloc</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>VSNORMAL</name></expr></argument>, <argument><expr><name>varflags</name> <operator>&amp;</operator> <name>VSQUOTE</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>EXP_SPLIT</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>var</name> <operator>==</operator> <literal type="char">'@'</literal> <operator>&amp;&amp;</operator> <name>varflags</name> <operator>&amp;</operator> <name>VSQUOTE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WORD_QUOTEMARK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>p</name></expr>;</return>

<case>case <expr><name>VSASSIGN</name></expr>:</case>
<case>case <expr><name>VSQUESTION</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>set</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>subevalvar_misc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>argbackq</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>,
<argument><expr><name>startloc</name></expr></argument>, <argument><expr><name>varflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>lookupvar</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strtodest</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>varflags</name> <operator>&amp;</operator> <name>VSQUOTE</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>VSERROR</name></expr>:</case>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>var</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"${%.*s%s}: Bad substitution"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>var</name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>CTLENDVAR</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"..."</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>

<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>nesting</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>==</operator> <name>CTLESC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <name>CTLBACKQ</name> <operator>||</operator> <name>c</name> <operator>==</operator> <operator>(</operator><name>CTLBACKQ</name><operator>|</operator><name>CTLQUOTE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>argbackq</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>argbackq</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <name>CTLVAR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>&amp;</operator> <name>VSTYPE</name><operator>)</operator> <operator>!=</operator> <name>VSNORMAL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nesting</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <name>CTLENDVAR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name>nesting</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block>
<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>varisset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nulok</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>backgndpidset</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'@'</literal> <operator>||</operator> <operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>shellparam</name><operator>.</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nulok</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>av</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>av</name> <operator>=</operator> <name><name>shellparam</name><operator>.</operator><name>p</name></name></expr>;</init> <condition><expr><operator>*</operator><name>av</name></expr>;</condition> <incr><expr><name>av</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>av</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_digit</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>num</name></decl>;</decl_stmt>

<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>num</name> <operator>&gt;</operator> <name><name>shellparam</name><operator>.</operator><name>nparam</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ap</name> <operator>=</operator> <name>arg0</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ap</name> <operator>=</operator> <name><name>shellparam</name><operator>.</operator><name>p</name><index>[<expr><name>num</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nulok</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ap</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>ap</name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>strtodest</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quoted</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>subtype</name> <operator>==</operator> <name>VSLENGTH</name> <operator>||</operator> <name>subtype</name> <operator>==</operator> <name>VSTRIMLEFT</name> <operator>||</operator>
<name>subtype</name> <operator>==</operator> <name>VSTRIMLEFTMAX</name> <operator>||</operator> <name>subtype</name> <operator>==</operator> <name>VSTRIMRIGHT</name> <operator>||</operator>
<name>subtype</name> <operator>==</operator> <name>VSTRIMRIGHTMAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STPUTS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>EXP_SPLIT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>quoted</name> <operator>&amp;&amp;</operator> <name>dst</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STPUTS_SPLIT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>BASESYNTAX</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <operator>(</operator><name>EXP_GLOB</name> <operator>|</operator> <name>EXP_CASE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STPUTS_QUOTES</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><ternary><condition><expr><name>quoted</name></expr> ?</condition><then> <expr><name>DQSYNTAX</name></expr> </then><else>: <expr><name>BASESYNTAX</name></expr></else></ternary></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STPUTS</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>reprocess</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>startloc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quoted</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>buflen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>startp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>zpos</name></decl>, <decl><type ref="prev"/><name>zlen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>startp</name> <operator>=</operator> <call><name>stackblock</name><argument_list>()</argument_list></call> <operator>+</operator> <name>startloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>expdest</name> <operator>-</operator> <name>startp</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>SIZE_MAX</name> <operator>/</operator> <literal type="number">2</literal> <operator>||</operator> <name>len</name> <operator>&gt;</operator> <name>PTRDIFF_MAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>INTOFF</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>buflen</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>buflen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>buflen</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ckmalloc</name><argument_list>(<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>INTON</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STADJUST</name><argument_list>(<argument><expr><operator>-</operator><operator>(</operator><name>ptrdiff_t</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>zpos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>zlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>zpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strtodest</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>zpos</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>zpos</name> <operator>+=</operator> <name>zlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>zpos</name> <operator>==</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>EXP_SPLIT</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>quoted</name> <operator>||</operator> <operator>(</operator><name>zlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>zpos</name> <operator>&lt;</operator> <name>len</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NEXTWORD</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>varvalue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quoted</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>subtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>worddest</name></name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>splitlater</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>sep</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><operator>(</operator><ternary><condition><expr><name>NSHORTOPTS</name> <operator>&gt;</operator> <literal type="number">10</literal></expr> ?</condition><then> <expr><name>NSHORTOPTS</name></expr> </then><else>: <expr><literal type="number">10</literal></expr></else></ternary><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>subtype</name> <operator>==</operator> <name>VSLENGTH</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flag</name> <operator>&amp;=</operator> <operator>~</operator><name>EXP_FULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>splitlater</name> <operator>=</operator> <name>subtype</name> <operator>==</operator> <name>VSTRIMLEFT</name> <operator>||</operator> <name>subtype</name> <operator>==</operator> <name>VSTRIMLEFTMAX</name> <operator>||</operator>
<name>subtype</name> <operator>==</operator> <name>VSTRIMRIGHT</name> <operator>||</operator> <name>subtype</name> <operator>==</operator> <name>VSTRIMRIGHTMAX</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>name</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'$'</literal></expr>:</case>
<expr_stmt><expr><name>num</name> <operator>=</operator> <name>rootpid</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<expr_stmt><expr><name>num</name> <operator>=</operator> <name>oexitstatus</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'#'</literal></expr>:</case>
<expr_stmt><expr><name>num</name> <operator>=</operator> <name><name>shellparam</name><operator>.</operator><name>nparam</name></name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'!'</literal></expr>:</case>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>backgndpidval</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'-'</literal></expr>:</case>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NSHORTOPTS</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>optval</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name><name>optletter</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strtodest</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><literal type="char">'@'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>EXP_SPLIT</name> <operator>&amp;&amp;</operator> <name>quoted</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><expr><name>ap</name> <operator>=</operator> <name><name>shellparam</name><operator>.</operator><name>p</name></name></expr> ;</init> <condition><expr><operator>(</operator><name>p</name> <operator>=</operator> <operator>*</operator><name>ap</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>strtodest</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ap</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>splitlater</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STPUTC</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NEXTWORD</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>,
<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>shellparam</name><operator>.</operator><name>nparam</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>WORD_QUOTEMARK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>ifsset</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ifsval</name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>sep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>ap</name> <operator>=</operator> <name><name>shellparam</name><operator>.</operator><name>p</name></name></expr> ;</init> <condition><expr><operator>(</operator><name>p</name> <operator>=</operator> <operator>*</operator><name>ap</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>strtodest</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>ap</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strtodest</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>flag</name> <operator>&amp;</operator> <name>EXP_SPLIT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>quoted</name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>*</operator><name>ap</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>splitlater</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STPUTC</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>NEXTWORD</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>expdest</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><call><name>is_digit</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>arg0</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>num</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>num</name> <operator>&lt;=</operator> <name><name>shellparam</name><operator>.</operator><name>nparam</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>shellparam</name><operator>.</operator><name>p</name><index>[<expr><name>num</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<return>return;</return></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>strtodest</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>cvtnum</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strtodest</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>, <argument><expr><name>quoted</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>expdir</name><index>[<expr><name>PATH_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>expdir_end</name></cpp:macro> <cpp:value>(expdir + sizeof(expdir))</cpp:value></cpp:define>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>expandmeta</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arglist</name></name> <modifier>*</modifier></type><name>dstlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>firstmatch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>firstmatch</name> <operator>=</operator> <name><name>dstlist</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>INTOFF</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expmeta</name><argument_list>(<argument><expr><name>expdir</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>dstlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>INTON</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>dstlist</name><operator>-&gt;</operator><name>count</name></name> <operator>==</operator> <name>firstmatch</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>rmescapes</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>appendarglist</name><argument_list>(<argument><expr><name>dstlist</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dstlist</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>firstmatch</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>dstlist</name><operator>-&gt;</operator><name>count</name></name> <operator>-</operator> <name>firstmatch</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>dstlist</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>expsortcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>expmeta</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>enddir</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arglist</name></name> <modifier>*</modifier></type><name>arglist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>endname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>metaflag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>statb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DIR</name> <modifier>*</modifier></type><name>dirp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>dirent</name></name> <modifier>*</modifier></type><name>dp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>atend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>matchdot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>esc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>namlen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>metaflag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>name</name></expr>;</init> <condition><expr><name>esc</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>+=</operator> <name>esc</name> <operator>+</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>metaflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>q</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>||</operator> <operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>q</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <name>CTLESC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>q</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>++</operator><name>q</name> <operator>==</operator> <literal type="char">']'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>metaflag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>CTLESC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>esc</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>esc</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>metaflag</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>start</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>esc</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>metaflag</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>enddir</name> <operator>!=</operator> <name>expdir</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>metaflag</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>name</name></expr> ;</init> <condition>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>CTLESC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>enddir</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>enddir</name> <operator>==</operator> <name>expdir_end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>metaflag</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>lstat</name><argument_list>(<argument><expr><name>expdir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statb</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>appendarglist</name><argument_list>(<argument><expr><name>arglist</name></expr></argument>, <argument><expr><call><name>stsavestr</name><argument_list>(<argument><expr><name>expdir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>endname</name> <operator>=</operator> <name>name</name> <operator>+</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>name</name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>start</name> <operator>!=</operator> <name>name</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>start</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>CTLESC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>enddir</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>enddir</name> <operator>==</operator> <name>expdir_end</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>enddir</name> <operator>==</operator> <name>expdir</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="string">"."</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>enddir</name> <operator>==</operator> <name>expdir</name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>expdir</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <literal type="string">"/"</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>expdir</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>enddir</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dirp</name> <operator>=</operator> <call><name>opendir</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>enddir</name> <operator>!=</operator> <name>expdir</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>enddir</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endname</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>atend</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>atend</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>endname</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>endname</name> <operator>+=</operator> <name>esc</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>matchdot</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>CTLESC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>matchdot</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>!</operator> <call><name>int_pending</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>dp</name> <operator>=</operator> <call><name>readdir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>d_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>!</operator> <name>matchdot</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>patmatch</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>namlen</name> <operator>=</operator> <name><name>dp</name><operator>-&gt;</operator><name>d_namlen</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>enddir</name> <operator>+</operator> <name>namlen</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>expdir_end</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>enddir</name></expr></argument>, <argument><expr><name><name>dp</name><operator>-&gt;</operator><name>d_name</name></name></expr></argument>, <argument><expr><name>namlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>atend</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>appendarglist</name><argument_list>(<argument><expr><name>arglist</name></expr></argument>, <argument><expr><call><name>stsavestr</name><argument_list>(<argument><expr><name>expdir</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>dp</name><operator>-&gt;</operator><name>d_type</name></name> <operator>!=</operator> <name>DT_UNKNOWN</name> <operator>&amp;&amp;</operator>
<name><name>dp</name><operator>-&gt;</operator><name>d_type</name></name> <operator>!=</operator> <name>DT_DIR</name> <operator>&amp;&amp;</operator>
<name><name>dp</name><operator>-&gt;</operator><name>d_type</name></name> <operator>!=</operator> <name>DT_LNK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>enddir</name> <operator>+</operator> <name>namlen</name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name>expdir_end</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>enddir</name><index>[<expr><name>namlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>enddir</name><index>[<expr><name>namlen</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>expmeta</name><argument_list>(<argument><expr><name>enddir</name> <operator>+</operator> <name>namlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>endname</name></expr></argument>, <argument><expr><name>arglist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>atend</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>endname</name><index>[<expr><operator>-</operator><name>esc</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>esc</name></expr> ?</condition><then> <expr><name>CTLESC</name></expr> </then><else>: <expr><literal type="char">'/'</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>expsortcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>p2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s1</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>p1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s2</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><operator>)</operator><name>p2</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><call><name>strcoll</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>wchar_t</name></type>
<name>get_wc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>wchar_t</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>chrlen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>chrlen</name> <operator>=</operator> <call><name>mbtowc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>c</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>chrlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>chrlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>+=</operator> <name>chrlen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>c</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>int</name></type>
<name>match_charclass</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>wchar_t</name></type> <name>chr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nameend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wctype_t</name></type> <name>cclass</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nameend</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">":]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nameend</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>nameend</name> <operator>-</operator> <name>p</name><operator>)</operator> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof> <operator>||</operator>
<name>nameend</name> <operator>==</operator> <name>p</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>nameend</name> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>name</name><index>[<expr><name>nameend</name> <operator>-</operator> <name>p</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name>nameend</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>cclass</name> <operator>=</operator> <call><name>wctype</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cclass</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>iswctype</name><argument_list>(<argument><expr><name>chr</name></expr></argument>, <argument><expr><name>cclass</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>patmatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bt_p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bt_q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wchar_t</name></type> <name>wc</name></decl>, <decl><type ref="prev"/><name>wc2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>pattern</name></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bt_p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bt_q</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>backtrack</name>;</goto></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<case>case <expr><name>CTLESC</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name><operator>++</operator> <operator>!=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>backtrack</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'?'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>localeisutf8</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>wc</name> <operator>=</operator> <call><name>get_wc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>wc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>backtrack</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>q</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'*'</literal></expr>:</case>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>




<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>






<expr_stmt><expr><name>bt_p</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bt_q</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'['</literal></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>savep</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>saveq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>invert</name></decl>, <decl><type ref="prev"/><name>found</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wchar_t</name></type> <name>chr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>savep</name> <operator>=</operator> <name>p</name></expr><operator>,</operator> <expr><name>saveq</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
<expr_stmt><expr><name>invert</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>invert</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>localeisutf8</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>chr</name> <operator>=</operator> <call><name>get_wc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>chr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>backtrack</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>chr</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>q</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<do>do <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>savep</name></expr><operator>,</operator> <expr><name>q</name> <operator>=</operator> <name>saveq</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'['</literal></expr>;</expr_stmt>
<goto>goto <name>dft</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'['</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>found</name> <operator>|=</operator> <call><name>match_charclass</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>chr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>end</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CTLESC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>localeisutf8</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>wc</name> <operator>=</operator> <call><name>get_wc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>wc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>wc</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><name>c</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>CTLESC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>localeisutf8</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>wc2</name> <operator>=</operator> <call><name>get_wc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>wc2</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>wc2</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator><operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>( <expr><call><name>collate_range_cmp</name><argument_list>(<argument><expr><name>chr</name></expr></argument>, <argument><expr><name>wc</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <call><name>collate_range_cmp</name><argument_list>(<argument><expr><name>chr</name></expr></argument>, <argument><expr><name>wc2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>
)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>chr</name> <operator>==</operator> <name>wc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><name>found</name> <operator>==</operator> <name>invert</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>backtrack</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block>
<label><name>dft</name>:</label> <default>default:</default>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>q</name><operator>++</operator> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<label><name>backtrack</name>:</label>





<if_stmt><if>if <condition>(<expr><name>bt_p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bt_q</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>bt_q</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>bt_p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> <operator>=</operator> <name>bt_q</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>







<function><type><name>void</name></type>
<name>rmescapes</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>CTLESC</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>CTLQUOTEMARK</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>CTLQUOTEEND</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>q</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>CTLQUOTEMARK</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <name>CTLQUOTEEND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>CTLESC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>q</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>q</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>int</name></type>
<name>casematch</name><parameter_list>(<parameter><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>stackmark</name></name></type> <name>smark</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier></type><name>argbackq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>setstackmark</name><argument_list>(<argument><expr><operator>&amp;</operator><name>smark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>argbackq</name> <operator>=</operator> <name><name>pattern</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>backquote</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STARTSTACKSTR</name><argument_list>(<argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>argstr</name><argument_list>(<argument><expr><name><name>pattern</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>text</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argbackq</name></expr></argument>, <argument><expr><name>EXP_TILDE</name> <operator>|</operator> <name>EXP_CASE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STPUTC</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>grabstackstr</name><argument_list>(<argument><expr><name>expdest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>patmatch</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>popstackmark</name><argument_list>(<argument><expr><operator>&amp;</operator><name>smark</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>cvtnum</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>temp</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>neg</name> <init>= <expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>temp</name> <operator>+</operator> <literal type="number">31</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>temp</name><index>[<expr><literal type="number">31</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<do>do <block>{<block_content>
<expr_stmt><expr><operator>*</operator><operator>--</operator><name>p</name> <operator>=</operator> <name>num</name> <operator>%</operator> <literal type="number">10</literal> <operator>+</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>(</operator><name>num</name> <operator>/=</operator> <literal type="number">10</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><name>neg</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><operator>--</operator><name>p</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>temp</name> <operator>+</operator> <literal type="number">32</literal> <operator>-</operator> <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>wordexpcmd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>out1fmt</name><argument_list>(<argument><expr><literal type="string">"%08x"</literal></expr></argument>, <argument><expr><name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>out1fmt</name><argument_list>(<argument><expr><literal type="string">"%08x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>outbin</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>out1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><name>int</name></type>
<name>freebsd_wordexpcmd</name><parameter_list>(<parameter><decl><type><name>int</name> <name>argc</name></type> <name>__unused</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><name>argv</name></type> <name>__unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>arglist</name></name></type> <name>arglist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>args</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>protected</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>nextopt</name><argument_list>(<argument><expr><literal type="string">"f:p"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'f'</literal></expr>:</case>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>number</name><argument_list>(<argument><expr><name>shoptarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'p'</literal></expr>:</case>
<expr_stmt><expr><name>protected</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>argptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"wrong number of arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"missing fd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>INTOFF</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setinputfd</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>INTON</name></expr>;</expr_stmt>
<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>parsewordexp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>popfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>protected</name></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name>args</name></expr>;</init> <condition><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>n</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>backquote</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>outcslow</name><argument_list>(<argument><expr><literal type="char">'C'</literal></expr></argument>, <argument><expr><name>out1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"command substitution disabled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>outcslow</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>out1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>emptyarglist</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arglist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name>args</name></expr>;</init> <condition><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>n</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>expandarg</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arglist</name></expr></argument>, <argument><expr><name>EXP_FULL</name> <operator>|</operator> <name>EXP_TILDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arglist</name><operator>.</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>arglist</name><operator>.</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>out1fmt</name><argument_list>(<argument><expr><literal type="string">"%016x %016zx"</literal></expr></argument>, <argument><expr><name><name>arglist</name><operator>.</operator><name>count</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arglist</name><operator>.</operator><name>count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>outbin</name><argument_list>(<argument><expr><name><name>arglist</name><operator>.</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>arglist</name><operator>.</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>out1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
