<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/bin/sh/parser.c">

































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>lint</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static char sccsid[] = "@(#)parser.c 8.7 (Berkeley) 5/16/95";
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/cdefs.h&gt;</cpp:file></cpp:include>
<expr_stmt><expr><call><name>__FBSDID</name><argument_list>(<argument><expr><literal type="string">"$FreeBSD$"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"shell.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"expand.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"syntax.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"options.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"input.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"output.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"memalloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mystring.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"alias.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"show.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"exec.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_HISTORY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"myhistedit.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROMPTLEN</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHKALIAS</name></cpp:macro> <cpp:value>0x1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHKKWD</name></cpp:macro> <cpp:value>0x2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHKNL</name></cpp:macro> <cpp:value>0x4</cpp:value></cpp:define>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"token.h"</cpp:file></cpp:include>



<struct>struct <name>heredoc</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>heredoc</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>here</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eofmark</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>striptabs</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>parser_temp</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>parser_temp</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
}</block>;</struct>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>heredoc</name></name> <modifier>*</modifier></type><name>heredoclist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>doprompt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>needprompt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>lasttoken</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tokpushback</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>wordtext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>checkkwd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier></type><name>backquotelist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>redirnode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>heredoc</name></name> <modifier>*</modifier></type><name>heredoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>quoteflag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>startlinno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>funclinno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>parser_temp</name></name> <modifier>*</modifier></type><name>parser_temp</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOEOFMARK</name></cpp:macro> <cpp:value>((const char *)&amp;heredoclist)</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>list</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>andor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>pipeline</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>simplecmd</name><parameter_list>(<parameter><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>makename</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>makebinary</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n1</name></decl></parameter>, <parameter><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parsefname</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parseheredoc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>peektoken</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>readtoken</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>xxreadtoken</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>readtoken1</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>noexpand</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>consumetoken</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>synexpect</name><argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list> <name>__dead2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>synerror</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>)</argument_list> <name>__dead2</name></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setprompt</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>pgetc_linecont</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getusername</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>parser_temp_alloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>parser_temp</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>INTOFF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>ckmalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>parser_temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parser_temp</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>ckmalloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>INTON</name></expr>;</expr_stmt>
<return>return <expr><name><name>t</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>parser_temp_realloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>parser_temp</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>INTOFF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>parser_temp</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>!=</operator> <name><name>t</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"bug: parser_temp_realloc misused"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>ckrealloc</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>INTON</name></expr>;</expr_stmt>
<return>return <expr><name><name>t</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>parser_temp_free_upto</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>parser_temp</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>INTOFF</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>parser_temp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>done</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>parser_temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parser_temp</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>done</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>INTON</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"bug: parser_temp_free_upto misused"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>parser_temp_free_all</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>parser_temp</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>INTOFF</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>parser_temp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>parser_temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parser_temp</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>INTON</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type>
<name>parsecmd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>interact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>




<expr_stmt><expr><call><name>parser_temp_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>heredoclist</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tokpushback</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>doprompt</name> <operator>=</operator> <name>interact</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>doprompt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>needprompt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>readtoken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>TEOF</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NEOF</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>TNL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><call><name>list</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type>
<name>parsewordexp</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>first</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>pnext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>




<expr_stmt><expr><call><name>parser_temp_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>heredoclist</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tokpushback</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>doprompt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>needprompt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>pnext</name> <operator>=</operator> <operator>&amp;</operator><name>first</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>t</name> <operator>=</operator> <call><name>readtoken</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>TEOF</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <name>TWORD</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synexpect</name><argument_list>(<argument><expr><name>TWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>makename</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pnext</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pnext</name> <operator>=</operator> <operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><name>first</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type>
<name>list</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nlflag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>ntop</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>

<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKNL</name> <operator>|</operator> <name>CHKKWD</name> <operator>|</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nlflag</name> <operator>&amp;&amp;</operator> <name><name>tokendlist</name><index>[<expr><call><name>peektoken</name><argument_list>()</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ntop</name> <operator>=</operator> <name>n1</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <call><name>andor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>readtoken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <name>TBACKGND</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>n2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>n2</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NPIPE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>npipe</name><operator>.</operator><name>backgnd</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>n2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>n2</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NREDIR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NBACKGND</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>n3</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nredir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n3</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NBACKGND</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n3</name><operator>-&gt;</operator><name>nredir</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name>n2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n3</name><operator>-&gt;</operator><name>nredir</name><operator>.</operator><name>redirect</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <name>n3</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ntop</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ntop</name> <operator>=</operator> <name>n2</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>n1</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <call><name>makebinary</name><argument_list>(<argument><expr><name>NSEMI</name></expr></argument>, <argument><expr><name>ntop</name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ntop</name> <operator>=</operator> <name>n1</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>n3</name> <operator>=</operator> <call><name>makebinary</name><argument_list>(<argument><expr><name>NSEMI</name></expr></argument>, <argument><expr><name><name>n1</name><operator>-&gt;</operator><name>nbinary</name><operator>.</operator><name>ch2</name></name></expr></argument>, <argument><expr><name>n2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>nbinary</name><operator>.</operator><name>ch2</name></name> <operator>=</operator> <name>n3</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <name>n3</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TBACKGND</name></expr>:</case>
<case>case <expr><name>TSEMI</name></expr>:</case>
<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>readtoken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<case>case <expr><name>TNL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>tok</name> <operator>==</operator> <name>TNL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>parseheredoc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>nlflag</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ntop</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>tok</name> <operator>==</operator> <name>TEOF</name> <operator>&amp;&amp;</operator> <name>nlflag</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>parseheredoc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ntop</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKNL</name> <operator>|</operator> <name>CHKKWD</name> <operator>|</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nlflag</name> <operator>&amp;&amp;</operator> <name><name>tokendlist</name><index>[<expr><call><name>peektoken</name><argument_list>()</argument_list></call></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ntop</name></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>TEOF</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>heredoclist</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parseheredoc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>ntop</name></expr>;</return>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>nlflag</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synexpect</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>ntop</name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></for>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type>
<name>andor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>pipeline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>t</name> <operator>=</operator> <call><name>readtoken</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>TAND</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>NAND</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>TOR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>NOR</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>makebinary</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><call><name>pipeline</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type>
<name>pipeline</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pipenode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier></type><name>lp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>negate</name></decl>, <decl><type ref="prev"/><name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>negate</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKNL</name> <operator>|</operator> <name>CHKKWD</name> <operator>|</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"pipeline: entered\n"</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TNOT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>negate</name> <operator>=</operator> <operator>!</operator><name>negate</name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <call><name>command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TPIPE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>pipenode</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>npipe</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pipenode</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NPIPE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pipenode</name><operator>-&gt;</operator><name>npipe</name><operator>.</operator><name>backgnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <operator>(</operator>struct <name>nodelist</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nodelist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pipenode</name><operator>-&gt;</operator><name>npipe</name><operator>.</operator><name>cmdlist</name></name> <operator>=</operator> <name>lp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>n1</name></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>lp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <operator>(</operator>struct <name>nodelist</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nodelist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKNL</name> <operator>|</operator> <name>CHKKWD</name> <operator>|</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>readtoken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>TNOT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <call><name>pipeline</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <call><name>command</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>lp</name></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TPIPE</name></expr>)</condition>;</do>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <name>pipenode</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>negate</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nnot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NNOT</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>nnot</name><operator>.</operator><name>com</name></name> <operator>=</operator> <name>n1</name></expr>;</expr_stmt>
<return>return <expr><name>n2</name></expr>;</return>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<return>return <expr><name>n1</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type>
<name>command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>ap</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>app</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>cp</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>cpp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>redir</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>rpp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_subshell</name></decl>;</decl_stmt>

<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKNL</name> <operator>|</operator> <name>CHKKWD</name> <operator>|</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>is_subshell</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>redir</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rpp</name> <operator>=</operator> <operator>&amp;</operator><name>redir</name></expr>;</expr_stmt>


<while>while <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TREDIR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>rpp</name> <operator>=</operator> <name>n2</name> <operator>=</operator> <name>redirnode</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rpp</name> <operator>=</operator> <operator>&amp;</operator><name><name>n2</name><operator>-&gt;</operator><name>nfile</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parsefname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TIF</name></expr>:</case>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nif</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NIF</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>n1</name><operator>-&gt;</operator><name>nif</name><operator>.</operator><name>test</name></name> <operator>=</operator> <call><name>list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synexpect</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>consumetoken</name><argument_list>(<argument><expr><name>TTHEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>nif</name><operator>.</operator><name>ifpart</name></name> <operator>=</operator> <call><name>list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <name>n1</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TELIF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>nif</name><operator>.</operator><name>elsepart</name></name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nif</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <name><name>n2</name><operator>-&gt;</operator><name>nif</name><operator>.</operator><name>elsepart</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NIF</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>n2</name><operator>-&gt;</operator><name>nif</name><operator>.</operator><name>test</name></name> <operator>=</operator> <call><name>list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synexpect</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>consumetoken</name><argument_list>(<argument><expr><name>TTHEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>nif</name><operator>.</operator><name>ifpart</name></name> <operator>=</operator> <call><name>list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>lasttoken</name> <operator>==</operator> <name>TELSE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>nif</name><operator>.</operator><name>elsepart</name></name> <operator>=</operator> <call><name>list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>nif</name><operator>.</operator><name>elsepart</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>consumetoken</name><argument_list>(<argument><expr><name>TFI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKKWD</name> <operator>|</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>TWHILE</name></expr>:</case>
<case>case <expr><name>TUNTIL</name></expr>:</case>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>lasttoken</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n1</name> <operator>=</operator> <call><name>list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synexpect</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>consumetoken</name><argument_list>(<argument><expr><name>TDO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <call><name>makebinary</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>t</name> <operator>==</operator> <name>TWHILE</name><operator>)</operator></expr>?</condition><then> <expr><name>NWHILE</name></expr> </then><else>: <expr><name>NUNTIL</name></expr></else></ternary></expr></argument>, <argument><expr><name>n1</name></expr></argument>, <argument><expr><call><name>list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>consumetoken</name><argument_list>(<argument><expr><name>TDONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKKWD</name> <operator>|</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>TFOR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TWORD</name> <operator>||</operator> <name>quoteflag</name> <operator>||</operator> <operator>!</operator> <call><name>goodname</name><argument_list>(<argument><expr><name>wordtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Bad for loop variable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nfor</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NFOR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>nfor</name><operator>.</operator><name>var</name></name> <operator>=</operator> <name>wordtext</name></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKNL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TWORD</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>quoteflag</name> <operator>&amp;&amp;</operator>
<call><name>equal</name><argument_list>(<argument><expr><name>wordtext</name></expr></argument>, <argument><expr><literal type="string">"in"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>app</name> <operator>=</operator> <operator>&amp;</operator><name>ap</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TWORD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <call><name>makename</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>app</name> <operator>=</operator> <name>n2</name></expr>;</expr_stmt>
<expr_stmt><expr><name>app</name> <operator>=</operator> <operator>&amp;</operator><name><name>n2</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>app</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>nfor</name><operator>.</operator><name>args</name></name> <operator>=</operator> <name>ap</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lasttoken</name> <operator>==</operator> <name>TNL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>lasttoken</name> <operator>!=</operator> <name>TSEMI</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synexpect</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>argvars</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <init>= <expr><block>{
<expr><name>CTLVAR</name></expr>, <expr><name>VSNORMAL</name><operator>|</operator><name>VSQUOTE</name></expr>, <expr><literal type="char">'@'</literal></expr>, <expr><literal type="char">'='</literal></expr>, <expr><literal type="char">'\0'</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>narg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NARG</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>text</name></name> <operator>=</operator> <name>argvars</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>backquote</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>nfor</name><operator>.</operator><name>args</name></name> <operator>=</operator> <name>n2</name></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>lasttoken</name> <operator>!=</operator> <name>TSEMI</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKNL</name> <operator>|</operator> <name>CHKKWD</name> <operator>|</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>t</name> <operator>=</operator> <call><name>readtoken</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>TDO</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>TDONE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>TBEGIN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>TEND</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synexpect</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>nfor</name><operator>.</operator><name>body</name></name> <operator>=</operator> <call><name>list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>consumetoken</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKKWD</name> <operator>|</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>TCASE</name></expr>:</case>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ncase</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NCASE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>consumetoken</name><argument_list>(<argument><expr><name>TWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>ncase</name><operator>.</operator><name>expr</name></name> <operator>=</operator> <call><name>makename</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKNL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TWORD</name> <operator>||</operator> <operator>!</operator> <call><name>equal</name><argument_list>(<argument><expr><name>wordtext</name></expr></argument>, <argument><expr><literal type="string">"in"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"expecting \"in\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cpp</name> <operator>=</operator> <operator>&amp;</operator><name><name>n1</name><operator>-&gt;</operator><name>ncase</name><operator>.</operator><name>cases</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKNL</name> <operator>|</operator> <name>CHKKWD</name></expr><operator>,</operator> <expr><call><name>readtoken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>lasttoken</name> <operator>!=</operator> <name>TESAC</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>cpp</name> <operator>=</operator> <name>cp</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nclist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NCLIST</name></expr>;</expr_stmt>
<expr_stmt><expr><name>app</name> <operator>=</operator> <operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>nclist</name><operator>.</operator><name>pattern</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lasttoken</name> <operator>==</operator> <name>TLP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>readtoken</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>app</name> <operator>=</operator> <name>ap</name> <operator>=</operator> <call><name>makename</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKNL</name> <operator>|</operator> <name>CHKKWD</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TPIPE</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>app</name> <operator>=</operator> <operator>&amp;</operator><name><name>ap</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>readtoken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>ap</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lasttoken</name> <operator>!=</operator> <name>TRP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synexpect</name><argument_list>(<argument><expr><name>TRP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>nclist</name><operator>.</operator><name>body</name></name> <operator>=</operator> <call><name>list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKNL</name> <operator>|</operator> <name>CHKKWD</name> <operator>|</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>t</name> <operator>=</operator> <call><name>readtoken</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>TESAC</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>TENDCASE</name></expr>)</condition><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>t</name> <operator>==</operator> <name>TFALLTHRU</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NCLISTFALLTHRU</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synexpect</name><argument_list>(<argument><expr><name>TENDCASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKNL</name> <operator>|</operator> <name>CHKKWD</name></expr><operator>,</operator> <expr><call><name>readtoken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cpp</name> <operator>=</operator> <operator>&amp;</operator><name><name>cp</name><operator>-&gt;</operator><name>nclist</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><operator>*</operator><name>cpp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKKWD</name> <operator>|</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>TLP</name></expr>:</case>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nredir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NSUBSHELL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>nredir</name><operator>.</operator><name>n</name></name> <operator>=</operator> <call><name>list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>nredir</name><operator>.</operator><name>redirect</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>consumetoken</name><argument_list>(<argument><expr><name>TRP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKKWD</name> <operator>|</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
<expr_stmt><expr><name>is_subshell</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>TBEGIN</name></expr>:</case>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <call><name>list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>consumetoken</name><argument_list>(<argument><expr><name>TEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>CHKKWD</name> <operator>|</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>TBACKGND</name></expr>:</case>
<case>case <expr><name>TSEMI</name></expr>:</case>
<case>case <expr><name>TAND</name></expr>:</case>
<case>case <expr><name>TOR</name></expr>:</case>
<case>case <expr><name>TPIPE</name></expr>:</case>
<case>case <expr><name>TENDCASE</name></expr>:</case>
<case>case <expr><name>TFALLTHRU</name></expr>:</case>
<case>case <expr><name>TEOF</name></expr>:</case>
<case>case <expr><name>TNL</name></expr>:</case>
<case>case <expr><name>TRP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>redir</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synexpect</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<case>case <expr><name>TWORD</name></expr>:</case>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <call><name>simplecmd</name><argument_list>(<argument><expr><name>rpp</name></expr></argument>, <argument><expr><name>redir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>n1</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>synexpect</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>


<while>while <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TREDIR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>rpp</name> <operator>=</operator> <name>n2</name> <operator>=</operator> <name>redirnode</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rpp</name> <operator>=</operator> <operator>&amp;</operator><name><name>n2</name><operator>-&gt;</operator><name>nfile</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parsefname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>rpp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>redir</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_subshell</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n2</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nredir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NREDIR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n2</name><operator>-&gt;</operator><name>nredir</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name>n1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n1</name> <operator>=</operator> <name>n2</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>n1</name><operator>-&gt;</operator><name>nredir</name><operator>.</operator><name>redirect</name></name> <operator>=</operator> <name>redir</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>n1</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type>
<name>simplecmd</name><parameter_list>(<parameter><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>rpp</name></decl></parameter>, <parameter><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>redir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>args</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>app</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>orig_rpp</name> <init>= <expr><name>rpp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>special</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>savecheckkwd</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>redir</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rpp</name> <operator>=</operator> <operator>&amp;</operator><name>redir</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>app</name> <operator>=</operator> <operator>&amp;</operator><name>args</name></expr>;</expr_stmt>





<expr_stmt><expr><name>orig_rpp</name> <operator>=</operator> <name>rpp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>savecheckkwd</name> <operator>=</operator> <name>CHKALIAS</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <name>savecheckkwd</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call> <operator>==</operator> <name>TWORD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>makename</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>app</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>app</name> <operator>=</operator> <operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>savecheckkwd</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isassignment</name><argument_list>(<argument><expr><name>wordtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>savecheckkwd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lasttoken</name> <operator>==</operator> <name>TREDIR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>rpp</name> <operator>=</operator> <name>n</name> <operator>=</operator> <name>redirnode</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rpp</name> <operator>=</operator> <operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>nfile</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parsefname</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>lasttoken</name> <operator>==</operator> <name>TLP</name> <operator>&amp;&amp;</operator> <name>app</name> <operator>==</operator> <operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>next</name></name>
<operator>&amp;&amp;</operator> <name>rpp</name> <operator>==</operator> <name>orig_rpp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>consumetoken</name><argument_list>(<argument><expr><name>TRP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>funclinno</name> <operator>=</operator> <name>plinno</name></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>noexpand</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>text</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name>quoteflag</name> <operator>||</operator>
<call><name>strchr</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>text</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"!%*+-=?@}~"</literal></expr></argument>,
<argument><expr><name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>text</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>text</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Bad function name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rmescapes</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>find_builtin</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>text</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>special</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name>special</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Cannot override a special builtin with a function"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NDEFUN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>next</name></name> <operator>=</operator> <call><name>command</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>funclinno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>app</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>rpp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>ncmd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NCMD</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>ncmd</name><operator>.</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>ncmd</name><operator>.</operator><name>redirect</name></name> <operator>=</operator> <name>redir</name></expr>;</expr_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type>
<name>makename</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>narg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NARG</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>text</name></name> <operator>=</operator> <name>wordtext</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>narg</name><operator>.</operator><name>backquote</name></name> <operator>=</operator> <name>backquotelist</name></expr>;</expr_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>union</name> <name>node</name></name> <modifier>*</modifier></type>
<name>makebinary</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n1</name></decl></parameter>, <parameter><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nbinary</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>nbinary</name><operator>.</operator><name>ch1</name></name> <operator>=</operator> <name>n1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>nbinary</name><operator>.</operator><name>ch2</name></name> <operator>=</operator> <name>n2</name></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>n</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>forcealias</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>checkkwd</name> <operator>|=</operator> <name>CHKALIAS</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>fixredir</name><parameter_list>(<parameter><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Fix redir %s %d\n"</literal><operator>,</operator> <name>text</name><operator>,</operator> <name>err</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>ndup</name><operator>.</operator><name>vname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_digit</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>text</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>ndup</name><operator>.</operator><name>dupfd</name></name> <operator>=</operator> <call><name>digit_val</name><argument_list>(<argument><expr><name><name>text</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>text</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>text</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>ndup</name><operator>.</operator><name>dupfd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Bad fd number"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>ndup</name><operator>.</operator><name>vname</name></name> <operator>=</operator> <call><name>makename</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>parsefname</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name>redirnode</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>consumetoken</name><argument_list>(<argument><expr><name>TWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NHERE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>heredoc</name></name> <modifier>*</modifier></type><name>here</name> <init>= <expr><name>heredoc</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>heredoc</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>quoteflag</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NXHERE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"Here document %d\n"</literal><operator>,</operator> <name><name>n</name><operator>-&gt;</operator><name>type</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>here</name><operator>-&gt;</operator><name>striptabs</name></name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>wordtext</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>wordtext</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>noexpand</name><argument_list>(<argument><expr><name>wordtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Illegal eof marker for &lt;&lt; redirection"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>rmescapes</name><argument_list>(<argument><expr><name>wordtext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>here</name><operator>-&gt;</operator><name>eofmark</name></name> <operator>=</operator> <name>wordtext</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>here</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>heredoclist</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>heredoclist</name> <operator>=</operator> <name>here</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>heredoclist</name></expr> ;</init> <condition><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr> ;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>here</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NTOFD</name> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NFROMFD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fixredir</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>wordtext</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>nfile</name><operator>.</operator><name>fname</name></name> <operator>=</operator> <call><name>makename</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>parseheredoc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>heredoc</name></name> <modifier>*</modifier></type><name>here</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>heredoclist</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>here</name> <operator>=</operator> <name>heredoclist</name></expr>;</expr_stmt>
<expr_stmt><expr><name>heredoclist</name> <operator>=</operator> <name><name>here</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>needprompt</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>needprompt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>readtoken1</name><argument_list>(<argument><expr><call><name>pgetc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name><name>here</name><operator>-&gt;</operator><name>here</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NHERE</name></expr>?</condition><then> <expr><name>SQSYNTAX</name></expr> </then><else>: <expr><name>DQSYNTAX</name></expr></else></ternary></expr></argument>,
<argument><expr><name><name>here</name><operator>-&gt;</operator><name>eofmark</name></name></expr></argument>, <argument><expr><name><name>here</name><operator>-&gt;</operator><name>striptabs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>makename</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>here</name><operator>-&gt;</operator><name>here</name><operator>-&gt;</operator><name>nhere</name><operator>.</operator><name>doc</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>peektoken</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>readtoken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tokpushback</name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>t</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>readtoken</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>alias</name></name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>alreadyseen</name> <init>= <expr><name>tokpushback</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>top</name>:</label>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>xxreadtoken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>checkkwd</name> <operator>&amp;</operator> <name>CHKNL</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name>t</name> <operator>==</operator> <name>TNL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>parseheredoc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>xxreadtoken</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <name>TWORD</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>quoteflag</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>checkkwd</name> <operator>&amp;</operator> <name>CHKKWD</name></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>pp</name> <operator>=</operator> <name>parsekwd</name></expr>;</init> <condition><expr><operator>*</operator><name>pp</name></expr>;</condition> <incr><expr><name>pp</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>pp</name> <operator>==</operator> <operator>*</operator><name>wordtext</name> <operator>&amp;&amp;</operator> <call><name>equal</name><argument_list>(<argument><expr><operator>*</operator><name>pp</name></expr></argument>, <argument><expr><name>wordtext</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>lasttoken</name> <operator>=</operator> <name>t</name> <operator>=</operator> <name>pp</name> <operator>-</operator> <name>parsekwd</name> <operator>+</operator> <name>KWDOFFSET</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"keyword %s recognized\n"</literal><operator>,</operator> <name><name>tokname</name><index>[<expr><name>t</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>out</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>checkkwd</name> <operator>&amp;</operator> <name>CHKALIAS</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>ap</name> <operator>=</operator> <call><name>lookupalias</name><argument_list>(<argument><expr><name>wordtext</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pushstring</name><argument_list>(<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ap</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>top</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<label><name>out</name>:</label>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <name>TNOT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>checkkwd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>alreadyseen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"token %s %s\n"</literal><operator>,</operator> <name><name>tokname</name><index>[<expr><name>t</name></expr>]</index></name><operator>,</operator> <ternary><condition><expr><name>t</name> <operator>==</operator> <name>TWORD</name></expr> ?</condition><then> <expr><name>wordtext</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>TRACE</name><argument_list>(<argument><expr><operator>(</operator><literal type="string">"reread token %s %s\n"</literal><operator>,</operator> <name><name>tokname</name><index>[<expr><name>t</name></expr>]</index></name><operator>,</operator> <ternary><condition><expr><name>t</name> <operator>==</operator> <name>TWORD</name></expr> ?</condition><then> <expr><name>wordtext</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><operator>(</operator><name>t</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>




















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN</name><parameter_list>(<parameter><type><name>token</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>return lasttoken = token</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>xxreadtoken</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tokpushback</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>tokpushback</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>lasttoken</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>needprompt</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>needprompt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>startlinno</name> <operator>=</operator> <name>plinno</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_macro</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">' '</literal></expr>:</case> <case>case <expr><literal type="char">'\t'</literal></expr>:</case>
<continue>continue;</continue>
<case>case <expr><literal type="char">'#'</literal></expr>:</case>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>PEOF</name></expr>)</condition><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></while>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>pgetc</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>startlinno</name> <operator>=</operator> <operator>++</operator><name>plinno</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>doprompt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<default>default:</default>
<return>return <expr><call><name>readtoken1</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>BASESYNTAX</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><literal type="char">'\n'</literal></expr>:</case>
<expr_stmt><expr><name>plinno</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>needprompt</name> <operator>=</operator> <name>doprompt</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>TNL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><name>PEOF</name></expr>:</case>
<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>TEOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><literal type="char">'&amp;'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>pgetc_linecont</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>TAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>TBACKGND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><literal type="char">'|'</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>pgetc_linecont</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'|'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>TOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>TPIPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><literal type="char">';'</literal></expr>:</case>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>TENDCASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>TFALLTHRU</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>TSEMI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><literal type="char">'('</literal></expr>:</case>
<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>TLP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><literal type="char">')'</literal></expr>:</case>
<expr_stmt><expr><call><name>RETURN</name><argument_list>(<argument><expr><name>TRP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
</block_content>}</block></for>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>RETURN</name></cpp:undef>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXNEST_static</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<struct>struct <name>tokenstate</name>
<block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>syntax</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>parenlevel</name></decl>;</decl_stmt>
<enum>enum <name>tokenstate_category</name>
<block>{
<decl><name>TSTATE_TOP</name></decl>,
<decl><name>TSTATE_VAR_OLD</name></decl>,
<decl><name>TSTATE_VAR_NEW</name></decl>,
<decl><name>TSTATE_ARITH</name></decl>
}</block> <decl><name>category</name></decl>;</enum>
}</block>;</struct>









<function><type><specifier>static</specifier> <name>int</name></type>
<name>checkend</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eofmark</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>striptabs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>striptabs</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <operator>*</operator><name>eofmark</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>q</name> <operator>=</operator> <name>eofmark</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>c2</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call></expr><operator>,</operator> <expr><operator>*</operator><name>q</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name>c2</name> <operator>==</operator> <operator>*</operator><name>q</name></expr>;</condition> <incr><expr><name>q</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c2</name> <operator>==</operator> <name>PEOF</name> <operator>||</operator> <name>c2</name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>*</operator><name>q</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>PEOF</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>plinno</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>needprompt</name> <operator>=</operator> <name>doprompt</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pushstring</name><argument_list>(<argument><expr><name>eofmark</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>q</name> <operator>-</operator> <operator>(</operator><name>eofmark</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>eofmark</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>PEOF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>plinno</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>needprompt</name> <operator>=</operator> <name>doprompt</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>(</operator><name>c</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type>
<name>parseredir</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name>fd</name> <init>= <expr><operator>*</operator><name>out</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>

<expr_stmt><expr><name>np</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nfile</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>nfile</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NAPPEND</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NTOFD</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'|'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NCLOBBER</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NTO</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>nfile</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nfile</name></expr></argument>)</argument_list></sizeof> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>nhere</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>np</name> <operator>=</operator> <operator>(</operator>union <name>node</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nhere</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>nfile</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NHERE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>heredoc</name> <operator>=</operator> <operator>(</operator>struct <name>heredoc</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>heredoc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>heredoc</name><operator>-&gt;</operator><name>here</name></name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>heredoc</name><operator>-&gt;</operator><name>striptabs</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>heredoc</name><operator>-&gt;</operator><name>striptabs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NFROMFD</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NFROMTO</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NFROM</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>nfile</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <call><name>digit_val</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>redirnode</name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>parsebackq</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>pbqlist</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>oldstyle</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dblquote</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>quoted</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>nlpp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>jmploc</name></name></type> <name>jmploc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>jmploc</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>savehandler</name> <init>= <expr><name>handler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>savelen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>saveprompt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bq_startlinno</name> <init>= <expr><name>plinno</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>ostr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>parsefile</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>savetopfile</name> <init>= <expr><call><name>getcurrentfile</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>heredoc</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>saveheredoclist</name> <init>= <expr><name>heredoclist</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>heredoc</name></name> <modifier>*</modifier></type><name>here</name></decl>;</decl_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>setjmp</name><argument_list>(<argument><expr><name><name>jmploc</name><operator>.</operator><name>loc</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>popfilesupto</name><argument_list>(<argument><expr><name>savetopfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ostr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>heredoclist</name> <operator>=</operator> <name>saveheredoclist</name></expr>;</expr_stmt>
<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>savehandler</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>exception</name> <operator>==</operator> <name>EXERROR</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>startlinno</name> <operator>=</operator> <name>bq_startlinno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Error in command substitution"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name><name>handler</name><operator>-&gt;</operator><name>loc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>INTOFF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>savelen</name> <operator>=</operator> <name>out</name> <operator>-</operator> <call><name>stackblock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>savelen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>ckmalloc</name><argument_list>(<argument><expr><name>savelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>stackblock</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>savelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>handler</name> <operator>=</operator> <operator>&amp;</operator><name>jmploc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>heredoclist</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>INTON</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>oldstyle</name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>olen</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>STARTSTACKSTR</name><argument_list>(<argument><expr><name>oout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>needprompt</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>needprompt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>CHECKSTRSPACE</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>oout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'`'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'`'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'$'</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>dblquote</name> <operator>||</operator> <name>c</name> <operator>!=</operator> <literal type="char">'"'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>oout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><literal type="char">'\n'</literal></expr>:</case>
<expr_stmt><expr><name>plinno</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>needprompt</name> <operator>=</operator> <name>doprompt</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>PEOF</name></expr>:</case>
<expr_stmt><expr><name>startlinno</name> <operator>=</operator> <name>plinno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"EOF in backquote substitution"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>oout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>oout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>olen</name> <operator>=</operator> <name>oout</name> <operator>-</operator> <call><name>stackblock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>INTOFF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ostr</name> <operator>=</operator> <call><name>ckmalloc</name><argument_list>(<argument><expr><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ostr</name></expr></argument>, <argument><expr><call><name>stackblock</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setinputstring</name><argument_list>(<argument><expr><name>ostr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>INTON</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nlpp</name> <operator>=</operator> <name>pbqlist</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>nlpp</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>nlpp</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>nlpp</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><operator>*</operator><name>nlpp</name> <operator>=</operator> <operator>(</operator>struct <name>nodelist</name> <operator>*</operator><operator>)</operator><call><name>stalloc</name><argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>nodelist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>nlpp</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>oldstyle</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>saveprompt</name> <operator>=</operator> <name>doprompt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>doprompt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>oldstyle</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>peektoken</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TEOF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synexpect</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>doprompt</name> <operator>=</operator> <name>saveprompt</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>consumetoken</name><argument_list>(<argument><expr><name>TRP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>nlpp</name><operator>)</operator><operator>-&gt;</operator><name>n</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>oldstyle</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><call><name>popfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tokpushback</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>STARTSTACKSTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECKSTRSPACE</name><argument_list>(<argument><expr><name>savelen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>INTOFF</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>savelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STADJUST</name><argument_list>(<argument><expr><name>savelen</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ostr</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>ckfree</name><argument_list>(<argument><expr><name>ostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ostr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>here</name> <operator>=</operator> <name>saveheredoclist</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>here</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name><name>here</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>here</name> <operator>=</operator> <name><name>here</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name><name>here</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>heredoclist</name></expr>;</expr_stmt>
<expr_stmt><expr><name>heredoclist</name> <operator>=</operator> <name>saveheredoclist</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>savehandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>INTON</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>quoted</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLBACKQ</name> <operator>|</operator> <name>CTLQUOTE</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLBACKQ</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>readcstyleesc</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>vc</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">'\0'</literal></expr>:</case>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Unterminated quoted string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<case>case <expr><literal type="char">'\n'</literal></expr>:</case>
<expr_stmt><expr><name>plinno</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>doprompt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return <expr><name>out</name></expr>;</return>
<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
<case>case <expr><literal type="char">'\''</literal></expr>:</case>
<case>case <expr><literal type="char">'"'</literal></expr>:</case>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'a'</literal></expr>:</case> <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="char">'\a'</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'b'</literal></expr>:</case> <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'e'</literal></expr>:</case> <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="char">'\033'</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'f'</literal></expr>:</case> <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'n'</literal></expr>:</case> <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'r'</literal></expr>:</case> <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'t'</literal></expr>:</case> <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'v'</literal></expr>:</case> <expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="char">'\v'</literal></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><literal type="char">'x'</literal></expr>:</case>
<expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'F'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'0'</literal></expr>:</case> <case>case <expr><literal type="char">'1'</literal></expr>:</case> <case>case <expr><literal type="char">'2'</literal></expr>:</case> <case>case <expr><literal type="char">'3'</literal></expr>:</case>
<case>case <expr><literal type="char">'4'</literal></expr>:</case> <case>case <expr><literal type="char">'5'</literal></expr>:</case> <case>case <expr><literal type="char">'6'</literal></expr>:</case> <case>case <expr><literal type="char">'7'</literal></expr>:</case>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'7'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>&lt;&lt;=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>+=</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'7'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>v</name> <operator>&lt;&lt;=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>+=</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'c'</literal></expr>:</case>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>c</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0x3f</literal> <operator>||</operator> <name>c</name></expr></argument> &gt;</argument_list></name> <literal type="number">0x7a</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="number">0x60</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Bad escape sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <call><name>pgetc</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Bad escape sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">127</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <name>c</name> <operator>&amp;</operator> <literal type="number">0x1f</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'u'</literal></expr>:</case>
<case>case <expr><literal type="char">'U'</literal></expr>:</case>
<expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><name>c</name> <operator>==</operator> <literal type="char">'U'</literal></expr> ?</condition><then> <expr><literal type="number">8</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'F'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'A'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>v</name> <operator>&lt;&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <name>c</name> <operator>-</operator> <literal type="char">'a'</literal> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Bad escape sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>v</name> <operator>&gt;=</operator> <literal type="number">0xd800</literal> <operator>&amp;&amp;</operator> <name>v</name> <operator>&lt;=</operator> <literal type="number">0xdfff</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Bad escape sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>initial_localeisutf8</name> <operator>&amp;&amp;</operator> <name>v</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>CHECKSTRSPACE</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;=</operator> <literal type="number">0x7ff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="number">0xc0</literal> <operator>|</operator> <name>v</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>v</name> <operator>&lt;=</operator> <literal type="number">0xffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="number">0xe0</literal> <operator>|</operator> <name>v</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>v</name> <operator>&lt;=</operator> <literal type="number">0x10ffff</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="number">0xf0</literal> <operator>|</operator> <name>v</name> <operator>&gt;&gt;</operator> <literal type="number">18</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><operator>(</operator><name>v</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="number">0x80</literal> <operator>|</operator> <operator>(</operator><name>v</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>v</name> <operator>=</operator> <literal type="char">'?'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Bad escape sequence"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><name>vc</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator><name>v</name></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>vc</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="char">'\''</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>PEOF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Unterminated quoted string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>plinno</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>doprompt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>SQSYNTAX</name><index>[<expr><name>vc</name></expr>]</index></name> <operator>==</operator> <name>CCTL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLESC</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>vc</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>














<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSESUB</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{goto parsesub; parsesub_return:;}</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARSEARITH</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{goto parsearith; parsearith_return:;}</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>readtoken1</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>firstc</name></decl></parameter>, <parameter><decl><type><name>char</name> <specifier>const</specifier> <modifier>*</modifier></type><name>initialsyntax</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>eofmark</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>striptabs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name>firstc</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>nodelist</name></name> <modifier>*</modifier></type><name>bqlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>quotef</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newvarnest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>synentry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tokenstate</name></name></type> <name><name>state_static</name><index>[<expr><name>MAXNEST_static</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>maxnest</name> <init>= <expr><name>MAXNEST_static</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>tokenstate</name></name> <modifier>*</modifier></type><name>state</name> <init>= <expr><name>state_static</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sqiscstyle</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>startlinno</name> <operator>=</operator> <name>plinno</name></expr>;</expr_stmt>
<expr_stmt><expr><name>quotef</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bqlist</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>newvarnest</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>level</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>=</operator> <name>initialsyntax</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>parenlevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>category</name> <operator>=</operator> <name>TSTATE_TOP</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STARTSTACKSTR</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>loop</name>:</label> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>eofmark</name> <operator>&amp;&amp;</operator> <name>eofmark</name> <operator>!=</operator> <name>NOEOFMARK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>checkend</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>eofmark</name></expr></argument>, <argument><expr><name>striptabs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>CHECKSTRSPACE</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>synentry</name> <operator>=</operator> <name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name><name>syntax</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name>synentry</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CNL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>endword</name>;</goto></block_content></block></if></if_stmt>

<case>case <expr><name>CQNL</name></expr>:</case>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>plinno</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>doprompt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>loop</name>;</goto>
<case>case <expr><name>CSBACK</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>sqiscstyle</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>readcstyleesc</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<case>case <expr><name>CWORD</name></expr>:</case>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CCTL</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>eofmark</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>initialsyntax</name> <operator>!=</operator> <name>SQSYNTAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLESC</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CBACK</name></expr>:</case>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>PEOF</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>plinno</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>doprompt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>DQSYNTAX</name> <operator>&amp;&amp;</operator>
<name>c</name> <operator>!=</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'`'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>c</name> <operator>!=</operator> <literal type="char">'"'</literal> <operator>||</operator> <operator>(</operator><name>eofmark</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<name>newvarnest</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>c</name> <operator>!=</operator> <literal type="char">'}'</literal> <operator>||</operator> <name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>category</name> <operator>!=</operator> <name>TSTATE_VAR_OLD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eofmark</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<name>newvarnest</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>BASESYNTAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLQUOTEMARK</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>SQSYNTAX</name><index>[<expr><name>c</name></expr>]</index></name> <operator>==</operator> <name>CCTL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLESC</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>eofmark</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
<name>newvarnest</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>BASESYNTAX</name> <operator>&amp;&amp;</operator>
<name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>category</name> <operator>==</operator> <name>TSTATE_VAR_OLD</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLQUOTEEND</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>quotef</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>CSQUOTE</name></expr>:</case>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLQUOTEMARK</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>=</operator> <name>SQSYNTAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sqiscstyle</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CDQUOTE</name></expr>:</case>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLQUOTEMARK</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>=</operator> <name>DQSYNTAX</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CENDQUOTE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>eofmark</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>newvarnest</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>category</name> <operator>==</operator> <name>TSTATE_VAR_OLD</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLQUOTEEND</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>=</operator> <name>BASESYNTAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name>quotef</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>CVAR</name></expr>:</case>
<expr_stmt><expr><call><name>PARSESUB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CENDVAR</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>category</name> <operator>==</operator> <name>TSTATE_VAR_OLD</name> <operator>&amp;&amp;</operator>
<name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator>
<name><name>state</name><index>[<expr><name>level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>syntax</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>category</name> <operator>==</operator> <name>TSTATE_VAR_NEW</name> <operator>&amp;&amp;</operator>
<name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>BASESYNTAX</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>category</name> <operator>==</operator> <name>TSTATE_VAR_NEW</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newvarnest</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLENDVAR</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>CLP</name></expr>:</case>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>parenlevel</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CRP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>parenlevel</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>parenlevel</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pgetc_linecont</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>category</name> <operator>==</operator> <name>TSTATE_ARITH</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>level</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLENDARI</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="char">')'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>CBQUOTE</name></expr>:</case>
<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>parsebackq</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bqlist</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
<argument><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>DQSYNTAX</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>eofmark</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>newvarnest</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>,
<argument><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>DQSYNTAX</name> <operator>||</operator> <name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>ARISYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CEOF</name></expr>:</case>
<goto>goto <name>endword</name>;</goto>
<case>case <expr><name>CIGN</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>endword</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></switch>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_macro</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block>
<label><name>endword</name>:</label>
<if_stmt><if>if <condition>(<expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>ARISYNTAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Missing '))'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>!=</operator> <name>BASESYNTAX</name> <operator>&amp;&amp;</operator> <name>eofmark</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Unterminated quoted string"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>category</name> <operator>==</operator> <name>TSTATE_VAR_OLD</name> <operator>||</operator>
<name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>category</name> <operator>==</operator> <name>TSTATE_VAR_NEW</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>startlinno</name> <operator>=</operator> <name>plinno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Missing '}'"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>state</name> <operator>!=</operator> <name>state_static</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>parser_temp_free_upto</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>out</name> <operator>-</operator> <call><name>stackblock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>stackblock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>eofmark</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>==</operator> <literal type="char">'&gt;'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'&lt;'</literal><operator>)</operator>
<operator>&amp;&amp;</operator> <name>quotef</name> <operator>==</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <name>len</name> <operator>&lt;=</operator> <literal type="number">2</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>out</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <call><name>is_digit</name><argument_list>(<argument><expr><operator>*</operator><name>out</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>parseredir</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>lasttoken</name> <operator>=</operator> <name>TREDIR</name></expr>;</return>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>quoteflag</name> <operator>=</operator> <name>quotef</name></expr>;</expr_stmt>
<expr_stmt><expr><name>backquotelist</name> <operator>=</operator> <name>bqlist</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>grabstackblock</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wordtext</name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
<return>return <expr><name>lasttoken</name> <operator>=</operator> <name>TWORD</name></expr>;</return>








<label><name>parsesub</name>:</label> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>subtype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>typeloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>types</name><index>[]</index></name> <init>= <expr><literal type="string">"}-+?="</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>linno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pgetc_linecont</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PARSEARITH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>parsebackq</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bqlist</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
<argument><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>DQSYNTAX</name> <operator>&amp;&amp;</operator>
<operator>(</operator><name>eofmark</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>newvarnest</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>,
<argument><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>DQSYNTAX</name> <operator>||</operator>
<name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>ARISYNTAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>||</operator> <call><name>is_name</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_special</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLVAR</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>typeloc</name> <operator>=</operator> <name>out</name> <operator>-</operator> <call><name>stackblock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>VSNORMAL</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>subtype</name> <operator>=</operator> <name>VSNORMAL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<label><name>varname</name>:</label>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_eof</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_name</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><call><name>STPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>is_eof</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>is_in_name</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator>
<call><name>strncmp</name><argument_list>(<argument><expr><name>out</name> <operator>-</operator> <name>length</name></expr></argument>, <argument><expr><literal type="string">"LINENO"</literal></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>STADJUST</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">6</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CHECKSTRSPACE</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>linno</name> <operator>=</operator> <name>plinno</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>funclinno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>linno</name> <operator>-=</operator> <name>funclinno</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>linno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>out</name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>VSLINENO</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_digit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>subtype</name> <operator>!=</operator> <name>VSNORMAL</name></expr>)</condition> <block>{<block_content>
<do>do <block>{<block_content>
<expr_stmt><expr><call><name>STPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>is_digit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_special</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>subtype</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c1</name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>subtype</name> <operator>=</operator> <name>VSLENGTH</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator>
<name>c</name> <operator>!=</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'%'</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>varname</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>!=</operator> <literal type="char">'}'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>c1</name></expr>;</expr_stmt>
<goto>goto <name>varname</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>c1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c1</name> <operator>=</operator> <literal type="char">'#'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>subtype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c1</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>subtype</name> <operator>=</operator> <name>VSERROR</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <name>PEOF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Unexpected end of line in substitution"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>BASESYNTAX</name><index>[<expr><name>c</name></expr>]</index></name> <operator>!=</operator> <name>CCTL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>subtype</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="char">':'</literal></expr>:</case>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>VSNUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<default>default:</default>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <name>PEOF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><literal type="string">"Unexpected end of line in substitution"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <name>VSNUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STPUTC</name><argument_list>(<argument><expr><literal type="char">':'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>BASESYNTAX</name><index>[<expr><name>c</name></expr>]</index></name> <operator>!=</operator> <name>CCTL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STPUTC</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>subtype</name> <operator>=</operator> <name>VSERROR</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>subtype</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>types</name> <operator>+</operator> <name>VSNORMAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><literal type="char">'%'</literal></expr>:</case>
<case>case <expr><literal type="char">'#'</literal></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cc</name> <init>= <expr><name>c</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>subtype</name> <operator>=</operator> <ternary><condition><expr><name>c</name> <operator>==</operator> <literal type="char">'#'</literal></expr> ?</condition><then> <expr><name>VSTRIMLEFT</name></expr> </then><else>:
<expr><name>VSTRIMRIGHT</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc_linecont</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>cc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>subtype</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
</block_content>}</block>
</block_content>}</block></switch>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>subtype</name> <operator>!=</operator> <name>VSERROR</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>subtype</name> <operator>==</operator> <name>VSLENGTH</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>subtype</name> <operator>=</operator> <name>VSERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>STPUTC</name><argument_list>(<argument><expr><literal type="char">'='</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>DQSYNTAX</name> <operator>||</operator>
<name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>ARISYNTAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>VSQUOTE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>stackblock</name><argument_list>()</argument_list></call> <operator>+</operator> <name>typeloc</name><operator>)</operator> <operator>=</operator> <name>subtype</name> <operator>|</operator> <name>flags</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>subtype</name> <operator>!=</operator> <name>VSNORMAL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>level</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>maxnest</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>maxnest</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>state_static</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>parser_temp_alloc</name><argument_list>(
<argument><expr><name>maxnest</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>state_static</name></expr></argument>,
<argument><expr><name>MAXNEST_static</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>parser_temp_realloc</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
<argument><expr><name>maxnest</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>parenlevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>subtype</name> <operator>==</operator> <name>VSMINUS</name> <operator>||</operator> <name>subtype</name> <operator>==</operator> <name>VSPLUS</name> <operator>||</operator>
<name>subtype</name> <operator>==</operator> <name>VSQUESTION</name> <operator>||</operator> <name>subtype</name> <operator>==</operator> <name>VSASSIGN</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>=</operator> <name><name>state</name><index>[<expr><name>level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>syntax</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>category</name> <operator>=</operator> <name>TSTATE_VAR_OLD</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>






<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>=</operator> <name>BASESYNTAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>category</name> <operator>=</operator> <name>TSTATE_VAR_NEW</name></expr>;</expr_stmt>
<expr_stmt><expr><name>newvarnest</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\''</literal> <operator>&amp;&amp;</operator> <name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>BASESYNTAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLQUOTEMARK</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>=</operator> <name>SQSYNTAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sqiscstyle</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="char">'$'</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<goto>goto <name>parsesub_return</name>;</goto>
</block_content>}</block>





<label><name>parsearith</name>:</label> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>level</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>maxnest</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>maxnest</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>state_static</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>parser_temp_alloc</name><argument_list>(
<argument><expr><name>maxnest</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>state_static</name></expr></argument>,
<argument><expr><name>MAXNEST_static</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>parser_temp_realloc</name><argument_list>(<argument><expr><name>state</name></expr></argument>,
<argument><expr><name>maxnest</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>level</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>=</operator> <name>ARISYNTAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>parenlevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>state</name><index>[<expr><name>level</name></expr>]</index></name><operator>.</operator><name>category</name> <operator>=</operator> <name>TSTATE_ARITH</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><name>CTLARI</name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>state</name><index>[<expr><name>level</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>syntax</name> <operator>==</operator> <name>DQSYNTAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="char">'"'</literal></expr></argument>,<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>USTPUTC</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>,<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<goto>goto <name>parsearith_return</name>;</goto>
</block_content>}</block>

</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>noexpand</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>text</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>text</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>( <expr><name>c</name> <operator>==</operator> <name>CTLQUOTEMARK</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>CTLESC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>BASESYNTAX</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name>c</name></expr>]</index></name> <operator>==</operator> <name>CCTL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>







<function><type><name>int</name></type>
<name>goodname</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>is_name</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<while>while <condition>(<expr><operator>*</operator><operator>++</operator><name>p</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>is_in_name</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>isassignment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_name</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>is_in_name</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>consumetoken</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>readtoken</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>token</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>synexpect</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type>
<name>synexpect</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>msg</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>token</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fmtstr</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%s unexpected (expecting %s)"</literal></expr></argument>,
<argument><expr><name><name>tokname</name><index>[<expr><name>lasttoken</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>tokname</name><index>[<expr><name>token</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>fmtstr</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><literal type="string">"%s unexpected"</literal></expr></argument>, <argument><expr><name><name>tokname</name><index>[<expr><name>lasttoken</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>synerror</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>synerror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>commandname</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>outfmt</name><argument_list>(<argument><expr><name>out2</name></expr></argument>, <argument><expr><literal type="string">"%s: %d: "</literal></expr></argument>, <argument><expr><name>commandname</name></expr></argument>, <argument><expr><name>startlinno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>arg0</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>outfmt</name><argument_list>(<argument><expr><name>out2</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>arg0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>outfmt</name><argument_list>(<argument><expr><name>out2</name></expr></argument>, <argument><expr><literal type="string">"Syntax error: %s\n"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>setprompt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>which</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name>whichprompt</name> <operator>=</operator> <name>which</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>which</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>NO_HISTORY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>el</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<expr_stmt><expr><call><name>out2str</name><argument_list>(<argument><expr><call><name>getprompt</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>flushout</name><argument_list>(<argument><expr><name>out2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>pgetc_linecont</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>pgetc_macro</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>plinno</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>doprompt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setprompt</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>pungetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pushstring</name><argument_list>(<argument><expr><literal type="string">"\\"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><call><name>pgetc</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
<return>return <expr><operator>(</operator><name>c</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type>
<name>getpwlogin</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>login</name></decl>;</decl_stmt>

<expr_stmt><expr><name>login</name> <operator>=</operator> <call><name>getlogin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>login</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><call><name>getpwnam</name><argument_list>(<argument><expr><name>login</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>getusername</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>namelen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>cached_name</name><index>[<expr><name>MAXLOGNAME</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>passwd</name></name> <modifier>*</modifier></type><name>pw</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uid_t</name></type> <name>euid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cached_name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>euid</name> <operator>=</operator> <call><name>geteuid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>







<expr_stmt><expr><name>pw</name> <operator>=</operator> <call><name>getpwlogin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pw</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pw</name><operator>-&gt;</operator><name>pw_uid</name></name> <operator>!=</operator> <name>euid</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pw</name> <operator>=</operator> <call><name>getpwuid</name><argument_list>(<argument><expr><name>euid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pw</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>cached_name</name></expr></argument>, <argument><expr><name><name>pw</name><operator>-&gt;</operator><name>pw_name</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cached_name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cached_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cached_name</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>euid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>cached_name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>char</name> <modifier>*</modifier></type>
<name>getprompt</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>unused</name></type> <name>__unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>ps</name><index>[<expr><name>PROMPTLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>home</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pwd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>homelen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>trim</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>internal_error</name><index>[]</index></name> <init>= <expr><literal type="string">"??"</literal></expr></init></decl>;</decl_stmt>




<switch>switch <condition>(<expr><name>whichprompt</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<expr_stmt><expr><name>fmt</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>ps1val</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>ps2val</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<return>return <expr><name>internal_error</name></expr>;</return>
</block_content>}</block></switch>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <name>PROMPTLEN</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>fmt</name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>fmt</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fmt</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
<switch>switch <condition>(<expr><operator>*</operator><operator>++</operator><name>fmt</name></expr>)</condition> <block>{<block_content>







<case>case <expr><literal type="char">'h'</literal></expr>:</case>
<case>case <expr><literal type="char">'H'</literal></expr>:</case>
<expr_stmt><expr><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>gethostname</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>PROMPTLEN</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ps</name><index>[<expr><name>PROMPTLEN</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>trim</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name>fmt</name> <operator>==</operator> <literal type="char">'h'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'.'</literal></expr> </then><else>: <expr><literal type="char">'\0'</literal></expr></else></ternary></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>(</operator><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>trim</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><operator>--</operator><name>i</name></expr>;</expr_stmt>
<break>break;</break>




<case>case <expr><literal type="char">'u'</literal></expr>:</case>
<expr_stmt><expr><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getusername</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>PROMPTLEN</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>ps</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<break>break;</break>







<case>case <expr><literal type="char">'W'</literal></expr>:</case>
<case>case <expr><literal type="char">'w'</literal></expr>:</case>
<expr_stmt><expr><name>pwd</name> <operator>=</operator> <call><name>lookupvar</name><argument_list>(<argument><expr><literal type="string">"PWD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pwd</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>pwd</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pwd</name> <operator>=</operator> <literal type="string">"?"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fmt</name> <operator>==</operator> <literal type="char">'W'</literal> <operator>&amp;&amp;</operator>
<operator>*</operator><name>pwd</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>pwd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strrchr</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><name>PROMPTLEN</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>home</name> <operator>=</operator> <call><name>lookupvar</name><argument_list>(<argument><expr><literal type="string">"HOME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>home</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>homelen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>home</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>home</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
<call><name>strcmp</name><argument_list>(<argument><expr><name>home</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<call><name>strncmp</name><argument_list>(<argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>home</name></expr></argument>, <argument><expr><name>homelen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>pwd</name><index>[<expr><name>homelen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator>
<name><name>pwd</name><index>[<expr><name>homelen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"~"</literal></expr></argument>,
<argument><expr><name>PROMPTLEN</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ps</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>pwd</name> <operator>+</operator> <name>homelen</name></expr></argument>,
<argument><expr><name>PROMPTLEN</name> <operator>-</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pwd</name></expr></argument>, <argument><expr><name>PROMPTLEN</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<while>while <condition>(<expr><name><name>ps</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<break>break;</break>






<case>case <expr><literal type="char">'$'</literal></expr>:</case>
<expr_stmt><expr><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>geteuid</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'$'</literal></expr> </then><else>: <expr><literal type="char">'#'</literal></expr></else></ternary></expr>;</expr_stmt>
<break>break;</break>




<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
<expr_stmt><expr><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<break>break;</break>




<default>default:</default>
<expr_stmt><expr><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>PROMPTLEN</name> <operator>-</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ps</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>fmt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>fmt</name></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></for>
<expr_stmt><expr><name><name>ps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><name>ps</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>expandstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>union</name> <name>node</name></name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>jmploc</name></name></type> <name>jmploc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>jmploc</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>savehandler</name> <init>= <expr><name>handler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>saveprompt</name> <init>= <expr><name>doprompt</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>parsefile</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>savetopfile</name> <init>= <expr><call><name>getcurrentfile</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>parser_temp</name></name> <modifier>*</modifier><specifier>const</specifier></type> <name>saveparser_temp</name> <init>= <expr><name>parser_temp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>setjmp</name><argument_list>(<argument><expr><name><name>jmploc</name><operator>.</operator><name>loc</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>handler</name> <operator>=</operator> <operator>&amp;</operator><name>jmploc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parser_temp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setinputstring</name><argument_list>(<argument><expr><name>ps</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>doprompt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>readtoken1</name><argument_list>(<argument><expr><call><name>pgetc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DQSYNTAX</name></expr></argument>, <argument><expr><name>NOEOFMARK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>backquotelist</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>error</name><argument_list>(<argument><expr><literal type="string">"Command substitution not allowed here"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>n</name><operator>.</operator><name>narg</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>NARG</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>.</operator><name>narg</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>.</operator><name>narg</name><operator>.</operator><name>text</name></name> <operator>=</operator> <name>wordtext</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>n</name><operator>.</operator><name>narg</name><operator>.</operator><name>backquote</name></name> <operator>=</operator> <name>backquotelist</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>expandarg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>stackblock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>INTOFF</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>handler</name> <operator>=</operator> <name>savehandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>doprompt</name> <operator>=</operator> <name>saveprompt</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>popfilesupto</name><argument_list>(<argument><expr><name>savetopfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>parser_temp</name> <operator>!=</operator> <name>saveparser_temp</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>parser_temp_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>parser_temp</name> <operator>=</operator> <name>saveparser_temp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>INTON</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>exception</name> <operator>==</operator> <name>EXINT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
