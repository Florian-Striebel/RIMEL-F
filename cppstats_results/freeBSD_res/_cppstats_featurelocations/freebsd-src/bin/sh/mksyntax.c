

































#if 0
#if !defined(lint)
static char const copyright[] =
"@(#) Copyright (c) 1991, 1993\n\
The Regents of the University of California. All rights reserved.\n";
#endif

#if !defined(lint)
static char sccsid[] = "@(#)mksyntax.c 8.2 (Berkeley) 5/4/95";
#endif
#endif
#include <sys/cdefs.h>
__FBSDID("$FreeBSD$");





#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "parser.h"


struct synclass {
const char *name;
const char *comment;
};


static const struct synclass synclass[] = {
{ "CWORD", "character is nothing special" },
{ "CNL", "newline character" },
{ "CQNL", "newline character in quotes" },
{ "CBACK", "a backslash character" },
{ "CSBACK", "a backslash character in single quotes" },
{ "CSQUOTE", "single quote" },
{ "CDQUOTE", "double quote" },
{ "CENDQUOTE", "a terminating quote" },
{ "CBQUOTE", "backwards single quote" },
{ "CVAR", "a dollar sign" },
{ "CENDVAR", "a '}' character" },
{ "CLP", "a left paren in arithmetic" },
{ "CRP", "a right paren in arithmetic" },
{ "CEOF", "end of file" },
{ "CCTL", "like CWORD, except it must be escaped" },
{ "CSPCL", "these terminate a word" },
{ "CIGN", "character should be ignored" },
{ NULL, NULL }
};






static const struct synclass is_entry[] = {
{ "ISDIGIT", "a digit" },
{ "ISUPPER", "an upper case letter" },
{ "ISLOWER", "a lower case letter" },
{ "ISUNDER", "an underscore" },
{ "ISSPECL", "the name of a special parameter" },
{ NULL, NULL }
};

static const char writer[] = "\
/*\n\
* This file was generated by the mksyntax program.\n\
*/\n\
\n";


static FILE *cfile;
static FILE *hfile;

static void add_default(void);
static void finish(void);
static void init(const char *);
static void add(const char *, const char *);
static void output_type_macros(void);

int
main(int argc __unused, char **argv __unused)
{
int i;
char buf[80];
int pos;


if ((cfile = fopen("syntax.c", "w")) == NULL) {
perror("syntax.c");
exit(2);
}
if ((hfile = fopen("syntax.h", "w")) == NULL) {
perror("syntax.h");
exit(2);
}
fputs(writer, hfile);
fputs(writer, cfile);

fputs("#include <sys/cdefs.h>\n", hfile);
fputs("#include <limits.h>\n\n", hfile);


fputs("/* Syntax classes */\n", hfile);
for (i = 0 ; synclass[i].name ; i++) {
sprintf(buf, "#define %s %d", synclass[i].name, i);
fputs(buf, hfile);
for (pos = strlen(buf) ; pos < 32 ; pos = (pos + 8) & ~07)
putc('\t', hfile);
fprintf(hfile, "/* %s */\n", synclass[i].comment);
}
putc('\n', hfile);
fputs("/* Syntax classes for is_ functions */\n", hfile);
for (i = 0 ; is_entry[i].name ; i++) {
sprintf(buf, "#define %s %#o", is_entry[i].name, 1 << i);
fputs(buf, hfile);
for (pos = strlen(buf) ; pos < 32 ; pos = (pos + 8) & ~07)
putc('\t', hfile);
fprintf(hfile, "/* %s */\n", is_entry[i].comment);
}
putc('\n', hfile);
fputs("#define SYNBASE (1 - CHAR_MIN)\n", hfile);
fputs("#define PEOF -SYNBASE\n\n", hfile);
putc('\n', hfile);
fputs("#define BASESYNTAX (basesyntax + SYNBASE)\n", hfile);
fputs("#define DQSYNTAX (dqsyntax + SYNBASE)\n", hfile);
fputs("#define SQSYNTAX (sqsyntax + SYNBASE)\n", hfile);
fputs("#define ARISYNTAX (arisyntax + SYNBASE)\n", hfile);
putc('\n', hfile);
output_type_macros();
putc('\n', hfile);


fputs("#include \"parser.h\"\n", cfile);
fputs("#include \"shell.h\"\n", cfile);
fputs("#include \"syntax.h\"\n\n", cfile);

fputs("/* syntax table used when not in quotes */\n", cfile);
init("basesyntax");
add_default();
add("\n", "CNL");
add("\\", "CBACK");
add("'", "CSQUOTE");
add("\"", "CDQUOTE");
add("`", "CBQUOTE");
add("$", "CVAR");
add("}", "CENDVAR");
add("<>();&| \t", "CSPCL");
finish();

fputs("\n/* syntax table used when in double quotes */\n", cfile);
init("dqsyntax");
add_default();
add("\n", "CQNL");
add("\\", "CBACK");
add("\"", "CENDQUOTE");
add("`", "CBQUOTE");
add("$", "CVAR");
add("}", "CENDVAR");

add("!*?[]=~:/-^", "CCTL");
finish();

fputs("\n/* syntax table used when in single quotes */\n", cfile);
init("sqsyntax");
add_default();
add("\n", "CQNL");
add("\\", "CSBACK");
add("'", "CENDQUOTE");

add("!*?[]=~:/-^", "CCTL");
finish();

fputs("\n/* syntax table used when in arithmetic */\n", cfile);
init("arisyntax");
add_default();
add("\n", "CQNL");
add("\\", "CBACK");
add("`", "CBQUOTE");
add("\"", "CIGN");
add("$", "CVAR");
add("}", "CENDVAR");
add("(", "CLP");
add(")", "CRP");
finish();

fputs("\n/* character classification table */\n", cfile);
init("is_type");
add("0123456789", "ISDIGIT");
add("abcdefghijklmnopqrstuvwxyz", "ISLOWER");
add("ABCDEFGHIJKLMNOPQRSTUVWXYZ", "ISUPPER");
add("_", "ISUNDER");
add("#?$!-*@", "ISSPECL");
finish();

exit(0);
}






static void
init(const char *name)
{
fprintf(hfile, "extern const char %s[];\n", name);
fprintf(cfile, "const char %s[SYNBASE + CHAR_MAX + 1] = {\n", name);
}


static void
add_one(const char *key, const char *type)
{
fprintf(cfile, "\t[SYNBASE + %s] = %s,\n", key, type);
}






static void
add_default(void)
{
add_one("PEOF", "CEOF");
add_one("CTLESC", "CCTL");
add_one("CTLVAR", "CCTL");
add_one("CTLENDVAR", "CCTL");
add_one("CTLBACKQ", "CCTL");
add_one("CTLBACKQ + CTLQUOTE", "CCTL");
add_one("CTLARI", "CCTL");
add_one("CTLENDARI", "CCTL");
add_one("CTLQUOTEMARK", "CCTL");
add_one("CTLQUOTEEND", "CCTL");
}






static void
finish(void)
{
fputs("};\n", cfile);
}






static void
add(const char *p, const char *type)
{
for (; *p; ++p) {
char c = *p;
switch (c) {
case '\t': c = 't'; break;
case '\n': c = 'n'; break;
case '\'': c = '\''; break;
case '\\': c = '\\'; break;

default:
fprintf(cfile, "\t[SYNBASE + '%c'] = %s,\n", c, type);
continue;
}
fprintf(cfile, "\t[SYNBASE + '\\%c'] = %s,\n", c, type);
}
}







static const char *macro[] = {
"#define is_digit(c)\t((unsigned int)((c) - '0') <= 9)",
"#define is_eof(c)\t((c) == PEOF)",
"#define is_alpha(c)\t((is_type+SYNBASE)[(int)c] & (ISUPPER|ISLOWER))",
"#define is_name(c)\t((is_type+SYNBASE)[(int)c] & (ISUPPER|ISLOWER|ISUNDER))",
"#define is_in_name(c)\t((is_type+SYNBASE)[(int)c] & (ISUPPER|ISLOWER|ISUNDER|ISDIGIT))",
"#define is_special(c)\t((is_type+SYNBASE)[(int)c] & (ISSPECL|ISDIGIT))",
"#define digit_val(c)\t((c) - '0')",
NULL
};

static void
output_type_macros(void)
{
const char **pp;

for (pp = macro ; *pp ; pp++)
fprintf(hfile, "%s\n", *pp);
}
