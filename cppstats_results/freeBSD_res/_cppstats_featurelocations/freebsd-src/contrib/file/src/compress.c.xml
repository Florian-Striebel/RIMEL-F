<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/file/src/compress.c">

































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"file.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>lint</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>FILE_RCSID</name><argument_list>(<argument><literal type="string">"@(#)$File: compress.c,v 1.129 2020/12/08 21:26:00 christos Exp $"</literal></argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"magic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNISTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SIG_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>sig_t</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl></typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ioctl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_WAIT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TIME_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>ZLIBSUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUILTIN_DECOMPRESS</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BZLIB_H</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>BZLIBSUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUILTIN_BZLIB</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;bzlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LZMA_H</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>XZLIBSUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUILTIN_XZLIB</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;lzma.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>tty</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DPRINTF</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if (tty == -1) tty = open("/dev/tty", O_RDWR); if (tty == -1) abort(); dprintf(tty, __VA_ARGS__); } while (0)</cpp:value></cpp:define>






<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DPRINTF</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZLIBSUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>





<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>zlibcode</name><index>[]</index></name> <init>=
<expr><literal type="string">"import sys, zlib; sys.stdout.write(zlib.decompress(sys.stdin.read()))"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>zlib_args</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">"python"</literal></expr>, <expr><literal type="string">"-c"</literal></expr>, <expr><name>zlibcode</name></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>zlibcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>x</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <macro><name>CAST</name><argument_list>(<argument>unsigned char *</argument>, <argument>CAST(void *, &amp;x)</argument>)</argument_list></macro></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf</literal><operator>)</operator> <operator>!=</operator> <literal type="number">8</literal> <operator>||</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>x</name> <operator>%</operator> <literal type="number">31</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>lzmacmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0x5d</literal> <operator>||</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0xff</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>gzip_flags</name></cpp:macro> <cpp:value>"-cd"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lrzip_flags</name></cpp:macro> <cpp:value>"-do"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lzip_flags</name></cpp:macro> <cpp:value>gzip_flags</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>gzip_args</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"gzip"</literal></expr>, <expr><name>gzip_flags</name></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>uncompress_args</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"uncompress"</literal></expr>, <expr><literal type="string">"-c"</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>bzip2_args</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"bzip2"</literal></expr>, <expr><literal type="string">"-cd"</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>lzip_args</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"lzip"</literal></expr>, <expr><name>lzip_flags</name></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>xz_args</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"xz"</literal></expr>, <expr><literal type="string">"-cd"</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>lrzip_args</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"lrzip"</literal></expr>, <expr><name>lrzip_flags</name></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>lz4_args</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"lz4"</literal></expr>, <expr><literal type="string">"-cd"</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>zstd_args</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"zstd"</literal></expr>, <expr><literal type="string">"-cd"</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>do_zlib</name></cpp:macro> <cpp:value>NULL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>do_bzlib</name></cpp:macro> <cpp:value>NULL</cpp:value></cpp:define>

<expr_stmt><expr><name>private</name> <specifier>const</specifier> struct <block>{
<expr>union <block>{
<expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>magic</name></expr>;
<macro><name>int</name> <argument_list>(<argument>*func</argument>)</argument_list></macro><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator></expr>;
}</block> <name>u</name></expr>;
<expr><name>int</name> <name>maglen</name></expr>;
<expr><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><name>argv</name></expr>;
<expr><name>void</name> <operator>*</operator><name>unused</name></expr>;
}</block> <name><name>compr</name><index>[]</index></name> <operator>=</operator> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METH_FROZEN</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METH_BZIP</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METH_XZ</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METH_LZMA</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>METH_ZLIB</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define>
<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>magic</name> <operator>=</operator> <literal type="string">"\037\235"</literal></expr> }</block></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>gzip_args</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,


<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>magic</name> <operator>=</operator> <literal type="string">"\037\235"</literal></expr> }</block></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>uncompress_args</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>magic</name> <operator>=</operator> <literal type="string">"\037\213"</literal></expr> }</block></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>gzip_args</name></expr>, <expr><name>do_zlib</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>magic</name> <operator>=</operator> <literal type="string">"\037\236"</literal></expr> }</block></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>gzip_args</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>magic</name> <operator>=</operator> <literal type="string">"\037\240"</literal></expr> }</block></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>gzip_args</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>magic</name> <operator>=</operator> <literal type="string">"\037\036"</literal></expr> }</block></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>gzip_args</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>magic</name> <operator>=</operator> <literal type="string">"PK\3\4"</literal></expr> }</block></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>gzip_args</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,

<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>magic</name> <operator>=</operator> <literal type="string">"BZh"</literal></expr> }</block></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>bzip2_args</name></expr>, <expr><name>do_bzlib</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>magic</name> <operator>=</operator> <literal type="string">"LZIP"</literal></expr> }</block></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>lzip_args</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>magic</name> <operator>=</operator> <literal type="string">"\3757zXZ\0"</literal></expr> }</block></expr>,<expr><literal type="number">6</literal></expr>, <expr><name>xz_args</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>magic</name> <operator>=</operator> <literal type="string">"LRZI"</literal></expr> }</block></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>lrzip_args</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>magic</name> <operator>=</operator> <literal type="string">"\004\"M\030"</literal></expr> }</block></expr>,<expr><literal type="number">4</literal></expr>, <expr><name>lz4_args</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>magic</name> <operator>=</operator> <literal type="string">"\x28\xB5\x2F\xFD"</literal></expr> }</block></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>zstd_args</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>func</name> <operator>=</operator> <name>lzmacmp</name></expr> }</block></expr>, <expr><operator>-</operator><literal type="number">13</literal></expr>, <expr><name>xz_args</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ZLIBSUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr><block>{ <expr><operator>.</operator><name>func</name> <operator>=</operator> <name>zlibcmp</name></expr> }</block></expr>, <expr><operator>-</operator><literal type="number">2</literal></expr>, <expr><name>zlib_args</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OKDATA</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODATA</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRDATA</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<function_decl><type><name>private</name> <name>ssize_t</name></type> <name>swrite</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_FORK</name></expr></cpp:if>
<decl_stmt><decl><type><name>private</name> <name>size_t</name></type> <name>ncompr</name> <init>= <expr><call><name>__arraycount</name><argument_list>(<argument><expr><name>compr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<function_decl><type><name>private</name> <name>int</name></type> <name>uncompressbuf</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BUILTIN_DECOMPRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>private</name> <name>int</name></type> <name>uncompresszlib</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>private</name> <name>int</name></type> <name>uncompressgzipped</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BUILTIN_BZLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>private</name> <name>int</name></type> <name>uncompressbzlib</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BUILTIN_XZLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>private</name> <name>int</name></type> <name>uncompressxzlib</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>,
<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>makeerror</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
__attribute__<parameter_list>(<parameter/></parameter_list>(__format__<parameter_list>(<parameter><decl><type><name>__printf__</name></type></decl></parameter>, <parameter/></parameter_list>3<operator>,</operator> 4</function_decl>)))<empty_stmt>;</empty_stmt>
<function_decl><type><name>private</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>methodname</name><parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>private</name> <name>int</name></type>
<name>format_decompression_error</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mime</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MAGIC_MIME</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mime</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">"ERROR:[%s: %s]"</literal></expr></argument>, <argument><expr><call><name>methodname</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isalnum</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">"application/x-decompression-error-%s-%s"</literal></expr></argument>,
<argument><expr><call><name>methodname</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>protected</name> <name>int</name></type>
<name>file_zmagic</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>buffer</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>newbuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nsz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>file_pushbuf_t</name> <modifier>*</modifier></type><name>pb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>urv</name></decl>, <decl><type ref="prev"/><name>prv</name></decl>, <decl><type ref="prev"/><name>rv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mime</name> <init>= <expr><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MAGIC_MIME</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>fd</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <macro><name>CAST</name><argument_list>(<argument>const unsigned char *</argument>, <argument>b-&gt;fbuf</argument>)</argument_list></macro></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>flen</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sa_saved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>sig_act</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MAGIC_COMPRESS</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncompr</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>zm</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>&lt;</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name><name>compr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>maglen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>compr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>maglen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>zm</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name><name>compr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>func</name></name><operator>)</operator><operator>(</operator><name>buf</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>zm</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>compr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>u</name><operator>.</operator><name>magic</name></name></expr></argument>,
<argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name><name>compr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>maglen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>zm</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sa_saved</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>sigaction</name></name></type> <name>new_act</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_act</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_act</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_act</name><operator>.</operator><name>sa_handler</name></name> <operator>=</operator> <name>SIG_IGN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sa_saved</name> <operator>=</operator> <call><name>sigaction</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_act</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sig_act</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nsz</name> <operator>=</operator> <name>nbytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>urv</name> <operator>=</operator> <call><name>uncompressbuf</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>ms</name><operator>-&gt;</operator><name>bytes_max</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr><literal type="string">"uncompressbuf = %d, %s, %"</literal> <name>SIZE_T_FORMAT</name> <literal type="string">"u\n"</literal></expr></argument>, <argument><expr><name>urv</name></expr></argument>,
<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>newbuf</name></expr></argument>, <argument><expr><name>nsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>urv</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OKDATA</name></expr>:</case>
<case>case <expr><name>ERRDATA</name></expr>:</case>
<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MAGIC_COMPRESS</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>urv</name> <operator>==</operator> <name>ERRDATA</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>prv</name> <operator>=</operator> <call><name>format_decompression_error</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>prv</name> <operator>=</operator> <call><name>file_buffer</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>newbuf</name></expr></argument>, <argument><expr><name>nsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>prv</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MAGIC_COMPRESS_TRANSP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>mime</name> <operator>!=</operator> <name>MAGIC_MIME</name> <operator>&amp;&amp;</operator> <name>mime</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>out</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>mime</name></expr> ?</condition><then> <expr><literal type="string">" compressed-encoding="</literal></expr> </then><else>: <expr><literal type="string">" ("</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pb</name> <operator>=</operator> <call><name>file_push_buffer</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>file_buffer</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_pop_buffer</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<goto>goto <name>error</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rbuf</name> <operator>=</operator> <call><name>file_pop_buffer</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>rbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>rbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mime</name> <operator>&amp;&amp;</operator> <call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

<case>case <expr><name>NODATA</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>error</name>:</label>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<label><name>out</name>:</label>
<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr><literal type="string">"rv = %d\n"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sa_saved</name> <operator>&amp;&amp;</operator> <name><name>sig_act</name><operator>.</operator><name>sa_handler</name></name> <operator>!=</operator> <name>SIG_IGN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sig_act</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MAGIC_COMPRESS</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr><literal type="string">"Zmagic returns %d\n"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<function><type><name>private</name> <name>ssize_t</name></type>
<name>swrite</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>rn</name> <init>= <expr><name>n</name></expr></init></decl>;</decl_stmt>

<do>do<block type="pseudo"><block_content>
<switch>switch <condition>(<expr><name>rv</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<default>default:</default>
<expr_stmt><expr><name>n</name> <operator>-=</operator> <name>rv</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>CAST</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>rv</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch></block_content></block>
while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
<return>return <expr><name>rn</name></expr>;</return>
</block_content>}</block></function>





<decl_stmt><decl><type><name>protected</name> <name>ssize_t</name></type>
<name>sread</name><argument_list>(<argument><expr><name>int</name> <name>fd</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>buf</name></expr></argument>, <argument><expr><name>size_t</name> <name>n</name></expr></argument>, <argument><expr><name>int</name> <name>canbepipe</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list>
<block>{<block_content>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>rv</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FIONREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>size_t</name></type> <name>rn</name> <init>= <expr><name>n</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>STDIN_FILENO</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nocheck</name>;</goto></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FIONREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>canbepipe</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>FIONREAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>t</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FD_ZERO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>cnt</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>fd_set</name></type> <name>check</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tout</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">100</literal> <operator>*</operator> <literal type="number">1000</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>selrv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>selrv</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>fd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>check</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>selrv</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>selrv</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cnt</name> <operator>&gt;=</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>ioctl</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>FIONREAD</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>n</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rn</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>nocheck</name>:</label>
<do>do<block type="pseudo"><block_content>
<switch>switch <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<return>return <expr><name>rn</name> <operator>-</operator> <name>n</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><name>n</name> <operator>-=</operator> <name>rv</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><call><name>CCAST</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator> <name>rv</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch></block_content></block>
while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
<return>return <expr><name>rn</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>protected</name> <name>int</name></type>
<name>file_pipe2file</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>startbuf</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4096</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tfd</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>strlcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"/tmp/file.XXXXXX"</literal></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MKSTEMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>mktemp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>tfd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>O_RDWR</name><operator>|</operator><name>O_TRUNC</name><operator>|</operator><name>O_EXCL</name><operator>|</operator><name>O_CREAT</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>unlink</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>
</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>te</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mode_t</name></type> <name>ou</name> <init>= <expr><call><name>umask</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>tfd</name> <operator>=</operator> <call><name>mkstemp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>umask</name><argument_list>(<argument><expr><name>ou</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>te</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>unlink</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>te</name></expr>;</expr_stmt>
</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>tfd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>file_error</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>,
<argument><expr><literal type="string">"cannot create temporary file for pipe copy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>swrite</name><argument_list>(<argument><expr><name>tfd</name></expr></argument>, <argument><expr><name>startbuf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>ssize_t</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<while>while <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>sread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>swrite</name><argument_list>(<argument><expr><name>tfd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>r</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></while>
</block_content>}</block></else></if_stmt>

<switch>switch <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>
<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><call><name>file_error</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"error copying from pipe to temp file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
<case>case <expr><literal type="number">0</literal></expr>:</case>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><call><name>file_error</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"error while writing to temp file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></switch>






<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>dup2</name><argument_list>(<argument><expr><name>tfd</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>file_error</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"could not dup descriptor for temp file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>close</name><argument_list>(<argument><expr><name>tfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>off_t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>off_t</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>file_badseek</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>fd</name></expr>;</return>
</block_content>}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_FORK</name></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BUILTIN_DECOMPRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FHCRC</name></cpp:macro> <cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FEXTRA</name></cpp:macro> <cpp:value>(1 &lt;&lt; 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNAME</name></cpp:macro> <cpp:value>(1 &lt;&lt; 3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FCOMMENT</name></cpp:macro> <cpp:value>(1 &lt;&lt; 4)</cpp:value></cpp:define>


<function><type><name>private</name> <name>int</name></type>
<name>uncompressgzipped</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newch</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>bytes_max</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>flg</name> <init>= <expr><name><name>old</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>data_start</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flg</name> <operator>&amp;</operator> <name>FEXTRA</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>data_start</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <operator>*</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><name>data_start</name> <operator>+=</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>old</name><index>[<expr><name>data_start</name></expr>]</index></name> <operator>+</operator> <name><name>old</name><index>[<expr><name>data_start</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <literal type="number">256</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flg</name> <operator>&amp;</operator> <name>FNAME</name></expr>)</condition> <block>{<block_content>
<while>while<condition>(<expr><name>data_start</name> <operator>&lt;</operator> <operator>*</operator><name>n</name> <operator>&amp;&amp;</operator> <name><name>old</name><index>[<expr><name>data_start</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>data_start</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>data_start</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flg</name> <operator>&amp;</operator> <name>FCOMMENT</name></expr>)</condition> <block>{<block_content>
<while>while<condition>(<expr><name>data_start</name> <operator>&lt;</operator> <operator>*</operator><name>n</name> <operator>&amp;&amp;</operator> <name><name>old</name><index>[<expr><name>data_start</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>data_start</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>data_start</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flg</name> <operator>&amp;</operator> <name>FHCRC</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>data_start</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>data_start</name> <operator>&gt;=</operator> <operator>*</operator><name>n</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>n</name> <operator>-=</operator> <name>data_start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>old</name> <operator>+=</operator> <name>data_start</name></expr>;</expr_stmt>
<return>return <expr><call><name>uncompresszlib</name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><name>newch</name></expr></argument>, <argument><expr><name>bytes_max</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
<label><name>err</name>:</label>
<return>return <expr><call><name>makeerror</name><argument_list>(<argument><expr><name>newch</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"File too short"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>private</name> <name>int</name></type>
<name>uncompresszlib</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newch</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>bytes_max</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>zlib</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>z_stream</name></type> <name>z</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>newch</name> <operator>=</operator> <macro><name>CAST</name><argument_list>(<argument>unsigned char *</argument>, <argument>malloc(bytes_max + <literal type="number">1</literal>)</argument>)</argument_list></macro><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>makeerror</name><argument_list>(<argument><expr><name>newch</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"No buffer, %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>z</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <call><name>CCAST</name><argument_list>(<argument><expr><name>Bytef</name> <operator>*</operator></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <operator>*</operator><name>newch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <macro><name>CAST</name><argument_list>(<argument>unsigned int</argument>, <argument>bytes_max</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name><operator>.</operator><name>zalloc</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name><operator>.</operator><name>zfree</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name><operator>.</operator><name>opaque</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>


<expr_stmt><expr><name>rc</name> <operator>=</operator> <ternary><condition><expr><name>zlib</name></expr> ?</condition><then> <expr><call><name>inflateInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>inflateInit2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">15</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>inflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><name>Z_SYNC_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>Z_OK</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>!=</operator> <name>Z_STREAM_END</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name><name>z</name><operator>.</operator><name>total_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>inflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>(</operator><operator>*</operator><name>newch</name><operator>)</operator><index>[<expr><operator>*</operator><name>n</name></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><name>OKDATA</name></expr>;</return>
<label><name>err</name>:</label>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>newch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name><name>z</name><operator>.</operator><name>msg</name></name></expr> ?</condition><then> <expr><name><name>z</name><operator>.</operator><name>msg</name></name></expr> </then><else>: <expr><call><name>zError</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><name>bytes_max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>newch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ERRDATA</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BUILTIN_BZLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>private</name> <name>int</name></type>
<name>uncompressbzlib</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newch</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>bytes_max</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bz_stream</name></type> <name>bz</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bz</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>BZ2_bzDecompressInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>BZ_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>newch</name> <operator>=</operator> <macro><name>CAST</name><argument_list>(<argument>unsigned char *</argument>, <argument>malloc(bytes_max + <literal type="number">1</literal>)</argument>)</argument_list></macro><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>makeerror</name><argument_list>(<argument><expr><name>newch</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"No buffer, %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>bz</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <call><name>CCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bz</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bz</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>newch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bz</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <macro><name>CAST</name><argument_list>(<argument>unsigned int</argument>, <argument>bytes_max</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>BZ2_bzDecompress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>BZ_OK</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>!=</operator> <name>BZ_STREAM_END</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>



<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name><name>bz</name><operator>.</operator><name>total_out_lo32</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>BZ_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>(</operator><operator>*</operator><name>newch</name><operator>)</operator><index>[<expr><operator>*</operator><name>n</name></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><name>OKDATA</name></expr>;</return>
<label><name>err</name>:</label>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>newch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bytes_max</name></expr></argument>, <argument><expr><literal type="string">"bunzip error %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>newch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ERRDATA</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BUILTIN_XZLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>private</name> <name>int</name></type>
<name>uncompressxzlib</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newch</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>bytes_max</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>lzma_stream</name></type> <name>xz</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xz</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lzma_auto_decoder</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xz</name></expr></argument>, <argument><expr><name>UINT64_MAX</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>LZMA_OK</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>newch</name> <operator>=</operator> <macro><name>CAST</name><argument_list>(<argument>unsigned char *</argument>, <argument>malloc(bytes_max + <literal type="number">1</literal>)</argument>)</argument_list></macro><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>makeerror</name><argument_list>(<argument><expr><name>newch</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"No buffer, %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>xz</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <call><name>CCAST</name><argument_list>(<argument><expr><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>xz</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>xz</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <call><name>RCAST</name><argument_list>(<argument><expr><name>uint8_t</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>newch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>xz</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <macro><name>CAST</name><argument_list>(<argument>unsigned int</argument>, <argument>bytes_max</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>lzma_code</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xz</name></expr></argument>, <argument><expr><name>LZMA_RUN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>LZMA_OK</name> <operator>&amp;&amp;</operator> <name>rc</name> <operator>!=</operator> <name>LZMA_STREAM_END</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>err</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name><name>xz</name><operator>.</operator><name>total_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>lzma_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><operator>(</operator><operator>*</operator><name>newch</name><operator>)</operator><index>[<expr><operator>*</operator><name>n</name></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><name>OKDATA</name></expr>;</return>
<label><name>err</name>:</label>
<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>newch</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bytes_max</name></expr></argument>, <argument><expr><literal type="string">"unxz error %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>newch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ERRDATA</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>makeerror</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vasprintf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<return>return <expr><name>NODATA</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <macro><name>RCAST</name><argument_list>(<argument>unsigned char *</argument>, <argument>msg</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ERRDATA</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>closefd</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fd</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name><name>fd</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fd</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>closep</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>closefd</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>copydesc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr><literal type="string">"dup(%d, %d) failed (%s)\n"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>writechild</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>





<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr><literal type="string">"Fork failed (%s)\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>swrite</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>old</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>ssize_t</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr><literal type="string">"Write failed (%s)\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>pid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>filter_error</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ubuf</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ubuf</name><index>[<expr><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>ubuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><macro><name>CAST</name><argument_list>(<argument>unsigned char</argument>, <argument>*buf</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>buf</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr><literal type="string">"Filter error[[[%s]]]\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><macro><name>CAST</name><argument_list>(<argument>unsigned char</argument>, <argument>*p</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>ubuf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr><literal type="string">"Filter error after[[[%s]]]\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ubuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><operator>*</operator><name>ubuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>ubuf</name> <operator>=</operator> <call><name>toupper</name><argument_list>(<argument><expr><operator>*</operator><name>ubuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>private</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>methodname</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>method</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<switch>switch <condition>(<expr><name>method</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BUILTIN_DECOMPRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>METH_FROZEN</name></expr>:</case>
<case>case <expr><name>METH_ZLIB</name></expr>:</case>
<return>return <expr><literal type="string">"zlib"</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BUILTIN_BZLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>METH_BZIP</name></expr>:</case>
<return>return <expr><literal type="string">"bzlib"</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BUILTIN_XZLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>METH_XZ</name></expr>:</case>
<case>case <expr><name>METH_LZMA</name></expr>:</case>
<return>return <expr><literal type="string">"xzlib"</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>
<return>return <expr><name><name>compr</name><index>[<expr><name>method</name></expr>]</index></name><operator>.</operator><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>private</name> <name>int</name></type>
<name>uncompressbuf</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bytes_max</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>method</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>old</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newch</name></decl></parameter>, <parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name><name>fdp</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>, <decl><type ref="prev"/><name>rv</name></decl>, <decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pid_t</name></type> <name>writepid</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>r</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>method</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BUILTIN_DECOMPRESS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>METH_FROZEN</name></expr>:</case>
<return>return <expr><call><name>uncompressgzipped</name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><name>newch</name></expr></argument>, <argument><expr><name>bytes_max</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
<case>case <expr><name>METH_ZLIB</name></expr>:</case>
<return>return <expr><call><name>uncompresszlib</name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><name>newch</name></expr></argument>, <argument><expr><name>bytes_max</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BUILTIN_BZLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>METH_BZIP</name></expr>:</case>
<return>return <expr><call><name>uncompressbzlib</name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><name>newch</name></expr></argument>, <argument><expr><name>bytes_max</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BUILTIN_XZLIB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>METH_XZ</name></expr>:</case>
<case>case <expr><name>METH_LZMA</name></expr>:</case>
<return>return <expr><call><name>uncompressxzlib</name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><name>newch</name></expr></argument>, <argument><expr><name>bytes_max</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>__arraycount</name><argument_list>(<argument><expr><name>fdp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>fdp</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>fdp</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>















<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>file_pipe_closexec</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDIN_FILENO</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>||</operator>
<call><name>file_pipe_closexec</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDOUT_FILENO</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
<call><name>file_pipe_closexec</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDERR_FILENO</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>closep</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDIN_FILENO</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>closep</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDOUT_FILENO</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>makeerror</name><argument_list>(<argument><expr><name>newch</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"Cannot create pipe, %s"</literal></expr></argument>,
<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>vfork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>makeerror</name><argument_list>(<argument><expr><name>newch</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"Cannot vfork, %s"</literal></expr></argument>,
<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>off_t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>copydesc</name><argument_list>(<argument><expr><name>STDIN_FILENO</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>copydesc</name><argument_list>(<argument><expr><name>STDIN_FILENO</name></expr></argument>, <argument><expr><name><name>fdp</name><index>[<expr><name>STDIN_FILENO</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDIN_FILENO</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fdp</name><index>[<expr><name>STDIN_FILENO</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDIN_FILENO</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>file_clear_closexec</name><argument_list>(<argument><expr><name>STDIN_FILENO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>copydesc</name><argument_list>(<argument><expr><name>STDOUT_FILENO</name></expr></argument>, <argument><expr><name><name>fdp</name><index>[<expr><name>STDOUT_FILENO</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDOUT_FILENO</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fdp</name><index>[<expr><name>STDOUT_FILENO</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDOUT_FILENO</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>file_clear_closexec</name><argument_list>(<argument><expr><name>STDOUT_FILENO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>copydesc</name><argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>, <argument><expr><name><name>fdp</name><index>[<expr><name>STDERR_FILENO</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDERR_FILENO</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fdp</name><index>[<expr><name>STDERR_FILENO</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>close</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDERR_FILENO</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>file_clear_closexec</name><argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>execvp</name><argument_list>(<argument><expr><name><name>compr</name><index>[<expr><name>method</name></expr>]</index></name><operator>.</operator><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
<argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>, <argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><name>intptr_t</name></expr></argument>, <argument><expr><name><name>compr</name><index>[<expr><name>method</name></expr>]</index></name><operator>.</operator><name>argv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dprintf</name><argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>, <argument><expr><literal type="string">"exec `%s' failed, %s"</literal></expr></argument>,
<argument><expr><name><name>compr</name><index>[<expr><name>method</name></expr>]</index></name><operator>.</operator><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>__arraycount</name><argument_list>(<argument><expr><name>fdp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>closefd</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>closefd</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDIN_FILENO</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>writepid</name> <operator>=</operator> <call><name>writechild</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDIN_FILENO</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>old</name></expr></argument>, <argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>closefd</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDIN_FILENO</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>newch</name> <operator>=</operator> <macro><name>CAST</name><argument_list>(<argument>unsigned char *</argument>, <argument>malloc(bytes_max + <literal type="number">1</literal>)</argument>)</argument_list></macro></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newch</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeerror</name><argument_list>(<argument><expr><name>newch</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"No buffer, %s"</literal></expr></argument>,
<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>OKDATA</name></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>sread</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDOUT_FILENO</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>*</operator><name>newch</name></expr></argument>, <argument><expr><name>bytes_max</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr><literal type="string">"Read stdout failed %d (%s)\n"</literal></expr></argument>, <argument><expr><name><name>fdp</name><index>[<expr><name>STDOUT_FILENO</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
<argument><expr><ternary><condition><expr><name>r</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr> ?</condition><then> <expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"no data"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>ERRDATA</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<operator>(</operator><name>r</name> <operator>=</operator> <call><name>sread</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDERR_FILENO</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>*</operator><name>newch</name></expr></argument>, <argument><expr><name>bytes_max</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>filter_error</name><argument_list>(<argument><expr><operator>*</operator><name>newch</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>ok</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>newch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeerror</name><argument_list>(<argument><expr><name>newch</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"Read failed, %s"</literal></expr></argument>,
<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeerror</name><argument_list>(<argument><expr><name>newch</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"No data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<goto>goto <name>err</name>;</goto>
</block_content>}</block></if></if_stmt>
<label><name>ok</name>:</label>
<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>newch</name><operator>)</operator><index>[<expr><operator>*</operator><name>n</name></expr>]</index> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<label><name>err</name>:</label>
<expr_stmt><expr><call><name>closefd</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDIN_FILENO</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>closefd</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDOUT_FILENO</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>closefd</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDERR_FILENO</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>waitpid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>wait_err</name>:</label>
<if_stmt><if>if <condition>(<expr><name>w</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>newch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>makeerror</name><argument_list>(<argument><expr><name>newch</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="string">"Wait failed, %s"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr><literal type="string">"Child wait return %#x\n"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr><literal type="string">"Child not exited (%#x)\n"</literal></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr><literal type="string">"Child exited (%#x)\n"</literal></expr></argument>, <argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>writepid</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>waitpid</name><argument_list>(<argument><expr><name>writepid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>writepid</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<goto>goto <name>wait_err</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>closefd</name><argument_list>(<argument><expr><name><name>fdp</name><index>[<expr><name>STDIN_FILENO</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DPRINTF</name><argument_list>(<argument><expr><literal type="string">"Returning %p n=%"</literal> <name>SIZE_T_FORMAT</name> <literal type="string">"u rv=%d\n"</literal></expr></argument>, <argument><expr><operator>*</operator><name>newch</name></expr></argument>, <argument><expr><operator>*</operator><name>n</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
