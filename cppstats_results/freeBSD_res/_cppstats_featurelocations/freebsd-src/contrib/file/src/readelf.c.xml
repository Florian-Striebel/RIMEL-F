<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/file/src/readelf.c">

























<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"file.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>lint</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>FILE_RCSID</name><argument_list>(<argument><literal type="string">"@(#)$File: readelf.c,v 1.178 2021/06/30 10:08:48 christos Exp $"</literal></argument>)</argument_list></macro>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BUILTIN_ELF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNISTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"readelf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"magic.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ELFCORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>private</name> <name>int</name></type> <name>dophn_core</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>off_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>,
<parameter><decl><type><name>off_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>private</name> <name>int</name></type> <name>dophn_exec</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>off_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>,
<parameter><decl><type><name>off_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>private</name> <name>int</name></type> <name>doshn</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>off_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>,
<parameter><decl><type><name>off_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>private</name> <name>size_t</name></type> <name>donote</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>,
<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>off_t</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>off_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELF_ALIGN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((a) + align - 1) / align) * align)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isquote</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(strchr("'\"`", (c)) != NULL)</cpp:value></cpp:define>

<function_decl><type><name>private</name> <name>uint16_t</name></type> <name>getu16</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>private</name> <name>uint32_t</name></type> <name>getu32</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>private</name> <name>uint64_t</name></type> <name>getu64</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PHNUM</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SHNUM</name></cpp:macro> <cpp:value>32768</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_UNKNOWN</name></cpp:macro> <cpp:value>CAST(off_t, -1)</cpp:value></cpp:define>

<function><type><name>private</name> <name>int</name></type>
<name>toomany</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MAGIC_MIME</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", too many %s (%u)"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>private</name> <name>uint16_t</name></type>
<name>getu16</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<union>union <block>{
<decl_stmt><decl><type><name>uint16_t</name></type> <name>ui</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>retval</name></decl>, <decl><type ref="prev"/><name>tmpval</name></decl>;</union>

<if_stmt><if>if <condition>(<expr><name>swap</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tmpval</name><operator>.</operator><name>ui</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<return>return <expr><name><name>retval</name><operator>.</operator><name>ui</name></name></expr>;</return>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<return>return <expr><name>value</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>private</name> <name>uint32_t</name></type>
<name>getu32</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<union>union <block>{
<decl_stmt><decl><type><name>uint32_t</name></type> <name>ui</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>retval</name></decl>, <decl><type ref="prev"/><name>tmpval</name></decl>;</union>

<if_stmt><if>if <condition>(<expr><name>swap</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tmpval</name><operator>.</operator><name>ui</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<return>return <expr><name><name>retval</name><operator>.</operator><name>ui</name></name></expr>;</return>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<return>return <expr><name>value</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>private</name> <name>uint64_t</name></type>
<name>getu64</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<union>union <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ui</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>retval</name></decl>, <decl><type ref="prev"/><name>tmpval</name></decl>;</union>

<if_stmt><if>if <condition>(<expr><name>swap</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>tmpval</name><operator>.</operator><name>ui</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name><name>tmpval</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<return>return <expr><name><name>retval</name><operator>.</operator><name>ui</name></name></expr>;</return>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<return>return <expr><name>value</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>elf_getu16</name><parameter_list>(<parameter><type><name>swap</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>getu16(swap, value)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>elf_getu32</name><parameter_list>(<parameter><type><name>swap</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>getu32(swap, value)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>elf_getu64</name><parameter_list>(<parameter><type><name>swap</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>getu64(swap, value)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xsh_addr</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? CAST(void *, &amp;sh32) : CAST(void *, &amp;sh64))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xsh_sizeof</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? sizeof(sh32) : sizeof(sh64))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xsh_size</name></cpp:macro> <cpp:value>CAST(size_t, (clazz == ELFCLASS32 ? elf_getu32(swap, sh32.sh_size) : elf_getu64(swap, sh64.sh_size)))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xsh_offset</name></cpp:macro> <cpp:value>CAST(off_t, (clazz == ELFCLASS32 ? elf_getu32(swap, sh32.sh_offset) : elf_getu64(swap, sh64.sh_offset)))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xsh_type</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? elf_getu32(swap, sh32.sh_type) : elf_getu32(swap, sh64.sh_type))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xsh_name</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? elf_getu32(swap, sh32.sh_name) : elf_getu32(swap, sh64.sh_name))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xph_addr</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? CAST(void *, &amp;ph32) : CAST(void *, &amp;ph64))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xph_sizeof</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? sizeof(ph32) : sizeof(ph64))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xph_type</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? elf_getu32(swap, ph32.p_type) : elf_getu32(swap, ph64.p_type))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xph_offset</name></cpp:macro> <cpp:value>CAST(off_t, (clazz == ELFCLASS32 ? elf_getu32(swap, ph32.p_offset) : elf_getu64(swap, ph64.p_offset)))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xph_align</name></cpp:macro> <cpp:value>CAST(size_t, (clazz == ELFCLASS32 ? CAST(off_t, (ph32.p_align ? elf_getu32(swap, ph32.p_align) : 4)): CAST(off_t, (ph64.p_align ? elf_getu64(swap, ph64.p_align) : 4))))</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xph_vaddr</name></cpp:macro> <cpp:value>CAST(size_t, (clazz == ELFCLASS32 ? CAST(off_t, (ph32.p_vaddr ? elf_getu32(swap, ph32.p_vaddr) : 4)): CAST(off_t, (ph64.p_vaddr ? elf_getu64(swap, ph64.p_vaddr) : 4))))</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xph_filesz</name></cpp:macro> <cpp:value>CAST(size_t, (clazz == ELFCLASS32 ? elf_getu32(swap, ph32.p_filesz) : elf_getu64(swap, ph64.p_filesz)))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xph_memsz</name></cpp:macro> <cpp:value>CAST(size_t, ((clazz == ELFCLASS32 ? elf_getu32(swap, ph32.p_memsz) : elf_getu64(swap, ph64.p_memsz))))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xnh_addr</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? CAST(void *, &amp;nh32) : CAST(void *, &amp;nh64))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xnh_sizeof</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? sizeof(nh32) : sizeof(nh64))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xnh_type</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? elf_getu32(swap, nh32.n_type) : elf_getu32(swap, nh64.n_type))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xnh_namesz</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? elf_getu32(swap, nh32.n_namesz) : elf_getu32(swap, nh64.n_namesz))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xnh_descsz</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? elf_getu32(swap, nh32.n_descsz) : elf_getu32(swap, nh64.n_descsz))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xdh_addr</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? CAST(void *, &amp;dh32) : CAST(void *, &amp;dh64))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xdh_sizeof</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? sizeof(dh32) : sizeof(dh64))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xdh_tag</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? elf_getu32(swap, dh32.d_tag) : elf_getu64(swap, dh64.d_tag))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xdh_val</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? elf_getu32(swap, dh32.d_un.d_val) : elf_getu64(swap, dh64.d_un.d_val))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xcap_addr</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? CAST(void *, &amp;cap32) : CAST(void *, &amp;cap64))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xcap_sizeof</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? sizeof(cap32) : sizeof(cap64))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xcap_tag</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? elf_getu32(swap, cap32.c_tag) : elf_getu64(swap, cap64.c_tag))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xcap_val</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? elf_getu32(swap, cap32.c_un.c_val) : elf_getu64(swap, cap64.c_un.c_val))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xauxv_addr</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? CAST(void *, &amp;auxv32) : CAST(void *, &amp;auxv64))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xauxv_sizeof</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? sizeof(auxv32) : sizeof(auxv64))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xauxv_type</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? elf_getu32(swap, auxv32.a_type) : elf_getu64(swap, auxv64.a_type))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xauxv_val</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? elf_getu32(swap, auxv32.a_v) : elf_getu64(swap, auxv64.a_v))</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>prpsoffsets</name><parameter_list>(<parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? prpsoffsets32[i] : prpsoffsets64[i])</cpp:value></cpp:define>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ELFCORE</name></expr></argument>)</argument_list></call></expr></cpp:if>




<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name><name>prpsoffsets32</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NT_PSINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><literal type="number">104</literal></expr>,
<expr><literal type="number">88</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><literal type="number">100</literal></expr>,
<expr><literal type="number">84</literal></expr>,

<expr><literal type="number">44</literal></expr>,
<expr><literal type="number">28</literal></expr>,

<expr><literal type="number">48</literal></expr>,
<expr><literal type="number">32</literal></expr>,

<expr><literal type="number">8</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name><name>prpsoffsets64</name><index>[]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NT_PSINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><literal type="number">152</literal></expr>,
<expr><literal type="number">136</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><literal type="number">136</literal></expr>,
<expr><literal type="number">120</literal></expr>,

<expr><literal type="number">56</literal></expr>,
<expr><literal type="number">40</literal></expr>,

<expr><literal type="number">16</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOFFSETS32</name></cpp:macro> <cpp:value>__arraycount(prpsoffsets32)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOFFSETS64</name></cpp:macro> <cpp:value>__arraycount(prpsoffsets64)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NOFFSETS</name></cpp:macro> <cpp:value>(clazz == ELFCLASS32 ? NOFFSETS32 : NOFFSETS64)</cpp:value></cpp:define>






























<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OS_STYLE_SVR4</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OS_STYLE_FREEBSD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OS_STYLE_NETBSD</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<decl_stmt><decl><type><name>private</name> <specifier>const</specifier> <name>char</name></type> <name><name>os_style_names</name><index>[]</index><index>[<expr><literal type="number">8</literal></expr>]</index></name> <init>= <expr><block>{
<expr><literal type="string">"SVR4"</literal></expr>,
<expr><literal type="string">"FreeBSD"</literal></expr>,
<expr><literal type="string">"NetBSD"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_CORE_STYLE</name></cpp:macro> <cpp:value>0x0003</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_DID_CORE</name></cpp:macro> <cpp:value>0x0004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_DID_OS_NOTE</name></cpp:macro> <cpp:value>0x0008</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_DID_BUILD_ID</name></cpp:macro> <cpp:value>0x0010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_DID_CORE_STYLE</name></cpp:macro> <cpp:value>0x0020</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_DID_NETBSD_PAX</name></cpp:macro> <cpp:value>0x0040</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_DID_NETBSD_MARCH</name></cpp:macro> <cpp:value>0x0080</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_DID_NETBSD_CMODEL</name></cpp:macro> <cpp:value>0x0100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_DID_NETBSD_EMULATION</name></cpp:macro> <cpp:value>0x0200</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_DID_NETBSD_UNKNOWN</name></cpp:macro> <cpp:value>0x0400</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_IS_CORE</name></cpp:macro> <cpp:value>0x0800</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAGS_DID_AUXV</name></cpp:macro> <cpp:value>0x1000</cpp:value></cpp:define>

<function><type><name>private</name> <name>int</name></type>
<name>dophn_core</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>clazz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>off</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>fsize</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>notecount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf32_Phdr</name></type> <name>ph32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Phdr</name></type> <name>ph64</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>nbuf</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bufsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>ph_off</name> <init>= <expr><name>off</name></expr></init></decl>, <decl><type ref="prev"/><name>offs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ph_num</name> <init>= <expr><name>num</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MAGIC_MIME</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", no program header"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name>xph_sizeof</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", corrupted program header size"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>




<for>for <control>( <init>;</init> <condition><expr><name>num</name></expr>;</condition> <incr><expr><name>num</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>xph_addr</name></expr></argument>, <argument><expr><name>xph_sizeof</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
<call><name>CAST</name><argument_list>(<argument><expr><name>ssize_t</name></expr></argument>, <argument><expr><name>xph_sizeof</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">", can't read elf program headers at %jd"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name>off</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>off</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fsize</name> <operator>!=</operator> <name>SIZE_UNKNOWN</name> <operator>&amp;&amp;</operator> <name>xph_offset</name> <operator>&gt;</operator> <name>fsize</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>xph_type</name> <operator>!=</operator> <name>PT_NOTE</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>





<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><name>xph_filesz</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></sizeof></expr> ?</condition><then> <expr><name>xph_filesz</name></expr> </then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>offs</name> <operator>=</operator> <name>xph_offset</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>bufsize</name> <operator>=</operator> <call><name>pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">" can't read note section at %jd"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name>offs</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>donote</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>clazz</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>notecount</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ph_off</name></expr></argument>,
<argument><expr><name>ph_num</name></expr></argument>, <argument><expr><name>fsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>do_note_netbsd_version</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>desc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", for NetBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>












<if_stmt><if>if <condition>(<expr><name>desc</name> <operator>&gt;</operator> <literal type="number">100000000U</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>ver_patch</name> <init>= <expr><operator>(</operator><name>desc</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator> <operator>%</operator> <literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>ver_rel</name> <init>= <expr><operator>(</operator><name>desc</name> <operator>/</operator> <literal type="number">10000</literal><operator>)</operator> <operator>%</operator> <literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>ver_min</name> <init>= <expr><operator>(</operator><name>desc</name> <operator>/</operator> <literal type="number">1000000</literal><operator>)</operator> <operator>%</operator> <literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>ver_maj</name> <init>= <expr><name>desc</name> <operator>/</operator> <literal type="number">100000000</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">" %u.%u"</literal></expr></argument>, <argument><expr><name>ver_maj</name></expr></argument>, <argument><expr><name>ver_min</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ver_rel</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ver_patch</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">".%u"</literal></expr></argument>, <argument><expr><name>ver_patch</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>ver_rel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name>ver_rel</name> <operator>&gt;</operator> <literal type="number">26</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">"Z"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ver_rel</name> <operator>-=</operator> <literal type="number">26</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><literal type="char">'A'</literal> <operator>+</operator> <name>ver_rel</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call>
<operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>do_note_freebsd_version</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>desc</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", for FreeBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>



























<if_stmt><if>if <condition>(<expr><name>desc</name> <operator>==</operator> <literal type="number">460002</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">" 4.6.2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>desc</name> <operator>&lt;</operator> <literal type="number">460100</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">" %d.%d"</literal></expr></argument>, <argument><expr><name>desc</name> <operator>/</operator> <literal type="number">100000</literal></expr></argument>,
<argument><expr><name>desc</name> <operator>/</operator> <literal type="number">10000</literal> <operator>%</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>desc</name> <operator>/</operator> <literal type="number">1000</literal> <operator>%</operator> <literal type="number">10</literal> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">".%d"</literal></expr></argument>, <argument><expr><name>desc</name> <operator>/</operator> <literal type="number">1000</literal> <operator>%</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>desc</name> <operator>%</operator> <literal type="number">1000</literal> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>desc</name> <operator>%</operator> <literal type="number">100000</literal> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">" (%d)"</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>desc</name> <operator>&lt;</operator> <literal type="number">500000</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">" %d.%d"</literal></expr></argument>, <argument><expr><name>desc</name> <operator>/</operator> <literal type="number">100000</literal></expr></argument>,
<argument><expr><name>desc</name> <operator>/</operator> <literal type="number">10000</literal> <operator>%</operator> <literal type="number">10</literal> <operator>+</operator> <name>desc</name> <operator>/</operator> <literal type="number">1000</literal> <operator>%</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>desc</name> <operator>/</operator> <literal type="number">100</literal> <operator>%</operator> <literal type="number">10</literal> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">" (%d)"</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>desc</name> <operator>/</operator> <literal type="number">10</literal> <operator>%</operator> <literal type="number">10</literal> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">".%d"</literal></expr></argument>, <argument><expr><name>desc</name> <operator>/</operator> <literal type="number">10</literal> <operator>%</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">" %d.%d"</literal></expr></argument>, <argument><expr><name>desc</name> <operator>/</operator> <literal type="number">100000</literal></expr></argument>,
<argument><expr><name>desc</name> <operator>/</operator> <literal type="number">1000</literal> <operator>%</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>desc</name> <operator>/</operator> <literal type="number">100</literal> <operator>%</operator> <literal type="number">10</literal> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>desc</name> <operator>%</operator> <literal type="number">100000</literal> <operator>/</operator> <literal type="number">100</literal> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">" (%d)"</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>desc</name> <operator>/</operator> <literal type="number">10</literal> <operator>%</operator> <literal type="number">10</literal> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">".%d"</literal></expr></argument>, <argument><expr><name>desc</name> <operator>/</operator> <literal type="number">10</literal> <operator>%</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>private</name> <name>int</name></type>

<name>do_bid_note</name><argument_list>(<argument><expr>struct <name>magic_set</name> <operator>*</operator><name>ms</name></expr></argument>, <argument><expr><name>unsigned</name> <name>char</name> <operator>*</operator><name>nbuf</name></expr></argument>, <argument><expr><name>uint32_t</name> <name>type</name></expr></argument>,
<argument><expr><name>int</name> <name>swap</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uint32_t</name> <name>namesz</name></expr></argument>, <argument><expr><name>uint32_t</name> <name>descsz</name></expr></argument>,
<argument><expr><name>size_t</name> <name>noff</name></expr></argument>, <argument><expr><name>size_t</name> <name>doff</name></expr></argument>, <argument><expr><name>int</name> <operator>*</operator><name>flags</name></expr></argument>)</argument_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>namesz</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>noff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"GNU"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name>type</name> <operator>==</operator> <name>NT_GNU_BUILD_ID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>descsz</name> <operator>&gt;=</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>descsz</name> <operator>&lt;=</operator> <literal type="number">20</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>desc</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>btype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_BUILD_ID</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>descsz</name></expr>)</condition> <block>{<block_content>
<case>case <expr><literal type="number">8</literal></expr>:</case>
<expr_stmt><expr><name>btype</name> <operator>=</operator> <literal type="string">"xxHash"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">16</literal></expr>:</case>
<expr_stmt><expr><name>btype</name> <operator>=</operator> <literal type="string">"md5/uuid"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">20</literal></expr>:</case>
<expr_stmt><expr><name>btype</name> <operator>=</operator> <literal type="string">"sha1"</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>btype</name> <operator>=</operator> <literal type="string">"unknown"</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", BuildID[%s]="</literal></expr></argument>, <argument><expr><name>btype</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>doff</name></expr>]</index></name></expr></argument>, <argument><expr><name>descsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>descsz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>desc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>namesz</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>noff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"Go"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name>type</name> <operator>==</operator> <name>NT_GO_BUILD_ID</name> <operator>&amp;&amp;</operator> <name>descsz</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", Go BuildID=%s"</literal></expr></argument>,
<argument><expr><call><name>file_copystr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>descsz</name></expr></argument>,
<argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>doff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name>private</name> <name>int</name></type>
<name>do_os_note</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>nbuf</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>namesz</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>descsz</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>noff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>doff</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>RCAST</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>noff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>namesz</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"SuSE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name>type</name> <operator>==</operator> <name>NT_GNU_VERSION</name> <operator>&amp;&amp;</operator> <name>descsz</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_OS_NOTE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", for SuSE %d.%d"</literal></expr></argument>, <argument><expr><name><name>nbuf</name><index>[<expr><name>doff</name></expr>]</index></name></expr></argument>,
<argument><expr><name><name>nbuf</name><index>[<expr><name>doff</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>namesz</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"GNU"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name>type</name> <operator>==</operator> <name>NT_GNU_VERSION</name> <operator>&amp;&amp;</operator> <name>descsz</name> <operator>==</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>desc</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>doff</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_OS_NOTE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", for GNU/"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name><name>desc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>GNU_OS_LINUX</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">"Linux"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>GNU_OS_HURD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">"Hurd"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>GNU_OS_SOLARIS</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">"Solaris"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>GNU_OS_KFREEBSD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">"kFreeBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>GNU_OS_KNETBSD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">"kNetBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">"&lt;unknown&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">" %d.%d.%d"</literal></expr></argument>, <argument><expr><call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name><name>desc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name><name>desc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name><name>desc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>namesz</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"NetBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>NT_NETBSD_VERSION</name> <operator>&amp;&amp;</operator> <name>descsz</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_OS_NOTE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>do_note_netbsd_version</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>doff</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>namesz</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"FreeBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>NT_FREEBSD_VERSION</name> <operator>&amp;&amp;</operator> <name>descsz</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_OS_NOTE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>do_note_freebsd_version</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>doff</name></expr>]</index></name></expr></argument>)</argument_list></call>
<operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>namesz</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"OpenBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name>type</name> <operator>==</operator> <name>NT_OPENBSD_VERSION</name> <operator>&amp;&amp;</operator> <name>descsz</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_OS_NOTE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", for OpenBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>namesz</name> <operator>==</operator> <literal type="number">10</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"DragonFly"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name>type</name> <operator>==</operator> <name>NT_DRAGONFLY_VERSION</name> <operator>&amp;&amp;</operator> <name>descsz</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>desc</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_OS_NOTE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", for DragonFly"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>doff</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">" %d.%d.%d"</literal></expr></argument>, <argument><expr><name>desc</name> <operator>/</operator> <literal type="number">100000</literal></expr></argument>,
<argument><expr><name>desc</name> <operator>/</operator> <literal type="number">10000</literal> <operator>%</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><name>desc</name> <operator>%</operator> <literal type="number">10000</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>private</name> <name>int</name></type>
<name>do_pax_note</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>nbuf</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>namesz</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>descsz</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>noff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>doff</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>RCAST</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>noff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>namesz</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"PaX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<name>type</name> <operator>==</operator> <name>NT_NETBSD_PAX</name> <operator>&amp;&amp;</operator> <name>descsz</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>pax</name><index>[]</index></name> <init>= <expr><block>{
<expr><literal type="string">"+mprotect"</literal></expr>,
<expr><literal type="string">"-mprotect"</literal></expr>,
<expr><literal type="string">"+segvguard"</literal></expr>,
<expr><literal type="string">"-segvguard"</literal></expr>,
<expr><literal type="string">"+ASLR"</literal></expr>,
<expr><literal type="string">"-ASLR"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>desc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>did</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_NETBSD_PAX</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>doff</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>desc</name> <operator>&amp;&amp;</operator> <call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", PaX: "</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>__arraycount</name><argument_list>(<argument><expr><name>pax</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;</operator> <name>desc</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>did</name><operator>++</operator></expr> ?</condition><then> <expr><literal type="string">","</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><name><name>pax</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>private</name> <name>int</name></type>
<name>do_core_note</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>nbuf</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>type</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>namesz</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>descsz</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>noff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>doff</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>clazz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ELFCORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>RCAST</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>noff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>os_style</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>














<if_stmt><if>if <condition>(<expr><operator>(</operator><name>namesz</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"CORE"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
<operator>(</operator><name>namesz</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"CORE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>os_style</name> <operator>=</operator> <name>OS_STYLE_SVR4</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>namesz</name> <operator>==</operator> <literal type="number">8</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"FreeBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>os_style</name> <operator>=</operator> <name>OS_STYLE_FREEBSD</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>namesz</name> <operator>&gt;=</operator> <literal type="number">11</literal> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"NetBSD-CORE"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call>
<operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>os_style</name> <operator>=</operator> <name>OS_STYLE_NETBSD</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>os_style</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>FLAGS_DID_CORE_STYLE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", %s-style"</literal></expr></argument>, <argument><expr><name><name>os_style_names</name><index>[<expr><name>os_style</name></expr>]</index></name></expr></argument>)</argument_list></call>
<operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_CORE_STYLE</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>os_style</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>os_style</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OS_STYLE_NETBSD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>NT_NETBSD_CORE_PROCINFO</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>sbuf</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>NetBSD_elfcore_procinfo</name></name></type> <name>pi</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pi</name></expr></argument>, <argument><expr><name>nbuf</name> <operator>+</operator> <name>doff</name></expr></argument>, <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>descsz</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", from '%.31s', pid=%u, uid=%u, "</literal>
<literal type="string">"gid=%u, nlwps=%u, lwp=%u (signal %u/code %u)"</literal></expr></argument>,
<argument><expr><call><name>file_printable</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>pi</name><operator>.</operator><name>cpi_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>pi</name><operator>.</operator><name>cpi_name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><name><name>pi</name><operator>.</operator><name>cpi_pid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name><name>pi</name><operator>.</operator><name>cpi_euid</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name><name>pi</name><operator>.</operator><name>cpi_egid</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name><name>pi</name><operator>.</operator><name>cpi_nlwps</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><name><name>pi</name><operator>.</operator><name>cpi_siglwp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name><name>pi</name><operator>.</operator><name>cpi_signo</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name><name>pi</name><operator>.</operator><name>cpi_sigcode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_CORE</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>OS_STYLE_FREEBSD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>NT_PRPSINFO</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>FLAGS_IS_CORE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>argoff</name></decl>, <decl><type ref="prev"/><name>pidoff</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>clazz</name> <operator>==</operator> <name>ELFCLASS32</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>argoff</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">17</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>argoff</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">4</literal> <operator>+</operator> <literal type="number">8</literal> <operator>+</operator> <literal type="number">17</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", from '%.80s'"</literal></expr></argument>, <argument><expr><name>nbuf</name> <operator>+</operator> <name>doff</name> <operator>+</operator>
<name>argoff</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pidoff</name> <operator>=</operator> <name>argoff</name> <operator>+</operator> <literal type="number">81</literal> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>doff</name> <operator>+</operator> <name>pidoff</name> <operator>+</operator> <literal type="number">4</literal> <operator>&lt;=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", pid=%u"</literal></expr></argument>,
<argument><expr><call><name>elf_getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><operator>*</operator><call><name>RCAST</name><argument_list>(<argument><expr><name>uint32_t</name> <operator>*</operator></expr></argument>, <argument><expr><operator>(</operator><name>nbuf</name> <operator>+</operator>
<name>doff</name> <operator>+</operator> <name>pidoff</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_CORE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>NT_PRPSINFO</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>FLAGS_IS_CORE</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>










<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NOFFSETS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cname</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>reloffset</name> <init>= <expr><call><name>prpsoffsets</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>noffset</name> <init>= <expr><name>doff</name> <operator>+</operator> <name>reloffset</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>k</name></decl>;</decl_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr><operator>,</operator> <expr><name>noffset</name><operator>++</operator></expr><operator>,</operator>
<expr><name>reloffset</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>





<if_stmt><if>if <condition>(<expr><name>noffset</name> <operator>&gt;=</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>tryanother</name>;</goto></block_content></block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><name>reloffset</name> <operator>&gt;=</operator> <name>descsz</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>tryanother</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>nbuf</name><index>[<expr><name>noffset</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>







<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>tryanother</name>;</goto></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<break>break;</break></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>





<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isprint</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isquote</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>tryanother</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>








<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr> ;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>NOFFSETS</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>no</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>adjust</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>prpsoffsets</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <call><name>prpsoffsets</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>no</name> <operator>=</operator> <name>doff</name> <operator>+</operator> <call><name>prpsoffsets</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>no</name> <operator>&lt;</operator> <name>doff</name> <operator>+</operator> <call><name>prpsoffsets</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>no</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>adjust</name> <operator>=</operator> <name>adjust</name>
<operator>&amp;&amp;</operator> <call><name>isprint</name><argument_list>(<argument><expr><name><name>nbuf</name><index>[<expr><name>no</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>adjust</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>cname</name> <operator>=</operator> <macro><name>CAST</name><argument_list>(<argument>unsigned char *</argument>,
<argument>&amp;nbuf[doff + prpsoffsets(i)]</argument>)</argument_list></macro></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>cname</name></expr>;</init> <condition><expr><name>cp</name> <operator>&lt;</operator> <name>nbuf</name> <operator>+</operator> <name>size</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cp</name>
<operator>&amp;&amp;</operator> <call><name>isprint</name><argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>




<while>while <condition>(<expr><name>cp</name> <operator>&gt;</operator> <name>cname</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><name><name>cp</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cp</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", from '%s'"</literal></expr></argument>,
<argument><expr><call><name>file_copystr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>cp</name> <operator>-</operator> <name>cname</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>cname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_CORE</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>

<label><name>tryanother</name>:</label>
<empty_stmt>;</empty_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>private</name> <name>off_t</name></type>
<name>get_offset_from_virtaddr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>clazz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>,
<parameter><decl><type><name>off_t</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>fsize</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>virtaddr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf32_Phdr</name></type> <name>ph32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Phdr</name></type> <name>ph64</name></decl>;</decl_stmt>





<for>for <control>( <init>;</init> <condition><expr><name>num</name></expr>;</condition> <incr><expr><name>num</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>xph_addr</name></expr></argument>, <argument><expr><name>xph_sizeof</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
<call><name>CAST</name><argument_list>(<argument><expr><name>ssize_t</name></expr></argument>, <argument><expr><name>xph_sizeof</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">", can't read elf program header at %jd"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name>off</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>off</name> <operator>+=</operator> <name>xph_sizeof</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fsize</name> <operator>!=</operator> <name>SIZE_UNKNOWN</name> <operator>&amp;&amp;</operator> <name>xph_offset</name> <operator>&gt;</operator> <name>fsize</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>virtaddr</name> <operator>&gt;=</operator> <name>xph_vaddr</name> <operator>&amp;&amp;</operator> <name>virtaddr</name> <operator>&lt;</operator> <name>xph_vaddr</name> <operator>+</operator> <name>xph_filesz</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>xph_offset</name> <operator>+</operator> <operator>(</operator><name>virtaddr</name> <operator>-</operator> <name>xph_vaddr</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>private</name> <name>size_t</name></type>
<name>get_string_on_virtaddr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>clazz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>ph_off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ph_num</name></decl></parameter>,
<parameter><decl><type><name>off_t</name></type> <name>fsize</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>virtaddr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>buflen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>offset</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>get_offset_from_virtaddr</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>, <argument><expr><name>clazz</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ph_off</name></expr></argument>, <argument><expr><name>ph_num</name></expr></argument>,
<argument><expr><name>fsize</name></expr></argument>, <argument><expr><name>virtaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<operator>(</operator><name>buflen</name> <operator>=</operator> <call><name>pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", can't read elf string at %jd"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>buflen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>



<for>for <control>(<init><expr><name>bptr</name> <operator>=</operator> <name>buf</name></expr>;</init> <condition><expr><operator>*</operator><name>bptr</name> <operator>&amp;&amp;</operator> <call><name>isprint</name><argument_list>(<argument><expr><macro><name>CAST</name><argument_list>(<argument>unsigned char</argument>, <argument>*bptr</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>bptr</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></for>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>bptr</name> <operator>-</operator> <name>buf</name></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name>private</name> <name>int</name></type>
<name>do_auxv_note</name><argument_list>(<argument><expr>struct <name>magic_set</name> <operator>*</operator><name>ms</name></expr></argument>, <argument><expr><name>unsigned</name> <name>char</name> <operator>*</operator><name>nbuf</name></expr></argument>, <argument><expr><name>uint32_t</name> <name>type</name></expr></argument>,
<argument><expr><name>int</name> <name>swap</name></expr></argument>, <argument><expr><name>uint32_t</name> <name>namesz</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>uint32_t</name> <name>descsz</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>size_t</name> <name>noff</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size_t</name> <name>doff</name></expr></argument>,
<argument><expr><name>int</name> <operator>*</operator><name>flags</name></expr></argument>, <argument><expr><name>size_t</name> <name>size</name> <call><name>__attribute__</name><argument_list>(<argument><expr><operator>(</operator><name>__unused__</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>int</name> <name>clazz</name></expr></argument>,
<argument><expr><name>int</name> <name>fd</name></expr></argument>, <argument><expr><name>off_t</name> <name>ph_off</name></expr></argument>, <argument><expr><name>int</name> <name>ph_num</name></expr></argument>, <argument><expr><name>off_t</name> <name>fsize</name></expr></argument>)</argument_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ELFCORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Aux32Info</name></type> <name>auxv32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Aux64Info</name></type> <name>auxv64</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>elsize</name> <init>= <expr><name>xauxv_sizeof</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>is_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nval</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>FLAGS_IS_CORE</name><operator>|</operator><name>FLAGS_DID_CORE_STYLE</name><operator>)</operator><operator>)</operator> <operator>!=</operator>
<operator>(</operator><name>FLAGS_IS_CORE</name><operator>|</operator><name>FLAGS_DID_CORE_STYLE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>FLAGS_CORE_STYLE</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>OS_STYLE_SVR4</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>NT_AUXV</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>notyet</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>OS_STYLE_NETBSD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>NT_NETBSD_CORE_AUXV</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<case>case <expr><name>OS_STYLE_FREEBSD</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>NT_FREEBSD_PROCSTAT_AUXV</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<default>default:</default>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></switch>

<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_AUXV</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><name>size_t</name></type> <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>off</name> <operator>+</operator> <name>elsize</name> <operator>&lt;=</operator> <name>descsz</name></expr>;</condition> <incr><expr><name>off</name> <operator>+=</operator> <name>elsize</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>xauxv_addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>doff</name> <operator>+</operator> <name>off</name></expr>]</index></name></expr></argument>, <argument><expr><name>xauxv_sizeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nval</name><operator>++</operator> <operator>&gt;=</operator> <literal type="number">50</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>file_error</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"Too many ELF Auxv elements"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<switch>switch<condition>(<expr><name>xauxv_type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>AT_LINUX_EXECFN</name></expr>:</case>
<expr_stmt><expr><name>is_string</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"execfn"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>AT_LINUX_PLATFORM</name></expr>:</case>
<expr_stmt><expr><name>is_string</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"platform"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>AT_LINUX_UID</name></expr>:</case>
<expr_stmt><expr><name>is_string</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"real uid"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>AT_LINUX_GID</name></expr>:</case>
<expr_stmt><expr><name>is_string</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"real gid"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>AT_LINUX_EUID</name></expr>:</case>
<expr_stmt><expr><name>is_string</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"effective uid"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>AT_LINUX_EGID</name></expr>:</case>
<expr_stmt><expr><name>is_string</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"effective gid"</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>is_string</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_string</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>buflen</name></decl>;</decl_stmt>
<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>get_string_on_virtaddr</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>, <argument><expr><name>clazz</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>,
<argument><expr><name>ph_off</name></expr></argument>, <argument><expr><name>ph_num</name></expr></argument>, <argument><expr><name>fsize</name></expr></argument>, <argument><expr><name>xauxv_val</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", %s: '%s'"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", %s: %d"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>,
<argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>xauxv_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></decl></decl_stmt>

<function><type><name>private</name> <name>size_t</name></type>
<name>dodynamic</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>clazz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pie</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>need</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf32_Dyn</name></type> <name>dh32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Dyn</name></type> <name>dh64</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dbuf</name> <init>= <macro><name>CAST</name><argument_list>(<argument>unsigned char *</argument>, <argument>vbuf</argument>)</argument_list></macro></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>xdh_sizeof</name> <operator>+</operator> <name>offset</name> <operator>&gt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>



<return>return <expr><name>xdh_sizeof</name> <operator>+</operator> <name>offset</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>xdh_addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>dbuf</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>xdh_sizeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>xdh_sizeof</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>xdh_tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DT_FLAGS_1</name></expr>:</case>
<expr_stmt><expr><operator>*</operator><name>pie</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>xdh_val</name> <operator>&amp;</operator> <name>DF_1_PIE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>mode</name></name> <operator>|=</operator> <literal type="number">0111</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">0111</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>DT_NEEDED</name></expr>:</case>
<expr_stmt><expr><operator>(</operator><operator>*</operator><name>need</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>private</name> <name>size_t</name></type>
<name>donote</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>vbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>clazz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>align</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>notecount</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>ph_off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ph_num</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>fsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf32_Nhdr</name></type> <name>nh32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Nhdr</name></type> <name>nh64</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>noff</name></decl>, <decl><type ref="prev"/><name>doff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>namesz</name></decl>, <decl><type ref="prev"/><name>descsz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>nbuf</name> <init>= <macro><name>CAST</name><argument_list>(<argument>unsigned char *</argument>, <argument>vbuf</argument>)</argument_list></macro></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>notecount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>--</operator><operator>*</operator><name>notecount</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>xnh_sizeof</name> <operator>+</operator> <name>offset</name> <operator>&gt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>



<return>return <expr><name>xnh_sizeof</name> <operator>+</operator> <name>offset</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nh32</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nh32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nh64</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nh64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>xnh_addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>xnh_sizeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>xnh_sizeof</name></expr>;</expr_stmt>

<expr_stmt><expr><name>namesz</name> <operator>=</operator> <name>xnh_namesz</name></expr>;</expr_stmt>
<expr_stmt><expr><name>descsz</name> <operator>=</operator> <name>xnh_descsz</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>namesz</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>descsz</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>



<return>return <expr><ternary><condition><expr><operator>(</operator><name>offset</name> <operator>&gt;=</operator> <name>size</name><operator>)</operator></expr> ?</condition><then> <expr><name>offset</name></expr> </then><else>: <expr><name>size</name></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>namesz</name> <operator>&amp;</operator> <literal type="number">0x80000000</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", bad note name size %#lx"</literal></expr></argument>,
<argument><expr><macro><name>CAST</name><argument_list>(<argument>unsigned long</argument>, <argument>namesz</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>descsz</name> <operator>&amp;</operator> <literal type="number">0x80000000</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", bad note description size %#lx"</literal></expr></argument>,
<argument><expr><macro><name>CAST</name><argument_list>(<argument>unsigned long</argument>, <argument>descsz</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>noff</name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>doff</name> <operator>=</operator> <call><name>ELF_ALIGN</name><argument_list>(<argument><expr><name>offset</name> <operator>+</operator> <name>namesz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>+</operator> <name>namesz</name> <operator>&gt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>



<return>return <expr><name>doff</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>ELF_ALIGN</name><argument_list>(<argument><expr><name>doff</name> <operator>+</operator> <name>descsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>doff</name> <operator>+</operator> <name>descsz</name> <operator>&gt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>



<return>return <expr><ternary><condition><expr><operator>(</operator><name>offset</name> <operator>&gt;=</operator> <name>size</name><operator>)</operator></expr> ?</condition><then> <expr><name>offset</name></expr> </then><else>: <expr><name>size</name></expr></else></ternary></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>FLAGS_DID_OS_NOTE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>do_os_note</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>xnh_type</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>,
<argument><expr><name>namesz</name></expr></argument>, <argument><expr><name>descsz</name></expr></argument>, <argument><expr><name>noff</name></expr></argument>, <argument><expr><name>doff</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>offset</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>FLAGS_DID_BUILD_ID</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>do_bid_note</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>xnh_type</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>,
<argument><expr><name>namesz</name></expr></argument>, <argument><expr><name>descsz</name></expr></argument>, <argument><expr><name>noff</name></expr></argument>, <argument><expr><name>doff</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>offset</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>FLAGS_DID_NETBSD_PAX</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>do_pax_note</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>xnh_type</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>,
<argument><expr><name>namesz</name></expr></argument>, <argument><expr><name>descsz</name></expr></argument>, <argument><expr><name>noff</name></expr></argument>, <argument><expr><name>doff</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>offset</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>FLAGS_DID_CORE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>do_core_note</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>xnh_type</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>,
<argument><expr><name>namesz</name></expr></argument>, <argument><expr><name>descsz</name></expr></argument>, <argument><expr><name>noff</name></expr></argument>, <argument><expr><name>doff</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>clazz</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>offset</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>FLAGS_DID_AUXV</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>do_auxv_note</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>xnh_type</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>,
<argument><expr><name>namesz</name></expr></argument>, <argument><expr><name>descsz</name></expr></argument>, <argument><expr><name>noff</name></expr></argument>, <argument><expr><name>doff</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>clazz</name></expr></argument>,
<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ph_off</name></expr></argument>, <argument><expr><name>ph_num</name></expr></argument>, <argument><expr><name>fsize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>offset</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>namesz</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><call><name>RCAST</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>noff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"NetBSD"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>descw</name></decl>, <decl><type ref="prev"/><name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>descsz</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>descsz</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<switch>switch <condition>(<expr><name>xnh_type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NT_NETBSD_VERSION</name></expr>:</case>
<return>return <expr><name>offset</name></expr>;</return>
<case>case <expr><name>NT_NETBSD_MARCH</name></expr>:</case>
<expr_stmt><expr><name>flag</name> <operator>=</operator> <name>FLAGS_DID_NETBSD_MARCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"compiled for"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>NT_NETBSD_CMODEL</name></expr>:</case>
<expr_stmt><expr><name>flag</name> <operator>=</operator> <name>FLAGS_DID_NETBSD_CMODEL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"compiler model"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>NT_NETBSD_EMULATION</name></expr>:</case>
<expr_stmt><expr><name>flag</name> <operator>=</operator> <name>FLAGS_DID_NETBSD_EMULATION</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <literal type="string">"emulation:"</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>FLAGS_DID_NETBSD_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>offset</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>FLAGS_DID_NETBSD_UNKNOWN</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", note=%u"</literal></expr></argument>, <argument><expr><name>xnh_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>offset</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>flags</name> <operator>&amp;</operator> <name>flag</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>offset</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>RCAST</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nbuf</name><index>[<expr><name>doff</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>descw</name> <operator>=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>descsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>flags</name> <operator>|=</operator> <name>flag</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", %s: %s"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>,
<argument><expr><call><name>file_copystr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>descw</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>


<typedef>typedef <type><struct>struct <name>cap_desc</name> <block>{
<decl_stmt><decl><type><name>uint64_t</name></type> <name>cd_mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cd_name</name></decl>;</decl_stmt>
}</block></struct></type> <name>cap_desc_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>cap_desc_t</name></type> <name><name>cap_desc_sparc</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>AV_SPARC_MUL32</name></expr>, <expr><literal type="string">"MUL32"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_SPARC_DIV32</name></expr>, <expr><literal type="string">"DIV32"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_SPARC_FSMULD</name></expr>, <expr><literal type="string">"FSMULD"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_SPARC_V8PLUS</name></expr>, <expr><literal type="string">"V8PLUS"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_SPARC_POPC</name></expr>, <expr><literal type="string">"POPC"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_SPARC_VIS</name></expr>, <expr><literal type="string">"VIS"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_SPARC_VIS2</name></expr>, <expr><literal type="string">"VIS2"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_SPARC_ASI_BLK_INIT</name></expr>, <expr><literal type="string">"ASI_BLK_INIT"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_SPARC_FMAF</name></expr>, <expr><literal type="string">"FMAF"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_SPARC_FJFMAU</name></expr>, <expr><literal type="string">"FJFMAU"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_SPARC_IMA</name></expr>, <expr><literal type="string">"IMA"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>cap_desc_t</name></type> <name><name>cap_desc_386</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr><name>AV_386_FPU</name></expr>, <expr><literal type="string">"FPU"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_TSC</name></expr>, <expr><literal type="string">"TSC"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_CX8</name></expr>, <expr><literal type="string">"CX8"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_SEP</name></expr>, <expr><literal type="string">"SEP"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_AMD_SYSC</name></expr>, <expr><literal type="string">"AMD_SYSC"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_CMOV</name></expr>, <expr><literal type="string">"CMOV"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_MMX</name></expr>, <expr><literal type="string">"MMX"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_AMD_MMX</name></expr>, <expr><literal type="string">"AMD_MMX"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_AMD_3DNow</name></expr>, <expr><literal type="string">"AMD_3DNow"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_AMD_3DNowx</name></expr>, <expr><literal type="string">"AMD_3DNowx"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_FXSR</name></expr>, <expr><literal type="string">"FXSR"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_SSE</name></expr>, <expr><literal type="string">"SSE"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_SSE2</name></expr>, <expr><literal type="string">"SSE2"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_PAUSE</name></expr>, <expr><literal type="string">"PAUSE"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_SSE3</name></expr>, <expr><literal type="string">"SSE3"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_MON</name></expr>, <expr><literal type="string">"MON"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_CX16</name></expr>, <expr><literal type="string">"CX16"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_AHF</name></expr>, <expr><literal type="string">"AHF"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_TSCP</name></expr>, <expr><literal type="string">"TSCP"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_AMD_SSE4A</name></expr>, <expr><literal type="string">"AMD_SSE4A"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_POPCNT</name></expr>, <expr><literal type="string">"POPCNT"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_AMD_LZCNT</name></expr>, <expr><literal type="string">"AMD_LZCNT"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_SSSE3</name></expr>, <expr><literal type="string">"SSSE3"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_SSE4_1</name></expr>, <expr><literal type="string">"SSE4.1"</literal></expr> }</block></expr>,
<expr><block>{ <expr><name>AV_386_SSE4_2</name></expr>, <expr><literal type="string">"SSE4.2"</literal></expr> }</block></expr>,
<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>private</name> <name>int</name></type>
<name>doshn</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>clazz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>off</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>fsize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mach</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>strtab</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>,
<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>notecount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf32_Shdr</name></type> <name>sh32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Shdr</name></type> <name>sh64</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stripped</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>has_debug_info</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nbadcap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>nbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>noff</name></decl>, <decl><type ref="prev"/><name>coff</name></decl>, <decl><type ref="prev"/><name>name_off</name></decl>, <decl><type ref="prev"/><name>offs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>cap_hw1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>cap_sf1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>namesize</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MAGIC_MIME</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", no section header"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name>xsh_sizeof</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", corrupted section header size"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>offs</name> <operator>=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>off_t</name></expr></argument>, <argument><expr><operator>(</operator><name>off</name> <operator>+</operator> <name>size</name> <operator>*</operator> <name>strtab</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>xsh_addr</name></expr></argument>, <argument><expr><name>xsh_sizeof</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>ssize_t</name></expr></argument>, <argument><expr><name>xsh_sizeof</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", missing section headers at %jd"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name>offs</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>name_off</name> <operator>=</operator> <name>xsh_offset</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fsize</name> <operator>!=</operator> <name>SIZE_UNKNOWN</name> <operator>&amp;&amp;</operator> <name>fsize</name> <operator>&lt;</operator> <name>name_off</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", too large section header offset %jd"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name>name_off</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<for>for <control>( <init>;</init> <condition><expr><name>num</name></expr>;</condition> <incr><expr><name>num</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>offs</name> <operator>=</operator> <name>name_off</name> <operator>+</operator> <name>xsh_name</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>namesize</name> <operator>=</operator> <call><name>pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">", can't read name of elf section at %jd"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name>offs</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>name</name><index>[<expr><name>namesize</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">".debug_info"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>has_debug_info</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>stripped</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>xsh_addr</name></expr></argument>, <argument><expr><name>xsh_sizeof</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
<call><name>CAST</name><argument_list>(<argument><expr><name>ssize_t</name></expr></argument>, <argument><expr><name>xsh_sizeof</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", can't read elf section at %jd"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name>off</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>off</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>


<switch>switch <condition>(<expr><name>xsh_type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SHT_SYMTAB</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
case SHT_DYNSYM:
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>stripped</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name>fsize</name> <operator>!=</operator> <name>SIZE_UNKNOWN</name> <operator>&amp;&amp;</operator> <name>xsh_offset</name> <operator>&gt;</operator> <name>fsize</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>



<switch>switch <condition>(<expr><name>xsh_type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>SHT_NOTE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><call><name>CAST</name><argument_list>(<argument><expr><name>uintmax_t</name></expr></argument>, <argument><expr><operator>(</operator><name>xsh_size</name> <operator>+</operator> <name>xsh_offset</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>&gt;</operator>
<call><name>CAST</name><argument_list>(<argument><expr><name>uintmax_t</name></expr></argument>, <argument><expr><name>fsize</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">", note offset/size %#"</literal> <name>INTMAX_T_FORMAT</name>
<literal type="string">"x+%#"</literal> <name>INTMAX_T_FORMAT</name> <literal type="string">"x exceeds"</literal>
<literal type="string">" file size %#"</literal> <name>INTMAX_T_FORMAT</name> <literal type="string">"x"</literal></expr></argument>,
<argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>uintmax_t</name></expr></argument>, <argument><expr><name>xsh_offset</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>uintmax_t</name></expr></argument>, <argument><expr><name>xsh_size</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>uintmax_t</name></expr></argument>, <argument><expr><name>fsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nbuf</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>xsh_size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>file_error</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><literal type="string">"Cannot allocate memory"</literal>
<literal type="string">" for note"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>offs</name> <operator>=</operator> <name>xsh_offset</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>xsh_size</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
<call><name>CAST</name><argument_list>(<argument><expr><name>ssize_t</name></expr></argument>, <argument><expr><name>xsh_size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">", can't read elf note at %jd"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name>offs</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>noff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>noff</name> <operator>&gt;=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>off_t</name></expr></argument>, <argument><expr><name>xsh_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>noff</name> <operator>=</operator> <call><name>donote</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>noff</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>xsh_size</name></expr></argument>, <argument><expr><name>clazz</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>notecount</name></expr></argument>,
<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>noff</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>SHT_SUNW_cap</name></expr>:</case>
<switch>switch <condition>(<expr><name>mach</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EM_SPARC</name></expr>:</case>
<case>case <expr><name>EM_SPARCV9</name></expr>:</case>
<case>case <expr><name>EM_IA_64</name></expr>:</case>
<case>case <expr><name>EM_386</name></expr>:</case>
<case>case <expr><name>EM_AMD64</name></expr>:</case>
<break>break;</break>
<default>default:</default>
<goto>goto <name>skip</name>;</goto>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>nbadcap</name> <operator>&gt;</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>xsh_offset</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call>
<operator>==</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>off_t</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>file_badseek</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>coff</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>Elf32_Cap</name></type> <name>cap32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Cap</name></type> <name>cap64</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>cbuf</name><index>[
<expr><call><name>MAX</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cap32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cap64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>coff</name> <operator>+=</operator> <name>xcap_sizeof</name><operator>)</operator> <operator>&gt;</operator>
<call><name>CAST</name><argument_list>(<argument><expr><name>off_t</name></expr></argument>, <argument><expr><name>xsh_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>xcap_sizeof</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator>
<call><name>CAST</name><argument_list>(<argument><expr><name>ssize_t</name></expr></argument>, <argument><expr><name>xcap_sizeof</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>file_badread</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'A'</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>notyet</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>cbuf</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>tag</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><literal type="string">"gnu"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">", unknown capability %.3s"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call>
<operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>getu32</name><argument_list>(<argument><expr><name>swap</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>tag</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", unknown gnu"</literal>
<literal type="string">" capability tag %d"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call>
<operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>xcap_addr</name></expr></argument>, <argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>xcap_sizeof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>xcap_tag</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CA_SUNW_NULL</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>CA_SUNW_HW_1</name></expr>:</case>
<expr_stmt><expr><name>cap_hw1</name> <operator>|=</operator> <name>xcap_val</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CA_SUNW_SF_1</name></expr>:</case>
<expr_stmt><expr><name>cap_sf1</name> <operator>|=</operator> <name>xcap_val</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">", with unknown capability "</literal>
<literal type="string">"%#"</literal> <name>INT64_T_FORMAT</name> <literal type="string">"x = %#"</literal>
<name>INT64_T_FORMAT</name> <literal type="string">"x"</literal></expr></argument>,
<argument><expr><macro><name>CAST</name><argument_list>(<argument>unsigned long long</argument>, <argument>xcap_tag</argument>)</argument_list></macro></expr></argument>,
<argument><expr><macro><name>CAST</name><argument_list>(<argument>unsigned long long</argument>, <argument>xcap_val</argument>)</argument_list></macro></expr></argument>)</argument_list></call>
<operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>nbadcap</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>coff</name> <operator>=</operator> <name>xsh_size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>

<label><name>skip</name>:</label>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>has_debug_info</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", with debug_info"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", %sstripped"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>stripped</name></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"not "</literal></expr></else></ternary></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cap_hw1</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>cap_desc_t</name> <modifier>*</modifier></type><name>cdp</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>mach</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>EM_SPARC</name></expr>:</case>
<case>case <expr><name>EM_SPARC32PLUS</name></expr>:</case>
<case>case <expr><name>EM_SPARCV9</name></expr>:</case>
<expr_stmt><expr><name>cdp</name> <operator>=</operator> <name>cap_desc_sparc</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>EM_386</name></expr>:</case>
<case>case <expr><name>EM_IA_64</name></expr>:</case>
<case>case <expr><name>EM_AMD64</name></expr>:</case>
<expr_stmt><expr><name>cdp</name> <operator>=</operator> <name>cap_desc_386</name></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>cdp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", uses"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cdp</name></expr>)</condition> <block>{<block_content>
<while>while <condition>(<expr><name><name>cdp</name><operator>-&gt;</operator><name>cd_name</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cap_hw1</name> <operator>&amp;</operator> <name><name>cdp</name><operator>-&gt;</operator><name>cd_mask</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name><name>cdp</name><operator>-&gt;</operator><name>cd_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>cap_hw1</name> <operator>&amp;=</operator> <operator>~</operator><name><name>cdp</name><operator>-&gt;</operator><name>cd_mask</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>cdp</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>cap_hw1</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">" unknown hardware capability %#"</literal>
<name>INT64_T_FORMAT</name> <literal type="string">"x"</literal></expr></argument>,
<argument><expr><macro><name>CAST</name><argument_list>(<argument>unsigned long long</argument>, <argument>cap_hw1</argument>)</argument_list></macro></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">" hardware capability %#"</literal> <name>INT64_T_FORMAT</name> <literal type="string">"x"</literal></expr></argument>,
<argument><expr><macro><name>CAST</name><argument_list>(<argument>unsigned long long</argument>, <argument>cap_hw1</argument>)</argument_list></macro></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>cap_sf1</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>cap_sf1</name> <operator>&amp;</operator> <name>SF1_SUNW_FPUSED</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name>cap_sf1</name> <operator>&amp;</operator> <name>SF1_SUNW_FPKNWN</name><operator>)</operator></expr>
?</condition><then> <expr><literal type="string">", uses frame pointer"</literal></expr>
</then><else>: <expr><literal type="string">", not known to use frame pointer"</literal></expr></else></ternary></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>cap_sf1</name> <operator>&amp;=</operator> <operator>~</operator><name>SF1_SUNW_MASK</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cap_sf1</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">", with unknown software capability %#"</literal>
<name>INT64_T_FORMAT</name> <literal type="string">"x"</literal></expr></argument>,
<argument><expr><macro><name>CAST</name><argument_list>(<argument>unsigned long long</argument>, <argument>cap_sf1</argument>)</argument_list></macro></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>







<function><type><name>private</name> <name>int</name></type>
<name>dophn_exec</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>clazz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>swap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>off</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>off_t</name></type> <name>fsize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sh_num</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>,
<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>notecount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>Elf32_Phdr</name></type> <name>ph32</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Phdr</name></type> <name>ph64</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>linking_style</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>nbuf</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>ibuf</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>interp</name><index>[<expr><name>BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>bufsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>, <decl><type ref="prev"/><name>align</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>need</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pie</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>dynamic</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", no program header"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name>xph_sizeof</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", corrupted program header size"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>interp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<for>for <control>( <init>;</init> <condition><expr><name>num</name></expr>;</condition> <incr><expr><name>num</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>doread</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>xph_addr</name></expr></argument>, <argument><expr><name>xph_sizeof</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call> <operator>&lt;</operator>
<call><name>CAST</name><argument_list>(<argument><expr><name>ssize_t</name></expr></argument>, <argument><expr><name>xph_sizeof</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">", can't read elf program headers at %jd"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name>off</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>off</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bufsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>align</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>


<switch>switch <condition>(<expr><name>xph_type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>PT_DYNAMIC</name></expr>:</case>
<expr_stmt><expr><name>doread</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>PT_NOTE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>sh_num</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>align</name> <operator>=</operator> <name>xph_align</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x80000000UL</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
<name>align</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">", invalid note alignment %#lx"</literal></expr></argument>,
<argument><expr><macro><name>CAST</name><argument_list>(<argument>unsigned long</argument>, <argument>align</argument>)</argument_list></macro></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>align</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<case>case <expr><name>PT_INTERP</name></expr>:</case>
<expr_stmt><expr><name>doread</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>doread</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fsize</name> <operator>!=</operator> <name>SIZE_UNKNOWN</name> <operator>&amp;&amp;</operator> <name>xph_offset</name> <operator>&gt;</operator> <name>fsize</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>doread</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><name>xph_filesz</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></sizeof></expr> ?</condition><then> <expr><name>xph_filesz</name></expr>
</then><else>: <expr><sizeof>sizeof<argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr>;</expr_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>offs</name> <init>= <expr><name>xph_offset</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>bufsize</name> <operator>=</operator> <call><name>pread</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>offs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bufsize</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><literal type="string">", can't read section at %jd"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>intmax_t</name><operator>)</operator><name>offs</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>


<switch>switch <condition>(<expr><name>xph_type</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>PT_DYNAMIC</name></expr>:</case>
<expr_stmt><expr><name>dynamic</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ms</name><operator>-&gt;</operator><name>mode</name></name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">0111</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>dodynamic</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
<argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>clazz</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>pie</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>need</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MAGIC_MIME</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>PT_INTERP</name></expr>:</case>
<expr_stmt><expr><name>need</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MAGIC_MIME</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bufsize</name> <operator>&amp;&amp;</operator> <name><name>nbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>nbuf</name><index>[<expr><name>bufsize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>interp</name></expr></argument>, <argument><expr><literal type="string">"*empty*"</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
<case>case <expr><name>PT_NOTE</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MAGIC_MIME</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>




<expr_stmt><expr><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;=</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>donote</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>,
<argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>clazz</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>, <argument><expr><name>align</name></expr></argument>,
<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>notecount</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<break>break;</break>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MAGIC_MIME</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MAGIC_MIME</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>dynamic</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>pie</name> <operator>&amp;&amp;</operator> <name>need</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>linking_style</name> <operator>=</operator> <literal type="string">"static-pie"</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>linking_style</name> <operator>=</operator> <literal type="string">"dynamically"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>linking_style</name> <operator>=</operator> <literal type="string">"statically"</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", %s linked"</literal></expr></argument>, <argument><expr><name>linking_style</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>interp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", interpreter %s"</literal></expr></argument>, <argument><expr><call><name>file_printable</name><argument_list>(<argument><expr><name>ms</name></expr></argument>,
<argument><expr><name>ibuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ibuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>interp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>interp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><name>protected</name> <name>int</name></type>
<name>file_tryelf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>magic_set</name></name> <modifier>*</modifier></type><name>ms</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>buffer</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>fd</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <macro><name>CAST</name><argument_list>(<argument>const unsigned char *</argument>, <argument>b-&gt;fbuf</argument>)</argument_list></macro></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name> <init>= <expr><name><name>b</name><operator>-&gt;</operator><name>flen</name></name></expr></init></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>int32_t</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>c</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32_t</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
}</block> <decl><name>u</name></decl>;</union>
<decl_stmt><decl><type><name>int</name></type> <name>clazz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>swap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>stat</name></name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>fsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf32_Ehdr</name></type> <name>elf32hdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Elf64_Ehdr</name></type> <name>elf64hdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint16_t</name></type> <name>type</name></decl>, <decl><type ref="prev"/><name>phnum</name></decl>, <decl><type ref="prev"/><name>shnum</name></decl>, <decl><type ref="prev"/><name>notecount</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ms</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <operator>(</operator><name>MAGIC_APPLE</name><operator>|</operator><name>MAGIC_EXTENSION</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>








<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>EI_MAG0</name></expr>]</index></name> <operator>!=</operator> <name>ELFMAG0</name>
<operator>||</operator> <operator>(</operator><name><name>buf</name><index>[<expr><name>EI_MAG1</name></expr>]</index></name> <operator>!=</operator> <name>ELFMAG1</name> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>EI_MAG1</name></expr>]</index></name> <operator>!=</operator> <name>OLFMAG1</name><operator>)</operator>
<operator>||</operator> <name><name>buf</name><index>[<expr><name>EI_MAG2</name></expr>]</index></name> <operator>!=</operator> <name>ELFMAG2</name> <operator>||</operator> <name><name>buf</name><index>[<expr><name>EI_MAG3</name></expr>]</index></name> <operator>!=</operator> <name>ELFMAG3</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>




<if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>lseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>CAST</name><argument_list>(<argument><expr><name>off_t</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>CAST</name><argument_list>(<argument><expr><name>off_t</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name>errno</name> <operator>==</operator> <name>ESPIPE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>file_pipe2file</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>file_badread</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>st</name></name></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>st</name><operator>.</operator><name>st_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><name>st</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>file_badread</name><argument_list>(<argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fsize</name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_size</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>fsize</name> <operator>=</operator> <name>SIZE_UNKNOWN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>clazz</name> <operator>=</operator> <name><name>buf</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>clazz</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ELFCLASS32</name></expr>:</case>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>elf_getu</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>elf_getu</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>elf_getu32(a, b)</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>elfhdr</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>elfhdr</name></cpp:macro> <cpp:value>elf32hdr</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"elfclass.h"</cpp:file></cpp:include>
<case>case <expr><name>ELFCLASS64</name></expr>:</case>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>elf_getu</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>elf_getu</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>elf_getu64(a, b)</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>elfhdr</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>elfhdr</name></cpp:macro> <cpp:value>elf64hdr</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"elfclass.h"</cpp:file></cpp:include>
<default>default:</default>
<if_stmt><if>if <condition>(<expr><call><name>file_printf</name><argument_list>(<argument><expr><name>ms</name></expr></argument>, <argument><expr><literal type="string">", unknown class %d"</literal></expr></argument>, <argument><expr><name>clazz</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
