<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/ASTNodeTraverser.h">













<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_ASTNODETRAVERSER_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_ASTNODETRAVERSER_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTTypeTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/AttrVisitor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/CommentVisitor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclVisitor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/LocInfoType.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtVisitor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TemplateArgumentVisitor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeVisitor.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>APValue</name></decl>;</decl_stmt>





























<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Derived</name></expr></argument>, <argument><expr><name>typename</name> <name>NodeDelegateType</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>ASTNodeTraverser</name>
<range>: <expr><name>public</name> <name><name>ConstDeclVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name></expr></range></decl>,
<decl><type ref="prev"/><name>public</name> <name><name>ConstStmtVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name></decl>,
<decl><type ref="prev"/><name>public</name> <name>comments</name>::<name><name>ConstCommentVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>, <argument><expr><name>void</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>comments</name><operator>::</operator><name>FullComment</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></decl>,
<decl><type ref="prev"/><name>public</name> <name><name>TypeVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name></decl>,
<decl><type ref="prev"/><name>public</name> <name><name>ConstAttrVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name></decl>,
<decl><type ref="prev"/><name>public</name> <name><name>ConstTemplateArgumentVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name> <block>{<block_content>



<decl_stmt><decl><type><name>bool</name></type> <name>Deserialize</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TraversalKind</name></type> <name>Traversal</name> <init>= <expr><name>TraversalKind</name><operator>::</operator><name>TK_AsIs</name></expr></init></decl>;</decl_stmt>

<function><type><name>NodeDelegateType</name> <modifier>&amp;</modifier></type><name>getNodeDelegate</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getDerived</name><argument_list>()</argument_list></call><operator>.</operator><call><name>doGetNodeDelegate</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>Derived</name> <modifier>&amp;</modifier></type><name>getDerived</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><operator>*</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<label><name>public</name>:</label>
<function><type><name>void</name></type> <name>setDeserialize</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Deserialize</name> <operator>=</operator> <name>D</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>bool</name> <macro><name>getDeserialize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Deserialize</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>SetTraversalKind</name><parameter_list>(<parameter><decl><type><name>TraversalKind</name></type> <name>TK</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Traversal</name> <operator>=</operator> <name>TK</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>TraversalKind</name> <macro><name>GetTraversalKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Traversal</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>Visit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Traversal</name> <operator>==</operator> <name>TK_IgnoreUnlessSpelledInSource</name> <operator>&amp;&amp;</operator> <call><name><name>D</name><operator>-&gt;</operator><name>isImplicit</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AddChild</name><argument_list>(<argument><expr><index>[<expr><operator>=</operator></expr>]</index> <block>{
<expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Visit</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>D</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<name><name>ConstDeclVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Visit</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></block></expr></argument>;

for <argument><expr><operator>(</operator><specifier>const</specifier> <name>auto</name> <operator>&amp;</operator><name>A</name> <operator>:</operator> <call><name><name>D</name><operator>-&gt;</operator><name>attrs</name></name><argument_list>()</argument_list></call><operator>)</operator>
<call><name>Visit</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></argument>;

if <argument><expr><operator>(</operator><specifier>const</specifier> <name>comments</name><operator>::</operator><name>FullComment</name> <operator>*</operator><name>Comment</name> <operator>=</operator>
<call><name><name>D</name><operator>-&gt;</operator><name>getASTContext</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLocalCommentForDeclUncached</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call><operator>)</operator>
<call><name>Visit</name><argument_list>(<argument><expr><name>Comment</name></expr></argument>, <argument><expr><name>Comment</name></expr></argument>)</argument_list></call></expr></argument>;


if <argument><expr><operator>(</operator><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>D</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>D</name></expr></argument>)</argument_list></call><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><name>Traversal</name> <operator>!=</operator> <name>TK_AsIs</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>CTSD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ClassTemplateSpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>SK</name> <init>= <expr><call><name><name>CTSD</name><operator>-&gt;</operator><name>getSpecializationKind</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>SK</name> <operator>==</operator> <name>TSK_ExplicitInstantiationDeclaration</name> <operator>||</operator>
<name>SK</name> <operator>==</operator> <name>TSK_ExplicitInstantiationDefinition</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>
}
if (const auto *DC = dyn_cast&lt;DeclContext&gt;(D</block></if></if_stmt>)</block_content></block></if></if_stmt>)
<call><name>dumpDeclContext</name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></block></expr></argument>;</argument_list></call></expr></expr_stmt>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt>)</block_content></block></decl>;</decl_stmt>
}

void <macro><name>Visit</name><argument_list>(<argument>const Stmt *Node</argument>, <argument>StringRef Label = {}</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AddChild</name><argument_list>(<argument><expr><name>Label</name></expr></argument>, <argument><expr><index>[<expr><operator>=</operator></expr>]</index> <block>{
<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name> <operator>=</operator> <name>Node</name></expr>;

<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>E</name> <operator>=</operator> <call><name><name>dyn_cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<switch>switch <condition>(<expr><name>Traversal</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>TK_AsIs</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>TK_IgnoreUnlessSpelledInSource</name></expr>:</case>
<expr_stmt><expr><name>S</name> <operator>=</operator> <call><name><name>E</name><operator>-&gt;</operator><name>IgnoreUnlessSpelledInSource</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<expr_stmt/>}</block_content>
}

getNodeDelegate(</block></switch>)</block_content>.Visit(S</block></if></if_stmt>)</block></expr></argument>;

if <argument><expr><operator>(</operator><operator>!</operator><name>S</name><operator>)</operator> <block>{
<return>return;</return>
}</block></expr></argument></argument_list></call></expr></expr_stmt>

<expr_stmt><expr><name><name>ConstStmtVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Visit</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>DeclStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>GenericSelectionExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>RequiresExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>Traversal</name> <operator>==</operator> <name>TK_IgnoreUnlessSpelledInSource</name> <operator>&amp;&amp;</operator>
<call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>LambdaExpr</name></expr></argument>, <argument><expr><name>CXXForRangeStmt</name></expr></argument>, <argument><expr><name>CallExpr</name></expr></argument>,
<argument><expr><name>CXXRewrittenBinaryOperator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name> <range>: <expr><call><name><name>S</name><operator>-&gt;</operator><name>children</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>SubStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block>)<empty_stmt>;</empty_stmt>
}

void <macro><name>Visit</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <block>{<block_content>
<decl_stmt><decl><type><name>SplitQualType</name></type> <name>SQT</name> <init>= <expr><call><name><name>T</name><operator>.</operator><name>split</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>SQT</name><operator>.</operator><name>Quals</name><operator>.</operator><name>hasQualifiers</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>Visit</name><argument_list>(<argument><expr><name><name>SQT</name><operator>.</operator><name>Ty</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AddChild</name><argument_list>(<argument><expr><index>[<expr><operator>=</operator></expr>]</index> <block>{
<expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Visit</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>split</name></name><argument_list>()</argument_list></call><operator>.</operator><name>Ty</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<function><type><name>void</name></type> <name>Visit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Type</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AddChild</name><argument_list>(<argument><expr><index>[<expr><operator>=</operator></expr>]</index> <block>{
<expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Visit</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>T</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<name><name>TypeVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Visit</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></block></expr></argument>;

<argument><expr><name>QualType</name> <name>SingleStepDesugar</name> <operator>=</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getLocallyUnqualifiedSingleStepDesugaredType</name></name><argument_list>()</argument_list></call></expr></argument>;
if <argument><expr><operator>(</operator><name>SingleStepDesugar</name> <operator>!=</operator> <call><name>QualType</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator>
<call><name>Visit</name><argument_list>(<argument><expr><name>SingleStepDesugar</name></expr></argument>)</argument_list></call></expr></argument>;</argument_list></call></expr></expr_stmt>
</block_content>}</block></function>)<empty_stmt>;</empty_stmt>
}

void <macro><name>Visit</name><argument_list>(<argument>const Attr *A</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AddChild</name><argument_list>(<argument><expr><index>[<expr><operator>=</operator></expr>]</index> <block>{
<expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Visit</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>ConstAttrVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Visit</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<function><type><name>void</name></type> <name>Visit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXCtorInitializer</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Traversal</name> <operator>==</operator> <name>TK_IgnoreUnlessSpelledInSource</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>Init</name><operator>-&gt;</operator><name>isWritten</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AddChild</name><argument_list>(<argument><expr><index>[<expr><operator>=</operator></expr>]</index> <block>{
<expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Visit</name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>Init</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name></type> <name>Visit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateArgument</name> <operator>&amp;</operator><name>A</name></expr></argument>, <argument><expr><name>SourceRange</name> <name>R</name> <operator>=</operator> <block>{}</block></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>From</name> <operator>=</operator> <name>nullptr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>Label</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AddChild</name><argument_list>(<argument><expr><index>[<expr><operator>=</operator></expr>]</index> <block>{
<expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Visit</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>From</name></expr></argument>, <argument><expr><name>Label</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>ConstTemplateArgumentVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>Visit</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>Visit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>BlockDecl</name><operator>::</operator><name>Capture</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AddChild</name><argument_list>(<argument><expr><index>[<expr><operator>=</operator></expr>]</index> <block>{
<expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Visit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>C</name><operator>.</operator><name>hasCopyExpr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>C</name><operator>.</operator><name>getCopyExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></argument></argument_list></call></expr></expr_stmt>)</block_content></block></decl>;</decl_stmt>
}

void <macro><name>Visit</name><argument_list>(<argument>const OMPClause *C</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AddChild</name><argument_list>(<argument><expr><index>[<expr><operator>=</operator></expr>]</index> <block>{
<expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Visit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>S</name> <range>: <expr><call><name><name>C</name><operator>-&gt;</operator><name>children</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
}</block></expr></argument></argument_list></call></expr></expr_stmt>)</block_content></block><empty_stmt>;</empty_stmt>
}

void <macro><name>Visit</name><argument_list>(<argument>const GenericSelectionExpr::ConstAssociation &amp;A</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AddChild</name><argument_list>(<argument><expr><index>[<expr><operator>=</operator></expr>]</index> <block>{
<expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Visit</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSI</name> <init>= <expr><call><name><name>A</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>TSI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<call><name>Visit</name><argument_list>(<argument><expr><call><name><name>A</name><operator>.</operator><name>getAssociationExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></block></expr></argument>;</argument_list></call></expr></expr_stmt>
</block_content>}</block>)<empty_stmt>;</empty_stmt>
}

void <macro><name>Visit</name><argument_list>(<argument>const concepts::Requirement *R</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AddChild</name><argument_list>(<argument><expr><index>[<expr><operator>=</operator></expr>]</index> <block>{
<expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Visit</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>R</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt></block></expr></argument>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>TR</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>concepts</name><operator>::</operator><name>TypeRequirement</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>TR</name><operator>-&gt;</operator><name>isSubstitutionFailure</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>TR</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypePtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>auto</name> <operator>*</operator><name>ER</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>concepts</name><operator>::</operator><name>ExprRequirement</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ER</name><operator>-&gt;</operator><name>isExprSubstitutionFailure</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>ER</name><operator>-&gt;</operator><name>getExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ER</name><operator>-&gt;</operator><name>getReturnTypeRequirement</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isEmpty</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>ER</name><operator>-&gt;</operator><name>getReturnTypeRequirement</name></name><argument_list>()</argument_list></call>
<operator>.</operator><call><name>getTypeConstraint</name><argument_list>()</argument_list></call>
<operator>-&gt;</operator><call><name>getImmediatelyDeclaredConstraint</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>auto</name> <operator>*</operator><name>NR</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>concepts</name><operator>::</operator><name>NestedRequirement</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>NR</name><operator>-&gt;</operator><name>isSubstitutionFailure</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>NR</name><operator>-&gt;</operator><name>getConstraintExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt></argument_list></call></expr></expr_stmt>
</block_content>}</block>)<empty_stmt>;</empty_stmt>
}

void <macro><name>Visit</name><argument_list>(<argument>const APValue &amp;Value</argument>, <argument>QualType Ty</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AddChild</name><argument_list>(<argument><expr><index>[<expr><operator>=</operator></expr>]</index> <block>{ <expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Visit</name><argument_list>(<argument><expr><name>Value</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr>; }</block></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<decl_stmt><decl><type><name>void</name></type> <name>Visit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>comments</name><operator>::</operator><name>Comment</name> <operator>*</operator><name>C</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>comments</name><operator>::</operator><name>FullComment</name> <operator>*</operator><name>FC</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>AddChild</name><argument_list>(<argument><expr><index>[<expr><operator>=</operator></expr>]</index> <block>{
<expr><call><name>getNodeDelegate</name><argument_list>()</argument_list></call><operator>.</operator><call><name>Visit</name><argument_list>(<argument><expr><name>C</name></expr></argument>, <argument><expr><name>FC</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>C</name></expr>)</condition> <block>{<block_content>
<return>return;</return>
<expr_stmt/>}</block_content>
comments::ConstCommentVisitor&lt;Derived</block><operator>,</operator> <expr_stmt><expr><name>void</name></expr><operator>,</operator>
<expr><specifier>const</specifier> <name>comments</name><operator>::</operator><name>FullComment</name> <operator>*</operator><operator>&gt;</operator><operator>::</operator><call><name>visit</name><argument_list>(<argument><expr><name>C</name></expr></argument>,
<argument><expr><name>FC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></if></if_stmt></block></expr></argument>
<for>for <control>(<init><expr><name>comments</name><operator>::</operator><name>Comment</name><operator>::</operator><name>child_iterator</name> <name>I</name> <operator>=</operator> <call><name><name>C</name><operator>-&gt;</operator><name>child_begin</name></name><argument_list>()</argument_list></call></expr><operator>,</operator>
<expr><name>E</name> <operator>=</operator> <call><name><name>C</name><operator>-&gt;</operator><name>child_end</name></name><argument_list>()</argument_list></call></expr>;</init>
<condition><expr><name>I</name> <operator>!=</operator> <name>E</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><operator>*</operator><name>I</name></expr></argument>, <argument><expr><name>FC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></argument_list></call></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt>)<empty_stmt>;</empty_stmt>
}

void <macro><name>Visit</name><argument_list>(<argument>const DynTypedNode &amp;N</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>D</name> <init>= <expr><name><name>N</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>Decl</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>S</name> <init>= <expr><name><name>N</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>Stmt</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>QT</name> <init>= <expr><name><name>N</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>QualType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><operator>*</operator><name>QT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>T</name> <init>= <expr><name><name>N</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>Type</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>C</name> <init>= <expr><name><name>N</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>CXXCtorInitializer</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>C</name> <init>= <expr><name><name>N</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>OMPClause</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>T</name> <init>= <expr><name><name>N</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>TemplateArgument</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><operator>*</operator><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>

<function><type><name>void</name></type> <name>dumpDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>DC</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>D</name> <range>: <expr><operator>(</operator><ternary><condition><expr><name>Deserialize</name></expr> ?</condition><then> <expr><call><name><name>DC</name><operator>-&gt;</operator><name>decls</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name><name>DC</name><operator>-&gt;</operator><name>noload_decls</name></name><argument_list>()</argument_list></call></expr></else></ternary><operator>)</operator></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dumpTemplateParameters</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateParameterList</name> <modifier>*</modifier></type><name>TPL</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TPL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>TP</name> <range>: <expr><operator>*</operator><name>TPL</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>TP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>RC</name> <init>= <expr><call><name><name>TPL</name><operator>-&gt;</operator><name>getRequiresClause</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>RC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>dumpASTTemplateArgumentListInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTTemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TALI</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>TALI</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>TA</name> <range>: <expr><call><name><name>TALI</name><operator>-&gt;</operator><name>arguments</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dumpTemplateArgumentLoc</name><argument_list>(<argument><expr><name>TA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dumpTemplateArgumentLoc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentLoc</name> <modifier>&amp;</modifier></type><name>A</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>From</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Label</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>A</name><operator>.</operator><name>getArgument</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>From</name></expr></argument>, <argument><expr><name>Label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dumpTemplateArgumentList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TAL</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name><name>TAL</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name><name>TAL</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>dumpObjCTypeParamList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCTypeParamList</name> <modifier>*</modifier></type><name>typeParams</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>typeParams</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>typeParam</name> <range>: <expr><operator>*</operator><name>typeParams</name></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>typeParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitComplexType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ComplexType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitLocInfoType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LocInfoType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitPointerType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PointerType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitBlockPointerType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BlockPointerType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitReferenceType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ReferenceType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitMemberPointerType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MemberPointerType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitArrayType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArrayType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitVariableArrayType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VariableArrayType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>VisitArrayType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitDependentSizedArrayType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DependentSizedArrayType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitDependentSizedExtVectorType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DependentSizedExtVectorType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getSizeExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitVectorType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VectorType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitFunctionType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getReturnType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitFunctionProtoType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>VisitFunctionType</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>QualType</name> <modifier>&amp;</modifier></type><name>PT</name> <range>: <expr><call><name><name>T</name><operator>-&gt;</operator><name>getParamTypes</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>PT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitTypeOfExprType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TypeOfExprType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getUnderlyingExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitDecltypeType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DecltypeType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getUnderlyingExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitUnaryTransformType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnaryTransformType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getBaseType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitAttributedType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AttributedType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getModifiedType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitSubstTemplateTypeParmType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SubstTemplateTypeParmType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getReplacedParameter</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type>
<name>VisitSubstTemplateTypeParmPackType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SubstTemplateTypeParmPackType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getReplacedParameter</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getArgumentPack</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitTemplateSpecializationType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateSpecializationType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>Arg</name> <range>: <expr><operator>*</operator><name>T</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>Arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitObjCObjectPointerType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectPointerType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitAtomicType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AtomicType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getValueType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitPipeType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PipeType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getElementType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitAdjustedType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AdjustedType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getOriginalType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitPackExpansionType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PackExpansionType</name> <modifier>*</modifier></type><name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>T</name><operator>-&gt;</operator><name>isSugared</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>T</name><operator>-&gt;</operator><name>getPattern</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>VisitTypedefDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TypedefDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getUnderlyingType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitEnumConstantDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>EnumConstantDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Init</name> <init>= <expr><call><name><name>D</name><operator>-&gt;</operator><name>getInitExpr</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitFunctionDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>FTSI</name> <init>= <expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateSpecializationInfo</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dumpTemplateArgumentList</name><argument_list>(<argument><expr><operator>*</operator><name><name>FTSI</name><operator>-&gt;</operator><name>TemplateArguments</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>param_begin</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Parameter</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>parameters</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>Parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>TRC</name> <init>= <expr><call><name><name>D</name><operator>-&gt;</operator><name>getTrailingRequiresClause</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>TRC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>Traversal</name> <operator>==</operator> <name>TK_IgnoreUnlessSpelledInSource</name> <operator>&amp;&amp;</operator> <call><name><name>D</name><operator>-&gt;</operator><name>isDefaulted</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>C</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>I</name> <range>: <expr><call><name><name>C</name><operator>-&gt;</operator><name>inits</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>doesThisDeclarationHaveABody</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitFieldDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FieldDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>isBitField</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBitWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name> <init>= <expr><call><name><name>D</name><operator>-&gt;</operator><name>getInClassInitializer</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitVarDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Traversal</name> <operator>==</operator> <name>TK_IgnoreUnlessSpelledInSource</name> <operator>&amp;&amp;</operator> <call><name><name>D</name><operator>-&gt;</operator><name>isCXXForRangeDecl</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>hasInit</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitDecompositionDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DecompositionDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>VisitVarDecl</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>B</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>bindings</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitBindingDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BindingDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Traversal</name> <operator>==</operator> <name>TK_IgnoreUnlessSpelledInSource</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>E</name> <init>= <expr><call><name><name>D</name><operator>-&gt;</operator><name>getBinding</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitFileScopeAsmDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileScopeAsmDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getAsmString</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitCapturedDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CapturedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitOMPThreadPrivateDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPThreadPrivateDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>E</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitOMPDeclareReductionDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPDeclareReductionDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getCombiner</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Initializer</name> <init>= <expr><call><name><name>D</name><operator>-&gt;</operator><name>getInitializer</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>Initializer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitOMPDeclareMapperDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPDeclareMapperDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>C</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>clauselists</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitOMPCapturedExprDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPCapturedExprDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitOMPAllocateDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPAllocateDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>E</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>varlists</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>C</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>clauselists</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SpecializationDecl</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>dumpTemplateDeclSpecialization</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SpecializationDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>RedeclWithBadType</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>redecls</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>



<expr_stmt><expr><name>auto</name> <operator>*</operator><name>Redecl</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>SpecializationDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RedeclWithBadType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Redecl</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RedeclWithBadType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"expected an injected-class-name"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>Redecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>TemplateDecl</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>dumpTemplateDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>dumpTemplateParameters</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateParameters</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplatedDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>Traversal</name> <operator>==</operator> <name>TK_AsIs</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Child</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>specializations</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dumpTemplateDeclSpecialization</name><argument_list>(<argument><expr><name>Child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitTypeAliasDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TypeAliasDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getUnderlyingType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitTypeAliasTemplateDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TypeAliasTemplateDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>dumpTemplateParameters</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateParameters</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplatedDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitStaticAssertDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>StaticAssertDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getAssertExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getMessage</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitFunctionTemplateDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionTemplateDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>dumpTemplateDecl</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitClassTemplateDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ClassTemplateDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>dumpTemplateDecl</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitClassTemplateSpecializationDecl</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>ClassTemplateSpecializationDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>dumpTemplateArgumentList</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitClassTemplatePartialSpecializationDecl</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>ClassTemplatePartialSpecializationDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>VisitClassTemplateSpecializationDecl</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dumpTemplateParameters</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateParameters</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitClassScopeFunctionSpecializationDecl</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>ClassScopeFunctionSpecializationDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getSpecialization</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dumpASTTemplateArgumentListInfo</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateArgsAsWritten</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitVarTemplateDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarTemplateDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>dumpTemplateDecl</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitBuiltinTemplateDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BuiltinTemplateDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>dumpTemplateParameters</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateParameters</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>VisitVarTemplateSpecializationDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarTemplateSpecializationDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>dumpTemplateArgumentList</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateArgs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VisitVarDecl</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitVarTemplatePartialSpecializationDecl</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>VarTemplatePartialSpecializationDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>dumpTemplateParameters</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateParameters</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VisitVarTemplateSpecializationDecl</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitTemplateTypeParmDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateTypeParmDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>TC</name> <init>= <expr><call><name><name>D</name><operator>-&gt;</operator><name>getTypeConstraint</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>TC</name><operator>-&gt;</operator><name>getImmediatelyDeclaredConstraint</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>hasDefaultArgument</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDefaultArgument</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceRange</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDefaultArgStorage</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getInheritedFrom</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><call><name><name>D</name><operator>-&gt;</operator><name>defaultArgumentWasInherited</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"inherited from"</literal></expr> </then><else>: <expr><literal type="string">"previous"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitNonTypeTemplateParmDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NonTypeTemplateParmDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>E</name> <init>= <expr><call><name><name>D</name><operator>-&gt;</operator><name>getPlaceholderTypeConstraint</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>hasDefaultArgument</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDefaultArgument</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceRange</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDefaultArgStorage</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getInheritedFrom</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><call><name><name>D</name><operator>-&gt;</operator><name>defaultArgumentWasInherited</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"inherited from"</literal></expr> </then><else>: <expr><literal type="string">"previous"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitTemplateTemplateParmDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateTemplateParmDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>dumpTemplateParameters</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateParameters</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>hasDefaultArgument</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dumpTemplateArgumentLoc</name><argument_list>(
<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDefaultArgument</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getDefaultArgStorage</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getInheritedFrom</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><call><name><name>D</name><operator>-&gt;</operator><name>defaultArgumentWasInherited</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"inherited from"</literal></expr> </then><else>: <expr><literal type="string">"previous"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitConceptDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ConceptDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>dumpTemplateParameters</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTemplateParameters</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getConstraintExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitConceptSpecializationExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ConceptSpecializationExpr</name> <modifier>*</modifier></type><name>CSE</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>CSE</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>ArgLoc</name> <range>: <expr><call><name><name>CSE</name><operator>-&gt;</operator><name>getTemplateArgsAsWritten</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>arguments</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dumpTemplateArgumentLoc</name><argument_list>(<argument><expr><name>ArgLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitUsingShadowDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UsingShadowDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>TD</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getUnderlyingDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>TD</name><operator>-&gt;</operator><name>getTypeForDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitFriendDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FriendDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>D</name><operator>-&gt;</operator><name>getFriendType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getFriendDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitObjCMethodDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>isThisDeclarationADefinition</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>dumpDeclContext</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>ParmVarDecl</name> <modifier>*</modifier></type><name>Parameter</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>parameters</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>Parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>hasBody</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitObjCCategoryDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCCategoryDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>dumpObjCTypeParamList</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTypeParamList</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitObjCInterfaceDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>dumpObjCTypeParamList</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getTypeParamListAsWritten</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitObjCImplementationDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>I</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>inits</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitBlockDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BlockDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>I</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>parameters</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>I</name> <range>: <expr><call><name><name>D</name><operator>-&gt;</operator><name>captures</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitDeclStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclStmt</name> <modifier>*</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>D</name> <range>: <expr><call><name><name>Node</name><operator>-&gt;</operator><name>decls</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitAttributedStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AttributedStmt</name> <modifier>*</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>A</name> <range>: <expr><call><name><name>Node</name><operator>-&gt;</operator><name>getAttrs</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitCXXCatchStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXCatchStmt</name> <modifier>*</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getExceptionDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitCapturedStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CapturedStmt</name> <modifier>*</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getCapturedDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitOMPExecutableDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPExecutableDirective</name> <modifier>*</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>C</name> <range>: <expr><call><name><name>Node</name><operator>-&gt;</operator><name>clauses</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitInitListExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InitListExpr</name> <modifier>*</modifier></type><name>ILE</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>Filler</name> <operator>=</operator> <call><name><name>ILE</name><operator>-&gt;</operator><name>getArrayFiller</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>Filler</name></expr></argument>, <argument><expr><literal type="string">"array_filler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitBlockExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BlockExpr</name> <modifier>*</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getBlockDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitOpaqueValueExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OpaqueValueExpr</name> <modifier>*</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><name>Expr</name> <modifier>*</modifier></type><name>Source</name> <init>= <expr><call><name><name>Node</name><operator>-&gt;</operator><name>getSourceExpr</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>Source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitGenericSelectionExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GenericSelectionExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getControllingExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getControllingExpr</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier></type> <name>Assoc</name> <range>: <expr><call><name><name>E</name><operator>-&gt;</operator><name>associations</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>Assoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitRequiresExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RequiresExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>D</name> <operator>:</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getLocalParameters</name></name><argument_list>()</argument_list></call></expr></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>R</name> <operator>:</operator> <call><name><name>E</name><operator>-&gt;</operator><name>getRequirements</name></name><argument_list>()</argument_list></call></expr></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitLambdaExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LambdaExpr</name> <modifier>*</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Traversal</name> <operator>==</operator> <name>TK_IgnoreUnlessSpelledInSource</name></expr>)</condition> <block>{<block_content>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>N</name> <init>= <expr><call><name><name>Node</name><operator>-&gt;</operator><name>capture_size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>C</name> <init>= <expr><call><name><name>Node</name><operator>-&gt;</operator><name>capture_begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>I</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>C</name><operator>-&gt;</operator><name>isExplicit</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>-&gt;</operator><name>isInitCapture</name></name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>C</name><operator>-&gt;</operator><name>getCapturedVar</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>capture_init_begin</name></name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>dumpTemplateParameters</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getTemplateParameterList</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>P</name> <range>: <expr><call><name><name>Node</name><operator>-&gt;</operator><name>getCallOperator</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>parameters</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<return>return <expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getLambdaClass</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitSizeOfPackExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SizeOfPackExpr</name> <modifier>*</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>-&gt;</operator><name>isPartiallySubstituted</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>A</name> <range>: <expr><call><name><name>Node</name><operator>-&gt;</operator><name>getPartialArguments</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitSubstNonTypeTemplateParmExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SubstNonTypeTemplateParmExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getParameter</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>VisitSubstNonTypeTemplateParmPackExpr</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>SubstNonTypeTemplateParmPackExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getParameterPack</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getArgumentPack</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitObjCAtCatchStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCAtCatchStmt</name> <modifier>*</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>CatchParam</name> <init>= <expr><call><name><name>Node</name><operator>-&gt;</operator><name>getCatchParamDecl</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>CatchParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitCXXForRangeStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXForRangeStmt</name> <modifier>*</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Traversal</name> <operator>==</operator> <name>TK_IgnoreUnlessSpelledInSource</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getInit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getLoopVariable</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getRangeInit</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitCallExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>Child</name> <range>:
<expr><call><name>make_filter_range</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>children</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><index>[<expr><name>this</name></expr>]</index><operator>(</operator><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>Child</name><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><name>Traversal</name> <operator>!=</operator> <name>TK_IgnoreUnlessSpelledInSource</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr></argument>
<return>return <expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>CXXDefaultArgExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Child</name></expr></argument>)</argument_list></call></expr>;</return></argument_list></call></expr></range></decl></init>
}</control></for>)</block_content></block></function>) <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>Child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
}

void <macro><name>VisitCXXRewrittenBinaryOperator</name><argument_list>(<argument>const CXXRewrittenBinaryOperator *Node</argument>)</argument_list></macro> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Traversal</name> <operator>==</operator> <name>TK_IgnoreUnlessSpelledInSource</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name><name>ConstStmtVisitor</name><argument_list type="generic">&lt;<argument><expr><name>Derived</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>VisitCXXRewrittenBinaryOperator</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>

<function><type><name>void</name></type> <name>VisitExpressionTemplateArgument</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>TA</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>TA</name><operator>.</operator><name>getAsExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitTypeTemplateArgument</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>TA</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name><name>TA</name><operator>.</operator><name>getAsType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VisitPackTemplateArgument</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>TA</name></decl></parameter>)</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>TArg</name> <range>: <expr><call><name><name>TA</name><operator>.</operator><name>pack_elements</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>TArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/AttrNodeTraverse.inc"</cpp:file></cpp:include>
};

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
