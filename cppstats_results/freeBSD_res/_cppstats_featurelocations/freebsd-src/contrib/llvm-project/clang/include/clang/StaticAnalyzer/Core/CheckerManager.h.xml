<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/StaticAnalyzer/Core/CheckerManager.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_STATICANALYZER_CORE_CHECKERMANAGER_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_STATICANALYZER_CORE_CHECKERMANAGER_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/ProgramPoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Diagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LangOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/Store.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>AnalyzerOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CallExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXNewExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LocationContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TranslationUnitDecl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>ento</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>AnalysisManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXAllocatorCall</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BugReporter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CallEvent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CheckerBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CheckerContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CheckerRegistry</name></decl>;</decl_stmt>
<struct_decl>struct <name>CheckerRegistryData</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>ExplodedGraph</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ExplodedNode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ExplodedNodeSet</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ExprEngine</name></decl>;</decl_stmt>
<struct_decl>struct <name>EvalCallOptions</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>MemRegion</name></decl>;</decl_stmt>
<struct_decl>struct <name>NodeBuilderContext</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCMethodCall</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>RegionAndSymbolInvalidationTraits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SVal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SymbolReaper</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>CheckerFn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>RET</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>Ps</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>RET</name><operator>(</operator><name>Ps</name><operator>...</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <block>{<block_content>
<decl_stmt><decl><type><name>using</name></type> <name>Func</name> <init>= <expr><call><call><name>RET</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>Ps</name><operator>...</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Func</name></type> <name>Fn</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>CheckerBase</name> <modifier>*</modifier></type><name>Checker</name></decl>;</decl_stmt>

<macro><name>CheckerFn</name><argument_list>(<argument>CheckerBase *checker</argument>, <argument>Func fn</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>Fn</name><argument_list>(<argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Checker</name><argument_list>(<argument>checker</argument>)</argument_list></macro> <expr><block>{}</block>

<name>RET</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><name>Ps</name><operator>...</operator> <name>ps</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name>Fn</name><argument_list>(<argument><expr><name>Checker</name></expr></argument>, <argument><expr><name>ps</name><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<enum>enum <name>PointerEscapeKind</name> <block>{


<decl><name>PSK_EscapeOnBind</name></decl>,


<decl><name>PSK_DirectEscapeOnCall</name></decl>,




<decl><name>PSK_IndirectEscapeOnCall</name></decl>,




<decl><name>PSK_EscapeOutParameters</name></decl>,



<decl><name>PSK_EscapeOther</name></decl>
}</block>;</enum>






<decl_stmt><decl><type><name>class</name></type> <name>CheckerNameRef</name> <block>{<block_content>
<expr_stmt><expr><name>friend</name> <name>class</name> <operator>::</operator><name>clang</name><operator>::</operator><name>ento</name><operator>::</operator><name>CheckerRegistry</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>StringRef</name></type> <name>Name</name></decl>;</decl_stmt>

<macro><name>explicit</name></macro> <macro><name>CheckerNameRef</name><argument_list>(<argument>StringRef Name</argument>)</argument_list></macro> : <macro><name>Name</name><argument_list>(<argument>Name</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>CheckerNameRef</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>

<expr_stmt><expr><name>StringRef</name> <macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Name</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>operator</name> <macro><name>StringRef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Name</name></expr>;</return> }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>ObjCMessageVisitKind</name> <block>{<block_content>
<expr_stmt><expr><name>Pre</name></expr><operator>,</operator>
<expr><name>Post</name></expr><operator>,</operator>
<expr><name>MessageNil</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CheckerManager</name> <block>{<block_content>
<decl_stmt><decl><type><name>ASTContext</name> <modifier>*</modifier></type><name>Context</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>LangOptions</name></type> <name>LangOpts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AnalyzerOptions</name> <modifier>&amp;</modifier></type><name>AOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Preprocessor</name> <modifier>*</modifier></type><name>PP</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CheckerNameRef</name></type> <name>CurrentCheckerName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiagnosticsEngine</name> <modifier>&amp;</modifier></type><name>Diags</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CheckerRegistryData</name></expr></argument>&gt;</argument_list></name> <name>RegistryData</name></expr>;</expr_stmt>

<label><name>public</name>:</label>






<expr_stmt><expr><call><name>CheckerManager</name><argument_list>(
<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>, <argument><expr><name>AnalyzerOptions</name> <operator>&amp;</operator><name>AOptions</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Preprocessor</name> <operator>&amp;</operator><name>PP</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>plugins</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>CheckerRegistry</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>checkerRegistrationFns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>CheckerManager</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>, <argument><expr><name>AnalyzerOptions</name> <operator>&amp;</operator><name>AOptions</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Preprocessor</name> <operator>&amp;</operator><name>PP</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CheckerManager</name><argument_list>(<argument>Context</argument>, <argument>AOptions</argument>, <argument>PP</argument>, <argument>{}</argument>, <argument>{}</argument>)</argument_list></macro> <block>{}</block>




<call><name>CheckerManager</name><argument_list>(<argument><expr><name>AnalyzerOptions</name> <operator>&amp;</operator><name>AOptions</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><name>LangOpts</name></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>plugins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>~</operator><call><name>CheckerManager</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<function><type><name>void</name></type> <name>setCurrentCheckerName</name><parameter_list>(<parameter><decl><type><name>CheckerNameRef</name></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>CurrentCheckerName</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>CheckerNameRef</name> <macro><name>getCurrentCheckerName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CurrentCheckerName</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasPathSensitiveCheckers</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>finishedCheckerRegistration</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><macro><name>getLangOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LangOpts</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>AnalyzerOptions</name> <operator>&amp;</operator><macro><name>getAnalyzerOptions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AOptions</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>Preprocessor</name> <operator>&amp;</operator><macro><name>getPreprocessor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>PP</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>PP</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>CheckerRegistryData</name> <operator>&amp;</operator><macro><name>getCheckerRegistryData</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><name>RegistryData</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><macro><name>getDiagnostics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Diags</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>ASTContext</name> <operator>&amp;</operator><macro><name>getASTContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>Context</name></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>reportInvalidCheckerOptionValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CheckerBase</name> <operator>*</operator><name>C</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>OptionName</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>ExpectedValueDesc</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckerRef</name> <init>= <expr><name>CheckerBase</name> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>CheckerTag</name> <init>= <expr><specifier>const</specifier> <name>void</name> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>CheckerDtor</name> <init>= <expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>










<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CHECKER</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>AT</name></expr></argument>&gt;</argument_list></name>
<name>CHECKER</name> <modifier>*</modifier></type><name>registerChecker</name><argument_list>(<argument><expr><name>AT</name> <operator>&amp;&amp;</operator><operator>...</operator> <name>Args</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>CheckerTag</name></type> <name>tag</name> <init>= <expr><call><name><name>getTag</name><argument_list type="generic">&lt;<argument><expr><name>CHECKER</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CheckerRef</name> <modifier>&amp;</modifier></type><name>ref</name> <init>= <expr><name><name>CheckerTags</name><index>[<expr><name>tag</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>ref</name> <operator>&amp;&amp;</operator> <literal type="string">"Checker already registered, use getChecker!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>CHECKER</name> <modifier>*</modifier></type><name>checker</name> <init>= <expr><name>new</name> <call><name>CHECKER</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>AT</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Args</name></expr></argument>)</argument_list></call><operator>...</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>checker</name><operator>-&gt;</operator><name>Name</name></name> <operator>=</operator> <name>CurrentCheckerName</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>CheckerDtors</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>CheckerDtor</name><argument_list>(<argument><expr><name>checker</name></expr></argument>, <argument><expr><name><name>destruct</name><argument_list type="generic">&lt;<argument><expr><name>CHECKER</name></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>CHECKER</name><operator>::</operator><call><name>_register</name><argument_list>(<argument><expr><name>checker</name></expr></argument>, <argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ref</name> <operator>=</operator> <name>checker</name></expr>;</expr_stmt>
<return>return <expr><name>checker</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CHECKER</name></expr></argument>&gt;</argument_list></name>
<name>CHECKER</name> <modifier>*</modifier></type><name>getChecker</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>CheckerTag</name></type> <name>tag</name> <init>= <expr><call><name><name>getTag</name><argument_list type="generic">&lt;<argument><expr><name>CHECKER</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>CheckerTags</name><operator>.</operator><name>count</name></name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<literal type="string">"Requested checker is not registered! Maybe you should add it as a "</literal>
<literal type="string">"dependency in Checkers.td?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>CHECKER</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>CheckerTags</name><index>[<expr><name>tag</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function_decl><type><name>void</name></type> <name>runCheckersOnASTDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>AnalysisManager</name><modifier>&amp;</modifier></type> <name>mgr</name></decl></parameter>,
<parameter><decl><type><name>BugReporter</name> <modifier>&amp;</modifier></type><name>BR</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>runCheckersOnASTBody</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>AnalysisManager</name><modifier>&amp;</modifier></type> <name>mgr</name></decl></parameter>,
<parameter><decl><type><name>BugReporter</name> <modifier>&amp;</modifier></type><name>BR</name></decl></parameter>)</parameter_list>;</function_decl>











<function><type><name>void</name></type> <name>runCheckersForPreStmt</name><parameter_list>(<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>runCheckersForStmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>Dst</name></expr></argument>, <argument><expr><name>Src</name></expr></argument>, <argument><expr><name>S</name></expr></argument>, <argument><expr><name>Eng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>runCheckersForPostStmt</name><parameter_list>(<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>wasInlined</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>runCheckersForStmt</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>Dst</name></expr></argument>, <argument><expr><name>Src</name></expr></argument>, <argument><expr><name>S</name></expr></argument>, <argument><expr><name>Eng</name></expr></argument>, <argument><expr><name>wasInlined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>runCheckersForStmt</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isPreVisit</name></decl></parameter>,
<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>wasInlined</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>runCheckersForPreObjCMessage</name><parameter_list>(<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodCall</name> <modifier>&amp;</modifier></type><name>msg</name></decl></parameter>,
<parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>runCheckersForObjCMessage</name><argument_list>(<argument><expr><name>ObjCMessageVisitKind</name><operator>::</operator><name>Pre</name></expr></argument>, <argument><expr><name>Dst</name></expr></argument>, <argument><expr><name>Src</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>Eng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>runCheckersForPostObjCMessage</name><parameter_list>(<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodCall</name> <modifier>&amp;</modifier></type><name>msg</name></decl></parameter>,
<parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>wasInlined</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>runCheckersForObjCMessage</name><argument_list>(<argument><expr><name>ObjCMessageVisitKind</name><operator>::</operator><name>Post</name></expr></argument>, <argument><expr><name>Dst</name></expr></argument>, <argument><expr><name>Src</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>Eng</name></expr></argument>,
<argument><expr><name>wasInlined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>runCheckersForObjCMessageNil</name><parameter_list>(<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodCall</name> <modifier>&amp;</modifier></type><name>msg</name></decl></parameter>,
<parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>runCheckersForObjCMessage</name><argument_list>(<argument><expr><name>ObjCMessageVisitKind</name><operator>::</operator><name>MessageNil</name></expr></argument>, <argument><expr><name>Dst</name></expr></argument>, <argument><expr><name>Src</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>,
<argument><expr><name>Eng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>runCheckersForObjCMessage</name><parameter_list>(<parameter><decl><type><name>ObjCMessageVisitKind</name></type> <name>visitKind</name></decl></parameter>,
<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodCall</name> <modifier>&amp;</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>wasInlined</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>runCheckersForPreCall</name><parameter_list>(<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CallEvent</name> <modifier>&amp;</modifier></type><name>Call</name></decl></parameter>, <parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>runCheckersForCallEvent</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>Dst</name></expr></argument>, <argument><expr><name>Src</name></expr></argument>, <argument><expr><name>Call</name></expr></argument>, <argument><expr><name>Eng</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>runCheckersForPostCall</name><parameter_list>(<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CallEvent</name> <modifier>&amp;</modifier></type><name>Call</name></decl></parameter>, <parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>wasInlined</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>runCheckersForCallEvent</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>Dst</name></expr></argument>, <argument><expr><name>Src</name></expr></argument>, <argument><expr><name>Call</name></expr></argument>, <argument><expr><name>Eng</name></expr></argument>,
<argument><expr><name>wasInlined</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>runCheckersForCallEvent</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isPreVisit</name></decl></parameter>, <parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CallEvent</name> <modifier>&amp;</modifier></type><name>Call</name></decl></parameter>, <parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>wasInlined</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>runCheckersForLocation</name><parameter_list>(<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>,
<parameter><decl><type><name>SVal</name></type> <name>location</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isLoad</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>NodeEx</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>BoundEx</name></decl></parameter>,
<parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>runCheckersForBind</name><parameter_list>(<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>,
<parameter><decl><type><name>SVal</name></type> <name>location</name></decl></parameter>, <parameter><decl><type><name>SVal</name></type> <name>val</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ProgramPoint</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>runCheckersForEndAnalysis</name><parameter_list>(<parameter><decl><type><name>ExplodedGraph</name> <modifier>&amp;</modifier></type><name>G</name></decl></parameter>, <parameter><decl><type><name>BugReporter</name> <modifier>&amp;</modifier></type><name>BR</name></decl></parameter>,
<parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>runCheckersForBeginFunction</name><parameter_list>(<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>BlockEdge</name> <modifier>&amp;</modifier></type><name>L</name></decl></parameter>,
<parameter><decl><type><name>ExplodedNode</name> <modifier>*</modifier></type><name>Pred</name></decl></parameter>,
<parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>runCheckersForEndFunction</name><parameter_list>(<parameter><decl><type><name>NodeBuilderContext</name> <modifier>&amp;</modifier></type><name>BC</name></decl></parameter>,
<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>,
<parameter><decl><type><name>ExplodedNode</name> <modifier>*</modifier></type><name>Pred</name></decl></parameter>,
<parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ReturnStmt</name> <modifier>*</modifier></type><name>RS</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>runCheckersForBranchCondition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>condition</name></decl></parameter>,
<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>, <parameter><decl><type><name>ExplodedNode</name> <modifier>*</modifier></type><name>Pred</name></decl></parameter>,
<parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>runCheckersForNewAllocator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXAllocatorCall</name> <modifier>&amp;</modifier></type><name>Call</name></decl></parameter>,
<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>, <parameter><decl><type><name>ExplodedNode</name> <modifier>*</modifier></type><name>Pred</name></decl></parameter>,
<parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wasInlined</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>runCheckersForLiveSymbols</name><parameter_list>(<parameter><decl><type><name>ProgramStateRef</name></type> <name>state</name></decl></parameter>,
<parameter><decl><type><name>SymbolReaper</name> <modifier>&amp;</modifier></type><name>SymReaper</name></decl></parameter>)</parameter_list>;</function_decl>






<decl_stmt><decl><type><name>void</name></type> <name>runCheckersForDeadSymbols</name><argument_list>(<argument><expr><name>ExplodedNodeSet</name> <operator>&amp;</operator><name>Dst</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ExplodedNodeSet</name> <operator>&amp;</operator><name>Src</name></expr></argument>,
<argument><expr><name>SymbolReaper</name> <operator>&amp;</operator><name>SymReaper</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>,
<argument><expr><name>ExprEngine</name> <operator>&amp;</operator><name>Eng</name></expr></argument>,
<argument><expr><name>ProgramPoint</name><operator>::</operator><name>Kind</name> <name>K</name></expr></argument>)</argument_list></decl>;</decl_stmt>












<function_decl><type><name>ProgramStateRef</name></type>
<name>runCheckersForRegionChanges</name><parameter_list>(<parameter><decl><type><name>ProgramStateRef</name></type> <name>state</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InvalidatedSymbols</name> <modifier>*</modifier></type><name>invalidated</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MemRegion</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>ExplicitRegions</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MemRegion</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Regions</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LocationContext</name> <modifier>*</modifier></type><name>LCtx</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CallEvent</name> <modifier>*</modifier></type><name>Call</name></decl></parameter>)</parameter_list>;</function_decl>
















<function_decl><type><name>ProgramStateRef</name></type>
<name>runCheckersForPointerEscape</name><parameter_list>(<parameter><decl><type><name>ProgramStateRef</name></type> <name>State</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InvalidatedSymbols</name> <modifier>&amp;</modifier></type><name>Escaped</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CallEvent</name> <modifier>*</modifier></type><name>Call</name></decl></parameter>,
<parameter><decl><type><name>PointerEscapeKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>RegionAndSymbolInvalidationTraits</name> <modifier>*</modifier></type><name>ITraits</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ProgramStateRef</name></type> <name>runCheckersForEvalAssume</name><parameter_list>(<parameter><decl><type><name>ProgramStateRef</name></type> <name>state</name></decl></parameter>,
<parameter><decl><type><name>SVal</name></type> <name>Cond</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Assumption</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>runCheckersForEvalCall</name><parameter_list>(<parameter><decl><type><name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExplodedNodeSet</name> <modifier>&amp;</modifier></type><name>Src</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CallEvent</name> <modifier>&amp;</modifier></type><name>CE</name></decl></parameter>, <parameter><decl><type><name>ExprEngine</name> <modifier>&amp;</modifier></type><name>Eng</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>EvalCallOptions</name> <modifier>&amp;</modifier></type><name>CallOpts</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>runCheckersOnEndOfTranslationUnit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TranslationUnitDecl</name> <modifier>*</modifier></type><name>TU</name></decl></parameter>,
<parameter><decl><type><name>AnalysisManager</name> <modifier>&amp;</modifier></type><name>mgr</name></decl></parameter>,
<parameter><decl><type><name>BugReporter</name> <modifier>&amp;</modifier></type><name>BR</name></decl></parameter>)</parameter_list>;</function_decl>











<decl_stmt><decl><type><name>void</name></type> <name>runCheckersForPrintStateJson</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>Out</name></expr></argument>, <argument><expr><name>ProgramStateRef</name> <name>State</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>NL</name> <operator>=</operator> <literal type="string">"\n"</literal></expr></argument>,
<argument><expr><name>unsigned</name> <name>int</name> <name>Space</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><name>bool</name> <name>IsDot</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>








<decl_stmt><decl><type><name>using</name></type> <name>CheckDeclFunc</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><specifier>const</specifier> <name>Decl</name> <operator>*</operator>, <name>AnalysisManager</name><operator>&amp;</operator>, <name>BugReporter</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>HandlesDeclFunc</name> <init>= <expr><call><call><name>bool</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>_registerForDecl</name><parameter_list>(<parameter><decl><type><name>CheckDeclFunc</name></type> <name>checkfn</name></decl></parameter>, <parameter><decl><type><name>HandlesDeclFunc</name></type> <name>isForDeclFn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForBody</name><parameter_list>(<parameter><decl><type><name>CheckDeclFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>using</name></type> <name>CheckStmtFunc</name> <init>= <expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><specifier>const</specifier> <name>Stmt</name> <operator>*</operator>, <name>CheckerContext</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckObjCMessageFunc</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><specifier>const</specifier> <name>ObjCMethodCall</name> <operator>&amp;</operator>, <name>CheckerContext</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckCallFunc</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><specifier>const</specifier> <name>CallEvent</name> <operator>&amp;</operator>, <name>CheckerContext</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckLocationFunc</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><specifier>const</specifier> <name>SVal</name> <operator>&amp;</operator><name>location</name>, <name>bool</name> <name>isLoad</name>, <specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name>,
<name>CheckerContext</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckBindFunc</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><specifier>const</specifier> <name>SVal</name> <operator>&amp;</operator><name>location</name>, <specifier>const</specifier> <name>SVal</name> <operator>&amp;</operator><name>val</name>, <specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name>,
<name>CheckerContext</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckEndAnalysisFunc</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><name>ExplodedGraph</name> <operator>&amp;</operator>, <name>BugReporter</name> <operator>&amp;</operator>, <name>ExprEngine</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckBeginFunctionFunc</name> <init>= <expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><name>CheckerContext</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckEndFunctionFunc</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><specifier>const</specifier> <name>ReturnStmt</name> <operator>*</operator>, <name>CheckerContext</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckBranchConditionFunc</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><specifier>const</specifier> <name>Stmt</name> <operator>*</operator>, <name>CheckerContext</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckNewAllocatorFunc</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><specifier>const</specifier> <name>CXXAllocatorCall</name> <operator>&amp;</operator><name>Call</name>, <name>CheckerContext</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckDeadSymbolsFunc</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><name>SymbolReaper</name> <operator>&amp;</operator>, <name>CheckerContext</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckLiveSymbolsFunc</name> <init>= <expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><name>ProgramStateRef</name>,<name>SymbolReaper</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckRegionChangesFunc</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>ProgramStateRef</name> <operator>(</operator><name>ProgramStateRef</name>,
<specifier>const</specifier> <name>InvalidatedSymbols</name> <operator>*</operator><name>symbols</name>,
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ExplicitRegions</name>,
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Regions</name>,
<specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name>,
<specifier>const</specifier> <name>CallEvent</name> <operator>*</operator><name>Call</name><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckPointerEscapeFunc</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>ProgramStateRef</name> <operator>(</operator><name>ProgramStateRef</name>,
<specifier>const</specifier> <name>InvalidatedSymbols</name> <operator>&amp;</operator><name>Escaped</name>,
<specifier>const</specifier> <name>CallEvent</name> <operator>*</operator><name>Call</name>, <name>PointerEscapeKind</name> <name>Kind</name>,
<name>RegionAndSymbolInvalidationTraits</name> <operator>*</operator><name>ITraits</name><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>EvalAssumeFunc</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>ProgramStateRef</name> <operator>(</operator><name>ProgramStateRef</name>, <specifier>const</specifier> <name>SVal</name> <operator>&amp;</operator><name>cond</name>,
<name>bool</name> <name>assumption</name><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>EvalCallFunc</name> <init>= <expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>bool</name> <operator>(</operator><specifier>const</specifier> <name>CallEvent</name> <operator>&amp;</operator>, <name>CheckerContext</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CheckEndOfTranslationUnit</name> <init>=
<expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><specifier>const</specifier> <name>TranslationUnitDecl</name> <operator>*</operator>, <name>AnalysisManager</name> <operator>&amp;</operator>,
<name>BugReporter</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>HandlesStmtFunc</name> <init>= <expr><call><call><name>bool</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>_registerForPreStmt</name><parameter_list>(<parameter><decl><type><name>CheckStmtFunc</name></type> <name>checkfn</name></decl></parameter>,
<parameter><decl><type><name>HandlesStmtFunc</name></type> <name>isForStmtFn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>_registerForPostStmt</name><parameter_list>(<parameter><decl><type><name>CheckStmtFunc</name></type> <name>checkfn</name></decl></parameter>,
<parameter><decl><type><name>HandlesStmtFunc</name></type> <name>isForStmtFn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForPreObjCMessage</name><parameter_list>(<parameter><decl><type><name>CheckObjCMessageFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>_registerForPostObjCMessage</name><parameter_list>(<parameter><decl><type><name>CheckObjCMessageFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForObjCMessageNil</name><parameter_list>(<parameter><decl><type><name>CheckObjCMessageFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForPreCall</name><parameter_list>(<parameter><decl><type><name>CheckCallFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>_registerForPostCall</name><parameter_list>(<parameter><decl><type><name>CheckCallFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForLocation</name><parameter_list>(<parameter><decl><type><name>CheckLocationFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForBind</name><parameter_list>(<parameter><decl><type><name>CheckBindFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForEndAnalysis</name><parameter_list>(<parameter><decl><type><name>CheckEndAnalysisFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForBeginFunction</name><parameter_list>(<parameter><decl><type><name>CheckBeginFunctionFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>_registerForEndFunction</name><parameter_list>(<parameter><decl><type><name>CheckEndFunctionFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForBranchCondition</name><parameter_list>(<parameter><decl><type><name>CheckBranchConditionFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForNewAllocator</name><parameter_list>(<parameter><decl><type><name>CheckNewAllocatorFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForLiveSymbols</name><parameter_list>(<parameter><decl><type><name>CheckLiveSymbolsFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForDeadSymbols</name><parameter_list>(<parameter><decl><type><name>CheckDeadSymbolsFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForRegionChanges</name><parameter_list>(<parameter><decl><type><name>CheckRegionChangesFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForPointerEscape</name><parameter_list>(<parameter><decl><type><name>CheckPointerEscapeFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForConstPointerEscape</name><parameter_list>(<parameter><decl><type><name>CheckPointerEscapeFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForEvalAssume</name><parameter_list>(<parameter><decl><type><name>EvalAssumeFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForEvalCall</name><parameter_list>(<parameter><decl><type><name>EvalCallFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>_registerForEndOfTranslationUnit</name><parameter_list>(<parameter><decl><type><name>CheckEndOfTranslationUnit</name></type> <name>checkfn</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>using</name></type> <name>EventTag</name> <init>= <expr><name>void</name> <operator>*</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>CheckEventFunc</name> <init>= <expr><name><name>CheckerFn</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><name>event</name><operator>)</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>EVENT</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>_registerListenerForEvent</name><parameter_list>(<parameter><decl><type><name>CheckEventFunc</name></type> <name>checkfn</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>EventInfo</name> <modifier>&amp;</modifier></type><name>info</name> <init>= <expr><name><name>Events</name><index>[<expr><operator>&amp;</operator><name>EVENT</name><operator>::</operator><name>Tag</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>info</name><operator>.</operator><name>Checkers</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>checkfn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>EVENT</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>_registerDispatcherForEvent</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>EventInfo</name> <modifier>&amp;</modifier></type><name>info</name> <init>= <expr><name><name>Events</name><index>[<expr><operator>&amp;</operator><name>EVENT</name><operator>::</operator><name>Tag</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>info</name><operator>.</operator><name>HasDispatcher</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>EVENT</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>_dispatchEvent</name><argument_list>(<argument><expr><specifier>const</specifier> <name>EVENT</name> <operator>&amp;</operator><name>event</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name>EventsTy</name><operator>::</operator><name>const_iterator</name> <name>I</name> <operator>=</operator> <call><name><name>Events</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>EVENT</name><operator>::</operator><name>Tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>I</name> <operator>==</operator> <call><name><name>Events</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>EventInfo</name> <modifier>&amp;</modifier></type><name>info</name> <init>= <expr><name><name>I</name><operator>-&gt;</operator><name>second</name></name></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>Checker</name> <range>: <expr><name><name>info</name><operator>.</operator><name>Checkers</name></name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Checker</name><argument_list>(<argument><expr><operator>&amp;</operator><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></decl></decl_stmt>





<label><name>private</name>:</label>
<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CHECKER</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>void</name></type> <name>destruct</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list> <block>{<block_content> <decl_stmt><decl><type><name>delete</name></type> <name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>CHECKER</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></decl>;</decl_stmt> </block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>getTag</name><parameter_list>()</parameter_list> <block>{<block_content> <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>tag</name></decl>;</decl_stmt> <return>return <expr><operator>&amp;</operator><name>tag</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>CheckerTag</name></expr></argument>, <argument><expr><name>CheckerRef</name></expr></argument>&gt;</argument_list></name> <name>CheckerTags</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckerDtor</name></expr></argument>&gt;</argument_list></name> <name>CheckerDtors</name></expr>;</expr_stmt>

<struct>struct <name>DeclCheckerInfo</name> <block>{
<decl_stmt><decl><type><name>CheckDeclFunc</name></type> <name>CheckFn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HandlesDeclFunc</name></type> <name>IsForDeclFn</name></decl>;</decl_stmt>
}</block>;</struct>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>DeclCheckerInfo</name></expr></argument>&gt;</argument_list></name> <name>DeclCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckDeclFunc</name></expr></argument>&gt;</argument_list></name> <name>BodyCheckers</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CachedDeclCheckers</name> <init>= <expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CheckDeclFunc</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>CachedDeclCheckersMapTy</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>CachedDeclCheckers</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CachedDeclCheckersMapTy</name></type> <name>CachedDeclCheckersMap</name></decl>;</decl_stmt>

<struct>struct <name>StmtCheckerInfo</name> <block>{
<decl_stmt><decl><type><name>CheckStmtFunc</name></type> <name>CheckFn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HandlesStmtFunc</name></type> <name>IsForStmtFn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>IsPreVisit</name></decl>;</decl_stmt>
}</block>;</struct>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>StmtCheckerInfo</name></expr></argument>&gt;</argument_list></name> <name>StmtCheckers</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>CachedStmtCheckers</name> <init>= <expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CheckStmtFunc</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>CachedStmtCheckersMapTy</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>CachedStmtCheckers</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CachedStmtCheckersMapTy</name></type> <name>CachedStmtCheckersMap</name></decl>;</decl_stmt>

<function_decl><type><specifier>const</specifier> <name>CachedStmtCheckers</name> <modifier>&amp;</modifier></type><name>getCachedStmtCheckersFor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isPreVisit</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckObjCMessageFunc</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator>
<macro><name>getObjCMessageCheckers</name><argument_list>(<argument>ObjCMessageVisitKind Kind</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckObjCMessageFunc</name></expr></argument>&gt;</argument_list></name> <name>PreObjCMessageCheckers</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckObjCMessageFunc</name></expr></argument>&gt;</argument_list></name> <name>PostObjCMessageCheckers</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckObjCMessageFunc</name></expr></argument>&gt;</argument_list></name> <name>ObjCMessageNilCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckCallFunc</name></expr></argument>&gt;</argument_list></name> <name>PreCallCheckers</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckCallFunc</name></expr></argument>&gt;</argument_list></name> <name>PostCallCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckLocationFunc</name></expr></argument>&gt;</argument_list></name> <name>LocationCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckBindFunc</name></expr></argument>&gt;</argument_list></name> <name>BindCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckEndAnalysisFunc</name></expr></argument>&gt;</argument_list></name> <name>EndAnalysisCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckBeginFunctionFunc</name></expr></argument>&gt;</argument_list></name> <name>BeginFunctionCheckers</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckEndFunctionFunc</name></expr></argument>&gt;</argument_list></name> <name>EndFunctionCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckBranchConditionFunc</name></expr></argument>&gt;</argument_list></name> <name>BranchConditionCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckNewAllocatorFunc</name></expr></argument>&gt;</argument_list></name> <name>NewAllocatorCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckLiveSymbolsFunc</name></expr></argument>&gt;</argument_list></name> <name>LiveSymbolsCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckDeadSymbolsFunc</name></expr></argument>&gt;</argument_list></name> <name>DeadSymbolsCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckRegionChangesFunc</name></expr></argument>&gt;</argument_list></name> <name>RegionChangesCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckPointerEscapeFunc</name></expr></argument>&gt;</argument_list></name> <name>PointerEscapeCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>EvalAssumeFunc</name></expr></argument>&gt;</argument_list></name> <name>EvalAssumeCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>EvalCallFunc</name></expr></argument>&gt;</argument_list></name> <name>EvalCallCheckers</name></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>CheckEndOfTranslationUnit</name></expr></argument>&gt;</argument_list></name> <name>EndOfTranslationUnitCheckers</name></expr>;</expr_stmt>

<struct>struct <name>EventInfo</name> <block>{
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CheckEventFunc</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>Checkers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasDispatcher</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>EventInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>using</name></type> <name>EventsTy</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>EventTag</name></expr></argument>, <argument><expr><name>EventInfo</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>EventsTy</name></type> <name>Events</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

</block_content>}</block></decl></decl_stmt>

</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
