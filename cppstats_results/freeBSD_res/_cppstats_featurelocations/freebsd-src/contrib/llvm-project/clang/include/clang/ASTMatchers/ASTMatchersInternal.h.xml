<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersInternal.h">
































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_ASTMATCHERS_ASTMATCHERSINTERNAL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_ASTMATCHERS_ASTMATCHERSINTERNAL_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTTypeTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclFriend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclTemplate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/NestedNameSpecifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Stmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TemplateName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeLoc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OperatorKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APFloat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/IntrusiveRefCntPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/ManagedStatic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Regex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;map&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tuple&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;type_traits&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>ast_matchers</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>BoundNodes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>internal</name> <block>{<block_content>





<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name><operator>...</operator> <name>Ts</name><operator>&gt;</operator> struct <name>TypeList</name> <block>{}</block></expr>;</expr_stmt>

<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T1</name></expr><operator>,</operator> <expr><name>typename</name><operator>...</operator> <name>Ts</name><operator>&gt;</operator> struct <name><name>TypeList</name><argument_list type="generic">&lt;<argument><expr><name>T1</name></expr></argument>, <argument><expr><name>Ts</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <block>{

<expr><name>using</name> <name>head</name> <operator>=</operator> <name>T1</name></expr>;





<expr><name>using</name> <name>tail</name> <operator>=</operator> <name><name>TypeList</name><argument_list type="generic">&lt;<argument><expr><name>Ts</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr>;
}</block></expr>;</expr_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>EmptyTypeList</name> <init>= <expr><name><name>TypeList</name><argument_list type="generic">&lt;&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>AnyTypeList</name></expr><operator>,</operator> <expr><name>typename</name> <name>T</name><operator>&gt;</operator> struct <name>TypeListContainsSuperOf</name> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <name>bool</name> <name>value</name> <operator>=</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>AnyTypeList</name><operator>::</operator><name>head</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name><name>TypeListContainsSuperOf</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>AnyTypeList</name><operator>::</operator><name>tail</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr>;
}</block></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator> struct <name><name>TypeListContainsSuperOf</name><argument_list type="generic">&lt;<argument><expr><name>EmptyTypeList</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <name>bool</name> <name>value</name> <operator>=</operator> <name>false</name></expr>;
}</block></expr>;</expr_stmt>






<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>ResultT</name></expr><operator>,</operator> <expr><name>typename</name> <name>ArgT</name></expr><operator>,</operator>
<expr><call><call><name>ResultT</name> <argument_list>(<argument><expr><operator>*</operator><name>Func</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgT</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list></call><operator>&gt;</operator>
struct <name>VariadicFunction</name> <block>{
<expr><name>ResultT</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><call><name>Func</name><argument_list>(<argument><expr><name>None</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>ArgsT</name></expr></argument>&gt;</argument_list></name>
<name>ResultT</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>ArgT</name> <operator>&amp;</operator><name>Arg1</name><operator>,</operator> <specifier>const</specifier> <name>ArgsT</name> <operator>&amp;</operator><operator>...</operator> <name>Args</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name>Execute</name><argument_list>(<argument><expr><name>Arg1</name></expr></argument>, <argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgT</name> <operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Args</name></expr></argument>)</argument_list></call><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>ResultT</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ArgT</name></expr></argument>&gt;</argument_list></name> <name>Args</name><operator>)</operator> <specifier>const</specifier> <block>{
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgT</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>InnerArgs</name></expr>;
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>ArgT</name> <modifier>&amp;</modifier></type><name>Arg</name> <range>: <expr><name>Args</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>InnerArgs</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block></expr>
<return>return <expr><call><name>Func</name><argument_list>(<argument><expr><name>InnerArgs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>ArgsT</name></expr></argument>&gt;</argument_list></name> <name>ResultT</name></type> <name>Execute</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ArgsT</name> <operator>&amp;</operator><operator>...</operator> <name>Args</name></expr></argument>)</argument_list> const <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>ArgT</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>ArgsArray</name><index>[]</index></name> <init>= <expr><block>{<expr><operator>&amp;</operator><name>Args</name><operator>...</operator></expr>}</block></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>Func</name><argument_list>(<argument><expr><call><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ArgT</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ArgsArray</name></expr></argument>, <argument><expr><sizeof type="pack">sizeof...<argument_list>(<argument><expr><name>ArgsT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<function><type><specifier>inline</specifier> <name>QualType</name></type> <name>getUnderlyingType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>&amp;</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>Node</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><specifier>inline</specifier> <name>QualType</name></type> <name>getUnderlyingType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ValueDecl</name> <modifier>&amp;</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>inline</specifier> <name>QualType</name></type> <name>getUnderlyingType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TypedefNameDecl</name> <modifier>&amp;</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getUnderlyingType</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>inline</specifier> <name>QualType</name></type> <name>getUnderlyingType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FriendDecl</name> <modifier>&amp;</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSI</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getFriendType</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>TSI</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>inline</specifier> <name>QualType</name></type> <name>getUnderlyingType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXBaseSpecifier</name> <modifier>&amp;</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>enable_if_t</name><argument_list type="generic">&lt;<argument><expr><name><name>TypeListContainsSuperOf</name><argument_list type="generic">&lt;
<argument><expr><name><name>TypeList</name><argument_list type="generic">&lt;<argument><expr><name>CXXBaseSpecifier</name></expr></argument>, <argument><expr><name>CXXCtorInitializer</name></expr></argument>,
<argument><expr><name>CXXTemporaryObjectExpr</name></expr></argument>, <argument><expr><name>CXXUnresolvedConstructExpr</name></expr></argument>,
<argument><expr><name>CompoundLiteralExpr</name></expr></argument>, <argument><expr><name>DeclaratorDecl</name></expr></argument>, <argument><expr><name>ObjCPropertyDecl</name></expr></argument>,
<argument><expr><name>TemplateArgumentLoc</name></expr></argument>, <argument><expr><name>TypedefNameDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name> <modifier>*</modifier> <operator>=</operator> <name>nullptr</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>TypeSourceInfo</name> <modifier>*</modifier></type><name>GetTypeSourceInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>enable_if_t</name><argument_list type="generic">&lt;<argument><expr><name><name>TypeListContainsSuperOf</name><argument_list type="generic">&lt;
<argument><expr><name><name>TypeList</name><argument_list type="generic">&lt;<argument><expr><name>CXXFunctionalCastExpr</name></expr></argument>, <argument><expr><name>ExplicitCastExpr</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name> <modifier>*</modifier> <operator>=</operator>
<name>nullptr</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name>TypeSourceInfo</name> <modifier>*</modifier></type><name>GetTypeSourceInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>T</name> <modifier>&amp;</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getTypeInfoAsWritten</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>inline</specifier> <name>TypeSourceInfo</name> <modifier>*</modifier></type><name>GetTypeSourceInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BlockDecl</name> <modifier>&amp;</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getSignatureAsWritten</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>inline</specifier> <name>TypeSourceInfo</name> <modifier>*</modifier></type><name>GetTypeSourceInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXNewExpr</name> <modifier>&amp;</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getAllocatedTypeSourceInfo</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>inline</specifier> <name>TypeSourceInfo</name> <modifier>*</modifier></type>
<name>GetTypeSourceInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ClassTemplateSpecializationDecl</name> <modifier>&amp;</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getTypeAsWritten</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>inline</specifier> <specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type>
<name>getFunctionProtoType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>&amp;</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>&amp;</operator><name>Node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>inline</specifier> <specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>getFunctionProtoType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>&amp;</modifier></type><name>Node</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>getAs</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><specifier>inline</specifier> <name>clang</name><operator>::</operator><name>AccessSpecifier</name> <macro><name>getAccessSpecifier</name><argument_list>(<argument>const Decl &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getAccess</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>clang</name><operator>::</operator><name>AccessSpecifier</name> <macro><name>getAccessSpecifier</name><argument_list>(<argument>const CXXBaseSpecifier &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getAccessSpecifier</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>BoundNodesMap</name> <block>{<block_content>
<label><name>public</name>:</label>



<function><type><name>void</name></type> <name>addNode</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>ID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DynTypedNode</name> <modifier>&amp;</modifier></type><name>DynNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>NodeMap</name><index>[<expr><name>std</name><operator>::</operator><call><name>string</name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>DynNode</name></expr>;</expr_stmt>
</block_content>}</block></function>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>T</name> <modifier>*</modifier></type><name>getNodeAs</name><argument_list>(<argument><expr><name>StringRef</name> <name>ID</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name>IDToNodeMap</name><operator>::</operator><name>const_iterator</name> <name>It</name> <operator>=</operator> <call><name><name>NodeMap</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>It</name> <operator>==</operator> <call><name><name>NodeMap</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><name>nullptr</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>It</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>DynTypedNode</name></type> <name>getNode</name><argument_list>(<argument><expr><name>StringRef</name> <name>ID</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><name>IDToNodeMap</name><operator>::</operator><name>const_iterator</name> <name>It</name> <operator>=</operator> <call><name><name>NodeMap</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>It</name> <operator>==</operator> <call><name><name>NodeMap</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name>DynTypedNode</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name><name>It</name><operator>-&gt;</operator><name>second</name></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><name>bool</name> <name>operator</name><operator>&lt;</operator><operator>(</operator><specifier>const</specifier> <name>BoundNodesMap</name> <operator>&amp;</operator><name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>NodeMap</name> <operator>&lt;</operator> <name><name>Other</name><operator>.</operator><name>NodeMap</name></name></expr>;</return>
}</block></expr></expr_stmt>






<decl_stmt><decl><type><name>using</name></type> <name>IDToNodeMap</name> <init>= <expr><name>std</name><operator>::</operator><name><name>map</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><name>DynTypedNode</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>less</name><argument_list type="generic">&lt;&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>IDToNodeMap</name> <operator>&amp;</operator><macro><name>getMap</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NodeMap</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isComparable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>IDAndNode</name> <range>: <expr><name>NodeMap</name></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>IDAndNode</name><operator>.</operator><name>second</name><operator>.</operator><name>getMemoizationData</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>
return true</block><empty_stmt>;</empty_stmt></for>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>IDToNodeMap</name></type> <name>NodeMap</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>BoundNodesTreeBuilder</name> <block>{<block_content>
<label><name>public</name>:</label>


<decl_stmt><decl><type><name>class</name></type> <name>Visitor</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>Visitor</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>




<function_decl><type><name>virtual</name> <name>void</name></type> <name>visitMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BoundNodes</name><modifier>&amp;</modifier></type> <name>BoundNodesView</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<function><type><name>void</name></type> <name>setBinding</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DynTypedNode</name> <modifier>&amp;</modifier></type><name>DynNode</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Bindings</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Bindings</name><operator>.</operator><name>emplace_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><decl><type><name>BoundNodesMap</name> <modifier>&amp;</modifier></type><name>Binding</name> <range>: <expr><name>Bindings</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Binding</name><operator>.</operator><name>addNode</name></name><argument_list>(<argument><expr><name>Id</name></expr></argument>, <argument><expr><name>DynNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>addMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BoundNodesTreeBuilder</name> <modifier>&amp;</modifier></type><name>Bindings</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>visitMatches</name><parameter_list>(<parameter><decl><type><name>Visitor</name><modifier>*</modifier></type> <name>ResultVisitor</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ExcludePredicate</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>removeBindings</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExcludePredicate</name> <modifier>&amp;</modifier></type><name>Predicate</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Bindings</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>remove_if</name><argument_list>(<argument><expr><call><name><name>Bindings</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Bindings</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Predicate</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Bindings</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>!</operator><call><name><name>Bindings</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <name>operator</name><operator>&lt;</operator><operator>(</operator><specifier>const</specifier> <name>BoundNodesTreeBuilder</name> <operator>&amp;</operator><name>Other</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>Bindings</name> <operator>&lt;</operator> <name><name>Other</name><operator>.</operator><name>Bindings</name></name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isComparable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>BoundNodesMap</name> <modifier>&amp;</modifier></type><name>NodesMap</name> <range>: <expr><name>Bindings</name></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>NodesMap</name><operator>.</operator><name>isComparable</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>
return true</block><empty_stmt>;</empty_stmt></for>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>BoundNodesMap</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></type> <name>Bindings</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ASTMatchFinder</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>class</name></type> <name>DynMatcherInterface</name>
<range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name><name>ThreadSafeRefCountedBase</name><argument_list type="generic">&lt;<argument><expr><name>DynMatcherInterface</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>virtual</name> <operator>~</operator><call><name>DynMatcherInterface</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;





<expr><name>virtual</name> <name>bool</name> <macro><name>dynMatches</name><argument_list>(<argument>const DynTypedNode &amp;DynNode</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>TraversalKind</name></expr></argument>&gt;</argument_list></name> <macro><name>TraversalKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return>
}</block>
}</expr>;








<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>MatcherInterface</name> <operator>:</operator> <name>public</name> <name>DynMatcherInterface</name> <block>{
<expr><name>public</name><operator>:</operator>




<name>virtual</name> <name>bool</name> <macro><name>matches</name><argument_list>(<argument>const T &amp;Node</argument>,
<argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>bool</name> <macro><name>dynMatches</name><argument_list>(<argument>const DynTypedNode &amp;DynNode</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>matches</name><argument_list>(<argument><expr><name><name>DynNode</name><operator>.</operator><name>getUnchecked</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>SingleNodeMatcherInterface</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>



<name>virtual</name> <name>bool</name> <macro><name>matchesNode</name><argument_list>(<argument>const T &amp;Node</argument>)</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>private</name><operator>:</operator>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const T &amp;Node</argument>,
<argument>ASTMatchFinder *</argument> ,
<argument>BoundNodesTreeBuilder *</argument> )</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>matchesNode</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>Matcher</name></expr>;








<expr><name>class</name> <name>DynTypedMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<call><name>DynTypedMatcher</name><argument_list>(<argument><expr><name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>Implementation</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SupportedKind</name><argument_list>(<argument><expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>RestrictKind</name><argument_list>(<argument><expr><name>SupportedKind</name></expr></argument>)</argument_list></call></expr>, <macro><name>Implementation</name><argument_list>(<argument>Implementation</argument>)</argument_list></macro> <expr><block>{}</block>


enum <name>VariadicOperator</name> <block>{

<expr><name>VO_AllOf</name></expr>,



<expr><name>VO_AnyOf</name></expr>,



<expr><name>VO_EachOf</name></expr>,



<expr><name>VO_Optionally</name></expr>,





<expr><name>VO_UnaryNot</name></expr>
}</block></expr>;

<expr><specifier>static</specifier> <name>DynTypedMatcher</name>
<macro><name>constructVariadic</name><argument_list>(<argument>VariadicOperator Op</argument>, <argument>ASTNodeKind SupportedKind</argument>,
<argument>std::vector&lt;DynTypedMatcher&gt; InnerMatchers</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>DynTypedMatcher</name>
<macro><name>constructRestrictedWrapper</name><argument_list>(<argument>const DynTypedMatcher &amp;InnerMatcher</argument>,
<argument>ASTNodeKind RestrictKind</argument>)</argument_list></macro></expr>;




<expr><specifier>static</specifier> <name>DynTypedMatcher</name> <macro><name>trueMatcher</name><argument_list>(<argument>ASTNodeKind NodeKind</argument>)</argument_list></macro></expr>;

<expr><name>void</name> <macro><name>setAllowBind</name><argument_list>(<argument>bool AB</argument>)</argument_list></macro> <block>{ <expr><name>AllowBind</name> <operator>=</operator> <name>AB</name></expr>; }</block>




<name>bool</name> <macro><name>canMatchNodesOfKind</name><argument_list>(<argument>ASTNodeKind Kind</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>DynTypedMatcher</name> <macro><name>dynCastTo</name><argument_list>(<argument>const ASTNodeKind Kind</argument>)</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>DynTypedMatcher</name> <macro><name>withTraversalKind</name><argument_list>(<argument>TraversalKind TK</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>matches</name><argument_list>(<argument>const DynTypedNode &amp;DynNode</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>bool</name> <macro><name>matchesNoKindCheck</name><argument_list>(<argument>const DynTypedNode &amp;DynNode</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>DynTypedMatcher</name></expr></argument>&gt;</argument_list></name> <macro><name>tryBind</name><argument_list>(<argument>StringRef ID</argument>)</argument_list></macro> <specifier>const</specifier></expr>;








<expr><name>using</name> <name>MatcherIDType</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ASTNodeKind</name></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>MatcherIDType</name> <macro><name>getID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><name>RestrictKind</name></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Implementation</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name>ASTNodeKind</name> <macro><name>getSupportedKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SupportedKind</name></expr>;</return> }</block>






<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>bool</name> <macro><name>canConvertTo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>canConvertTo</name><argument_list>(<argument><expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>bool</name> <macro><name>canConvertTo</name><argument_list>(<argument>ASTNodeKind To</argument>)</argument_list></macro> <specifier>const</specifier></expr>;






<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>convertTo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>canConvertTo</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>unconditionalConvertTo</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>





<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>unconditionalConvertTo</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>TraversalKind</name></expr></argument>&gt;</argument_list></name> <macro><name>getTraversalKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Implementation</name><operator>-&gt;</operator><name>TraversalKind</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<macro><name>DynTypedMatcher</name><argument_list>(<argument>ASTNodeKind SupportedKind</argument>, <argument>ASTNodeKind RestrictKind</argument>,
<argument>IntrusiveRefCntPtr&lt;DynMatcherInterface&gt; Implementation</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SupportedKind</name><argument_list>(<argument><expr><name>SupportedKind</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>RestrictKind</name><argument_list>(<argument><expr><name>RestrictKind</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Implementation</name><argument_list>(<argument>std::move(Implementation)</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <name>AllowBind</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>ASTNodeKind</name> <name>SupportedKind</name></expr>;





<expr><name>ASTNodeKind</name> <name>RestrictKind</name></expr>;
<expr><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>DynMatcherInterface</name></expr></argument>&gt;</argument_list></name> <name>Implementation</name></expr>;
}</block></expr>;









<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>Matcher</name> <block>{
<expr><name>public</name><operator>:</operator>

<name>explicit</name> <call><name>Matcher</name><argument_list>(<argument><expr><name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>Implementation</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Implementation</name><argument_list>(<argument>Implementation</argument>)</argument_list></macro> <block>{}</block>




<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>From</name></expr></argument>&gt;</argument_list></name>
<call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>From</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Other</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>enable_if_t</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>From</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>From</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name> <operator>*</operator> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Implementation</name><argument_list>(<argument>restrictMatcher(Other.Implementation)</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Implementation</name><operator>.</operator><name>getSupportedKind</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isSame</name><argument_list>(
<argument><expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>




<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>TypeT</name></expr></argument>&gt;</argument_list></name>
<call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>TypeT</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Other</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>enable_if_t</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>&amp;&amp;</operator>
<name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>TypeT</name></expr></argument>, <argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name> <operator>*</operator> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Implementation</name><argument_list>(<argument>new TypeToQualType&lt;TypeT&gt;(Other)</argument>)</argument_list></macro> <block>{}</block>




<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name> <macro><name>dynCastTo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_LVALUE_FUNCTION</name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>, <argument><expr><literal type="string">"Invalid dynCast call."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Implementation</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_HAS_RVALUE_REFERENCE_THIS</name></expr></cpp:if>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name> <call><name>dynCastTo</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>, <argument><expr><literal type="string">"Invalid dynCast call."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Implementation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const T &amp;Node</argument>,
<argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Implementation</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>DynTypedNode</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>DynTypedMatcher</name><operator>::</operator><name>MatcherIDType</name> <macro><name>getID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Implementation</name><operator>.</operator><name>getID</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>





<name>operator</name> <macro><name>DynTypedMatcher</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_LVALUE_FUNCTION</name> <block>{
<return>return <expr><name>Implementation</name></expr>;</return>
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_HAS_RVALUE_REFERENCE_THIS</name></expr></cpp:if>
<name>operator</name> <call><name>DynTypedMatcher</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <block>{ <return>return <expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Implementation</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>







<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>TypeT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>TypeToQualType</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>const</specifier> <name>DynTypedMatcher</name> <name>InnerMatcher</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>TypeToQualType</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>TypeT</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>InnerMatcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>InnerMatcher</name><argument_list>(<argument>InnerMatcher</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const QualType &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>DynTypedNode</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><operator>*</operator><name>Node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>TraversalKind</name></expr></argument>&gt;</argument_list></name> <macro><name>TraversalKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>InnerMatcher</name><operator>.</operator><name>getTraversalKind</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name>private</name><operator>:</operator>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>U</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>Matcher</name></expr>;


<expr><name>friend</name> <name>class</name> <name>DynTypedMatcher</name></expr>;

<expr><specifier>static</specifier> <name>DynTypedMatcher</name> <macro><name>restrictMatcher</name><argument_list>(<argument>const DynTypedMatcher &amp;Other</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Other</name><operator>.</operator><name>dynCastTo</name></name><argument_list>(<argument><expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>explicit</name> <call><name>Matcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DynTypedMatcher</name> <operator>&amp;</operator><name>Implementation</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Implementation</name><argument_list>(<argument>restrictMatcher(Implementation)</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>this</name><operator>-&gt;</operator><name>Implementation</name><operator>.</operator><name>getSupportedKind</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isSame</name><argument_list>(
<argument><expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>DynTypedMatcher</name> <name>Implementation</name></expr>;
}</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>makeMatcher</name><argument_list>(<argument>MatcherInterface&lt;T&gt; *Implementation</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Implementation</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



















<name>class</name> <name>ASTMatchFinder</name> <block>{
<expr><name>public</name><operator>:</operator>

enum <name>BindKind</name> <block>{

<expr><name>BK_First</name></expr>,


<expr><name>BK_All</name></expr>
}</block></expr>;


enum <expr><name>AncestorMatchMode</name> <block>{

<expr><name>AMM_All</name></expr>,


<expr><name>AMM_ParentOnly</name></expr>
}</block></expr>;

<expr><name>virtual</name> <operator>~</operator><call><name>ASTMatchFinder</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;





<expr><name>virtual</name> <name>bool</name> <macro><name>classIsDerivedFrom</name><argument_list>(<argument>const CXXRecordDecl *Declaration</argument>,
<argument>const Matcher&lt;NamedDecl&gt; &amp;Base</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>,
<argument>bool Directly</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;





<expr><name>virtual</name> <name>bool</name> <macro><name>objcClassIsDerivedFrom</name><argument_list>(<argument>const ObjCInterfaceDecl *Declaration</argument>,
<argument>const Matcher&lt;NamedDecl&gt; &amp;Base</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>,
<argument>bool Directly</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>matchesChildOf</name><argument_list>(<argument>const T &amp;Node</argument>, <argument>const DynTypedMatcher &amp;Matcher</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>, <argument>BindKind Bind</argument>)</argument_list></macro> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>NestedNameSpecifier</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>NestedNameSpecifierLoc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>TypeLoc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"unsupported type for recursive matching"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>matchesChildOf</name><argument_list>(<argument><expr><name>DynTypedNode</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Matcher</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>, <argument><expr><name>Bind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>matchesDescendantOf</name><argument_list>(<argument>const T &amp;Node</argument>, <argument>const DynTypedMatcher &amp;Matcher</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>, <argument>BindKind Bind</argument>)</argument_list></macro> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>NestedNameSpecifier</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>NestedNameSpecifierLoc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>TypeLoc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"unsupported type for recursive matching"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>matchesDescendantOf</name><argument_list>(<argument><expr><name>DynTypedNode</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Matcher</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>, <argument><expr><name>Bind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>matchesAncestorOf</name><argument_list>(<argument>const T &amp;Node</argument>, <argument>const DynTypedMatcher &amp;Matcher</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>,
<argument>AncestorMatchMode MatchMode</argument>)</argument_list></macro> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>NestedNameSpecifierLoc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>TypeLoc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"type not allowed for recursive matching"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>matchesAncestorOf</name><argument_list>(<argument><expr><name>DynTypedNode</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getASTContext</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Matcher</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>, <argument><expr><name>MatchMode</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>virtual</name> <name>ASTContext</name> <operator>&amp;</operator><macro><name>getASTContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsMatchingInASTNodeNotSpelledInSource</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>IsMatchingInASTNodeNotAsIs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>bool</name> <macro><name>isTraversalIgnoringImplicitNodes</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>protected</name><operator>:</operator>
<name>virtual</name> <name>bool</name> <macro><name>matchesChildOf</name><argument_list>(<argument>const DynTypedNode &amp;Node</argument>, <argument>ASTContext &amp;Ctx</argument>,
<argument>const DynTypedMatcher &amp;Matcher</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>,
<argument>BindKind Bind</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>matchesDescendantOf</name><argument_list>(<argument>const DynTypedNode &amp;Node</argument>, <argument>ASTContext &amp;Ctx</argument>,
<argument>const DynTypedMatcher &amp;Matcher</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>,
<argument>BindKind Bind</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>virtual</name> <name>bool</name> <macro><name>matchesAncestorOf</name><argument_list>(<argument>const DynTypedNode &amp;Node</argument>, <argument>ASTContext &amp;Ctx</argument>,
<argument>const DynTypedMatcher &amp;Matcher</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>,
<argument>AncestorMatchMode MatchMode</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>private</name><operator>:</operator>
<name>friend</name> struct <name>ASTChildrenNotSpelledInSourceScope</name></expr>;
<expr><name>virtual</name> <name>bool</name> <macro><name>isMatchingChildrenNotSpelledInSource</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>virtual</name> <name>void</name> <macro><name>setMatchingChildrenNotSpelledInSource</name><argument_list>(<argument>bool Set</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block></expr>;

struct <expr><name>ASTChildrenNotSpelledInSourceScope</name> <block>{
<macro><name>ASTChildrenNotSpelledInSourceScope</name><argument_list>(<argument>ASTMatchFinder *V</argument>, <argument>bool B</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>MV</name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>, <macro><name>MB</name><argument_list>(<argument>V-&gt;isMatchingChildrenNotSpelledInSource()</argument>)</argument_list></macro> <expr><block>{
<expr><call><name><name>V</name><operator>-&gt;</operator><name>setMatchingChildrenNotSpelledInSource</name></name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;
}</block>
<operator>~</operator><macro><name>ASTChildrenNotSpelledInSourceScope</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name><name>MV</name><operator>-&gt;</operator><name>setMatchingChildrenNotSpelledInSource</name></name><argument_list>(<argument><expr><name>MB</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>ASTMatchFinder</name> <operator>*</operator><name>MV</name></expr>;
<expr><name>bool</name> <name>MB</name></expr>;
}</block></expr>;





<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <name>DynTypedMatcher</name><operator>::</operator><macro><name>convertTo</name></macro><operator>&lt;</operator><name>QualType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>canConvertTo</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>ASTNodeKind</name> <name>SourceKind</name> <operator>=</operator> <call><name>getSupportedKind</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>SourceKind</name><operator>.</operator><name>isSame</name></name><argument_list>(<argument><expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name><name>unconditionalConvertTo</name><argument_list type="generic">&lt;<argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
return unconditionalConvertTo&lt;QualType&gt;(</block></if></if_stmt>)</block></expr>;
}</block>


<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcherT</name></expr></argument>, <argument><expr><name>typename</name> <name>IteratorT</name></expr></argument>&gt;</argument_list></name>
<name>IteratorT</name> <macro><name>matchesFirstInRange</name><argument_list>(<argument>const MatcherT &amp;Matcher</argument>, <argument>IteratorT Start</argument>,
<argument>IteratorT End</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><decl><type><name>IteratorT</name></type> <name>I</name> <init>= <expr><name>Start</name></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>End</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>Result</name><argument_list>(<argument><expr><operator>*</operator><name>Builder</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Matcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><name>I</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>Builder</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>I</name></expr>;</return>
<expr_stmt/>}</block_content>
}
return End</block><empty_stmt>;</empty_stmt></if></if_stmt>
<expr_stmt/>}</block_content>



template &lt;typename MatcherT</block><operator>,</operator> <expr_stmt><expr><name>typename</name> <name>IteratorT</name><operator>&gt;</operator>
<name>IteratorT</name> <macro><name>matchesFirstInPointerRange</name><argument_list>(<argument>const MatcherT &amp;Matcher</argument>, <argument>IteratorT Start</argument>,
<argument>IteratorT End</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><decl><type><name>IteratorT</name></type> <name>I</name> <init>= <expr><name>Start</name></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>End</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>BoundNodesTreeBuilder</name></type> <name>Result</name><argument_list>(<argument><expr><operator>*</operator><name>Builder</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Matcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>I</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Result</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>Builder</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>I</name></expr>;</return>
<expr_stmt/>}</block_content>
}
return End</block><empty_stmt>;</empty_stmt></if></if_stmt>
<expr_stmt/>}</block_content>

template &lt;typename T</block><operator>,</operator> <expr_stmt><expr><name>std</name><operator>::</operator><name><name>enable_if_t</name><argument_list type="generic">&lt;<argument><expr><operator>!</operator><name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name>
<operator>*</operator> <operator>=</operator> <name>nullptr</name><operator>&gt;</operator>
<specifier>inline</specifier> <name>bool</name> <macro><name>isDefaultedHelper</name><argument_list>(<argument>const T *</argument>)</argument_list></macro> <block>{
<return>return <expr><name>false</name></expr>;</return>
}</block>
<specifier>inline</specifier> <name>bool</name> <macro><name>isDefaultedHelper</name><argument_list>(<argument>const FunctionDecl *FD</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>FD</name><operator>-&gt;</operator><name>isDefaulted</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Ty</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>has_getDecl</name> <block>{
<expr><name>using</name> <name>yes</name> <operator>=</operator> <name><name>char</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;
<expr><name>using</name> <name>no</name> <operator>=</operator> <name><name>char</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Inner</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>yes</name><operator>&amp;</operator> <call><name>test</name><argument_list>(<argument><expr><name>Inner</name> <operator>*</operator><name>I</name></expr></argument>, <argument><expr><call><name>decltype</name><argument_list>(<argument><expr><call><name><name>I</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>*</operator> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name>no</name><operator>&amp;</operator> <call><name>test</name><argument_list>(<argument><expr><operator>...</operator></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <specifier>const</specifier> <name>bool</name> <name>value</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><call><name><name>test</name><argument_list type="generic">&lt;<argument><expr><name>Ty</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>yes</name></expr></argument>)</argument_list></sizeof></expr>;
}</block></expr>;</expr_stmt></for>





<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>HasOverloadedOperatorNameMatcher</name> <operator>:</operator> <name>public</name> <name><name>SingleNodeMatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>CXXOperatorCallExpr</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"unsupported class for matcher"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>ArgT</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"argument type must be std::vector&lt;std::string&gt;"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>HasOverloadedOperatorNameMatcher</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>Names</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name><name>SingleNodeMatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>, <macro><name>Names</name><argument_list>(<argument>std::move(Names)</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>matchesNode</name><argument_list>(<argument>const T &amp;Node</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>matchesSpecialized</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>




<name>bool</name> <macro><name>matchesSpecialized</name><argument_list>(<argument>const CXXOperatorCallExpr &amp;Node</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>is_contained</name><argument_list>(<argument><expr><name>Names</name></expr></argument>, <argument><expr><call><name>getOperatorSpelling</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getOperator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>matchesSpecialized</name><argument_list>(<argument>const FunctionDecl &amp;Node</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>isOverloadedOperator</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<name>llvm</name><operator>::</operator><call><name>is_contained</name><argument_list>(
<argument><expr><name>Names</name></expr></argument>, <argument><expr><call><name>getOperatorSpelling</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getOverloadedOperator</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>Names</name></expr>;
}</block></block></expr>;</expr_stmt></for>




<name>class</name> <name>HasNameMatcher</name> <operator>:</operator> <name>public</name> <name><name>SingleNodeMatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>HasNameMatcher</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>Names</name></expr></argument>)</argument_list></call></expr>;

<expr><name>bool</name> <macro><name>matchesNode</name><argument_list>(<argument>const NamedDecl &amp;Node</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>private</name><operator>:</operator>




<name>bool</name> <macro><name>matchesNodeUnqualified</name><argument_list>(<argument>const NamedDecl &amp;Node</argument>)</argument_list></macro> <specifier>const</specifier></expr>;







<expr><name>bool</name> <macro><name>matchesNodeFullFast</name><argument_list>(<argument>const NamedDecl &amp;Node</argument>)</argument_list></macro> <specifier>const</specifier></expr>;






<expr><name>bool</name> <macro><name>matchesNodeFullSlow</name><argument_list>(<argument>const NamedDecl &amp;Node</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <name>UseUnqualifiedMatch</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>Names</name></expr>;
}</block></block></expr>;



<expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name></expr></argument>&gt;</argument_list></name> <call><name>hasAnyNameFunc</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>StringRef</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>NameRefs</name></expr></argument>)</argument_list></call></expr>;



<expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMessageExpr</name></expr></argument>&gt;</argument_list></name> <call><name>hasAnySelectorFunc</name><argument_list>(
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>StringRef</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>NameRefs</name></expr></argument>)</argument_list></call></expr>;





<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>DeclMatcherT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>HasDeclarationMatcher</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>DeclMatcherT</name></expr></argument>, <argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"instantiated with wrong types"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>DynTypedMatcher</name> <name>InnerMatcher</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>HasDeclarationMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>InnerMatcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>InnerMatcher</name><argument_list>(<argument>InnerMatcher</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const T &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name>matchesSpecialized</name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>

<name>bool</name> <macro><name>matchesSpecialized</name><argument_list>(<argument>const QualType &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><call><name>matchesSpecialized</name><argument_list>(<argument><expr><operator>*</operator><name>Node</name></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>matchesSpecialized</name><argument_list>(<argument>const Type &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <block>{


<expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>EffectiveType</name> <operator>=</operator> <operator>&amp;</operator><name>Node</name></expr>;
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>S</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeducedType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>EffectiveType</name> <operator>=</operator> <call><name><name>S</name><operator>-&gt;</operator><name>getDeducedType</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getTypePtrOrNull</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>EffectiveType</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>



if (const auto *S = dyn_cast&lt;TagType&gt;(EffectiveType</block></if></if_stmt>))</block> <block>{
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>S</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>InjectedClassNameType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>EffectiveType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
if (const auto *S = dyn_cast&lt;TemplateTypeParmType&gt;(EffectiveType</block></if></if_stmt>))</block> <block>{
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>S</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>TypedefType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>EffectiveType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
if (const auto *S = dyn_cast&lt;UnresolvedUsingType&gt;(EffectiveType</block></if></if_stmt>))</block> <block>{
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>S</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCObjectType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>EffectiveType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getInterface</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>









<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>S</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>SubstTemplateTypeParmType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>EffectiveType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<return>return <expr><call><name>matchesSpecialized</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getReplacementType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>S</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateSpecializationType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>EffectiveType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>S</name><operator>-&gt;</operator><name>isTypeAlias</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>S</name><operator>-&gt;</operator><name>isSugared</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>






<return>return <expr><call><name>matchesSpecialized</name><argument_list>(<argument><expr><operator>*</operator><call><name><name>S</name><operator>-&gt;</operator><name>desugar</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>


<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>getTemplateName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAsTemplateDecl</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>S</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ElaboratedType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>EffectiveType</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<return>return <expr><call><name>matchesSpecialized</name><argument_list>(<argument><expr><call><name><name>S</name><operator>-&gt;</operator><name>desugar</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>matchesSpecialized</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclRefExpr</name> <operator>&amp;</operator><name>Node</name></expr></argument>, <argument><expr><name>ASTMatchFinder</name> <operator>*</operator><name>Finder</name></expr></argument>,
<argument><expr><name>BoundNodesTreeBuilder</name> <operator>*</operator><name>Builder</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>matchesSpecialized</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CallExpr</name> <operator>&amp;</operator><name>Node</name></expr></argument>, <argument><expr><name>ASTMatchFinder</name> <operator>*</operator><name>Finder</name></expr></argument>,
<argument><expr><name>BoundNodesTreeBuilder</name> <operator>*</operator><name>Builder</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getCalleeDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>matchesSpecialized</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXConstructExpr</name> <operator>&amp;</operator><name>Node</name></expr></argument>,
<argument><expr><name>ASTMatchFinder</name> <operator>*</operator><name>Finder</name></expr></argument>,
<argument><expr><name>BoundNodesTreeBuilder</name> <operator>*</operator><name>Builder</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getConstructor</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>matchesSpecialized</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCIvarRefExpr</name> <operator>&amp;</operator><name>Node</name></expr></argument>,
<argument><expr><name>ASTMatchFinder</name> <operator>*</operator><name>Finder</name></expr></argument>,
<argument><expr><name>BoundNodesTreeBuilder</name> <operator>*</operator><name>Builder</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>matchesSpecialized</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXNewExpr</name> <operator>&amp;</operator><name>Node</name></expr></argument>,
<argument><expr><name>ASTMatchFinder</name> <operator>*</operator><name>Finder</name></expr></argument>,
<argument><expr><name>BoundNodesTreeBuilder</name> <operator>*</operator><name>Builder</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getOperatorNew</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>matchesSpecialized</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MemberExpr</name> <operator>&amp;</operator><name>Node</name></expr></argument>,
<argument><expr><name>ASTMatchFinder</name> <operator>*</operator><name>Finder</name></expr></argument>,
<argument><expr><name>BoundNodesTreeBuilder</name> <operator>*</operator><name>Builder</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getMemberDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>matchesSpecialized</name><argument_list>(<argument><expr><specifier>const</specifier> <name>AddrLabelExpr</name> <operator>&amp;</operator><name>Node</name></expr></argument>,
<argument><expr><name>ASTMatchFinder</name> <operator>*</operator><name>Finder</name></expr></argument>,
<argument><expr><name>BoundNodesTreeBuilder</name> <operator>*</operator><name>Builder</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getLabel</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>matchesSpecialized</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LabelStmt</name> <operator>&amp;</operator><name>Node</name></expr></argument>, <argument><expr><name>ASTMatchFinder</name> <operator>*</operator><name>Finder</name></expr></argument>,
<argument><expr><name>BoundNodesTreeBuilder</name> <operator>*</operator><name>Builder</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name>matchesDecl</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>matchesDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>Node</name></expr></argument>, <argument><expr><name>ASTMatchFinder</name> <operator>*</operator><name>Finder</name></expr></argument>,
<argument><expr><name>BoundNodesTreeBuilder</name> <operator>*</operator><name>Builder</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>Node</name> <operator>!=</operator> <name>nullptr</name> <operator>&amp;&amp;</operator>
<operator>!</operator><operator>(</operator><call><name><name>Finder</name><operator>-&gt;</operator><name>isTraversalIgnoringImplicitNodes</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Node</name><operator>-&gt;</operator><name>isImplicit</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name><name>this</name><operator>-&gt;</operator><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>DynTypedNode</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><operator>*</operator><name>Node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>T</name><operator>&gt;</operator>
struct <name>IsBaseType</name> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <name>bool</name> <name>value</name> <operator>=</operator>
<name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>Decl</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator> <name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>Stmt</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator> <name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>Type</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>TypeLoc</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>NestedNameSpecifier</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>NestedNameSpecifierLoc</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>CXXCtorInitializer</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr>;
}</block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>bool</name> <name><name>IsBaseType</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>using</name></type> <name>AllNodeBaseTypes</name> <init>=
<expr><name><name>TypeList</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>, <argument><expr><name>Stmt</name></expr></argument>, <argument><expr><name>NestedNameSpecifier</name></expr></argument>, <argument><expr><name>NestedNameSpecifierLoc</name></expr></argument>, <argument><expr><name>QualType</name></expr></argument>,
<argument><expr><name>Type</name></expr></argument>, <argument><expr><name>TypeLoc</name></expr></argument>, <argument><expr><name>CXXCtorInitializer</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>





<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>T</name><operator>&gt;</operator> struct <name>ExtractFunctionArgMeta</name></expr>;</expr_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>class</name> <name>T</name><operator>&gt;</operator> struct <name><name>ExtractFunctionArgMeta</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>T</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>type</name> <operator>=</operator> <name>T</name></expr>;
}</block></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>, <argument><expr><name>class</name> <name>Tuple</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>size_t</name><modifier>...</modifier> <name>I</name></expr></argument>&gt;</argument_list></name>
<name>constexpr</name> <name>T</name> <modifier>*</modifier></type><name>new_from_tuple_impl</name><argument_list>(<argument><expr><name>Tuple</name> <operator>&amp;&amp;</operator><name>t</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>index_sequence</name><argument_list type="generic">&lt;<argument><expr><name>I</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>new</name> <call><name>T</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>I</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>, <argument><expr><name>class</name> <name>Tuple</name></expr></argument>&gt;</argument_list></name> <name>constexpr</name> <name>T</name> <modifier>*</modifier></type><name>new_from_tuple</name><argument_list>(<argument><expr><name>Tuple</name> <operator>&amp;&amp;</operator><name>t</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <macro><name>new_from_tuple_impl</name></macro><expr><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator>
<name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call><operator>,</operator>
<name>std</name><operator>::</operator><name><name>make_index_sequence</name><argument_list type="generic">&lt;
<argument><expr><name>std</name><operator>::</operator><name><name>tuple_size</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>remove_reference_t</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><block>{}</block><operator>)</operator></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>AdaptativeDefaultFromTypes</name> <init>= <expr><name>AllNodeBaseTypes</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>AdaptativeDefaultToTypes</name> <init>=
<expr><name><name>TypeList</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>, <argument><expr><name>Stmt</name></expr></argument>, <argument><expr><name>NestedNameSpecifier</name></expr></argument>, <argument><expr><name>NestedNameSpecifierLoc</name></expr></argument>, <argument><expr><name>TypeLoc</name></expr></argument>,
<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>HasDeclarationSupportedTypes</name> <init>=
<expr><name><name>TypeList</name><argument_list type="generic">&lt;<argument><expr><name>CallExpr</name></expr></argument>, <argument><expr><name>CXXConstructExpr</name></expr></argument>, <argument><expr><name>CXXNewExpr</name></expr></argument>, <argument><expr><name>DeclRefExpr</name></expr></argument>, <argument><expr><name>EnumType</name></expr></argument>,
<argument><expr><name>ElaboratedType</name></expr></argument>, <argument><expr><name>InjectedClassNameType</name></expr></argument>, <argument><expr><name>LabelStmt</name></expr></argument>, <argument><expr><name>AddrLabelExpr</name></expr></argument>,
<argument><expr><name>MemberExpr</name></expr></argument>, <argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>RecordType</name></expr></argument>, <argument><expr><name>TagType</name></expr></argument>,
<argument><expr><name>TemplateSpecializationType</name></expr></argument>, <argument><expr><name>TemplateTypeParmType</name></expr></argument>, <argument><expr><name>TypedefType</name></expr></argument>,
<argument><expr><name>UnresolvedUsingType</name></expr></argument>, <argument><expr><name>ObjCIvarRefExpr</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>BindableMatcher</name> <range>: <expr><name>public</name> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>BindableMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>M</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>M</name><operator>)</operator> <block>{}</block>
<name>explicit</name> <call><name>BindableMatcher</name><argument_list>(<argument><expr><name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>Implementation</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>Implementation</name><operator>)</operator> <block>{}</block>





<name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>bind</name><argument_list>(<argument>StringRef ID</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>DynTypedMatcher</name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call>
<operator>.</operator><call><name>tryBind</name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><name>template</name> <call><name><name>unconditionalConvertTo</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>operator</name> <macro><name>DynTypedMatcher</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>DynTypedMatcher</name> <name>Result</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Result</name><operator>.</operator><name>setAllowBind</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Result</name></expr>;</return>
}</block>
}</expr>;





<expr><name>class</name> <name>TrueMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>using</name> <name>ReturnTypes</name> <operator>=</operator> <name>AllNodeBaseTypes</name></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>DynTypedMatcher</name><operator>::</operator><call><name>trueMatcher</name><argument_list>(<argument><expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><name>template</name> <call><name><name>unconditionalConvertTo</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>BindableMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name>
<macro><name>makeAllOfComposite</name><argument_list>(<argument>ArrayRef&lt;const Matcher&lt;T&gt; *&gt; InnerMatchers</argument>)</argument_list></macro> <block>{

<if_stmt><if>if <condition>(<expr><call><name><name>InnerMatchers</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return <expr><call><name><name>BindableMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>TrueMatcher</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>


if (InnerMatchers.size(</block></if></if_stmt>) <operator>==</operator> <literal type="number">1</literal>)</block> <block>{
<return>return <expr><call><name><name>BindableMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name><name>InnerMatchers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>PI</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>pointee_iterator</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>DynTypedMatcher</name></expr></argument>&gt;</argument_list></name> <call><name>DynMatchers</name><argument_list>(<argument><expr><call><name>PI</name><argument_list>(<argument><expr><call><name><name>InnerMatchers</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PI</name><argument_list>(<argument><expr><call><name><name>InnerMatchers</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <macro><name>BindableMatcher</name></macro><expr><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator>
<name>DynTypedMatcher</name><operator>::</operator><call><name>constructVariadic</name><argument_list>(<argument><expr><name>DynTypedMatcher</name><operator>::</operator><name>VO_AllOf</name></expr></argument>,
<argument><expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>DynMatchers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><name>template</name> <call><name><name>unconditionalConvertTo</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block>







<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>InnerT</name></expr></argument>&gt;</argument_list></name>
<name><name>BindableMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name>
<macro><name>makeDynCastAllOfComposite</name><argument_list>(<argument>ArrayRef&lt;const Matcher&lt;InnerT&gt; *&gt; InnerMatchers</argument>)</argument_list></macro> <block>{
<return>return <macro><name>BindableMatcher</name></macro><expr><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator>
<call><name>makeAllOfComposite</name><argument_list>(<argument><expr><name>InnerMatchers</name></expr></argument>)</argument_list></call><operator>.</operator><name>template</name> <call><name><name>dynCastTo</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block>












<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>SourceT</name></expr></argument>, <argument><expr><name>typename</name> <name>TargetT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>VariadicDynCastAllOfMatcher</name>
<operator>:</operator> <name>public</name> <name><name>VariadicFunction</name><argument_list type="generic">&lt;<argument><expr><name><name>BindableMatcher</name><argument_list type="generic">&lt;<argument><expr><name>SourceT</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>TargetT</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name><name>makeDynCastAllOfComposite</name><argument_list type="generic">&lt;<argument><expr><name>SourceT</name></expr></argument>, <argument><expr><name>TargetT</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>VariadicDynCastAllOfMatcher</name><argument_list>()</argument_list></macro> <block>{}</block></expr>
}</block></expr>;











<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>VariadicAllOfMatcher</name>
<operator>:</operator> <name>public</name> <name><name>VariadicFunction</name><argument_list type="generic">&lt;<argument><expr><name><name>BindableMatcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name><name>makeAllOfComposite</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>VariadicAllOfMatcher</name><argument_list>()</argument_list></macro> <block>{}</block></expr>
}</block></expr>;










<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Ps</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>VariadicOperatorMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>VariadicOperatorMatcher</name><argument_list>(<argument>DynTypedMatcher::VariadicOperator Op</argument>, <argument>Ps &amp;&amp;... Params</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Op</name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call></expr>, <macro><name>Params</name><argument_list>(<argument>std::forward&lt;Ps&gt;(Params)...</argument>)</argument_list></macro> <expr><block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <name>LLVM_LVALUE_FUNCTION</name> <block>{
<return>return <expr><name>DynTypedMatcher</name><operator>::</operator><call><name>constructVariadic</name><argument_list>(
<argument><expr><name>Op</name></expr></argument>, <argument><expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getMatchers</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>index_sequence_for</name><argument_list type="generic">&lt;<argument><expr><name>Ps</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><name>template</name> <call><name><name>unconditionalConvertTo</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_HAS_RVALUE_REFERENCE_THIS</name></expr></cpp:if>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>operator</name> <call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <block>{
<return>return <expr><name>DynTypedMatcher</name><operator>::</operator><call><name>constructVariadic</name><argument_list>(
<argument><expr><name>Op</name></expr></argument>, <argument><expr><name>ASTNodeKind</name><operator>::</operator><call><name><name>getFromNodeKind</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getMatchers</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>index_sequence_for</name><argument_list type="generic">&lt;<argument><expr><name>Ps</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>.</operator><name>template</name> <call><name><name>unconditionalConvertTo</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>private</name><operator>:</operator>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>size_t</name><modifier>...</modifier> <name>Is</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>DynTypedMatcher</name></expr></argument>&gt;</argument_list></name>
<macro><name>getMatchers</name><argument_list>(<argument>std::index_sequence&lt;Is...&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <name>LLVM_LVALUE_FUNCTION</name> <block>{
<return>return <expr><block>{<expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>Is</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>...</operator></expr>}</block></expr>;</return>
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_HAS_RVALUE_REFERENCE_THIS</name></expr></cpp:if>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>size_t</name><modifier>...</modifier> <name>Is</name></expr></argument>&gt;</argument_list></name>
<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>DynTypedMatcher</name></expr></argument>&gt;</argument_list></name> <call><name>getMatchers</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>index_sequence</name><argument_list type="generic">&lt;<argument><expr><name>Is</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <block>{
<return>return <expr><block>{<expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>Is</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>...</operator></expr>}</block></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<specifier>const</specifier> <name>DynTypedMatcher</name><operator>::</operator><name>VariadicOperator</name> <name>Op</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>Ps</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <name>Params</name></expr>;
}</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>unsigned</name> <name>MinCount</name></expr></argument>, <argument><expr><name>unsigned</name> <name>MaxCount</name></expr></argument>&gt;</argument_list></name>
struct <name>VariadicOperatorMatcherFunc</name> <block>{
<expr><name>DynTypedMatcher</name><operator>::</operator><name>VariadicOperator</name> <name>Op</name></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Ms</name></expr></argument>&gt;</argument_list></name>
<name><name>VariadicOperatorMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Ms</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><name>Ms</name> <operator>&amp;&amp;</operator><operator>...</operator> <name>Ps</name><operator>)</operator> <specifier>const</specifier> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>MinCount</name> <operator>&lt;=</operator> <sizeof type="pack">sizeof...<argument_list>(<argument><expr><name>Ms</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator> <sizeof type="pack">sizeof...<argument_list>(<argument><expr><name>Ms</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>MaxCount</name></expr></argument>,
<argument><expr><literal type="string">"invalid number of parameters for variadic matcher"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>VariadicOperatorMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Ms</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Op</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>Ms</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Ps</name></expr></argument>)</argument_list></call><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>, <argument><expr><name>typename</name> <name>Tuple</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>size_t</name><modifier>...</modifier> <name>I</name></expr></argument>&gt;</argument_list></name>
<name>constexpr</name> <name>auto</name> <macro><name>applyMatcherImpl</name><argument_list>(<argument>F &amp;&amp;f</argument>, <argument>Tuple &amp;&amp;args</argument>,
<argument>std::index_sequence&lt;I...&gt;</argument>)</argument_list></macro> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>F</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>I</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>forward</name><argument_list type="generic">&lt;<argument><expr><name>Tuple</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>...</operator></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>F</name></expr></argument>, <argument><expr><name>typename</name> <name>Tuple</name></expr></argument>&gt;</argument_list></name>
<name>constexpr</name> <name>auto</name> <macro><name>applyMatcher</name><argument_list>(<argument>F &amp;&amp;f</argument>, <argument>Tuple &amp;&amp;args</argument>)</argument_list></macro> <block>{
<return>return <macro><name>applyMatcherImpl</name><argument_list>(
<argument>std::forward&lt;F&gt;(f)</argument>, <argument>std::forward&lt;Tuple&gt;(args)</argument>,
<argument>std::make_index_sequence&lt;
std::tuple_size&lt;typename std::decay&lt;Tuple&gt;::type&gt;::value&gt;()</argument>)</argument_list></macro>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>bool</name> <name>IsBaseOf</name></expr></argument>, <argument><expr><name>typename</name> <name>Head</name></expr></argument>, <argument><expr><name>typename</name> <name>Tail</name></expr></argument>&gt;</argument_list></name>
struct <name>GetCladeImpl</name> <block>{
<expr><name>using</name> <name>Type</name> <operator>=</operator> <name>Head</name></expr>;
}</block></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>Head</name></expr></argument>, <argument><expr><name>typename</name> <name>Tail</name></expr></argument>&gt;</argument_list></name>
struct <name><name>GetCladeImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>Head</name></expr></argument>, <argument><expr><name>Tail</name></expr></argument>&gt;</argument_list></name>
<operator>:</operator> <name><name>GetCladeImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Tail</name><operator>::</operator><name>head</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><name>typename</name> <name>Tail</name><operator>::</operator><name>head</name></expr></argument>, <argument><expr><name>typename</name> <name>Tail</name><operator>::</operator><name>tail</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>U</name></expr></argument>&gt;</argument_list></name>
struct <name>GetClade</name> <operator>:</operator> <name><name>GetCladeImpl</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>AllNodeBaseTypes</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>CladeType</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>MatcherTypes</name></expr></argument>&gt;</argument_list></name>
struct <name>MapAnyOfMatcherImpl</name> <block>{

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>InnerMatchers</name></expr></argument>&gt;</argument_list></name>
<name><name>BindableMatcher</name><argument_list type="generic">&lt;<argument><expr><name>CladeType</name></expr></argument>&gt;</argument_list></name>
<macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><name>InnerMatchers</name> <operator>&amp;&amp;</operator><operator>...</operator> <name>InnerMatcher</name><operator>)</operator> <specifier>const</specifier> <block>{

<return>return <macro><name>VariadicAllOfMatcher</name></macro><expr><operator>&lt;</operator><name>CladeType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>(</operator><macro><name>applyMatcher</name><argument_list>(
<argument>internal::VariadicOperatorMatcherFunc&lt;
<literal type="number">0</literal></argument>, <argument>std::numeric_limits&lt;unsigned&gt;::max()&gt;{
internal::DynTypedMatcher::VO_AnyOf}</argument>,
<argument>applyMatcher(
[&amp;](auto... Matcher) {
return std::make_tuple(Matcher(InnerMatcher...)...);
},
std::tuple&lt;
VariadicDynCastAllOfMatcher&lt;CladeType, MatcherTypes&gt;...&gt;())</argument>)</argument_list></macro><operator>)</operator></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>MatcherTypes</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>MapAnyOfMatcher</name> <operator>=</operator>
<name><name>MapAnyOfMatcherImpl</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name><name>GetClade</name><argument_list type="generic">&lt;<argument><expr><name>MatcherTypes</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Type</name></expr></argument>,
<argument><expr><name>MatcherTypes</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>MatcherTypes</name></expr></argument>&gt;</argument_list></name> struct <name>MapAnyOfHelper</name> <block>{
<expr><name>using</name> <name>CladeType</name> <operator>=</operator> <name>typename</name> <name><name>GetClade</name><argument_list type="generic">&lt;<argument><expr><name>MatcherTypes</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Type</name></expr>;

<expr><name><name>MapAnyOfMatcher</name><argument_list type="generic">&lt;<argument><expr><name>MatcherTypes</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <name>with</name></expr>;

<expr><name>operator</name> <macro><name>BindableMatcher</name></macro><operator>&lt;</operator><name>CladeType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{ <return>return <expr><call><name>with</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>CladeType</name></expr></argument>&gt;</argument_list></name> <macro><name>bind</name><argument_list>(<argument>StringRef ID</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>with</name><argument_list>()</argument_list></call><operator>.</operator><call><name>bind</name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ToArg</name></expr></argument>, <argument><expr><name>typename</name> <name>FromArg</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>ArgumentAdapterT</name></expr></argument>,
<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>ToTypes</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>ArgumentAdaptingMatcherFuncAdaptor</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>ArgumentAdaptingMatcherFuncAdaptor</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>InnerMatcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>InnerMatcher</name><argument_list>(<argument>InnerMatcher</argument>)</argument_list></macro> <block>{}</block>

<name>using</name> <name>ReturnTypes</name> <operator>=</operator> <name>ToTypes</name></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name> <name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>To</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <name>LLVM_LVALUE_FUNCTION</name> <block>{
<return>return <macro><name>Matcher</name></macro><expr><operator>&lt;</operator><name>To</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>ArgumentAdapterT</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_HAS_RVALUE_REFERENCE_THIS</name></expr></cpp:if>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>To</name></expr></argument>&gt;</argument_list></name> <name>operator</name> <call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <block>{
<return>return <macro><name>Matcher</name></macro><expr><operator>&lt;</operator><name>To</name><operator>&gt;</operator><operator>(</operator><name>new</name> <call><name><name>ArgumentAdapterT</name><argument_list type="generic">&lt;<argument><expr><name>To</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>private</name><operator>:</operator>
<name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>InnerMatcher</name></expr>;
}</block></expr>;














<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ToArg</name></expr></argument>, <argument><expr><name>typename</name> <name>FromArg</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>ArgumentAdapterT</name></expr></argument>,
<argument><expr><name>typename</name> <name>FromTypes</name> <operator>=</operator> <name>AdaptativeDefaultFromTypes</name></expr></argument>,
<argument><expr><name>typename</name> <name>ToTypes</name> <operator>=</operator> <name>AdaptativeDefaultToTypes</name></expr></argument>&gt;</argument_list></name>
struct <name>ArgumentAdaptingMatcherFunc</name> <block>{
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <name><name>ArgumentAdaptingMatcherFuncAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>ArgumentAdapterT</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>ToTypes</name></expr></argument>&gt;</argument_list></name>
<macro><name>create</name><argument_list>(<argument>const Matcher&lt;T&gt; &amp;InnerMatcher</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>ArgumentAdaptingMatcherFuncAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>ArgumentAdapterT</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>ToTypes</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>ArgumentAdaptingMatcherFuncAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>ArgumentAdapterT</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>ToTypes</name></expr></argument>&gt;</argument_list></name>
<macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>InnerMatcher</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name>create</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>ArgumentAdaptingMatcherFuncAdaptor</name><argument_list type="generic">&lt;<argument><expr><name>ArgumentAdapterT</name></expr></argument>,
<argument><expr><name>typename</name> <name><name>GetClade</name><argument_list type="generic">&lt;<argument><expr><name>T</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name><operator>::</operator><name>Type</name></expr></argument>, <argument><expr><name>ToTypes</name></expr></argument>&gt;</argument_list></name>
<macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name><name>MapAnyOfHelper</name><argument_list type="generic">&lt;<argument><expr><name>T</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>InnerMatcher</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name>create</name><argument_list>(<argument><expr><call><name><name>InnerMatcher</name><operator>.</operator><name>with</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>TraversalMatcher</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>DynTypedMatcher</name> <name>InnerMatcher</name></expr>;
<expr><name>clang</name><operator>::</operator><name>TraversalKind</name> <name>Traversal</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>TraversalMatcher</name><argument_list>(<argument>clang::TraversalKind TK</argument>,
<argument>const Matcher&lt;T&gt; &amp;InnerMatcher</argument>)</argument_list></macro>
<operator>:</operator> <call><name>InnerMatcher</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr>, <macro><name>Traversal</name><argument_list>(<argument>TK</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const T &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>DynTypedNode</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>TraversalKind</name></expr></argument>&gt;</argument_list></name> <macro><name>TraversalKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<if_stmt><if>if <condition>(<decl><type><name>auto</name></type> <name>NestedKind</name> <init>= <expr><call><name><name>this</name><operator>-&gt;</operator><name>InnerMatcher</name><operator>.</operator><name>getTraversalKind</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NestedKind</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>Traversal</name></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>MatcherType</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>TraversalWrapper</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>TraversalWrapper</name><argument_list>(<argument>TraversalKind TK</argument>, <argument>const MatcherType &amp;InnerMatcher</argument>)</argument_list></macro>
<operator>:</operator> <call><name>TK</name><argument_list>(<argument><expr><name>TK</name></expr></argument>)</argument_list></call></expr>, <macro><name>InnerMatcher</name><argument_list>(<argument>InnerMatcher</argument>)</argument_list></macro> <expr><block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <name>LLVM_LVALUE_FUNCTION</name> <block>{
<return>return <expr><name>internal</name><operator>::</operator><name>DynTypedMatcher</name><operator>::</operator><macro><name>constructRestrictedWrapper</name><argument_list>(
<argument>new internal::TraversalMatcher&lt;T&gt;(TK, InnerMatcher)</argument>,
<argument>ASTNodeKind::getFromNodeKind&lt;T&gt;()</argument>)</argument_list></macro>
<operator>.</operator><name>template</name> <call><name><name>unconditionalConvertTo</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_HAS_RVALUE_REFERENCE_THIS</name></expr></cpp:if>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>operator</name> <call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <block>{
<return>return <expr><name>internal</name><operator>::</operator><name>DynTypedMatcher</name><operator>::</operator><macro><name>constructRestrictedWrapper</name><argument_list>(
<argument>new internal::TraversalMatcher&lt;T&gt;(TK, std::move(InnerMatcher))</argument>,
<argument>ASTNodeKind::getFromNodeKind&lt;T&gt;()</argument>)</argument_list></macro>
<operator>.</operator><name>template</name> <call><name><name>unconditionalConvertTo</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>private</name><operator>:</operator>
<name>TraversalKind</name> <name>TK</name></expr>;
<expr><name>MatcherType</name> <name>InnerMatcher</name></expr>;
}</block></expr>;













<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>Params</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>MatcherT</name></expr></argument>,
<argument><expr><name>typename</name> <name>ReturnTypesF</name></expr></argument>, <argument><expr><name>typename</name><modifier>...</modifier> <name>ParamTypes</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>PolymorphicMatcher</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PolymorphicMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ParamTypes</name> <operator>&amp;</operator><operator>...</operator> <name>Params</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Params</name><argument_list>(<argument>Params...</argument>)</argument_list></macro> <block>{}</block>

<name>using</name> <name>ReturnTypes</name> <operator>=</operator> <name>typename</name> <name><name>ExtractFunctionArgMeta</name><argument_list type="generic">&lt;<argument><expr><name>ReturnTypesF</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <name>LLVM_LVALUE_FUNCTION</name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name><name>TypeListContainsSuperOf</name><argument_list type="generic">&lt;<argument><expr><name>ReturnTypes</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"right polymorphic conversion"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>new_from_tuple</name><argument_list type="generic">&lt;<argument><expr><name><name>MatcherT</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ParamTypes</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LLVM_HAS_RVALUE_REFERENCE_THIS</name></expr></cpp:if>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>operator</name> <call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name><name>TypeListContainsSuperOf</name><argument_list type="generic">&lt;<argument><expr><name>ReturnTypes</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"right polymorphic conversion"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>new_from_tuple</name><argument_list type="generic">&lt;<argument><expr><name><name>MatcherT</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>ParamTypes</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<name>private</name><operator>:</operator>
<name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>ParamTypes</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <name>Params</name></expr>;
}</block></expr>;





<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>ChildT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>HasMatcher</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>DynTypedMatcher</name> <name>InnerMatcher</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>HasMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>ChildT</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>InnerMatcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>InnerMatcher</name><argument_list>(<argument>InnerMatcher</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const T &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>Finder</name><operator>-&gt;</operator><name>matchesChildOf</name></name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>InnerMatcher</name></name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>,
<argument><expr><name>ASTMatchFinder</name><operator>::</operator><name>BK_First</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;






<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>ChildT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>ForEachMatcher</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name><name>IsBaseType</name><argument_list type="generic">&lt;<argument><expr><name>ChildT</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"for each only accepts base type matcher"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>DynTypedMatcher</name> <name>InnerMatcher</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>ForEachMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>ChildT</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>InnerMatcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>InnerMatcher</name><argument_list>(<argument>InnerMatcher</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const T &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>Finder</name><operator>-&gt;</operator><name>matchesChildOf</name></name><argument_list>(
<argument><expr><name>Node</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>InnerMatcher</name></name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>,
<argument><expr><name>ASTMatchFinder</name><operator>::</operator><name>BK_All</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>DynTypedMatcher</name><operator>::</operator><macro><name>unconditionalConvertTo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>DescendantT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>HasDescendantMatcher</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name><name>IsBaseType</name><argument_list type="generic">&lt;<argument><expr><name>DescendantT</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"has descendant only accepts base type matcher"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>DynTypedMatcher</name> <name>DescendantMatcher</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>HasDescendantMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>DescendantT</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>DescendantMatcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>DescendantMatcher</name><argument_list>(<argument>DescendantMatcher</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const T &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>Finder</name><operator>-&gt;</operator><name>matchesDescendantOf</name></name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>DescendantMatcher</name></name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>,
<argument><expr><name>ASTMatchFinder</name><operator>::</operator><name>BK_First</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;





<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>ParentT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>HasParentMatcher</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name><name>IsBaseType</name><argument_list type="generic">&lt;<argument><expr><name>ParentT</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"has parent only accepts base type matcher"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>DynTypedMatcher</name> <name>ParentMatcher</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>HasParentMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>ParentT</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>ParentMatcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ParentMatcher</name><argument_list>(<argument>ParentMatcher</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const T &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>Finder</name><operator>-&gt;</operator><name>matchesAncestorOf</name></name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>ParentMatcher</name></name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>,
<argument><expr><name>ASTMatchFinder</name><operator>::</operator><name>AMM_ParentOnly</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;





<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>AncestorT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>HasAncestorMatcher</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name><name>IsBaseType</name><argument_list type="generic">&lt;<argument><expr><name>AncestorT</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"has ancestor only accepts base type matcher"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>DynTypedMatcher</name> <name>AncestorMatcher</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>HasAncestorMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>AncestorT</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>AncestorMatcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>AncestorMatcher</name><argument_list>(<argument>AncestorMatcher</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const T &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>Finder</name><operator>-&gt;</operator><name>matchesAncestorOf</name></name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>AncestorMatcher</name></name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>,
<argument><expr><name>ASTMatchFinder</name><operator>::</operator><name>AMM_All</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;







<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>DescendantT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>ForEachDescendantMatcher</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name><name>IsBaseType</name><argument_list type="generic">&lt;<argument><expr><name>DescendantT</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"for each descendant only accepts base type matcher"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>DynTypedMatcher</name> <name>DescendantMatcher</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>ForEachDescendantMatcher</name><argument_list>(
<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>DescendantT</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>DescendantMatcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>DescendantMatcher</name><argument_list>(<argument>DescendantMatcher</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const T &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>Finder</name><operator>-&gt;</operator><name>matchesDescendantOf</name></name><argument_list>(<argument><expr><name>Node</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>DescendantMatcher</name></name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>,
<argument><expr><name>ASTMatchFinder</name><operator>::</operator><name>BK_All</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>ValueT</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>ValueEqualsMatcher</name> <operator>:</operator> <name>public</name> <name><name>SingleNodeMatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>CharacterLiteral</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>CXXBoolLiteralExpr</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>FloatingLiteral</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>IntegerLiteral</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"the node must have a getValue method"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>ValueEqualsMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueT</name> <operator>&amp;</operator><name>ExpectedValue</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>ExpectedValue</name><argument_list>(<argument>ExpectedValue</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>matchesNode</name><argument_list>(<argument>const T &amp;Node</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExpectedValue</name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>ValueT</name> <name>ExpectedValue</name></expr>;
}</block></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name> <name><name>ValueEqualsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>FloatingLiteral</name></expr></argument>, <argument><expr><name>double</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>matchesNode</name><argument_list>(
<argument>const FloatingLiteral &amp;Node</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>&amp;</operator><call><name><name>Node</name><operator>.</operator><name>getSemantics</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <operator>&amp;</operator><name>llvm</name><operator>::</operator><name>APFloat</name><operator>::</operator><call><name>IEEEsingle</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>convertToFloat</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExpectedValue</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>&amp;</operator><call><name><name>Node</name><operator>.</operator><name>getSemantics</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <operator>&amp;</operator><name>llvm</name><operator>::</operator><name>APFloat</name><operator>::</operator><call><name>IEEEdouble</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>convertToDouble</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExpectedValue</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>
<name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name> <name><name>ValueEqualsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>FloatingLiteral</name></expr></argument>, <argument><expr><name>float</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>matchesNode</name><argument_list>(
<argument>const FloatingLiteral &amp;Node</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>&amp;</operator><call><name><name>Node</name><operator>.</operator><name>getSemantics</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <operator>&amp;</operator><name>llvm</name><operator>::</operator><name>APFloat</name><operator>::</operator><call><name>IEEEsingle</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>convertToFloat</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExpectedValue</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>&amp;</operator><call><name><name>Node</name><operator>.</operator><name>getSemantics</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <operator>&amp;</operator><name>llvm</name><operator>::</operator><name>APFloat</name><operator>::</operator><call><name>IEEEdouble</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>convertToDouble</name><argument_list>()</argument_list></call> <operator>==</operator> <name>ExpectedValue</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>false</name></expr>;</return>
}</block>
<name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name> <name><name>ValueEqualsMatcher</name><argument_list type="generic">&lt;<argument><expr><name>FloatingLiteral</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>APFloat</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>matchesNode</name><argument_list>(
<argument>const FloatingLiteral &amp;Node</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ExpectedValue</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator><name>APFloat</name><operator>::</operator><name>cmpEqual</name></expr>;</return>
}</block>



<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>TLoc</name></expr></argument>, <argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>LocMatcher</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>TLoc</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>DynTypedMatcher</name> <name>InnerMatcher</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>LocMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>InnerMatcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>InnerMatcher</name><argument_list>(<argument>InnerMatcher</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const TLoc &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Node</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><call><name>extract</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>static</specifier> <name>DynTypedNode</name> <macro><name>extract</name><argument_list>(<argument>const NestedNameSpecifierLoc &amp;Loc</argument>)</argument_list></macro> <block>{
<return>return <expr><name>DynTypedNode</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Loc</name><operator>.</operator><name>getNestedNameSpecifier</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;





<expr><name>class</name> <name>TypeLocTypeMatcher</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>TypeLoc</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>DynTypedMatcher</name> <name>InnerMatcher</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>TypeLocTypeMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>InnerMatcher</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>InnerMatcher</name><argument_list>(<argument>InnerMatcher</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const TypeLoc &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Node</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>DynTypedNode</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>Finder</name></expr></argument>, <argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;




<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>TypeTraverseMatcher</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>DynTypedMatcher</name> <name>InnerMatcher</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>TypeTraverseMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>InnerMatcher</name></expr></argument>,
<argument><expr><macro><name>QualType</name> <argument_list>(<argument>T::*TraverseFunction</argument>)</argument_list></macro><operator>(</operator><operator>)</operator> <specifier>const</specifier></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>InnerMatcher</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr>, <macro><name>TraverseFunction</name><argument_list>(<argument>TraverseFunction</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const T &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><name>QualType</name> <name>NextNode</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>.*</operator><name>TraverseFunction</name><operator>)</operator><operator>(</operator><operator>)</operator></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>NextNode</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>DynTypedNode</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><name>NextNode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<macro><name>QualType</name> <argument_list>(<argument>T::*TraverseFunction</argument>)</argument_list></macro><operator>(</operator><operator>)</operator> <specifier>const</specifier></expr>;
}</block></expr>;




<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>TypeLocTraverseMatcher</name> <operator>:</operator> <name>public</name> <name><name>MatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>DynTypedMatcher</name> <name>InnerMatcher</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>TypeLocTraverseMatcher</name><argument_list>(<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>TypeLoc</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>InnerMatcher</name></expr></argument>,
<argument><expr><macro><name>TypeLoc</name> <argument_list>(<argument>T::*TraverseFunction</argument>)</argument_list></macro><operator>(</operator><operator>)</operator> <specifier>const</specifier></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>InnerMatcher</name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>)</argument_list></call></expr>, <macro><name>TraverseFunction</name><argument_list>(<argument>TraverseFunction</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>matches</name><argument_list>(<argument>const T &amp;Node</argument>, <argument>ASTMatchFinder *Finder</argument>,
<argument>BoundNodesTreeBuilder *Builder</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><name>TypeLoc</name> <name>NextNode</name> <operator>=</operator> <operator>(</operator><name>Node</name><operator>.*</operator><name>TraverseFunction</name><operator>)</operator><operator>(</operator><operator>)</operator></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>NextNode</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>this</name><operator>-&gt;</operator><name>InnerMatcher</name><operator>.</operator><name>matches</name></name><argument_list>(<argument><expr><name>DynTypedNode</name><operator>::</operator><call><name>create</name><argument_list>(<argument><expr><name>NextNode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Finder</name></expr></argument>,
<argument><expr><name>Builder</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<macro><name>TypeLoc</name> <argument_list>(<argument>T::*TraverseFunction</argument>)</argument_list></macro><operator>(</operator><operator>)</operator> <specifier>const</specifier></expr>;
}</block></expr>;







<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InnerTBase</name></expr></argument>,
<argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>OuterT</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>Getter</name></expr></argument>,
<argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>OuterT</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>MatcherImpl</name></expr></argument>,
<argument><expr><name>typename</name> <name>ReturnTypesF</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>TypeTraversePolymorphicMatcher</name> <block>{
<expr><name>private</name><operator>:</operator>
<name>using</name> <name>Self</name> <operator>=</operator> <name><name>TypeTraversePolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerTBase</name></expr></argument>, <argument><expr><name>Getter</name></expr></argument>, <argument><expr><name>MatcherImpl</name></expr></argument>,
<argument><expr><name>ReturnTypesF</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><specifier>static</specifier> <name>Self</name> <call><name>create</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerTBase</name></expr></argument>&gt;</argument_list></name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>InnerMatchers</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>using</name> <name>ReturnTypes</name> <operator>=</operator> <name>typename</name> <name><name>ExtractFunctionArgMeta</name><argument_list type="generic">&lt;<argument><expr><name>ReturnTypesF</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr>;

<expr><name>explicit</name> <call><name>TypeTraversePolymorphicMatcher</name><argument_list>(
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerTBase</name></expr></argument>&gt;</argument_list></name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>InnerMatchers</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>InnerMatcher</name><argument_list>(<argument>makeAllOfComposite(InnerMatchers)</argument>)</argument_list></macro> <block>{}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>OuterT</name></expr></argument>&gt;</argument_list></name> <name>operator</name> <macro><name>Matcher</name></macro><operator>&lt;</operator><name>OuterT</name><operator>&gt;</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <macro><name>Matcher</name></macro><expr><operator>&lt;</operator><name>OuterT</name><operator>&gt;</operator><operator>(</operator>
<name>new</name> <call><name><name>MatcherImpl</name><argument_list type="generic">&lt;<argument><expr><name>OuterT</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>InnerMatcher</name></expr></argument>, <argument><expr><name><name>Getter</name><argument_list type="generic">&lt;<argument><expr><name>OuterT</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
}</block>

struct <name>Func</name>
<operator>:</operator> <name>public</name> <name><name>VariadicFunction</name><argument_list type="generic">&lt;<argument><expr><name>Self</name></expr></argument>, <argument><expr><name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerTBase</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Self</name><operator>::</operator><name>create</name></expr></argument>&gt;</argument_list></name> <block>{
<macro><name>Func</name><argument_list>()</argument_list></macro> <expr><block>{}</block></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>
<name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerTBase</name></expr></argument>&gt;</argument_list></name> <name>InnerMatcher</name></expr>;
}</block></expr>;





<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Matcher</name></expr></argument>, <argument><expr><name>Matcher</name> <operator>(</operator><operator>*</operator><name>Func</name><operator>)</operator><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>class</name> <name>MemoizedMatcher</name> <block>{
struct <expr><name>Wrapper</name> <block>{
<expr><call><name>Wrapper</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>M</name><argument_list>(<argument>Func()</argument>)</argument_list></macro> <block>{}</block>

<name>Matcher</name> <name>M</name></expr>;
}</block></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <specifier>const</specifier> <name>Matcher</name> <operator>&amp;</operator><macro><name>getInstance</name><argument_list>()</argument_list></macro> <block>{
<expr><specifier>static</specifier> <name>llvm</name><operator>::</operator><name><name>ManagedStatic</name><argument_list type="generic">&lt;<argument><expr><name>Wrapper</name></expr></argument>&gt;</argument_list></name> <name>Instance</name></expr>;
<return>return <expr><name><name>Instance</name><operator>-&gt;</operator><name>M</name></name></expr>;</return>
}</block>
}</expr>;




<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>InnerTBase</name></expr></argument>, <argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>OuterT</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>Getter</name></expr></argument>,
<argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>OuterT</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>MatcherImpl</name></expr></argument>, <argument><expr><name>typename</name> <name>ReturnTypesF</name></expr></argument>&gt;</argument_list></name>
<name><name>TypeTraversePolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>InnerTBase</name></expr></argument>, <argument><expr><name>Getter</name></expr></argument>, <argument><expr><name>MatcherImpl</name></expr></argument>, <argument><expr><name>ReturnTypesF</name></expr></argument>&gt;</argument_list></name>
<name><name>TypeTraversePolymorphicMatcher</name><argument_list type="generic">&lt;
<argument><expr><name>InnerTBase</name></expr></argument>, <argument><expr><name>Getter</name></expr></argument>, <argument><expr><name>MatcherImpl</name></expr></argument>,
<argument><expr><name>ReturnTypesF</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>create</name><argument_list>(<argument>ArrayRef&lt;const Matcher&lt;InnerTBase&gt; *&gt; InnerMatchers</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>Self</name><argument_list>(<argument><expr><name>InnerMatchers</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<specifier>inline</specifier> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name>
<macro><name>getTemplateSpecializationArgs</name><argument_list>(<argument>const ClassTemplateSpecializationDecl &amp;D</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>D</name><operator>.</operator><name>getTemplateArgs</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>asArray</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name>
<macro><name>getTemplateSpecializationArgs</name><argument_list>(<argument>const TemplateSpecializationType &amp;T</argument>)</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>T</name><operator>.</operator><name>getArgs</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>T</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>inline</specifier> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name>
<macro><name>getTemplateSpecializationArgs</name><argument_list>(<argument>const FunctionDecl &amp;FD</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier><modifier>*</modifier></type> <name>TemplateArgs</name> <init>= <expr><call><name><name>FD</name><operator>.</operator><name>getTemplateSpecializationArgs</name></name><argument_list>()</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>TemplateArgs</name><operator>-&gt;</operator><name>asArray</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

struct <name>NotEqualsBoundNodePredicate</name> <block>{
<expr><name>bool</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><specifier>const</specifier> <name>internal</name><operator>::</operator><name>BoundNodesMap</name> <operator>&amp;</operator><name>Nodes</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Nodes</name><operator>.</operator><name>getNode</name></name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Node</name></expr>;</return>
}</block>

<name>std</name><operator>::</operator><name>string</name> <name>ID</name></expr>;
<expr><name>DynTypedNode</name> <name>Node</name></expr>;
}</block></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Ty</name></expr></argument>, <argument><expr><name>typename</name> <name>Enable</name> <operator>=</operator> <name>void</name></expr></argument>&gt;</argument_list></name> struct <name>GetBodyMatcher</name> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>get</name><argument_list>(<argument>const Ty &amp;Node</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>Node</name><operator>.</operator><name>getBody</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Ty</name></expr></argument>&gt;</argument_list></name>
struct <name><name>GetBodyMatcher</name><argument_list type="generic">&lt;<argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>typename</name> <name>std</name><operator>::</operator><name><name>enable_if</name><argument_list type="generic">&lt;
<argument><expr><name>std</name><operator>::</operator><name><name>is_base_of</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>get</name><argument_list>(<argument>const Ty &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>doesThisDeclarationHaveABody</name></name><argument_list>()</argument_list></call> <operator>?</operator> <call><name><name>Node</name><operator>.</operator><name>getBody</name></name><argument_list>()</argument_list></call> <operator>:</operator> <name>nullptr</name></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>NodeType</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>BinaryOperatorKind</name></expr></argument>&gt;</argument_list></name>
<macro><name>equivalentBinaryOperator</name><argument_list>(<argument>const NodeType &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getOpcode</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>BinaryOperatorKind</name></expr></argument>&gt;</argument_list></name>
<macro><name>equivalentBinaryOperator</name></macro><operator>&lt;</operator><name>CXXOperatorCallExpr</name><operator>&gt;</operator><operator>(</operator><specifier>const</specifier> <name>CXXOperatorCallExpr</name> <operator>&amp;</operator><name>Node</name><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>None</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<switch>switch <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>getOperator</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<default>default:</default>
<return>return <expr><name>None</name></expr>;</return>
<case>case <expr><name>OO_ArrowStar</name></expr>:</case>
<return>return <expr><name>BO_PtrMemI</name></expr>;</return>
<case>case <expr><name>OO_Star</name></expr>:</case>
<return>return <expr><name>BO_Mul</name></expr>;</return>
<case>case <expr><name>OO_Slash</name></expr>:</case>
<return>return <expr><name>BO_Div</name></expr>;</return>
<case>case <expr><name>OO_Percent</name></expr>:</case>
<return>return <expr><name>BO_Rem</name></expr>;</return>
<case>case <expr><name>OO_Plus</name></expr>:</case>
<return>return <expr><name>BO_Add</name></expr>;</return>
<case>case <expr><name>OO_Minus</name></expr>:</case>
<return>return <expr><name>BO_Sub</name></expr>;</return>
<case>case <expr><name>OO_LessLess</name></expr>:</case>
<return>return <expr><name>BO_Shl</name></expr>;</return>
<case>case <expr><name>OO_GreaterGreater</name></expr>:</case>
<return>return <expr><name>BO_Shr</name></expr>;</return>
<case>case <expr><name>OO_Spaceship</name></expr>:</case>
<return>return <expr><name>BO_Cmp</name></expr>;</return>
<case>case <expr><name>OO_Less</name></expr>:</case>
<return>return <expr><name>BO_LT</name></expr>;</return>
<case>case <expr><name>OO_Greater</name></expr>:</case>
<return>return <expr><name>BO_GT</name></expr>;</return>
<case>case <expr><name>OO_LessEqual</name></expr>:</case>
<return>return <expr><name>BO_LE</name></expr>;</return>
<case>case <expr><name>OO_GreaterEqual</name></expr>:</case>
<return>return <expr><name>BO_GE</name></expr>;</return>
<case>case <expr><name>OO_EqualEqual</name></expr>:</case>
<return>return <expr><name>BO_EQ</name></expr>;</return>
<case>case <expr><name>OO_ExclaimEqual</name></expr>:</case>
<return>return <expr><name>BO_NE</name></expr>;</return>
<case>case <expr><name>OO_Amp</name></expr>:</case>
<return>return <expr><name>BO_And</name></expr>;</return>
<case>case <expr><name>OO_Caret</name></expr>:</case>
<return>return <expr><name>BO_Xor</name></expr>;</return>
<case>case <expr><name>OO_Pipe</name></expr>:</case>
<return>return <expr><name>BO_Or</name></expr>;</return>
<case>case <expr><name>OO_AmpAmp</name></expr>:</case>
<return>return <expr><name>BO_LAnd</name></expr>;</return>
<case>case <expr><name>OO_PipePipe</name></expr>:</case>
<return>return <expr><name>BO_LOr</name></expr>;</return>
<case>case <expr><name>OO_Equal</name></expr>:</case>
<return>return <expr><name>BO_Assign</name></expr>;</return>
<case>case <expr><name>OO_StarEqual</name></expr>:</case>
<return>return <expr><name>BO_MulAssign</name></expr>;</return>
<case>case <expr><name>OO_SlashEqual</name></expr>:</case>
<return>return <expr><name>BO_DivAssign</name></expr>;</return>
<case>case <expr><name>OO_PercentEqual</name></expr>:</case>
<return>return <expr><name>BO_RemAssign</name></expr>;</return>
<case>case <expr><name>OO_PlusEqual</name></expr>:</case>
<return>return <expr><name>BO_AddAssign</name></expr>;</return>
<case>case <expr><name>OO_MinusEqual</name></expr>:</case>
<return>return <expr><name>BO_SubAssign</name></expr>;</return>
<case>case <expr><name>OO_LessLessEqual</name></expr>:</case>
<return>return <expr><name>BO_ShlAssign</name></expr>;</return>
<case>case <expr><name>OO_GreaterGreaterEqual</name></expr>:</case>
<return>return <expr><name>BO_ShrAssign</name></expr>;</return>
<case>case <expr><name>OO_AmpEqual</name></expr>:</case>
<return>return <expr><name>BO_AndAssign</name></expr>;</return>
<case>case <expr><name>OO_CaretEqual</name></expr>:</case>
<return>return <expr><name>BO_XorAssign</name></expr>;</return>
<case>case <expr><name>OO_PipeEqual</name></expr>:</case>
<return>return <expr><name>BO_OrAssign</name></expr>;</return>
<case>case <expr><name>OO_Comma</name></expr>:</case>
<return>return <expr><name>BO_Comma</name></expr>;</return>
<expr_stmt/>}</block_content>
}

template &lt;typename NodeType&gt;
<namespace><specifier>inline</specifier> Optional<name/>&lt;<name>UnaryOperatorKind</name>&gt;
<name>equivalentUnaryOperator</name>(const <name>NodeType</name> &amp;<name>Node</name></namespace></block></switch>) <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getOpcode</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></block>

<name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>UnaryOperatorKind</name></expr></argument>&gt;</argument_list></name>
<macro><name>equivalentUnaryOperator</name></macro><operator>&lt;</operator><name>CXXOperatorCallExpr</name><operator>&gt;</operator><operator>(</operator><specifier>const</specifier> <name>CXXOperatorCallExpr</name> <operator>&amp;</operator><name>Node</name><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>getNumArgs</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name><name>Node</name><operator>.</operator><name>getOperator</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>OO_PlusPlus</name> <operator>&amp;&amp;</operator>
<call><name><name>Node</name><operator>.</operator><name>getOperator</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>OO_MinusMinus</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>None</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<switch>switch <condition>(<expr><call><name><name>Node</name><operator>.</operator><name>getOperator</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<default>default:</default>
<return>return <expr><name>None</name></expr>;</return>
<case>case <expr><name>OO_Plus</name></expr>:</case>
<return>return <expr><name>UO_Plus</name></expr>;</return>
<case>case <expr><name>OO_Minus</name></expr>:</case>
<return>return <expr><name>UO_Minus</name></expr>;</return>
<case>case <expr><name>OO_Amp</name></expr>:</case>
<return>return <expr><name>UO_AddrOf</name></expr>;</return>
<case>case <expr><name>OO_Star</name></expr>:</case>
<return>return <expr><name>UO_Deref</name></expr>;</return>
<case>case <expr><name>OO_Tilde</name></expr>:</case>
<return>return <expr><name>UO_Not</name></expr>;</return>
<case>case <expr><name>OO_Exclaim</name></expr>:</case>
<return>return <expr><name>UO_LNot</name></expr>;</return>
<case>case <expr><name>OO_PlusPlus</name></expr>:</case> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>FD</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getDirectCallee</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>FD</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>None</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><call><name><name>FD</name><operator>-&gt;</operator><name>getNumParams</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>UO_PostInc</name></expr> </then><else>: <expr><name>UO_PreInc</name></expr></else></ternary></expr>;</return>
<expr_stmt/>}</block_content>
case OO_MinusMinus: <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>FD</name> <init>= <expr><call><name><name>Node</name><operator>.</operator><name>getDirectCallee</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>FD</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>None</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><ternary><condition><expr><call><name><name>FD</name><operator>-&gt;</operator><name>getNumParams</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>UO_PostDec</name></expr> </then><else>: <expr><name>UO_PreDec</name></expr></else></ternary></expr>;</return>
<expr_stmt/>}</block_content>
case OO_Coawait:
return UO_Coawait</block></block><empty_stmt>;</empty_stmt>
<expr_stmt/>}</block_content>
}

template &lt;typename NodeType&gt; <namespace><specifier>inline</specifier> const <name>Expr</name> *<name>getLHS</name>(const <name>NodeType</name> &amp;<name>Node</name></namespace></block></switch>) <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getLHS</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></block>
<name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <specifier>const</specifier> <name>Expr</name> <operator>*</operator>
<macro><name>getLHS</name></macro><operator>&lt;</operator><name>CXXOperatorCallExpr</name><operator>&gt;</operator><operator>(</operator><specifier>const</specifier> <name>CXXOperatorCallExpr</name> <operator>&amp;</operator><name>Node</name><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>internal</name><operator>::</operator><call><name>equivalentBinaryOperator</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>NodeType</name></expr></argument>&gt;</argument_list></name> <specifier>inline</specifier> <specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getRHS</name><argument_list>(<argument>const NodeType &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <specifier>const</specifier> <name>Expr</name> <operator>*</operator>
<macro><name>getRHS</name></macro><operator>&lt;</operator><name>CXXOperatorCallExpr</name><operator>&gt;</operator><operator>(</operator><specifier>const</specifier> <name>CXXOperatorCallExpr</name> <operator>&amp;</operator><name>Node</name><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>internal</name><operator>::</operator><call><name>equivalentBinaryOperator</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>NodeType</name></expr></argument>&gt;</argument_list></name>
<specifier>inline</specifier> <specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getSubExpr</name><argument_list>(<argument>const NodeType &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <specifier>const</specifier> <name>Expr</name> <operator>*</operator>
<macro><name>getSubExpr</name></macro><operator>&lt;</operator><name>CXXOperatorCallExpr</name><operator>&gt;</operator><operator>(</operator><specifier>const</specifier> <name>CXXOperatorCallExpr</name> <operator>&amp;</operator><name>Node</name><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>internal</name><operator>::</operator><call><name>equivalentUnaryOperator</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getArg</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Ty</name></expr></argument>&gt;</argument_list></name>
struct <name>HasSizeMatcher</name> <block>{
<expr><specifier>static</specifier> <name>bool</name> <macro><name>hasSize</name><argument_list>(<argument>const Ty &amp;Node</argument>, <argument>unsigned int N</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getSize</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>N</name></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <name>bool</name> <name><name>HasSizeMatcher</name><argument_list type="generic">&lt;<argument><expr><name>StringLiteral</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>hasSize</name><argument_list>(
<argument>const StringLiteral &amp;Node</argument>, <argument>unsigned int N</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getLength</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>N</name></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Ty</name></expr></argument>&gt;</argument_list></name>
struct <name>GetSourceExpressionMatcher</name> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>get</name><argument_list>(<argument>const Ty &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getSubExpr</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <specifier>const</specifier> <name>Expr</name> <operator>*</operator><name><name>GetSourceExpressionMatcher</name><argument_list type="generic">&lt;<argument><expr><name>OpaqueValueExpr</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>get</name><argument_list>(
<argument>const OpaqueValueExpr &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getSourceExpr</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Ty</name></expr></argument>&gt;</argument_list></name>
struct <name>CompoundStmtMatcher</name> <block>{
<expr><specifier>static</specifier> <specifier>const</specifier> <name>CompoundStmt</name> <operator>*</operator><macro><name>get</name><argument_list>(<argument>const Ty &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>&amp;</operator><name>Node</name></expr>;</return>
}</block>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<specifier>inline</specifier> <specifier>const</specifier> <name>CompoundStmt</name> <operator>*</operator>
<name><name>CompoundStmtMatcher</name><argument_list type="generic">&lt;<argument><expr><name>StmtExpr</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>get</name><argument_list>(<argument>const StmtExpr &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>





<name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name>
<macro><name>getExpansionLocOfMacro</name><argument_list>(<argument>StringRef MacroName</argument>, <argument>SourceLocation Loc</argument>,
<argument>const ASTContext &amp;Context</argument>)</argument_list></macro></expr>;

<expr><specifier>inline</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>getOpName</name><argument_list>(<argument>const UnaryOperator &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getOpcodeStr</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getOpcode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>inline</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>getOpName</name><argument_list>(<argument>const BinaryOperator &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getOpcodeStr</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>inline</specifier> <name>StringRef</name> <macro><name>getOpName</name><argument_list>(<argument>const CXXRewrittenBinaryOperator &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getOpcodeStr</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>inline</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>getOpName</name><argument_list>(<argument>const CXXOperatorCallExpr &amp;Node</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>optBinaryOpcode</name> <operator>=</operator> <call><name>equivalentBinaryOperator</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optBinaryOpcode</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>optUnaryOpcode</name> <init>= <expr><call><name>equivalentUnaryOperator</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optUnaryOpcode</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>None</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>UnaryOperator</name><operator>::</operator><call><name>getOpcodeStr</name><argument_list>(<argument><expr><operator>*</operator><name>optUnaryOpcode</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
return BinaryOperator::getOpcodeStr(*optBinaryOpcode</block></if></if_stmt>)</block></expr>;
}</block>





<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>ArgT</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>HasAnyOperatorNameMatcher</name> <operator>:</operator> <name>public</name> <name><name>SingleNodeMatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>BinaryOperator</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>CXXOperatorCallExpr</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>CXXRewrittenBinaryOperator</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>UnaryOperator</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"Matcher only supports `BinaryOperator`, `UnaryOperator`, "</literal>
<literal type="string">"`CXXOperatorCallExpr` and `CXXRewrittenBinaryOperator`"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>ArgT</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"Matcher ArgT must be std::vector&lt;std::string&gt;"</literal></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>HasAnyOperatorNameMatcher</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>Names</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name><name>SingleNodeMatcherInterface</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>, <macro><name>Names</name><argument_list>(<argument>std::move(Names)</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>matchesNode</name><argument_list>(<argument>const T &amp;Node</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <name>OptOpName</name> <operator>=</operator> <call><name>getOpName</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>OptOpName</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>llvm</name><operator>::</operator><call><name>any_of</name><argument_list>(<argument><expr><name>Names</name></expr></argument>, <argument><expr><index>[<expr><name>OpName</name> <operator>=</operator> <operator>*</operator><name>OptOpName</name></expr>]</index><operator>(</operator><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>Name</name><operator>)</operator> <block>{
<return>return <expr><name>Name</name> <operator>==</operator> <name>OpName</name></expr>;</return>
}</block></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<specifier>static</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>getOpName</name><argument_list>(<argument>const UnaryOperator &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getOpcodeStr</name></name><argument_list>(<argument><expr><call><name><name>Node</name><operator>.</operator><name>getOpcode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>getOpName</name><argument_list>(<argument>const BinaryOperator &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getOpcodeStr</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>StringRef</name> <macro><name>getOpName</name><argument_list>(<argument>const CXXRewrittenBinaryOperator &amp;Node</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Node</name><operator>.</operator><name>getOpcodeStr</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>getOpName</name><argument_list>(<argument>const CXXOperatorCallExpr &amp;Node</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>optBinaryOpcode</name> <operator>=</operator> <call><name>equivalentBinaryOperator</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optBinaryOpcode</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>auto</name></type> <name>optUnaryOpcode</name> <init>= <expr><call><name>equivalentUnaryOperator</name><argument_list>(<argument><expr><name>Node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>optUnaryOpcode</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>None</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>UnaryOperator</name><operator>::</operator><call><name>getOpcodeStr</name><argument_list>(<argument><expr><operator>*</operator><name>optUnaryOpcode</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/>}</block_content>
return BinaryOperator::getOpcodeStr(*optBinaryOpcode</block></if></if_stmt>)</block></expr>;
}</block>

<name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <name>Names</name></expr>;
}</block></expr>;

<expr><name>using</name> <name>HasOpNameMatcher</name> <operator>=</operator>
<name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>HasAnyOperatorNameMatcher</name></expr></argument>,
<argument><expr><name>void</name><operator>(</operator>
<name><name>TypeList</name><argument_list type="generic">&lt;<argument><expr><name>BinaryOperator</name></expr></argument>, <argument><expr><name>CXXOperatorCallExpr</name></expr></argument>,
<argument><expr><name>CXXRewrittenBinaryOperator</name></expr></argument>, <argument><expr><name>UnaryOperator</name></expr></argument>&gt;</argument_list></name><operator>)</operator></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>HasOpNameMatcher</name> <call><name>hasAnyOperatorNameFunc</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>StringRef</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>NameRefs</name></expr></argument>)</argument_list></call></expr>;

<expr><name>using</name> <name>HasOverloadOpNameMatcher</name> <operator>=</operator>
<name><name>PolymorphicMatcher</name><argument_list type="generic">&lt;<argument><expr><name>HasOverloadedOperatorNameMatcher</name></expr></argument>,
<argument><expr><name>void</name><operator>(</operator><name><name>TypeList</name><argument_list type="generic">&lt;<argument><expr><name>CXXOperatorCallExpr</name></expr></argument>, <argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><operator>)</operator></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>HasOverloadOpNameMatcher</name>
<call><name>hasAnyOverloadedOperatorNameFunc</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>StringRef</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>NameRefs</name></expr></argument>)</argument_list></call></expr>;




<expr><name>bool</name> <call><name>matchesAnyBase</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <operator>&amp;</operator><name>Node</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name><name>Matcher</name><argument_list type="generic">&lt;<argument><expr><name>CXXBaseSpecifier</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>BaseSpecMatcher</name></expr></argument>,
<argument><expr><name>ASTMatchFinder</name> <operator>*</operator><name>Finder</name></expr></argument>, <argument><expr><name>BoundNodesTreeBuilder</name> <operator>*</operator><name>Builder</name></expr></argument>)</argument_list></call></expr>;

<expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Regex</name></expr></argument>&gt;</argument_list></name> <macro><name>createAndVerifyRegex</name><argument_list>(<argument>StringRef Regex</argument>,
<argument>llvm::Regex::RegexFlags Flags</argument>,
<argument>StringRef MatcherID</argument>)</argument_list></macro></expr>;

}</block></expr>

}</block></expr></range></decl></decl_stmt>

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
