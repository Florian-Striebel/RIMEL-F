<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SYMBOLMANAGER_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SYMBOLMANAGER_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/AnalysisDeclContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/MemRegion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/StoreRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>ento</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>BasicValueFactory</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StoreManager</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>SymbolRegionValue</name> <range>: <expr><name>public</name> <name>SymbolData</name> <block>{
<expr><specifier>const</specifier> <name>TypedValueRegion</name> <operator>*</operator><name>R</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>SymbolRegionValue</name><argument_list>(<argument>SymbolID sym</argument>, <argument>const TypedValueRegion *r</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SymbolData</name><argument_list>(<argument><expr><name>SymbolRegionValueKind</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>, <macro><name>R</name><argument_list>(<argument>r</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isValidTypeForSymbol</name><argument_list>(<argument><expr><call><name><name>r</name><operator>-&gt;</operator><name>getValueType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>TypedValueRegion</name><operator>*</operator> <macro><name>getRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>R</name></expr>;</return> }</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; profile</argument>, <argument>const TypedValueRegion* R</argument>)</argument_list></macro> <block>{
<expr><call><name><name>profile</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name>SymbolRegionValueKind</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; profile</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>profile</name></expr></argument>, <argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>StringRef</name> <macro><name>getKindStr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><macro><name>getOriginRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name>getRegion</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;


<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SymExpr *SE</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SE</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SymbolRegionValueKind</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>SymbolConjured</name> <operator>:</operator> <name>public</name> <name>SymbolData</name> <block>{
<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr>;
<expr><name>QualType</name> <name>T</name></expr>;
<expr><name>unsigned</name> <name>Count</name></expr>;
<expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name></expr>;
<expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>SymbolTag</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>SymbolConjured</name><argument_list>(<argument>SymbolID sym</argument>, <argument>const Stmt *s</argument>, <argument>const LocationContext *lctx</argument>,
<argument>QualType t</argument>, <argument>unsigned count</argument>, <argument>const void *symbolTag</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SymbolData</name><argument_list>(<argument><expr><name>SymbolConjuredKind</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>S</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>T</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Count</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LCtx</name><argument_list>(<argument><expr><name>lctx</name></expr></argument>)</argument_list></call></expr>, <macro><name>SymbolTag</name><argument_list>(<argument>symbolTag</argument>)</argument_list></macro> <expr><block>{





<expr><call><name>assert</name><argument_list>(<argument><expr><name>lctx</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isValidTypeForSymbol</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>S</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getCount</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Count</name></expr>;</return> }</block>
<specifier>const</specifier> <name>void</name> <operator>*</operator><macro><name>getTag</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SymbolTag</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>StringRef</name> <macro><name>getKindStr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; profile</argument>, <argument>const Stmt *S</argument>,
<argument>QualType T</argument>, <argument>unsigned Count</argument>, <argument>const LocationContext *LCtx</argument>,
<argument>const void *SymbolTag</argument>)</argument_list></macro> <block>{
<expr><call><name><name>profile</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name>SymbolConjuredKind</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>Count</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>SymbolTag</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; profile</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>profile</name></expr></argument>, <argument><expr><name>S</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>Count</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>, <argument><expr><name>SymbolTag</name></expr></argument>)</argument_list></call></expr>;
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SymExpr *SE</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SE</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SymbolConjuredKind</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>SymbolDerived</name> <operator>:</operator> <name>public</name> <name>SymbolData</name> <block>{
<expr><name>SymbolRef</name> <name>parentSymbol</name></expr>;
<expr><specifier>const</specifier> <name>TypedValueRegion</name> <operator>*</operator><name>R</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>SymbolDerived</name><argument_list>(<argument>SymbolID sym</argument>, <argument>SymbolRef parent</argument>, <argument>const TypedValueRegion *r</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SymbolData</name><argument_list>(<argument><expr><name>SymbolDerivedKind</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>parentSymbol</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>, <macro><name>R</name><argument_list>(<argument>r</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isValidTypeForSymbol</name><argument_list>(<argument><expr><call><name><name>r</name><operator>-&gt;</operator><name>getValueType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>SymbolRef</name> <macro><name>getParentSymbol</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>parentSymbol</name></expr>;</return> }</block>
<specifier>const</specifier> <name>TypedValueRegion</name> <operator>*</operator><macro><name>getRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>R</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>StringRef</name> <macro><name>getKindStr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;
<expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><macro><name>getOriginRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><call><name>getRegion</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; profile</argument>, <argument>SymbolRef parent</argument>,
<argument>const TypedValueRegion *r</argument>)</argument_list></macro> <block>{
<expr><call><name><name>profile</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name>SymbolDerivedKind</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; profile</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>profile</name></expr></argument>, <argument><expr><name>parentSymbol</name></expr></argument>, <argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SymExpr *SE</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SE</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SymbolDerivedKind</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>SymbolExtent</name> <operator>:</operator> <name>public</name> <name>SymbolData</name> <block>{
<expr><specifier>const</specifier> <name>SubRegion</name> <operator>*</operator><name>R</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>SymbolExtent</name><argument_list>(<argument>SymbolID sym</argument>, <argument>const SubRegion *r</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SymbolData</name><argument_list>(<argument><expr><name>SymbolExtentKind</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>, <macro><name>R</name><argument_list>(<argument>r</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>SubRegion</name> <operator>*</operator><macro><name>getRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>R</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>StringRef</name> <macro><name>getKindStr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; profile</argument>, <argument>const SubRegion *R</argument>)</argument_list></macro> <block>{
<expr><call><name><name>profile</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name>SymbolExtentKind</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; profile</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>profile</name></expr></argument>, <argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SymExpr *SE</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SE</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SymbolExtentKind</name></expr>;</return>
}</block>
}</expr>;





<expr><name>class</name> <name>SymbolMetadata</name> <operator>:</operator> <name>public</name> <name>SymbolData</name> <block>{
<expr><specifier>const</specifier> <name>MemRegion</name><operator>*</operator> <name>R</name></expr>;
<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr>;
<expr><name>QualType</name> <name>T</name></expr>;
<expr><specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><name>LCtx</name></expr>;
<expr><name>unsigned</name> <name>Count</name></expr>;
<expr><specifier>const</specifier> <name>void</name> <operator>*</operator><name>Tag</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>SymbolMetadata</name><argument_list>(<argument>SymbolID sym</argument>, <argument>const MemRegion* r</argument>, <argument>const Stmt *s</argument>, <argument>QualType t</argument>,
<argument>const LocationContext *LCtx</argument>, <argument>unsigned count</argument>, <argument>const void *tag</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SymbolData</name><argument_list>(<argument><expr><name>SymbolMetadataKind</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>R</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>S</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>T</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LCtx</name><argument_list>(<argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Count</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>, <macro><name>Tag</name><argument_list>(<argument>tag</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isValidTypeForSymbol</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><macro><name>getRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>R</name></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>S</name></expr>;</return> }</block>
<specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><macro><name>getLocationContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LCtx</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getCount</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Count</name></expr>;</return> }</block>
<specifier>const</specifier> <name>void</name> <operator>*</operator><macro><name>getTag</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Tag</name></expr>;</return> }</block>

<name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>StringRef</name> <macro><name>getKindStr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; profile</argument>, <argument>const MemRegion *R</argument>,
<argument>const Stmt *S</argument>, <argument>QualType T</argument>, <argument>const LocationContext *LCtx</argument>,
<argument>unsigned Count</argument>, <argument>const void *Tag</argument>)</argument_list></macro> <block>{
<expr><call><name><name>profile</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name>SymbolMetadataKind</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>LCtx</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>Count</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>profile</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>Tag</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; profile</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>profile</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>S</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>, <argument><expr><name>Count</name></expr></argument>, <argument><expr><name>Tag</name></expr></argument>)</argument_list></call></expr>;
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SymExpr *SE</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SE</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SymbolMetadataKind</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>SymbolCast</name> <operator>:</operator> <name>public</name> <name>SymExpr</name> <block>{
<expr><specifier>const</specifier> <name>SymExpr</name> <operator>*</operator><name>Operand</name></expr>;


<expr><name>QualType</name> <name>FromTy</name></expr>;


<expr><name>QualType</name> <name>ToTy</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>SymbolCast</name><argument_list>(<argument>const SymExpr *In</argument>, <argument>QualType From</argument>, <argument>QualType To</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SymExpr</name><argument_list>(<argument><expr><name>SymbolCastKind</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Operand</name><argument_list>(<argument><expr><name>In</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>FromTy</name><argument_list>(<argument><expr><name>From</name></expr></argument>)</argument_list></call></expr>, <macro><name>ToTy</name><argument_list>(<argument>To</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>In</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isValidTypeForSymbol</name><argument_list>(<argument><expr><name>From</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;


}</block>

<name>unsigned</name> <macro><name>computeComplexity</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<if_stmt><if>if <condition>(<expr><name>Complexity</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Complexity</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name><name>Operand</name><operator>-&gt;</operator><name>computeComplexity</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>Complexity</name></expr>;</return>
}</block>

<name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>ToTy</name></expr>;</return> }</block>

<specifier>const</specifier> <name>SymExpr</name> <operator>*</operator><macro><name>getOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Operand</name></expr>;</return> }</block>

<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>,
<argument>const SymExpr *In</argument>, <argument>QualType From</argument>, <argument>QualType To</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name>SymbolCastKind</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><name>In</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>From</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>To</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Operand</name></expr></argument>, <argument><expr><name>FromTy</name></expr></argument>, <argument><expr><name>ToTy</name></expr></argument>)</argument_list></call></expr>;
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SymExpr *SE</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>SE</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SymbolCastKind</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>BinarySymExpr</name> <operator>:</operator> <name>public</name> <name>SymExpr</name> <block>{
<expr><name>BinaryOperator</name><operator>::</operator><name>Opcode</name> <name>Op</name></expr>;
<expr><name>QualType</name> <name>T</name></expr>;

<expr><name>protected</name><operator>:</operator>
<macro><name>BinarySymExpr</name><argument_list>(<argument>Kind k</argument>, <argument>BinaryOperator::Opcode op</argument>, <argument>QualType t</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SymExpr</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Op</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>, <macro><name>T</name><argument_list>(<argument>t</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>classof</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;



<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isValidTypeForSymbol</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>Loc</name><operator>::</operator><call><name>isLocType</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>


<name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{ <return>return <expr><name>T</name></expr>;</return> }</block>

<name>BinaryOperator</name><operator>::</operator><name>Opcode</name> <macro><name>getOpcode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Op</name></expr>;</return> }</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SymExpr *SE</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <name>k</name> <operator>=</operator> <call><name><name>SE</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call></expr>;
<return>return <expr><name>k</name> <operator>&gt;=</operator> <name>BEGIN_BINARYSYMEXPRS</name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;=</operator> <name>END_BINARYSYMEXPRS</name></expr>;</return>
}</block>

<name>protected</name><operator>:</operator>
<specifier>static</specifier> <name>unsigned</name> <macro><name>computeOperandComplexity</name><argument_list>(<argument>const SymExpr *Value</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>Value</name><operator>-&gt;</operator><name>computeComplexity</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>unsigned</name> <macro><name>computeOperandComplexity</name><argument_list>(<argument>const llvm::APSInt &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><literal type="number">1</literal></expr>;</return>
}</block>

<specifier>static</specifier> <specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APSInt</name> <operator>*</operator><macro><name>getPointer</name><argument_list>(<argument>const llvm::APSInt &amp;Value</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>&amp;</operator><name>Value</name></expr>;</return>
}</block>
<specifier>static</specifier> <specifier>const</specifier> <name>SymExpr</name> <operator>*</operator><macro><name>getPointer</name><argument_list>(<argument>const SymExpr *Value</argument>)</argument_list></macro> <block>{ <return>return <expr><name>Value</name></expr>;</return> }</block>

<specifier>static</specifier> <name>void</name> <call><name>dumpToStreamImpl</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>os</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>SymExpr</name> <operator>*</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>void</name> <call><name>dumpToStreamImpl</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>os</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APSInt</name> <operator>&amp;</operator><name>Value</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>void</name> <macro><name>dumpToStreamImpl</name><argument_list>(<argument>raw_ostream &amp;os</argument>, <argument>BinaryOperator::Opcode op</argument>)</argument_list></macro></expr>;
}</block></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>LHSTYPE</name></expr></argument>, <argument><expr><name>class</name> <name>RHSTYPE</name></expr></argument>, <argument><expr><name>SymExpr</name><operator>::</operator><name>Kind</name> <name>ClassKind</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>BinarySymExprImpl</name> <operator>:</operator> <name>public</name> <name>BinarySymExpr</name> <block>{
<expr><name>LHSTYPE</name> <name>LHS</name></expr>;
<expr><name>RHSTYPE</name> <name>RHS</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>BinarySymExprImpl</name><argument_list>(<argument>LHSTYPE lhs</argument>, <argument>BinaryOperator::Opcode op</argument>, <argument>RHSTYPE rhs</argument>,
<argument>QualType t</argument>)</argument_list></macro>
<operator>:</operator> <call><name>BinarySymExpr</name><argument_list>(<argument><expr><name>ClassKind</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LHS</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>, <macro><name>RHS</name><argument_list>(<argument>rhs</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getPointer</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getPointer</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>dumpToStream</name><argument_list>(<argument>raw_ostream &amp;os</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<expr><call><name>dumpToStreamImpl</name><argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>dumpToStreamImpl</name><argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>dumpToStreamImpl</name><argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>LHSTYPE</name> <macro><name>getLHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LHS</name></expr>;</return> }</block>
<name>RHSTYPE</name> <macro><name>getRHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RHS</name></expr>;</return> }</block>

<name>unsigned</name> <macro><name>computeComplexity</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>override</name> <block>{
<if_stmt><if>if <condition>(<expr><name>Complexity</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Complexity</name> <operator>=</operator>
<call><name>computeOperandComplexity</name><argument_list>(<argument><expr><name>RHS</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>computeOperandComplexity</name><argument_list>(<argument><expr><name>LHS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>Complexity</name></expr>;</return>
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>LHSTYPE lhs</argument>,
<argument>BinaryOperator::Opcode op</argument>, <argument>RHSTYPE rhs</argument>, <argument>QualType t</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>ClassKind</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name>getPointer</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddInteger</name></name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name>getPointer</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><call><name>getOpcode</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><call><name>getType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const SymExpr *SE</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>SE</name><operator>-&gt;</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ClassKind</name></expr>;</return> }</block>
}</expr>;


<expr><name>using</name> <name>SymIntExpr</name> <operator>=</operator> <name><name>BinarySymExprImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>SymExpr</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APSInt</name> <operator>&amp;</operator></expr></argument>,
<argument><expr><name>SymExpr</name><operator>::</operator><name>Kind</name><operator>::</operator><name>SymIntExprKind</name></expr></argument>&gt;</argument_list></name></expr>;


<expr><name>using</name> <name>IntSymExpr</name> <operator>=</operator> <name><name>BinarySymExprImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APSInt</name> <operator>&amp;</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>SymExpr</name> <operator>*</operator></expr></argument>,
<argument><expr><name>SymExpr</name><operator>::</operator><name>Kind</name><operator>::</operator><name>IntSymExprKind</name></expr></argument>&gt;</argument_list></name></expr>;


<expr><name>using</name> <name>SymSymExpr</name> <operator>=</operator> <name><name>BinarySymExprImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>SymExpr</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>SymExpr</name> <operator>*</operator></expr></argument>,
<argument><expr><name>SymExpr</name><operator>::</operator><name>Kind</name><operator>::</operator><name>SymSymExprKind</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>class</name> <name>SymbolManager</name> <block>{
<expr><name>using</name> <name>DataSetTy</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>SymExpr</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>SymbolDependTy</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>SymbolRef</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>SymbolRefSmallVectorTy</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>DataSetTy</name> <name>DataSet</name></expr>;



<expr><name>SymbolDependTy</name> <name>SymbolDependencies</name></expr>;

<expr><name>unsigned</name> <name>SymbolCounter</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name><operator>&amp;</operator> <name>BPAlloc</name></expr>;
<expr><name>BasicValueFactory</name> <operator>&amp;</operator><name>BV</name></expr>;
<expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>SymbolManager</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>ctx</name></expr></argument>, <argument><expr><name>BasicValueFactory</name> <operator>&amp;</operator><name>bv</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name><operator>&amp;</operator> <name>bpalloc</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SymbolDependencies</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>, <expr><call><name>BPAlloc</name><argument_list>(<argument><expr><name>bpalloc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>BV</name><argument_list>(<argument><expr><name>bv</name></expr></argument>)</argument_list></call></expr>, <macro><name>Ctx</name><argument_list>(<argument>ctx</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>canSymbolicate</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro></expr>;


<expr><specifier>const</specifier> <name>SymbolRegionValue</name><operator>*</operator> <call><name>getRegionValueSymbol</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TypedValueRegion</name><operator>*</operator> <name>R</name></expr></argument>)</argument_list></call></expr>;

<expr><specifier>const</specifier> <name>SymbolConjured</name><operator>*</operator> <macro><name>conjureSymbol</name><argument_list>(<argument>const Stmt *E</argument>,
<argument>const LocationContext *LCtx</argument>,
<argument>QualType T</argument>,
<argument>unsigned VisitCount</argument>,
<argument>const void *SymbolTag = nullptr</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>SymbolConjured</name><operator>*</operator> <macro><name>conjureSymbol</name><argument_list>(<argument>const Expr *E</argument>,
<argument>const LocationContext *LCtx</argument>,
<argument>unsigned VisitCount</argument>,
<argument>const void *SymbolTag = nullptr</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>conjureSymbol</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>LCtx</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>VisitCount</name></expr></argument>, <argument><expr><name>SymbolTag</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>SymbolDerived</name> <operator>*</operator><macro><name>getDerivedSymbol</name><argument_list>(<argument>SymbolRef parentSymbol</argument>,
<argument>const TypedValueRegion *R</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>SymbolExtent</name> <operator>*</operator><call><name>getExtentSymbol</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SubRegion</name> <operator>*</operator><name>R</name></expr></argument>)</argument_list></call></expr>;





<expr><specifier>const</specifier> <name>SymbolMetadata</name> <operator>*</operator><macro><name>getMetadataSymbol</name><argument_list>(<argument>const MemRegion *R</argument>, <argument>const Stmt *S</argument>,
<argument>QualType T</argument>,
<argument>const LocationContext *LCtx</argument>,
<argument>unsigned VisitCount</argument>,
<argument>const void *SymbolTag = nullptr</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>SymbolCast</name><operator>*</operator> <macro><name>getCastSymbol</name><argument_list>(<argument>const SymExpr *Operand</argument>,
<argument>QualType From</argument>, <argument>QualType To</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>SymIntExpr</name> <operator>*</operator><macro><name>getSymIntExpr</name><argument_list>(<argument>const SymExpr *lhs</argument>, <argument>BinaryOperator::Opcode op</argument>,
<argument>const llvm::APSInt&amp; rhs</argument>, <argument>QualType t</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>SymIntExpr</name> <operator>*</operator><macro><name>getSymIntExpr</name><argument_list>(<argument>const SymExpr &amp;lhs</argument>, <argument>BinaryOperator::Opcode op</argument>,
<argument>const llvm::APSInt&amp; rhs</argument>, <argument>QualType t</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>getSymIntExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lhs</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>rhs</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>IntSymExpr</name> <operator>*</operator><macro><name>getIntSymExpr</name><argument_list>(<argument>const llvm::APSInt&amp; lhs</argument>,
<argument>BinaryOperator::Opcode op</argument>,
<argument>const SymExpr *rhs</argument>, <argument>QualType t</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>SymSymExpr</name> <operator>*</operator><macro><name>getSymSymExpr</name><argument_list>(<argument>const SymExpr *lhs</argument>, <argument>BinaryOperator::Opcode op</argument>,
<argument>const SymExpr *rhs</argument>, <argument>QualType t</argument>)</argument_list></macro></expr>;

<expr><name>QualType</name> <macro><name>getType</name><argument_list>(<argument>const SymExpr *SE</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>SE</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>void</name> <macro><name>addSymbolDependency</name><argument_list>(<argument>const SymbolRef Primary</argument>, <argument>const SymbolRef Dependent</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>SymbolRefSmallVectorTy</name> <operator>*</operator><macro><name>getDependentSymbols</name><argument_list>(<argument>const SymbolRef Primary</argument>)</argument_list></macro></expr>;

<expr><name>ASTContext</name> <operator>&amp;</operator><macro><name>getContext</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Ctx</name></expr>;</return> }</block>
<name>BasicValueFactory</name> <operator>&amp;</operator><macro><name>getBasicVals</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>BV</name></expr>;</return> }</block>
}</expr>;


<expr><name>class</name> <name>SymbolReaper</name> <block>{
enum <expr><name>SymbolStatus</name> <block>{
<expr><name>NotProcessed</name></expr>,
<expr><name>HaveMarkedDependents</name></expr>
}</block></expr>;

<expr><name>using</name> <name>SymbolSetTy</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><name>SymbolRef</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>SymbolMapTy</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>SymbolRef</name></expr></argument>, <argument><expr><name>SymbolStatus</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>RegionSetTy</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>SymbolMapTy</name> <name>TheLiving</name></expr>;
<expr><name>SymbolSetTy</name> <name>MetadataInUse</name></expr>;

<expr><name>RegionSetTy</name> <name>RegionRoots</name></expr>;

<expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>LCtx</name></expr>;
<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>Loc</name></expr>;
<expr><name>SymbolManager</name><operator>&amp;</operator> <name>SymMgr</name></expr>;
<expr><name>StoreRef</name> <name>reapedStore</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>includedRegionCache</name></expr>;

<expr><name>public</name><operator>:</operator>







<call><name>SymbolReaper</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><name>Ctx</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>s</name></expr></argument>,
<argument><expr><name>SymbolManager</name> <operator>&amp;</operator><name>symmgr</name></expr></argument>, <argument><expr><name>StoreManager</name> <operator>&amp;</operator><name>storeMgr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>LCtx</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Loc</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>SymMgr</name><argument_list>(<argument><expr><name>symmgr</name></expr></argument>)</argument_list></call></expr>, <macro><name>reapedStore</name><argument_list>(<argument>nullptr</argument>, <argument>storeMgr</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><macro><name>getLocationContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LCtx</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isLive</name><argument_list>(<argument>SymbolRef sym</argument>)</argument_list></macro></expr>;
<expr><name>bool</name> <call><name>isLiveRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>region</name></expr></argument>)</argument_list></call></expr>;
<expr><name>bool</name> <macro><name>isLive</name><argument_list>(<argument>const Expr *ExprVal</argument>, <argument>const LocationContext *LCtx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>bool</name> <macro><name>isLive</name><argument_list>(<argument>const VarRegion *VR</argument>, <argument>bool includeStoreBindings = false</argument>)</argument_list></macro> <specifier>const</specifier></expr>;






<expr><name>void</name> <macro><name>markLive</name><argument_list>(<argument>SymbolRef sym</argument>)</argument_list></macro></expr>;








<expr><name>void</name> <macro><name>markInUse</name><argument_list>(<argument>SymbolRef sym</argument>)</argument_list></macro></expr>;

<expr><name>using</name> <name>region_iterator</name> <operator>=</operator> <name>RegionSetTy</name><operator>::</operator><name>const_iterator</name></expr>;

<expr><name>region_iterator</name> <macro><name>region_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>RegionRoots</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>region_iterator</name> <macro><name>region_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>RegionRoots</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>





<name>bool</name> <macro><name>isDead</name><argument_list>(<argument>SymbolRef sym</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>!</operator><call><name>isLive</name><argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <call><name>markLive</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>region</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <call><name>markElementIndicesLive</name><argument_list>(<argument><expr><specifier>const</specifier> <name>MemRegion</name> <operator>*</operator><name>region</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <macro><name>setReapedStore</name><argument_list>(<argument>StoreRef st</argument>)</argument_list></macro> <block>{ <expr><name>reapedStore</name> <operator>=</operator> <name>st</name></expr>; }</block>

<name>private</name><operator>:</operator>

<name>void</name> <macro><name>markDependentsLive</name><argument_list>(<argument>SymbolRef sym</argument>)</argument_list></macro></expr>;
}</block></expr>;

<expr><name>class</name> <name>SymbolVisitor</name> <block>{
<expr><name>protected</name><operator>:</operator>
<operator>~</operator><call><name>SymbolVisitor</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>public</name><operator>:</operator>
<call><name>SymbolVisitor</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><call><name>SymbolVisitor</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SymbolVisitor</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;
<macro><name>SymbolVisitor</name><argument_list>(<argument>SymbolVisitor &amp;&amp;</argument>)</argument_list></macro> <expr><block>{}</block>





<name>virtual</name> <name>bool</name> <macro><name>VisitSymbol</name><argument_list>(<argument>SymbolRef sym</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name>virtual</name> <name>bool</name> <macro><name>VisitMemRegion</name><argument_list>(<argument>const MemRegion *</argument>)</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
}</expr>;

}</block></expr>

}</block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt></block_content></block></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
