












#if !defined(LLVM_CLANG_AST_CLONEDETECTION_H)
#define LLVM_CLANG_AST_CLONEDETECTION_H

#include "clang/AST/StmtVisitor.h"
#include "llvm/Support/Regex.h"
#include <vector>

namespace clang {

class Stmt;
class Decl;
class VarDecl;
class ASTContext;
class CompoundStmt;





class StmtSequence {



const Stmt *S;


const Decl *D;




unsigned StartIndex;
unsigned EndIndex;

public:












StmtSequence(const CompoundStmt *Stmt, const Decl *D, unsigned StartIndex,
unsigned EndIndex);





StmtSequence(const Stmt *Stmt, const Decl *D);


StmtSequence();

typedef const Stmt *const *iterator;


iterator begin() const;


iterator end() const;




const Stmt *front() const {
assert(!empty());
return begin()[0];
}




const Stmt *back() const {
assert(!empty());
return begin()[size() - 1];
}


unsigned size() const {
if (holdsSequence())
return EndIndex - StartIndex;
if (S == nullptr)
return 0;
return 1;
}


bool empty() const { return size() == 0; }


ASTContext &getASTContext() const;


const Decl *getContainingDecl() const {
assert(D);
return D;
}


bool holdsSequence() const { return EndIndex != 0; }




SourceLocation getBeginLoc() const;




SourceLocation getEndLoc() const;



SourceRange getSourceRange() const;

bool operator==(const StmtSequence &Other) const {
return std::tie(S, StartIndex, EndIndex) ==
std::tie(Other.S, Other.StartIndex, Other.EndIndex);
}

bool operator!=(const StmtSequence &Other) const {
return std::tie(S, StartIndex, EndIndex) !=
std::tie(Other.S, Other.StartIndex, Other.EndIndex);
}






bool contains(const StmtSequence &Other) const;
};














class CloneDetector {

public:

typedef llvm::SmallVector<StmtSequence, 8> CloneGroup;



void analyzeCodeBody(const Decl *D);









template <typename T>
static void constrainClones(std::vector<CloneGroup> &CloneGroups, T C) {
C.constrain(CloneGroups);
}






template <typename T1, typename... Ts>
static void constrainClones(std::vector<CloneGroup> &CloneGroups, T1 C,
Ts... ConstraintList) {
constrainClones(CloneGroups, C);
constrainClones(CloneGroups, ConstraintList...);
}






template <typename... Ts>
void findClones(std::vector<CloneGroup> &Result, Ts... ConstraintList) {



CloneGroup AllClones;
AllClones.reserve(Sequences.size());
for (const auto &C : Sequences) {
AllClones.push_back(C);
}

Result.push_back(AllClones);

constrainClones(Result, ConstraintList...);
}

private:
CloneGroup Sequences;
};



class CloneConstraint {
public:





static void filterGroups(
std::vector<CloneDetector::CloneGroup> &CloneGroups,
llvm::function_ref<bool(const CloneDetector::CloneGroup &)> Filter) {
CloneGroups.erase(
std::remove_if(CloneGroups.begin(), CloneGroups.end(), Filter),
CloneGroups.end());
}







static void splitCloneGroups(
std::vector<CloneDetector::CloneGroup> &CloneGroups,
llvm::function_ref<bool(const StmtSequence &, const StmtSequence &)>
Compare);
};








class RecursiveCloneTypeIIHashConstraint {
public:
void constrain(std::vector<CloneDetector::CloneGroup> &Sequences);
};







class RecursiveCloneTypeIIVerifyConstraint {
public:
void constrain(std::vector<CloneDetector::CloneGroup> &Sequences);
};






class MinComplexityConstraint {
unsigned MinComplexity;

public:
MinComplexityConstraint(unsigned MinComplexity)
: MinComplexity(MinComplexity) {}





size_t calculateStmtComplexity(const StmtSequence &Seq, std::size_t Limit,
const std::string &ParentMacroStack = "");

void constrain(std::vector<CloneDetector::CloneGroup> &CloneGroups) {
CloneConstraint::filterGroups(
CloneGroups, [this](const CloneDetector::CloneGroup &A) {
if (!A.empty())
return calculateStmtComplexity(A.front(), MinComplexity) <
MinComplexity;
else
return false;
});
}
};


class MinGroupSizeConstraint {
unsigned MinGroupSize;

public:
MinGroupSizeConstraint(unsigned MinGroupSize = 2)
: MinGroupSize(MinGroupSize) {}

void constrain(std::vector<CloneDetector::CloneGroup> &CloneGroups) {
CloneConstraint::filterGroups(CloneGroups,
[this](const CloneDetector::CloneGroup &A) {
return A.size() < MinGroupSize;
});
}
};


struct OnlyLargestCloneConstraint {
void constrain(std::vector<CloneDetector::CloneGroup> &Result);
};

struct FilenamePatternConstraint {
StringRef IgnoredFilesPattern;
std::shared_ptr<llvm::Regex> IgnoredFilesRegex;

FilenamePatternConstraint(StringRef IgnoredFilesPattern)
: IgnoredFilesPattern(IgnoredFilesPattern) {
IgnoredFilesRegex = std::make_shared<llvm::Regex>("^(" +
IgnoredFilesPattern.str() + "$)");
}

bool isAutoGenerated(const CloneDetector::CloneGroup &Group);

void constrain(std::vector<CloneDetector::CloneGroup> &CloneGroups) {
CloneConstraint::filterGroups(
CloneGroups, [this](const CloneDetector::CloneGroup &Group) {
return isAutoGenerated(Group);
});
}
};


class VariablePattern {


struct VariableOccurence {

size_t KindID;

const Stmt *Mention;

VariableOccurence(size_t KindID, const Stmt *Mention)
: KindID(KindID), Mention(Mention) {}
};


std::vector<VariableOccurence> Occurences;


std::vector<const VarDecl *> Variables;




void addVariableOccurence(const VarDecl *VarDecl, const Stmt *Mention);


void addVariables(const Stmt *S);

public:


VariablePattern(const StmtSequence &Sequence) {
for (const Stmt *S : Sequence)
addVariables(S);
}



struct SuspiciousClonePair {


struct SuspiciousCloneInfo {

const VarDecl *Variable;

const Stmt *Mention;



const VarDecl *Suggestion;
SuspiciousCloneInfo(const VarDecl *Variable, const Stmt *Mention,
const VarDecl *Suggestion)
: Variable(Variable), Mention(Mention), Suggestion(Suggestion) {}
SuspiciousCloneInfo() {}
};

SuspiciousCloneInfo FirstCloneInfo;

SuspiciousCloneInfo SecondCloneInfo;
};
























unsigned countPatternDifferences(
const VariablePattern &Other,
VariablePattern::SuspiciousClonePair *FirstMismatch = nullptr);
};


struct MatchingVariablePatternConstraint {
void constrain(std::vector<CloneDetector::CloneGroup> &CloneGroups);
};

}

#endif
