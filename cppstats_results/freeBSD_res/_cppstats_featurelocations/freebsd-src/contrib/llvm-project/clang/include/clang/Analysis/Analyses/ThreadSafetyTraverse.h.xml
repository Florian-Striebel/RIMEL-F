<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Analysis/Analyses/ThreadSafetyTraverse.h">














<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYTRAVERSE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_ANALYSIS_ANALYSES_THREADSAFETYTRAVERSE_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/Analyses/ThreadSafetyTIL.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/Analyses/ThreadSafetyUtil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ostream&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>threadSafety</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>til</name> <block>{<block_content>


























<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Self</name></expr></argument>, <argument><expr><name>class</name> <name>R</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Traversal</name> <block>{<block_content>
<label><name>public</name>:</label>
<function><type><name>Self</name> <modifier>*</modifier></type><name>self</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Self</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>






<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>typename</name> <name>R</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverse</name><argument_list>(<argument>T* &amp;E</argument>, <argument>typename R::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>traverseSExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>typename</name> <name>R</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverseSExpr</name><argument_list>(<argument>SExpr *E</argument>, <argument>typename R::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>traverseByCase</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>typename</name> <name>R</name><operator>::</operator><name>R_SExpr</name> <macro><name>traverseByCase</name><argument_list>(<argument>SExpr *E</argument>, <argument>typename R::R_Ctx Ctx</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIL_OPCODE_DEF</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case COP_##X: return self()-&gt;traverse##X(cast&lt;X&gt;(E), Ctx);</cpp:value></cpp:define>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ThreadSafetyOps.def"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TIL_OPCODE_DEF</name></cpp:undef>
<expr_stmt/>}</block_content>
return self(</block></switch>)<operator>-&gt;</operator><call><name>reduceNull</name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIL_OPCODE_DEF</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>typename R::R_SExpr traverse##X(X *e, typename R::R_Ctx Ctx) { return e-&gt;traverse(*self(), Ctx); }</cpp:value></cpp:define>



<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ThreadSafetyOps.def"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TIL_OPCODE_DEF</name></cpp:undef>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>SimpleReducerBase</name> <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>TraversalKind</name> <block>{

<decl><name>TRV_Normal</name></decl>,


<decl><name>TRV_Decl</name></decl>,


<decl><name>TRV_Lazy</name></decl>,


<decl><name>TRV_Type</name></decl>
}</block>;</enum>




<decl_stmt><decl><type><name>using</name></type> <name>R_Ctx</name> <init>= <expr><name>TraversalKind</name></expr></init></decl>;</decl_stmt>


<function><type><name>R_Ctx</name></type> <name>subExprCtx</name><parameter_list>(<parameter><decl><type><name>R_Ctx</name></type> <name>Ctx</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>TRV_Normal</name></expr>;</return> </block_content>}</block></function>



<function><type><name>R_Ctx</name></type> <name>declCtx</name><parameter_list>(<parameter><decl><type><name>R_Ctx</name></type> <name>Ctx</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>TRV_Decl</name></expr>;</return> </block_content>}</block></function>



<function><type><name>R_Ctx</name></type> <name>lazyCtx</name><parameter_list>(<parameter><decl><type><name>R_Ctx</name></type> <name>Ctx</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>TRV_Lazy</name></expr>;</return> </block_content>}</block></function>


<function><type><name>R_Ctx</name></type> <name>typeCtx</name><parameter_list>(<parameter><decl><type><name>R_Ctx</name></type> <name>Ctx</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>TRV_Type</name></expr>;</return> </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>CopyReducerBase</name> <range>: <expr><name>public</name> <name>SimpleReducerBase</name> <block>{
<expr><name>public</name><operator>:</operator>


<name>using</name> <name>R_SExpr</name> <operator>=</operator> <name>SExpr</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>R_BasicBlock</name> <operator>=</operator> <name>BasicBlock</name> <operator>*</operator></expr>;



<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>Container</name> <block>{
<expr><name>public</name><operator>:</operator>

<macro><name>Container</name><argument_list>(<argument>CopyReducerBase &amp;S</argument>, <argument>unsigned N</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Elems</name><argument_list>(<argument>S.Arena</argument>, <argument>N</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>push_back</name><argument_list>(<argument>T E</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Elems</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>; }</block>

<name><name>SimpleArray</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <name>Elems</name></expr>;
}</block></expr>;

<macro><name>CopyReducerBase</name><argument_list>(<argument>MemRegionRef A</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Arena</name><argument_list>(<argument>A</argument>)</argument_list></macro> <expr><block>{}</block>

<name>protected</name><operator>:</operator>
<name>MemRegionRef</name> <name>Arena</name></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>VisitReducerBase</name> <range>: <expr><name>public</name> <name>SimpleReducerBase</name> <block>{
<expr><name>public</name><operator>:</operator>

<name>using</name> <name>R_SExpr</name> <operator>=</operator> <name>bool</name></expr>;
<expr><name>using</name> <name>R_BasicBlock</name> <operator>=</operator> <name>bool</name></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>Container</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>bool</name> <name>Success</name> <operator>=</operator> <name>true</name></expr>;

<macro><name>Container</name><argument_list>(<argument>VisitReducerBase &amp;S</argument>, <argument>unsigned N</argument>)</argument_list></macro> <expr><block>{}</block>

<name>void</name> <macro><name>push_back</name><argument_list>(<argument>bool E</argument>)</argument_list></macro> <block>{ <expr><name>Success</name> <operator>=</operator> <name>Success</name> <operator>&amp;&amp;</operator> <name>E</name></expr>; }</block></expr>
}</block></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>Self</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>VisitReducer</name> <range>: <expr><name>public</name> <name><name>Traversal</name><argument_list type="generic">&lt;<argument><expr><name>Self</name></expr></argument>, <argument><expr><name>VisitReducerBase</name></expr></argument>&gt;</argument_list></name></expr></range></decl>,
<decl><type ref="prev"/><name>public</name> <name>VisitReducerBase</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>VisitReducer</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>

<label><name>public</name>:</label>
<function><type><name>R_SExpr</name></type> <name>reduceNull</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>
<function><type><name>R_SExpr</name></type> <name>reduceUndefined</name><parameter_list>(<parameter><decl><type><name>Undefined</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>
<function><type><name>R_SExpr</name></type> <name>reduceWildcard</name><parameter_list>(<parameter><decl><type><name>Wildcard</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceLiteral</name><parameter_list>(<parameter><decl><type><name>Literal</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>
<function><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>R_SExpr</name></type> <name>reduceLiteralT</name><parameter_list>(<parameter><decl><type><name><name>LiteralT</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>
<function><type><name>R_SExpr</name></type> <name>reduceLiteralPtr</name><parameter_list>(<parameter><decl><type><name>Literal</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceFunction</name><parameter_list>(<parameter><decl><type><name>Function</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>Variable</name> <modifier>*</modifier></type><name>Nvd</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>Nvd</name> <operator>&amp;&amp;</operator> <name>E0</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceSFunction</name><parameter_list>(<parameter><decl><type><name>SFunction</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>Variable</name> <modifier>*</modifier></type><name>Nvd</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>Nvd</name> <operator>&amp;&amp;</operator> <name>E0</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceCode</name><parameter_list>(<parameter><decl><type><name>Code</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E1</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>E0</name> <operator>&amp;&amp;</operator> <name>E1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceField</name><parameter_list>(<parameter><decl><type><name>Field</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E1</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>E0</name> <operator>&amp;&amp;</operator> <name>E1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceApply</name><parameter_list>(<parameter><decl><type><name>Apply</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E1</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>E0</name> <operator>&amp;&amp;</operator> <name>E1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceSApply</name><parameter_list>(<parameter><decl><type><name>SApply</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E1</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>E0</name> <operator>&amp;&amp;</operator> <name>E1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceProject</name><parameter_list>(<parameter><decl><type><name>Project</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>E0</name></expr>;</return> </block_content>}</block></function>
<function><type><name>R_SExpr</name></type> <name>reduceCall</name><parameter_list>(<parameter><decl><type><name>Call</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>E0</name></expr>;</return> </block_content>}</block></function>
<function><type><name>R_SExpr</name></type> <name>reduceAlloc</name><parameter_list>(<parameter><decl><type><name>Alloc</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>E0</name></expr>;</return> </block_content>}</block></function>
<function><type><name>R_SExpr</name></type> <name>reduceLoad</name><parameter_list>(<parameter><decl><type><name>Load</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>E0</name></expr>;</return> </block_content>}</block></function>
<function><type><name>R_SExpr</name></type> <name>reduceStore</name><parameter_list>(<parameter><decl><type><name>Store</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E1</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>E0</name> <operator>&amp;&amp;</operator> <name>E1</name></expr>;</return> </block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceArrayIndex</name><parameter_list>(<parameter><decl><type><name>Store</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E1</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>E0</name> <operator>&amp;&amp;</operator> <name>E1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceArrayAdd</name><parameter_list>(<parameter><decl><type><name>Store</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E1</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>E0</name> <operator>&amp;&amp;</operator> <name>E1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceUnaryOp</name><parameter_list>(<parameter><decl><type><name>UnaryOp</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>E0</name></expr>;</return> </block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceBinaryOp</name><parameter_list>(<parameter><decl><type><name>BinaryOp</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E1</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>E0</name> <operator>&amp;&amp;</operator> <name>E1</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceCast</name><parameter_list>(<parameter><decl><type><name>Cast</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>E0</name></expr>;</return> </block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceSCFG</name><parameter_list>(<parameter><decl><type><name>SCFG</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name><name>Container</name><argument_list type="generic">&lt;<argument><expr><name>BasicBlock</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Bbs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name><name>Bbs</name><operator>.</operator><name>Success</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_BasicBlock</name></type> <name>reduceBasicBlock</name><parameter_list>(<parameter><decl><type><name>BasicBlock</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name><name>Container</name><argument_list type="generic">&lt;<argument><expr><name>R_SExpr</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>As</name></decl></parameter>,
<parameter><decl><type><name><name>Container</name><argument_list type="generic">&lt;<argument><expr><name>R_SExpr</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Is</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name><name>As</name><operator>.</operator><name>Success</name></name> <operator>&amp;&amp;</operator> <name><name>Is</name><operator>.</operator><name>Success</name></name> <operator>&amp;&amp;</operator> <name>T</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reducePhi</name><parameter_list>(<parameter><decl><type><name>Phi</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name><name>Container</name><argument_list type="generic">&lt;<argument><expr><name>R_SExpr</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>As</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name><name>As</name><operator>.</operator><name>Success</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceGoto</name><parameter_list>(<parameter><decl><type><name>Goto</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>BasicBlock</name> <modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceBranch</name><parameter_list>(<parameter><decl><type><name>Branch</name> <modifier>&amp;</modifier></type><name>O</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>C</name></decl></parameter>, <parameter><decl><type><name>BasicBlock</name> <modifier>*</modifier></type><name>B0</name></decl></parameter>, <parameter><decl><type><name>BasicBlock</name> <modifier>*</modifier></type><name>B1</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>C</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceReturn</name><parameter_list>(<parameter><decl><type><name>Return</name> <modifier>&amp;</modifier></type><name>O</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>E</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceIdentifier</name><parameter_list>(<parameter><decl><type><name>Identifier</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceIfThenElse</name><parameter_list>(<parameter><decl><type><name>IfThenElse</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>C</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>C</name> <operator>&amp;&amp;</operator> <name>T</name> <operator>&amp;&amp;</operator> <name>E</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>R_SExpr</name></type> <name>reduceLet</name><parameter_list>(<parameter><decl><type><name>Let</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>Variable</name> <modifier>*</modifier></type><name>Nvd</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>B</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>Nvd</name> <operator>&amp;&amp;</operator> <name>B</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Variable</name> <modifier>*</modifier></type><name>enterScope</name><parameter_list>(<parameter><decl><type><name>Variable</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>, <parameter><decl><type><name>R_SExpr</name></type> <name>E0</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><operator>&amp;</operator><name>Orig</name></expr>;</return> </block_content>}</block></function>
<function><type><name>void</name></type> <name>exitScope</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variable</name> <modifier>&amp;</modifier></type><name>Orig</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<function><type><name>void</name></type> <name>enterCFG</name><parameter_list>(<parameter><decl><type><name>SCFG</name> <modifier>&amp;</modifier></type><name>Cfg</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<function><type><name>void</name></type> <name>exitCFG</name><parameter_list>(<parameter><decl><type><name>SCFG</name> <modifier>&amp;</modifier></type><name>Cfg</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<function><type><name>void</name></type> <name>enterBasicBlock</name><parameter_list>(<parameter><decl><type><name>BasicBlock</name> <modifier>&amp;</modifier></type><name>BB</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<function><type><name>void</name></type> <name>exitBasicBlock</name><parameter_list>(<parameter><decl><type><name>BasicBlock</name> <modifier>&amp;</modifier></type><name>BB</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>

<function><type><name>Variable</name> <modifier>*</modifier></type><name>reduceVariableRef</name><parameter_list>(<parameter><decl><type><name>Variable</name> <modifier>*</modifier></type><name>Ovd</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>Ovd</name></expr>;</return> </block_content>}</block></function>
<function><type><name>BasicBlock</name> <modifier>*</modifier></type><name>reduceBasicBlockRef</name><parameter_list>(<parameter><decl><type><name>BasicBlock</name> <modifier>*</modifier></type><name>Obb</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>Obb</name></expr>;</return> </block_content>}</block></function>

<label><name>public</name>:</label>
<function><type><name>bool</name></type> <name>traverse</name><parameter_list>(<parameter><decl><type><name>SExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>TraversalKind</name></type> <name>K</name> <init>= <expr><name>TRV_Normal</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Success</name> <operator>=</operator> <name>Success</name> <operator>&amp;&amp;</operator> <call><name><name>this</name><operator>-&gt;</operator><name>traverseByCase</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Success</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>visit</name><parameter_list>(<parameter><decl><type><name>SExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Self</name></type> <name>Visitor</name></decl>;</decl_stmt>
<return>return <expr><call><name><name>Visitor</name><operator>.</operator><name>traverse</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>TRV_Normal</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>bool</name></type> <name>Success</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Self</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>Comparator</name> <block>{<block_content>
<label><name>protected</name>:</label>
<function><type><name>Self</name> <modifier>*</modifier></type><name>self</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Self</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<label><name>public</name>:</label>
<function><type><name>bool</name></type> <name>compareByCase</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SExpr</name> <modifier>*</modifier></type><name>E1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SExpr</name><modifier>*</modifier></type> <name>E2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><call><name><name>E1</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIL_OPCODE_DEF</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case COP_##X: return cast&lt;X&gt;(E1)-&gt;compare(cast&lt;X&gt;(E2), *self());</cpp:value></cpp:define>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ThreadSafetyOps.def"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TIL_OPCODE_DEF</name></cpp:undef>
</block_content>}</block></switch>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>EqualsComparator</name> <range>: <expr><name>public</name> <name><name>Comparator</name><argument_list type="generic">&lt;<argument><expr><name>EqualsComparator</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>



<name>using</name> <name>CType</name> <operator>=</operator> <name>bool</name></expr>;

<expr><name>CType</name> <macro><name>trueResult</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>bool</name> <macro><name>notTrue</name><argument_list>(<argument>CType ct</argument>)</argument_list></macro> <block>{ <return>return <expr><operator>!</operator><name>ct</name></expr>;</return> }</block>

<name>bool</name> <macro><name>compareIntegers</name><argument_list>(<argument>unsigned i</argument>, <argument>unsigned j</argument>)</argument_list></macro> <block>{ <return>return <expr><name>i</name> <operator>==</operator> <name>j</name></expr>;</return> }</block>
<name>bool</name> <macro><name>compareStrings</name> <argument_list>(<argument>StringRef s</argument>, <argument>StringRef r</argument>)</argument_list></macro> <block>{ <return>return <expr><name>s</name> <operator>==</operator> <name>r</name></expr>;</return> }</block>
<name>bool</name> <macro><name>comparePointers</name><argument_list>(<argument>const void* P</argument>, <argument>const void* Q</argument>)</argument_list></macro> <block>{ <return>return <expr><name>P</name> <operator>==</operator> <name>Q</name></expr>;</return> }</block>

<name>bool</name> <macro><name>compare</name><argument_list>(<argument>const SExpr *E1</argument>, <argument>const SExpr* E2</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>E1</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>E2</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>compareByCase</name><argument_list>(<argument><expr><name>E1</name></expr></argument>, <argument><expr><name>E2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>


<function><type><name>void</name></type> <name>enterScope</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variable</name> <modifier>*</modifier></type><name>V1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Variable</name> <modifier>*</modifier></type><name>V2</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<function><type><name>void</name></type> <name>leaveScope</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>

<function><type><name>bool</name></type> <name>compareVariableRefs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variable</name> <modifier>*</modifier></type><name>V1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Variable</name> <modifier>*</modifier></type><name>V2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>V1</name> <operator>==</operator> <name>V2</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>compareExprs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SExpr</name> <modifier>*</modifier></type><name>E1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SExpr</name><modifier>*</modifier></type> <name>E2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>EqualsComparator</name></type> <name>Eq</name></decl>;</decl_stmt>
<return>return <expr><call><name><name>Eq</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>E1</name></expr></argument>, <argument><expr><name>E2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>MatchComparator</name> <range>: <expr><name>public</name> <name><name>Comparator</name><argument_list type="generic">&lt;<argument><expr><name>MatchComparator</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>



<name>using</name> <name>CType</name> <operator>=</operator> <name>bool</name></expr>;

<expr><name>CType</name> <macro><name>trueResult</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block>
<name>bool</name> <macro><name>notTrue</name><argument_list>(<argument>CType ct</argument>)</argument_list></macro> <block>{ <return>return <expr><operator>!</operator><name>ct</name></expr>;</return> }</block>

<name>bool</name> <macro><name>compareIntegers</name><argument_list>(<argument>unsigned i</argument>, <argument>unsigned j</argument>)</argument_list></macro> <block>{ <return>return <expr><name>i</name> <operator>==</operator> <name>j</name></expr>;</return> }</block>
<name>bool</name> <macro><name>compareStrings</name> <argument_list>(<argument>StringRef s</argument>, <argument>StringRef r</argument>)</argument_list></macro> <block>{ <return>return <expr><name>s</name> <operator>==</operator> <name>r</name></expr>;</return> }</block>
<name>bool</name> <macro><name>comparePointers</name><argument_list>(<argument>const void *P</argument>, <argument>const void *Q</argument>)</argument_list></macro> <block>{ <return>return <expr><name>P</name> <operator>==</operator> <name>Q</name></expr>;</return> }</block>

<name>bool</name> <macro><name>compare</name><argument_list>(<argument>const SExpr *E1</argument>, <argument>const SExpr *E2</argument>)</argument_list></macro> <block>{

<if_stmt><if>if <condition>(<expr><call><name><name>E1</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Wildcard</name> <operator>||</operator> <call><name><name>E2</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Wildcard</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr>

<if_stmt><if>if <condition>(<expr><call><name><name>E1</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name><name>E2</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr></range></decl></decl_stmt>
<return>return <expr><call><name>compareByCase</name><argument_list>(<argument><expr><name>E1</name></expr></argument>, <argument><expr><name>E2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><name>void</name></type> <name>enterScope</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variable</name><modifier>*</modifier></type> <name>V1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Variable</name><modifier>*</modifier></type> <name>V2</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<function><type><name>void</name></type> <name>leaveScope</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>

<function><type><name>bool</name></type> <name>compareVariableRefs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variable</name><modifier>*</modifier></type> <name>V1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Variable</name><modifier>*</modifier></type> <name>V2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>V1</name> <operator>==</operator> <name>V2</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>compareExprs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SExpr</name> <modifier>*</modifier></type><name>E1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SExpr</name><modifier>*</modifier></type> <name>E2</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>MatchComparator</name></type> <name>Matcher</name></decl>;</decl_stmt>
<return>return <expr><call><name><name>Matcher</name><operator>.</operator><name>compare</name></name><argument_list>(<argument><expr><name>E1</name></expr></argument>, <argument><expr><name>E2</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
};






<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Self</name></expr></argument>, <argument><expr><name>typename</name> <name>StreamType</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>PrettyPrinter</name> <block>{<block_content>
<label><name>private</name>:</label>

<decl_stmt><decl><type><name>bool</name></type> <name>Verbose</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>Cleanup</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>CStyle</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>PrettyPrinter</name><argument_list>(<argument>bool V = false</argument>, <argument>bool C = true</argument>, <argument>bool CS = true</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Verbose</name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Cleanup</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>CStyle</name><argument_list>(<argument>CS</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>void</name> <macro><name>print</name><argument_list>(<argument>const SExpr *E</argument>, <argument>StreamType &amp;SS</argument>)</argument_list></macro> <block>{
<expr><name>Self</name> <name>printer</name></expr>;
<expr><call><name><name>printer</name><operator>.</operator><name>printSExpr</name></name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_MAX</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>protected</name><operator>:</operator>
<name>Self</name> <operator>*</operator><macro><name>self</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Self</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>newline</name><parameter_list>(<parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"\n"</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name></type> <name>Prec_Atom</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name></type> <name>Prec_Postfix</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name></type> <name>Prec_Unary</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name></type> <name>Prec_Binary</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name></type> <name>Prec_Other</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name></type> <name>Prec_Decl</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name></type> <name>Prec_MAX</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>;</decl_stmt>


<function><type><name>unsigned</name></type> <name>precedence</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>COP_Future</name></expr>:</case> <return>return <expr><name>Prec_Atom</name></expr>;</return>
<case>case <expr><name>COP_Undefined</name></expr>:</case> <return>return <expr><name>Prec_Atom</name></expr>;</return>
<case>case <expr><name>COP_Wildcard</name></expr>:</case> <return>return <expr><name>Prec_Atom</name></expr>;</return>

<case>case <expr><name>COP_Literal</name></expr>:</case> <return>return <expr><name>Prec_Atom</name></expr>;</return>
<case>case <expr><name>COP_LiteralPtr</name></expr>:</case> <return>return <expr><name>Prec_Atom</name></expr>;</return>
<case>case <expr><name>COP_Variable</name></expr>:</case> <return>return <expr><name>Prec_Atom</name></expr>;</return>
<case>case <expr><name>COP_Function</name></expr>:</case> <return>return <expr><name>Prec_Decl</name></expr>;</return>
<case>case <expr><name>COP_SFunction</name></expr>:</case> <return>return <expr><name>Prec_Decl</name></expr>;</return>
<case>case <expr><name>COP_Code</name></expr>:</case> <return>return <expr><name>Prec_Decl</name></expr>;</return>
<case>case <expr><name>COP_Field</name></expr>:</case> <return>return <expr><name>Prec_Decl</name></expr>;</return>

<case>case <expr><name>COP_Apply</name></expr>:</case> <return>return <expr><name>Prec_Postfix</name></expr>;</return>
<case>case <expr><name>COP_SApply</name></expr>:</case> <return>return <expr><name>Prec_Postfix</name></expr>;</return>
<case>case <expr><name>COP_Project</name></expr>:</case> <return>return <expr><name>Prec_Postfix</name></expr>;</return>

<case>case <expr><name>COP_Call</name></expr>:</case> <return>return <expr><name>Prec_Postfix</name></expr>;</return>
<case>case <expr><name>COP_Alloc</name></expr>:</case> <return>return <expr><name>Prec_Other</name></expr>;</return>
<case>case <expr><name>COP_Load</name></expr>:</case> <return>return <expr><name>Prec_Postfix</name></expr>;</return>
<case>case <expr><name>COP_Store</name></expr>:</case> <return>return <expr><name>Prec_Other</name></expr>;</return>
<case>case <expr><name>COP_ArrayIndex</name></expr>:</case> <return>return <expr><name>Prec_Postfix</name></expr>;</return>
<case>case <expr><name>COP_ArrayAdd</name></expr>:</case> <return>return <expr><name>Prec_Postfix</name></expr>;</return>

<case>case <expr><name>COP_UnaryOp</name></expr>:</case> <return>return <expr><name>Prec_Unary</name></expr>;</return>
<case>case <expr><name>COP_BinaryOp</name></expr>:</case> <return>return <expr><name>Prec_Binary</name></expr>;</return>
<case>case <expr><name>COP_Cast</name></expr>:</case> <return>return <expr><name>Prec_Atom</name></expr>;</return>

<case>case <expr><name>COP_SCFG</name></expr>:</case> <return>return <expr><name>Prec_Decl</name></expr>;</return>
<case>case <expr><name>COP_BasicBlock</name></expr>:</case> <return>return <expr><name>Prec_MAX</name></expr>;</return>
<case>case <expr><name>COP_Phi</name></expr>:</case> <return>return <expr><name>Prec_Atom</name></expr>;</return>
<case>case <expr><name>COP_Goto</name></expr>:</case> <return>return <expr><name>Prec_Atom</name></expr>;</return>
<case>case <expr><name>COP_Branch</name></expr>:</case> <return>return <expr><name>Prec_Atom</name></expr>;</return>
<case>case <expr><name>COP_Return</name></expr>:</case> <return>return <expr><name>Prec_Other</name></expr>;</return>

<case>case <expr><name>COP_Identifier</name></expr>:</case> <return>return <expr><name>Prec_Atom</name></expr>;</return>
<case>case <expr><name>COP_IfThenElse</name></expr>:</case> <return>return <expr><name>Prec_Other</name></expr>;</return>
<case>case <expr><name>COP_Let</name></expr>:</case> <return>return <expr><name>Prec_Decl</name></expr>;</return>
</block_content>}</block></switch>
<return>return <expr><name>Prec_MAX</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printBlockLabel</name><parameter_list>(<parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type> <name>SS</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BasicBlock</name> <modifier>*</modifier></type><name>BB</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>index</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>BB</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"BB_null"</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"BB_"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <call><name><name>BB</name><operator>-&gt;</operator><name>blockID</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">":"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <name>index</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printSExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>P</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Sub</name><init>=<expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>E</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printNull</name><argument_list>(<argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>Sub</name> <operator>&amp;&amp;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>block</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>COP_Variable</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"_x"</literal> <operator>&lt;&lt;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>id</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>precedence</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>P</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"("</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">")"</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIL_OPCODE_DEF</name><parameter_list>(<parameter><type><name>X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case COP_##X: self()-&gt;print##X(cast&lt;X&gt;(E), SS); return;</cpp:value></cpp:define>



<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ThreadSafetyOps.def"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>TIL_OPCODE_DEF</name></cpp:undef>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printNull</name><parameter_list>(<parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"#null"</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printFuture</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Future</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>maybeGetResult</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printUndefined</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Undefined</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"#undefined"</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printWildcard</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Wildcard</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"*"</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>printLiteralT</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>LiteralT</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>value</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printLiteralT</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>LiteralT</name><argument_list type="generic">&lt;<argument><expr><name>uint8_t</name></expr></argument>&gt;</argument_list></name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"'"</literal> <operator>&lt;&lt;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>value</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">"'"</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printLiteral</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Literal</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>clangExpr</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <call><name>getSourceLiteralString</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>clangExpr</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>ValueType</name></type> <name>VT</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>valueType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>VT</name><operator>.</operator><name>Base</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ValueType</name><operator>::</operator><name>BT_Void</name></expr>:</case>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"void"</literal></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><name>ValueType</name><operator>::</operator><name>BT_Bool</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>E</name><operator>-&gt;</operator><name>as</name></name><operator>&lt;</operator><name>bool</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>.</operator><call><name>value</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"true"</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"false"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return;</return>
<case>case <expr><name>ValueType</name><operator>::</operator><name>BT_Int</name></expr>:</case>
<switch>switch <condition>(<expr><name><name>VT</name><operator>.</operator><name>Size</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ValueType</name><operator>::</operator><name>ST_8</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>VT</name><operator>.</operator><name>Signed</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printLiteralT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>E</name><operator>-&gt;</operator><name>as</name></name><operator>&lt;</operator><name>int8_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printLiteralT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>E</name><operator>-&gt;</operator><name>as</name></name><operator>&lt;</operator><name>uint8_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return;</return>
<case>case <expr><name>ValueType</name><operator>::</operator><name>ST_16</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>VT</name><operator>.</operator><name>Signed</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printLiteralT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>E</name><operator>-&gt;</operator><name>as</name></name><operator>&lt;</operator><name>int16_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printLiteralT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>E</name><operator>-&gt;</operator><name>as</name></name><operator>&lt;</operator><name>uint16_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return;</return>
<case>case <expr><name>ValueType</name><operator>::</operator><name>ST_32</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>VT</name><operator>.</operator><name>Signed</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printLiteralT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>E</name><operator>-&gt;</operator><name>as</name></name><operator>&lt;</operator><name>int32_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printLiteralT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>E</name><operator>-&gt;</operator><name>as</name></name><operator>&lt;</operator><name>uint32_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return;</return>
<case>case <expr><name>ValueType</name><operator>::</operator><name>ST_64</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>VT</name><operator>.</operator><name>Signed</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printLiteralT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>E</name><operator>-&gt;</operator><name>as</name></name><operator>&lt;</operator><name>int64_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printLiteralT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>E</name><operator>-&gt;</operator><name>as</name></name><operator>&lt;</operator><name>uint64_t</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<return>return;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><name>ValueType</name><operator>::</operator><name>BT_Float</name></expr>:</case>
<switch>switch <condition>(<expr><name><name>VT</name><operator>.</operator><name>Size</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>ValueType</name><operator>::</operator><name>ST_32</name></expr>:</case>
<expr_stmt><expr><call><name>printLiteralT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>E</name><operator>-&gt;</operator><name>as</name></name><operator>&lt;</operator><name>float</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><name>ValueType</name><operator>::</operator><name>ST_64</name></expr>:</case>
<expr_stmt><expr><call><name>printLiteralT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>E</name><operator>-&gt;</operator><name>as</name></name><operator>&lt;</operator><name>double</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>
<break>break;</break>
<case>case <expr><name>ValueType</name><operator>::</operator><name>BT_String</name></expr>:</case>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"\""</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printLiteralT</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>E</name><operator>-&gt;</operator><name>as</name></name><operator>&lt;</operator><name>StringRef</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"\""</literal></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><name>ValueType</name><operator>::</operator><name>BT_Pointer</name></expr>:</case>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"#ptr"</literal></expr>;</expr_stmt>
<return>return;</return>
<case>case <expr><name>ValueType</name><operator>::</operator><name>BT_ValueRef</name></expr>:</case>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"#vref"</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></switch>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"#lit"</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printLiteralPtr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LiteralPtr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>clangDecl</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getNameAsString</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Variable</name> <modifier>*</modifier></type><name>V</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsVarDecl</name><init>=<expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>CStyle</name> <operator>&amp;&amp;</operator> <call><name><name>V</name><operator>-&gt;</operator><name>kind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Variable</name><operator>::</operator><name>VK_SFun</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"this"</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <call><name><name>V</name><operator>-&gt;</operator><name>name</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <call><name><name>V</name><operator>-&gt;</operator><name>id</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Function</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>sugared</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>sugared</name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"\\("</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">1</literal></expr>:</case>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"("</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><literal type="number">2</literal></expr>:</case>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printVariable</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>variableDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">": "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>variableDecl</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>definition</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>SExpr</name> <modifier>*</modifier></type><name>B</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>body</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>B</name> <operator>&amp;&amp;</operator> <call><name><name>B</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Function</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printFunction</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Function</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">")"</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printSFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SFunction</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"@"</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printVariable</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>variableDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>body</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printCode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Code</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">": "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>returnType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Decl</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">" -&gt; "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>body</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printField</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Field</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">": "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>range</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Decl</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">" = "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>body</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Decl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printApply</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Apply</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sugared</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>SExpr</name> <modifier>*</modifier></type><name>F</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>fun</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>F</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Apply</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printApply</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Apply</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Postfix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"("</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>arg</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sugared</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">")$"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printSApply</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SApply</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>sfun</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Postfix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>isDelegation</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"@("</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>arg</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">")"</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printProject</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Project</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>CStyle</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>SAP</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>SApply</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>record</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>V</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>Variable</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>SAP</name><operator>-&gt;</operator><name>sfun</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>SAP</name><operator>-&gt;</operator><name>isDelegation</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>V</name><operator>-&gt;</operator><name>kind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Variable</name><operator>::</operator><name>VK_SFun</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>slotName</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>Wildcard</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>record</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"&amp;"</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>clangDecl</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getQualifiedNameAsString</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>record</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Postfix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>CStyle</name> <operator>&amp;&amp;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>isArrow</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"-&gt;"</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"."</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>slotName</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Call</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>SExpr</name> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>target</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>T</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Apply</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printApply</name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Apply</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">")"</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Postfix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"()"</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printAlloc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Alloc</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"new "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>dataType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Other</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printLoad</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Load</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>pointer</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Postfix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CStyle</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"^"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printStore</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Store</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>destination</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Other</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">" := "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>source</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Other</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printArrayIndex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArrayIndex</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>array</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Postfix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"["</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>index</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"]"</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printArrayAdd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArrayAdd</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>array</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Postfix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">" + "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>index</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Atom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printUnaryOp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnaryOp</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <call><name>getUnaryOpcodeString</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>unaryOpcode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>expr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Unary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printBinaryOp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BinaryOp</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>expr0</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Binary</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">" "</literal> <operator>&lt;&lt;</operator> <call><name>getBinaryOpcodeString</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>binaryOpcode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>expr1</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Binary</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printCast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Cast</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CStyle</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"cast["</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>castOpcode</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CAST_none</name></expr>:</case>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"none"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CAST_extendNum</name></expr>:</case>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"extendNum"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CAST_truncNum</name></expr>:</case>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"truncNum"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CAST_toFloat</name></expr>:</case>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"toFloat"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CAST_toInt</name></expr>:</case>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"toInt"</literal></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CAST_objToPtr</name></expr>:</case>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"objToPtr"</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"]("</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>expr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Unary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">")"</literal></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>expr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Unary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printSCFG</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SCFG</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"CFG {\n"</literal></expr>;</expr_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>BBI</name> <range>: <expr><operator>*</operator><name>E</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printBasicBlock</name><argument_list>(<argument><expr><name>BBI</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"}"</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>newline</name><argument_list>(<argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printBBInstr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>Sub</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>COP_Variable</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>V</name> <init>= <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Variable</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"let "</literal> <operator>&lt;&lt;</operator> <call><name><name>V</name><operator>-&gt;</operator><name>name</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <call><name><name>V</name><operator>-&gt;</operator><name>id</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">" = "</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>E</name> <operator>=</operator> <call><name><name>V</name><operator>-&gt;</operator><name>definition</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Sub</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>opcode</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>COP_Store</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"let _x"</literal> <operator>&lt;&lt;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>id</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">" = "</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_MAX</name></expr></argument>, <argument><expr><name>Sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">";"</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>newline</name><argument_list>(<argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printBasicBlock</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BasicBlock</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"BB_"</literal> <operator>&lt;&lt;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>blockID</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <literal type="string">":"</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>parent</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">" BB_"</literal> <operator>&lt;&lt;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>parent</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>blockID</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>newline</name><argument_list>(<argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>A</name> <range>: <expr><call><name><name>E</name><operator>-&gt;</operator><name>arguments</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printBBInstr</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>I</name> <range>: <expr><call><name><name>E</name><operator>-&gt;</operator><name>instructions</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>printBBInstr</name><argument_list>(<argument><expr><name>I</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<decl_stmt><decl><type><specifier>const</specifier> <name>SExpr</name> <modifier>*</modifier></type><name>T</name> <init>= <expr><call><name><name>E</name><operator>-&gt;</operator><name>terminator</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>T</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_MAX</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">";"</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>newline</name><argument_list>(<argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>newline</name><argument_list>(<argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printPhi</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Phi</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"phi("</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>E</name><operator>-&gt;</operator><name>status</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>Phi</name><operator>::</operator><name>PH_SingleVal</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>values</name></name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>V</name> <range>: <expr><call><name><name>E</name><operator>-&gt;</operator><name>values</name></name><argument_list>()</argument_list></call></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">", "</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><name>V</name></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">")"</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printGoto</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Goto</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"goto "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printBlockLabel</name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>targetBlock</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>index</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printBranch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Branch</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"branch ("</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>condition</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">") "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printBlockLabel</name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>thenBlock</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printBlockLabel</name><argument_list>(<argument><expr><name>SS</name></expr></argument>, <argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>elseBlock</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printReturn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Return</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"return "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>self</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>returnValue</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printIdentifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Identifier</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <call><name><name>E</name><operator>-&gt;</operator><name>name</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printIfThenElse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IfThenElse</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>CStyle</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>condition</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Unary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">" ? "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>thenExpr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Unary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">" : "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>elseExpr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Unary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"if ("</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>condition</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">") then "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>thenExpr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">" else "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>elseExpr</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Other</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>printLet</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Let</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>StreamType</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"let "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printVariable</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>variableDecl</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">" = "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>variableDecl</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>definition</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Decl</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SS</name> <operator>&lt;&lt;</operator> <literal type="string">"; "</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printSExpr</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>body</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SS</name></expr></argument>, <argument><expr><name>Prec_Decl</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>StdPrinter</name> <range>: <expr><name>public</name> <name><name>PrettyPrinter</name><argument_list type="generic">&lt;<argument><expr><name>StdPrinter</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>ostream</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr></range></decl>;</decl_stmt>

}
}
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
