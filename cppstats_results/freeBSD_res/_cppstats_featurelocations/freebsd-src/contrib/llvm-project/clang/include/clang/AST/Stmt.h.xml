<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/Stmt.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_STMT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_STMT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclGroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DependenceFlags.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtIterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/CapturedStmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/BitmaskEnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/ErrorHandling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;algorithm&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>FoldingSetNodeID</name></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Attr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CapturedDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>AddrLabelExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LabelDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ODRHash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PrinterHelper</name></decl>;</decl_stmt>
<struct_decl>struct <name>PrintingPolicy</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>RecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SourceManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StringLiteral</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Token</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarDecl</name></decl>;</decl_stmt>







<function><type><name>class</name></type> <name>alignas</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> Stmt <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>StmtClass</name> <block>{
<decl><name>NoStmtClass</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STMT</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>PARENT</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CLASS##Class,</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STMT_RANGE</name><parameter_list>(<parameter><type><name>BASE</name></type></parameter>, <parameter><type><name>FIRST</name></type></parameter>, <parameter><type><name>LAST</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class,</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAST_STMT_RANGE</name><parameter_list>(<parameter><type><name>BASE</name></type></parameter>, <parameter><type><name>FIRST</name></type></parameter>, <parameter><type><name>LAST</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>first##BASE##Constant=FIRST##Class, last##BASE##Constant=LAST##Class</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_STMT</name><parameter_list>(<parameter><type><name>STMT</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtNodes.inc"</cpp:file></cpp:include>
}</block>;</enum>


<label><name>protected</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtWriter</name></decl>;</decl_stmt>

<function><type><name>void</name> <modifier>*</modifier><name>operator</name></type> <name>new</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>)</parameter_list> noexcept <block>{<block_content>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Stmts cannot be allocated with regular 'new'."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name> <name>operator</name></type> <name>delete</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> noexcept <block>{<block_content>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Stmts cannot be released with regular 'delete'."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<decl_stmt><decl><type><name>class</name></type> <name>StmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>sClass</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <block>{ <decl><name>NumStmtBits</name> <init>= <expr><literal type="number">8</literal></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>NullStmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>NullStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>






<decl_stmt><decl><type><name>unsigned</name></type> <name>HasLeadingEmptyMacro</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>SemiLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CompoundStmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CompoundStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>NumStmts</name> <range>: <expr><literal type="number">32</literal> <operator>-</operator> <name>NumStmtBits</name></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>LBraceLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>LabelStmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LabelStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>IdentLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>AttributedStmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>AttributedStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumAttrs</name> <range>: <expr><literal type="number">32</literal> <operator>-</operator> <name>NumStmtBits</name></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>AttrLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>IfStmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>IfStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsConstexpr</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HasElse</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HasVar</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HasInit</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>IfLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>SwitchStmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>SwitchStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HasInit</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HasVar</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>AllEnumCasesCovered</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>SwitchLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>WhileStmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>WhileStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HasVar</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>WhileLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>DoStmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DoStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>DoLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ForStmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ForStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ForLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>GotoStmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>GotoStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>IndirectGotoStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>GotoLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ContinueStmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ContinueStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ContinueLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>BreakStmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>BreakStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>BreakLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ReturnStmtBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ReturnStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HasNRVOCandidate</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>RetLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>SwitchCaseBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>SwitchCase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CaseStmt</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>CaseStmtIsGNURange</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>KeywordLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>ExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>AtomicExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>BlockDeclRefExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CallExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXConstructExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXDependentScopeMemberExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXNewExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXUnresolvedConstructExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DeclRefExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DependentScopeDeclRefExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DesignatedInitExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>InitListExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ObjCArrayLiteral</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ObjCDictionaryLiteral</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ObjCMessageExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>OffsetOfExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>OpaqueValueExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>OverloadExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ParenListExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>PseudoObjectExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ShuffleVectorExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumStmtBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>ValueKind</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ObjectKind</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Dependent</name> <range>: <expr><name>llvm</name><operator>::</operator><name><name>BitWidth</name><argument_list type="generic">&lt;<argument><expr><name>ExprDependence</name></expr></argument>&gt;</argument_list></name></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <block>{ <decl><name>NumExprBits</name> <init>= <expr><name>NumStmtBits</name> <operator>+</operator> <literal type="number">5</literal> <operator>+</operator> <name>llvm</name><operator>::</operator><name><name>BitWidth</name><argument_list type="generic">&lt;<argument><expr><name>ExprDependence</name></expr></argument>&gt;</argument_list></name></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>ConstantExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ConstantExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ResultKind</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>APValueKind</name> <range>: <expr><literal type="number">4</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>IsUnsigned</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>BitWidth</name> <range>: <expr><literal type="number">7</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>HasCleanup</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsImmediateInvocation</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>PredefinedExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>PredefinedExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>Kind</name> <range>: <expr><literal type="number">4</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>HasFunctionName</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>DeclRefExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DeclRefExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>HasQualifier</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>HasTemplateKWAndArgsInfo</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>HasFoundDecl</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>HadMultipleCandidates</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>RefersToEnclosingVariableOrCapture</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NonOdrUseReason</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>FloatingLiteralBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>FloatingLiteral</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Semantics</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>IsExact</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>StringLiteralBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>StringLiteral</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>Kind</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>CharByteWidth</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>IsPascal</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumConcatenated</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CharacterLiteralBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CharacterLiteral</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Kind</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>UnaryOperatorBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>UnaryOperator</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Opc</name> <range>: <expr><literal type="number">5</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>CanOverflow</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>HasFPFeatures</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>UnaryExprOrTypeTraitExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>UnaryExprOrTypeTraitExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Kind</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>IsType</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ArrayOrMatrixSubscriptExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ArraySubscriptExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>MatrixSubscriptExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>RBracketLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CallExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CallExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>NumPreArgs</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>UsesADL</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HasFPFeatures</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<label><name>unsigned</name> :</label> <expr_stmt><expr><literal type="number">24</literal> <operator>-</operator> <literal type="number">3</literal> <operator>-</operator> <name>NumExprBits</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>OffsetToTrailingObjects</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <block>{ <decl><name>NumCallExprBits</name> <init>= <expr><literal type="number">32</literal></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>MemberExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>MemberExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsArrow</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>unsigned</name></type> <name>HasQualifierOrFoundDecl</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>






<decl_stmt><decl><type><name>unsigned</name></type> <name>HasTemplateKWAndArgsInfo</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>HadMultipleCandidates</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>NonOdrUseReason</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>OperatorLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CastExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CastExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ImplicitCastExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Kind</name> <range>: <expr><literal type="number">7</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>PartOfExplicitCast</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HasFPFeatures</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>BasePathSize</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>BinaryOperatorBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>BinaryOperator</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Opc</name> <range>: <expr><literal type="number">6</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>HasFPFeatures</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>InitListExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>InitListExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>HadArrayRangeDesignator</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ParenListExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ParenListExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumExprs</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>GenericSelectionExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>GenericSelectionExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>GenericLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>PseudoObjectExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>PseudoObjectExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumSubExprs</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ResultIndex</name> <range>: <expr><literal type="number">32</literal> <operator>-</operator> <literal type="number">8</literal> <operator>-</operator> <name>NumExprBits</name></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>SourceLocExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>SourceLocExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>Kind</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>StmtExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>StmtExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>TemplateDepth</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>CXXOperatorCallExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXOperatorCallExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumCallExprBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>OperatorKind</name> <range>: <expr><literal type="number">6</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXRewrittenBinaryOperatorBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXRewrittenBinaryOperator</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumCallExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>IsReversed</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXBoolLiteralExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXBoolLiteralExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>Value</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXNullPtrLiteralExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXNullPtrLiteralExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXThisExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXThisExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsImplicit</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXThrowExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXThrowExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsThrownVariableInScope</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ThrowLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXDefaultArgExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXDefaultArgExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXDefaultInitExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXDefaultInitExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXScalarValueInitExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXScalarValueInitExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXNewExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXNewExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsGlobalNew</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>IsArray</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ShouldPassAlignment</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>UsualArrayDeleteWantsSize</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>StoredInitializationStyle</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsParenTypeId</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumPlacementArgs</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXDeleteExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXDeleteExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>GlobalDelete</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ArrayForm</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>ArrayFormAsWritten</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>UsualArrayDeleteWantsSize</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>TypeTraitExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>TypeTraitExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>Kind</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>Value</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>NumArgs</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>DependentScopeDeclRefExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>DependentScopeDeclRefExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>HasTemplateKWAndArgsInfo</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXConstructExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXConstructExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Elidable</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>HadMultipleCandidates</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ListInitialization</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>StdInitListInitialization</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ZeroInitialization</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ConstructionKind</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ExprWithCleanupsBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ExprWithCleanups</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>CleanupsHaveSideEffects</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>NumObjects</name> <range>: <expr><literal type="number">32</literal> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>NumExprBits</name></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXUnresolvedConstructExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXUnresolvedConstructExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumArgs</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXDependentScopeMemberExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXDependentScopeMemberExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>IsArrow</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>HasTemplateKWAndArgsInfo</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>HasFirstQualifierFoundInScope</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>OperatorLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>OverloadExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>OverloadExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>HasTemplateKWAndArgsInfo</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<label><name>unsigned</name> :</label> <expr_stmt><expr><literal type="number">32</literal> <operator>-</operator> <name>NumExprBits</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumResults</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <block>{ <decl><name>NumOverloadExprBits</name> <init>= <expr><name>NumExprBits</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>UnresolvedLookupExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>UnresolvedLookupExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumOverloadExprBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>RequiresADL</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>Overloaded</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UnresolvedLookupExprBitfields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">4</literal></expr></argument>,
<argument><expr><literal type="string">"UnresolvedLookupExprBitfields must be &lt;= than 4 bytes to"</literal>
<literal type="string">"avoid trashing OverloadExprBitfields::NumResults!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>UnresolvedMemberExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>UnresolvedMemberExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumOverloadExprBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>IsArrow</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HasUnresolvedUsing</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>UnresolvedMemberExprBitfields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">4</literal></expr></argument>,
<argument><expr><literal type="string">"UnresolvedMemberExprBitfields must be &lt;= than 4 bytes to"</literal>
<literal type="string">"avoid trashing OverloadExprBitfields::NumResults!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CXXNoexceptExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CXXNoexceptExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Value</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>SubstNonTypeTemplateParmExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>SubstNonTypeTemplateParmExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>LambdaExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>LambdaExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>CaptureDefault</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>ExplicitParams</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ExplicitResultType</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumCaptures</name> <range>: <expr><literal type="number">16</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>RequiresExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>RequiresExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>IsSatisfied</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>RequiresKWLoc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>CoawaitExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CoawaitExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>IsImplicit</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>ObjCIndirectCopyRestoreExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ObjCIndirectCopyRestoreExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>ShouldCopy</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>OpaqueValueExprBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTStmtReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>OpaqueValueExpr</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumExprBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>IsUnique</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<union>union <block>{


<decl_stmt><decl><type><name>StmtBitfields</name></type> <name>StmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NullStmtBitfields</name></type> <name>NullStmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CompoundStmtBitfields</name></type> <name>CompoundStmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LabelStmtBitfields</name></type> <name>LabelStmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AttributedStmtBitfields</name></type> <name>AttributedStmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IfStmtBitfields</name></type> <name>IfStmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SwitchStmtBitfields</name></type> <name>SwitchStmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>WhileStmtBitfields</name></type> <name>WhileStmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DoStmtBitfields</name></type> <name>DoStmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ForStmtBitfields</name></type> <name>ForStmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GotoStmtBitfields</name></type> <name>GotoStmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ContinueStmtBitfields</name></type> <name>ContinueStmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BreakStmtBitfields</name></type> <name>BreakStmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ReturnStmtBitfields</name></type> <name>ReturnStmtBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SwitchCaseBitfields</name></type> <name>SwitchCaseBits</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ExprBitfields</name></type> <name>ExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ConstantExprBitfields</name></type> <name>ConstantExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PredefinedExprBitfields</name></type> <name>PredefinedExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclRefExprBitfields</name></type> <name>DeclRefExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FloatingLiteralBitfields</name></type> <name>FloatingLiteralBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StringLiteralBitfields</name></type> <name>StringLiteralBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharacterLiteralBitfields</name></type> <name>CharacterLiteralBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UnaryOperatorBitfields</name></type> <name>UnaryOperatorBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UnaryExprOrTypeTraitExprBitfields</name></type> <name>UnaryExprOrTypeTraitExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ArrayOrMatrixSubscriptExprBitfields</name></type> <name>ArrayOrMatrixSubscriptExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CallExprBitfields</name></type> <name>CallExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemberExprBitfields</name></type> <name>MemberExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CastExprBitfields</name></type> <name>CastExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BinaryOperatorBitfields</name></type> <name>BinaryOperatorBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>InitListExprBitfields</name></type> <name>InitListExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParenListExprBitfields</name></type> <name>ParenListExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GenericSelectionExprBitfields</name></type> <name>GenericSelectionExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PseudoObjectExprBitfields</name></type> <name>PseudoObjectExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocExprBitfields</name></type> <name>SourceLocExprBits</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>StmtExprBitfields</name></type> <name>StmtExprBits</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CXXOperatorCallExprBitfields</name></type> <name>CXXOperatorCallExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXRewrittenBinaryOperatorBitfields</name></type> <name>CXXRewrittenBinaryOperatorBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXBoolLiteralExprBitfields</name></type> <name>CXXBoolLiteralExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXNullPtrLiteralExprBitfields</name></type> <name>CXXNullPtrLiteralExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXThisExprBitfields</name></type> <name>CXXThisExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXThrowExprBitfields</name></type> <name>CXXThrowExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXDefaultArgExprBitfields</name></type> <name>CXXDefaultArgExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXDefaultInitExprBitfields</name></type> <name>CXXDefaultInitExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXScalarValueInitExprBitfields</name></type> <name>CXXScalarValueInitExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXNewExprBitfields</name></type> <name>CXXNewExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXDeleteExprBitfields</name></type> <name>CXXDeleteExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TypeTraitExprBitfields</name></type> <name>TypeTraitExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DependentScopeDeclRefExprBitfields</name></type> <name>DependentScopeDeclRefExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXConstructExprBitfields</name></type> <name>CXXConstructExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprWithCleanupsBitfields</name></type> <name>ExprWithCleanupsBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXUnresolvedConstructExprBitfields</name></type> <name>CXXUnresolvedConstructExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXDependentScopeMemberExprBitfields</name></type> <name>CXXDependentScopeMemberExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OverloadExprBitfields</name></type> <name>OverloadExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UnresolvedLookupExprBitfields</name></type> <name>UnresolvedLookupExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UnresolvedMemberExprBitfields</name></type> <name>UnresolvedMemberExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXNoexceptExprBitfields</name></type> <name>CXXNoexceptExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SubstNonTypeTemplateParmExprBitfields</name></type> <name>SubstNonTypeTemplateParmExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LambdaExprBitfields</name></type> <name>LambdaExprBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RequiresExprBitfields</name></type> <name>RequiresExprBits</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CoawaitExprBitfields</name></type> <name>CoawaitBits</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ObjCIndirectCopyRestoreExprBitfields</name></type> <name>ObjCIndirectCopyRestoreExprBits</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>OpaqueValueExprBitfields</name></type> <name>OpaqueValueExprBits</name></decl>;</decl_stmt>
}</block>;</union>

<label><name>public</name>:</label>


<decl_stmt><decl><type><name>void</name><modifier>*</modifier> <name>operator</name></type> <name>new</name><argument_list>(<argument><expr><name>size_t</name> <name>bytes</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name><operator>&amp;</operator> <name>C</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>alignment</name> <operator>=</operator> <literal type="number">8</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><name>void</name><modifier>*</modifier> <name>operator</name></type> <name>new</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ASTContext</name><modifier>*</modifier></type> <name>C</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>alignment</name> <init>= <expr><literal type="number">8</literal></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>operator</name> <call><name>new</name><argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><operator>*</operator><name>C</name></expr></argument>, <argument><expr><name>alignment</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier><name>operator</name></type> <name>new</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>bytes</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>mem</name></decl></parameter>)</parameter_list> noexcept <block>{<block_content> <return>return <expr><name>mem</name></expr>;</return> </block_content>}</block></function>

<function><type><name>void</name> <name>operator</name></type> <name>delete</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name></type></decl></parameter>)</parameter_list> noexcept <block>{<block_content/>}</block></function>
<function><type><name>void</name> <name>operator</name></type> <name>delete</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>unsigned</name></type></decl></parameter>)</parameter_list> noexcept <block>{<block_content/>}</block></function>
<function><type><name>void</name> <name>operator</name></type> <name>delete</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list> noexcept <block>{<block_content/>}</block></function>
<function><type><name>void</name> <name>operator</name></type> <name>delete</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> noexcept <block>{<block_content/>}</block></function>

<label><name>public</name>:</label>



<struct>struct <name>EmptyShell</name> <block>{}</block>;</struct>


<enum>enum <name>Likelihood</name> <block>{
<decl><name>LH_Unlikely</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
<decl><name>LH_None</name></decl>,

<decl><name>LH_Likely</name></decl>
}</block>;</enum>

<label><name>protected</name>:</label>




<decl_stmt><decl><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <name>TPtr</name> <operator>=</operator> <name>T</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>typename</name> <name>StmtPtr</name> <operator>=</operator> <name>Stmt</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name>
struct</type> <name>CastIterator</name>
<range>: <expr><name>llvm</name><operator>::</operator><name><name>iterator_adaptor_base</name><argument_list type="generic">&lt;<argument><expr><name><name>CastIterator</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><name>TPtr</name></expr></argument>, <argument><expr><name>StmtPtr</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>StmtPtr</name> <operator>*</operator></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name>random_access_iterator_tag</name></expr></argument>, <argument><expr><name>TPtr</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>Base</name> <operator>=</operator> <name>typename</name> <name>CastIterator</name><operator>::</operator><name>iterator_adaptor_base</name></expr>;

<expr><call><name>CastIterator</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Base</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <block>{}</block>
<call><name>CastIterator</name><argument_list>(<argument><expr><name>StmtPtr</name> <operator>*</operator><name>I</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Base</name><argument_list>(<argument>I</argument>)</argument_list></macro> <block>{}</block>

<name>typename</name> <name>Base</name><operator>::</operator><name>value_type</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>using</name> <name>ConstCastIterator</name> <operator>=</operator> <name><name>CastIterator</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>T</name> <operator>*</operator><specifier>const</specifier></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><specifier>const</specifier></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>using</name> <name>ExprIterator</name> <operator>=</operator> <name><name>CastIterator</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>ConstExprIterator</name> <operator>=</operator> <name><name>ConstCastIterator</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>private</name><operator>:</operator>

<specifier>static</specifier> <name>bool</name> <name>StatisticsEnabled</name></expr>;

<expr><name>protected</name><operator>:</operator>

<name>explicit</name> <macro><name>Stmt</name><argument_list>(<argument>StmtClass SC</argument>, <argument>EmptyShell</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>SC</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<call><name>Stmt</name><argument_list>()</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><call><name>Stmt</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><call><name>Stmt</name><argument_list>(<argument><expr><name>Stmt</name> <operator>&amp;&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;
<expr><name>Stmt</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><specifier>const</specifier> <name>Stmt</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;
<expr><name>Stmt</name> <operator>&amp;</operator><name>operator</name><operator>=</operator><operator>(</operator><name>Stmt</name> <operator>&amp;&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr>;

<macro><name>Stmt</name><argument_list>(<argument>StmtClass SC</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <literal type="number">8</literal></expr></argument>,
<argument><expr><literal type="string">"changing bitfields changed sizeof(Stmt)"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>this</name></expr></argument>)</argument_list></sizeof> <operator>%</operator> <call><name>alignof</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><literal type="string">"Insufficient alignment!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>StmtBits</name><operator>.</operator><name>sClass</name></name> <operator>=</operator> <name>SC</name></expr>;
<if_stmt><if>if <condition>(<expr><name>StatisticsEnabled</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>Stmt</name><operator>::</operator><call><name>addStmtClass</name><argument_list>(<argument><expr><name>SC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>StmtClass</name> <macro><name>getStmtClass</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>StmtClass</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>StmtBits</name><operator>.</operator><name>sClass</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getStmtClassName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;
<expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;


<expr><specifier>static</specifier> <name>void</name> <macro><name>addStmtClass</name><argument_list>(<argument>const StmtClass s</argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>void</name> <call><name>EnableStatistics</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>void</name> <call><name>PrintStats</name><argument_list>()</argument_list></call></expr>;


<expr><specifier>static</specifier> <name>Likelihood</name> <call><name>getLikelihood</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Attrs</name></expr></argument>)</argument_list></call></expr>;


<expr><specifier>static</specifier> <name>Likelihood</name> <call><name>getLikelihood</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>)</argument_list></call></expr>;


<expr><specifier>static</specifier> <specifier>const</specifier> <name>Attr</name> <operator>*</operator><call><name>getLikelihoodAttr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>)</argument_list></call></expr>;




<expr><specifier>static</specifier> <name>Likelihood</name> <call><name>getLikelihood</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>Then</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>Else</name></expr></argument>)</argument_list></call></expr>;




<expr><specifier>static</specifier> <name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<call><name>determineLikelihoodConflict</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>Then</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><name>Else</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>dump</name><argument_list>(<argument>raw_ostream &amp;OS</argument>, <argument>const ASTContext &amp;Context</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>int64_t</name> <macro><name>getID</name><argument_list>(<argument>const ASTContext &amp;Context</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>void</name> <macro><name>dumpColor</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>void</name> <macro><name>dumpPretty</name><argument_list>(<argument>const ASTContext &amp;Context</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <macro><name>printPretty</name><argument_list>(<argument>raw_ostream &amp;OS</argument>, <argument>PrinterHelper *Helper</argument>,
<argument>const PrintingPolicy &amp;Policy</argument>, <argument>unsigned Indentation = <literal type="number">0</literal></argument>,
<argument>StringRef NewlineSymbol = <literal type="string">"\n"</literal></argument>,
<argument>const ASTContext *Context = nullptr</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>void</name> <macro><name>printJson</name><argument_list>(<argument>raw_ostream &amp;Out</argument>, <argument>PrinterHelper *Helper</argument>,
<argument>const PrintingPolicy &amp;Policy</argument>, <argument>bool AddQuotes</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>void</name> <macro><name>viewAST</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>Stmt</name> <operator>*</operator><macro><name>IgnoreContainers</name><argument_list>(<argument>bool IgnoreCaptured = false</argument>)</argument_list></macro></expr>;
<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>IgnoreContainers</name><argument_list>(<argument>bool IgnoreCaptured = false</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>IgnoreContainers</name><argument_list>(<argument><expr><name>IgnoreCaptured</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>stripLabelLikeStatements</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>Stmt</name> <operator>*</operator><macro><name>stripLabelLikeStatements</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Stmt</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>stripLabelLikeStatements</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>using</name> <name>child_iterator</name> <operator>=</operator> <name>StmtIterator</name></expr>;
<expr><name>using</name> <name>const_child_iterator</name> <operator>=</operator> <name>ConstStmtIterator</name></expr>;

<expr><name>using</name> <name>child_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>child_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>const_child_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_child_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>child_range</name> <call><name>children</name><argument_list>()</argument_list></call></expr>;

<expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>children</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>child_iterator</name> <macro><name>child_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>children</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>const_child_iterator</name> <macro><name>child_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>children</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_child_iterator</name> <macro><name>child_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>children</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return> }</block>













<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>const ASTContext &amp;Context</argument>,
<argument>bool Canonical</argument>)</argument_list></macro> <specifier>const</specifier></expr>;








<expr><name>void</name> <macro><name>ProcessODRHash</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>, <argument>ODRHash&amp; Hash</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>DeclStmt</name> <range>: <expr><name>public</name> <name>Stmt</name> <block>{
<expr><name>DeclGroupRef</name> <name>DG</name></expr>;
<expr><name>SourceLocation</name> <name>StartLoc</name></expr>, <expr><name>EndLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>DeclStmt</name><argument_list>(<argument>DeclGroupRef dg</argument>, <argument>SourceLocation startLoc</argument>, <argument>SourceLocation endLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Stmt</name><argument_list>(<argument><expr><name>DeclStmtClass</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>DG</name><argument_list>(<argument><expr><name>dg</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>StartLoc</name><argument_list>(<argument><expr><name>startLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>EndLoc</name><argument_list>(<argument>endLoc</argument>)</argument_list></macro> <expr><block>{}</block>


<name>explicit</name> <macro><name>DeclStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>DeclStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>



<name>bool</name> <macro><name>isSingleDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>DG</name><operator>.</operator><name>isSingleDecl</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getSingleDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>DG</name><operator>.</operator><name>getSingleDecl</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>Decl</name> <operator>*</operator><macro><name>getSingleDecl</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>DG</name><operator>.</operator><name>getSingleDecl</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>DeclGroupRef</name> <macro><name>getDeclGroup</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DG</name></expr>;</return> }</block>
<name>DeclGroupRef</name> <macro><name>getDeclGroup</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>DG</name></expr>;</return> }</block>
<name>void</name> <macro><name>setDeclGroup</name><argument_list>(<argument>DeclGroupRef DGR</argument>)</argument_list></macro> <block>{ <expr><name>DG</name> <operator>=</operator> <name>DGR</name></expr>; }</block>

<name>void</name> <macro><name>setStartLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>StartLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EndLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setEndLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>EndLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>StartLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclStmtClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>(<argument><expr><call><name><name>DG</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>DG</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>child_iterator</name><argument_list>(<argument><expr><call><name><name>DG</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>DG</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>Children</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>decl_iterator</name> <operator>=</operator> <name>DeclGroupRef</name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_decl_iterator</name> <operator>=</operator> <name>DeclGroupRef</name><operator>::</operator><name>const_iterator</name></expr>;
<expr><name>using</name> <name>decl_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>decl_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>decl_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_decl_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>decl_range</name> <macro><name>decls</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>decl_range</name><argument_list>(<argument><expr><call><name>decl_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>decl_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>decl_const_range</name> <macro><name>decls</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>decl_const_range</name><argument_list>(<argument><expr><call><name>decl_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>decl_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>decl_iterator</name> <macro><name>decl_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>DG</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>decl_iterator</name> <macro><name>decl_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>DG</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_decl_iterator</name> <macro><name>decl_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>DG</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_decl_iterator</name> <macro><name>decl_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>DG</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>using</name> <name>reverse_decl_iterator</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><name>decl_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>reverse_decl_iterator</name> <macro><name>decl_rbegin</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>reverse_decl_iterator</name><argument_list>(<argument><expr><call><name>decl_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>reverse_decl_iterator</name> <macro><name>decl_rend</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>reverse_decl_iterator</name><argument_list>(<argument><expr><call><name>decl_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>NullStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>NullStmt</name><argument_list>(<argument>SourceLocation L</argument>, <argument>bool hasLeadingEmptyMacro = false</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>NullStmtClass</argument>)</argument_list></macro> <block>{
<expr><name><name>NullStmtBits</name><operator>.</operator><name>HasLeadingEmptyMacro</name></name> <operator>=</operator> <name>hasLeadingEmptyMacro</name></expr>;
<expr><call><name>setSemiLoc</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>NullStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>NullStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getSemiLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>NullStmtBits</name><operator>.</operator><name>SemiLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setSemiLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>NullStmtBits</name><operator>.</operator><name>SemiLoc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>bool</name> <macro><name>hasLeadingEmptyMacro</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>NullStmtBits</name><operator>.</operator><name>HasLeadingEmptyMacro</name></name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getSemiLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getSemiLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NullStmtClass</name></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>CompoundStmt</name> <name>final</name> <operator>:</operator> <name>public</name> <name>Stmt</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CompoundStmt</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>SourceLocation</name> <name>RBraceLoc</name></expr>;

<macro><name>CompoundStmt</name><argument_list>(<argument>ArrayRef&lt;Stmt *&gt; Stmts</argument>, <argument>SourceLocation LB</argument>, <argument>SourceLocation RB</argument>)</argument_list></macro>;
<expr><name>explicit</name> <macro><name>CompoundStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>CompoundStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>void</name> <call><name>setStmts</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Stmts</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>static</specifier> <name>CompoundStmt</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>ArrayRef&lt;Stmt *&gt; Stmts</argument>,
<argument>SourceLocation LB</argument>, <argument>SourceLocation RB</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>CompoundStmt</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Stmt</name><argument_list>(<argument><expr><name>CompoundStmtClass</name></expr></argument>)</argument_list></call></expr>, <macro><name>RBraceLoc</name><argument_list>(<argument>Loc</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CompoundStmtBits</name><operator>.</operator><name>NumStmts</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><name><name>CompoundStmtBits</name><operator>.</operator><name>LBraceLoc</name></name> <operator>=</operator> <name>Loc</name></expr>;
}</block>


<specifier>static</specifier> <name>CompoundStmt</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumStmts</argument>)</argument_list></macro></expr>;

<expr><name>bool</name> <macro><name>body_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CompoundStmtBits</name><operator>.</operator><name>NumStmts</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return> }</block>
<name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CompoundStmtBits</name><operator>.</operator><name>NumStmts</name></name></expr>;</return> }</block>

<name>using</name> <name>body_iterator</name> <operator>=</operator> <name>Stmt</name> <operator>*</operator><operator>*</operator></expr>;
<expr><name>using</name> <name>body_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>body_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>body_range</name> <macro><name>body</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>body_range</name><argument_list>(<argument><expr><call><name>body_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>body_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>body_iterator</name> <macro><name>body_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>body_iterator</name> <macro><name>body_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>body_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>size</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>Stmt</name> <operator>*</operator><macro><name>body_front</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><operator>!</operator><call><name>body_empty</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name>body_begin</name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>:</operator> <name>nullptr</name></expr>;</return> }</block>

<name>Stmt</name> <operator>*</operator><macro><name>body_back</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><ternary><condition><expr><operator>!</operator><call><name>body_empty</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>body_begin</name><argument_list>()</argument_list></call><index>[<expr><call><name>size</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></expr> </then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<name>using</name> <name>const_body_iterator</name> <operator>=</operator> <name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr>;
<expr><name>using</name> <name>body_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_body_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>body_const_range</name> <macro><name>body</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>body_const_range</name><argument_list>(<argument><expr><call><name>body_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>body_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_body_iterator</name> <macro><name>body_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>const_body_iterator</name> <macro><name>body_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>body_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>size</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>body_front</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><operator>!</operator><call><name>body_empty</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>body_begin</name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr> </then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>body_back</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><operator>!</operator><call><name>body_empty</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>body_begin</name><argument_list>()</argument_list></call><index>[<expr><call><name>size</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></expr> </then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<name>using</name> <name>reverse_body_iterator</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><name>body_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>reverse_body_iterator</name> <macro><name>body_rbegin</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>reverse_body_iterator</name><argument_list>(<argument><expr><call><name>body_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>reverse_body_iterator</name> <macro><name>body_rend</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>reverse_body_iterator</name><argument_list>(<argument><expr><call><name>body_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>const_reverse_body_iterator</name> <operator>=</operator>
<name>std</name><operator>::</operator><name><name>reverse_iterator</name><argument_list type="generic">&lt;<argument><expr><name>const_body_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>const_reverse_body_iterator</name> <macro><name>body_rbegin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_reverse_body_iterator</name><argument_list>(<argument><expr><call><name>body_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_reverse_body_iterator</name> <macro><name>body_rend</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_reverse_body_iterator</name><argument_list>(<argument><expr><call><name>body_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>









<name>Stmt</name> <operator>*</operator><macro><name>getStmtExprResult</name><argument_list>()</argument_list></macro> <block>{
<for>for <control>(<init><expr><name>auto</name> <operator>*</operator><name>B</name> <operator>:</operator> <name>llvm</name><operator>::</operator><call><name>reverse</name><argument_list>(<argument><expr><call><name>body</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>NullStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>B</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>
return body_back(</block></for>)</block></expr>;
}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getStmtExprResult</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>CompoundStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getStmtExprResult</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CompoundStmtBits</name><operator>.</operator><name>LBraceLoc</name></name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RBraceLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getLBracLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CompoundStmtBits</name><operator>.</operator><name>LBraceLoc</name></name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getRBracLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RBraceLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CompoundStmtClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>body_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>body_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>body_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>body_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>SwitchCase</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>protected</name><operator>:</operator>

<name>SourceLocation</name> <name>ColonLoc</name></expr>;






<expr><name>SwitchCase</name> <operator>*</operator><name>NextSwitchCase</name> <operator>=</operator> <name>nullptr</name></expr>;

<macro><name>SwitchCase</name><argument_list>(<argument>StmtClass SC</argument>, <argument>SourceLocation KWLoc</argument>, <argument>SourceLocation ColonLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Stmt</name><argument_list>(<argument><expr><name>SC</name></expr></argument>)</argument_list></call></expr>, <macro><name>ColonLoc</name><argument_list>(<argument>ColonLoc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setKeywordLoc</name><argument_list>(<argument><expr><name>KWLoc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<macro><name>SwitchCase</name><argument_list>(<argument>StmtClass SC</argument>, <argument>EmptyShell</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>SC</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<specifier>const</specifier> <name>SwitchCase</name> <operator>*</operator><macro><name>getNextSwitchCase</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NextSwitchCase</name></expr>;</return> }</block>
<name>SwitchCase</name> <operator>*</operator><macro><name>getNextSwitchCase</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>NextSwitchCase</name></expr>;</return> }</block>
<name>void</name> <macro><name>setNextSwitchCase</name><argument_list>(<argument>SwitchCase *SC</argument>)</argument_list></macro> <block>{ <expr><name>NextSwitchCase</name> <operator>=</operator> <name>SC</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>SwitchCaseBits</name><operator>.</operator><name>KeywordLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setKeywordLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>SwitchCaseBits</name><operator>.</operator><name>KeywordLoc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<specifier>inline</specifier> <name>Stmt</name> <operator>*</operator><call><name>getSubStmt</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getSubStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>SwitchCase</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getSubStmt</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKeywordLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<specifier>inline</specifier> <name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CaseStmtClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DefaultStmtClass</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>CaseStmt</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>SwitchCase</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>CaseStmt</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>TrailingObjects</name></expr>;
















enum <expr><block>{ <expr><name>LhsOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><name>SubStmtOffsetFromRhs</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
enum <expr><block>{ <expr><name>NumMandatoryStmtPtr</name> <operator>=</operator> <literal type="number">2</literal></expr> }</block></expr>;

<expr><name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Stmt *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumMandatoryStmtPtr</name> <operator>+</operator> <call><name>caseStmtIsGNURange</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;SourceLocation&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>caseStmtIsGNURange</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>lhsOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LhsOffset</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>rhsOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LhsOffset</name> <operator>+</operator> <call><name>caseStmtIsGNURange</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>unsigned</name> <macro><name>subStmtOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>rhsOffset</name><argument_list>()</argument_list></call> <operator>+</operator> <name>SubStmtOffsetFromRhs</name></expr>;</return> }</block>



<macro><name>CaseStmt</name><argument_list>(<argument>Expr *lhs</argument>, <argument>Expr *rhs</argument>, <argument>SourceLocation caseLoc</argument>,
<argument>SourceLocation ellipsisLoc</argument>, <argument>SourceLocation colonLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>SwitchCase</name><argument_list>(<argument>CaseStmtClass</argument>, <argument>caseLoc</argument>, <argument>colonLoc</argument>)</argument_list></macro> <block>{

<expr><name>bool</name> <name>IsGNURange</name> <operator>=</operator> <name>rhs</name> <operator>!=</operator> <name>nullptr</name></expr>;
<expr><name><name>SwitchCaseBits</name><operator>.</operator><name>CaseStmtIsGNURange</name></name> <operator>=</operator> <name>IsGNURange</name></expr>;
<expr><call><name>setLHS</name><argument_list>(<argument><expr><name>lhs</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setSubStmt</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>IsGNURange</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>setRHS</name><argument_list>(<argument><expr><name>rhs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setEllipsisLoc</name><argument_list>(<argument><expr><name>ellipsisLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}


explicit CaseStmt(EmptyShell Empty</block><operator>,</operator> <expr_stmt><expr><name>bool</name> <name>CaseStmtIsGNURange</name></expr></expr_stmt></if></if_stmt>)
<operator>:</operator> <macro><name>SwitchCase</name><argument_list>(<argument>CaseStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{
<expr><name><name>SwitchCaseBits</name><operator>.</operator><name>CaseStmtIsGNURange</name></name> <operator>=</operator> <name>CaseStmtIsGNURange</name></expr>;
}</block></block>

<name>public</name><operator>:</operator>

<specifier>static</specifier> <name>CaseStmt</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>Expr *lhs</argument>, <argument>Expr *rhs</argument>,
<argument>SourceLocation caseLoc</argument>, <argument>SourceLocation ellipsisLoc</argument>,
<argument>SourceLocation colonLoc</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>CaseStmt</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>bool CaseStmtIsGNURange</argument>)</argument_list></macro></expr>;




<expr><name>bool</name> <macro><name>caseStmtIsGNURange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>SwitchCaseBits</name><operator>.</operator><name>CaseStmtIsGNURange</name></name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getCaseLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKeywordLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setCaseLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><call><name>setKeywordLoc</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>; }</block>


<name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>caseStmtIsGNURange</name><argument_list>()</argument_list></call> <operator>?</operator> <operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>void</name> <macro><name>setEllipsisLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(
<argument><expr><call><name>caseStmtIsGNURange</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"setEllipsisLoc but this is not a case stmt of the form LHS ... RHS!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>=</operator> <name>L</name></expr>;
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getLHS</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>lhsOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getLHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>lhsOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setLHS</name><argument_list>(<argument>Expr *Val</argument>)</argument_list></macro> <block>{
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>lhsOffset</name><argument_list>()</argument_list></call></expr>]</index> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getRHS</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><ternary><condition><expr><call><name>caseStmtIsGNURange</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>rhsOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getRHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>caseStmtIsGNURange</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>rhsOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<name>void</name> <macro><name>setRHS</name><argument_list>(<argument>Expr *Val</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>caseStmtIsGNURange</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"setRHS but this is not a case stmt of the form LHS ... RHS!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>rhsOffset</name><argument_list>()</argument_list></call></expr>]</index> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>Stmt</name> <operator>*</operator><macro><name>getSubStmt</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>subStmtOffset</name><argument_list>()</argument_list></call></expr>]</index></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getSubStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>subStmtOffset</name><argument_list>()</argument_list></call></expr>]</index></expr>;</return>
}</block>

<name>void</name> <macro><name>setSubStmt</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>subStmtOffset</name><argument_list>()</argument_list></call></expr>]</index> <operator>=</operator> <name>S</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKeywordLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{

<expr><specifier>const</specifier> <name>CaseStmt</name> <operator>*</operator><name>CS</name> <operator>=</operator> <name>this</name></expr>;
<while>while <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>CS2</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CaseStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>CS</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>CS</name> <operator>=</operator> <name>CS2</name></expr>;</expr_stmt></block_content></block></while></block></expr>

<return>return <expr><call><name><name>CS</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CaseStmtClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>DefaultStmt</name> <operator>:</operator> <name>public</name> <name>SwitchCase</name> <block>{
<expr><name>Stmt</name> <operator>*</operator><name>SubStmt</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>DefaultStmt</name><argument_list>(<argument>SourceLocation DL</argument>, <argument>SourceLocation CL</argument>, <argument>Stmt *substmt</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SwitchCase</name><argument_list>(<argument><expr><name>DefaultStmtClass</name></expr></argument>, <argument><expr><name>DL</name></expr></argument>, <argument><expr><name>CL</name></expr></argument>)</argument_list></call></expr>, <macro><name>SubStmt</name><argument_list>(<argument>substmt</argument>)</argument_list></macro> <expr><block>{}</block>


<name>explicit</name> <macro><name>DefaultStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>SwitchCase</name><argument_list>(<argument>DefaultStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>Stmt</name> <operator>*</operator><macro><name>getSubStmt</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>SubStmt</name></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getSubStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SubStmt</name></expr>;</return> }</block>
<name>void</name> <macro><name>setSubStmt</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{ <expr><name>SubStmt</name> <operator>=</operator> <name>S</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getDefaultLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKeywordLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setDefaultLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><call><name>setKeywordLoc</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKeywordLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>SubStmt</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DefaultStmtClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubStmt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubStmt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name>SourceLocation</name> <name>SwitchCase</name><operator>::</operator><macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>CS</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CaseStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>CS</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>*</modifier></type><name>DS</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>DefaultStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>DS</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"SwitchCase is neither a CaseStmt nor a DefaultStmt!"</literal></expr></argument>)</argument_list></call></block></expr>;
}</block>

<name>Stmt</name> <operator>*</operator><name>SwitchCase</name><operator>::</operator><macro><name>getSubStmt</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>CS</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CaseStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>CS</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>auto</name> <operator>*</operator><name>DS</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>DefaultStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>DS</name><operator>-&gt;</operator><name>getSubStmt</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"SwitchCase is neither a CaseStmt nor a DefaultStmt!"</literal></expr></argument>)</argument_list></call></block></expr>;
}</block>







<name>class</name> <name>ValueStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>using</name> <name>Stmt</name><operator>::</operator><name>Stmt</name></expr>;

<expr><name>public</name><operator>:</operator>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getExprStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>Expr</name> <operator>*</operator><macro><name>getExprStmt</name><argument_list>()</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>ValueStmt</name> <operator>*</operator><name>ConstThis</name> <operator>=</operator> <name>this</name></expr>;
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>ConstThis</name><operator>-&gt;</operator><name>getExprStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>firstValueStmtConstant</name> <operator>&amp;&amp;</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>lastValueStmtConstant</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>LabelStmt</name> <operator>:</operator> <name>public</name> <name>ValueStmt</name> <block>{
<expr><name>LabelDecl</name> <operator>*</operator><name>TheDecl</name></expr>;
<expr><name>Stmt</name> <operator>*</operator><name>SubStmt</name></expr>;
<expr><name>bool</name> <name>SideEntry</name> <operator>=</operator> <name>false</name></expr>;

<expr><name>public</name><operator>:</operator>

<macro><name>LabelStmt</name><argument_list>(<argument>SourceLocation IL</argument>, <argument>LabelDecl *D</argument>, <argument>Stmt *substmt</argument>)</argument_list></macro>
<operator>:</operator> <call><name>ValueStmt</name><argument_list>(<argument><expr><name>LabelStmtClass</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>TheDecl</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>, <macro><name>SubStmt</name><argument_list>(<argument>substmt</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setIdentLoc</name><argument_list>(<argument><expr><name>IL</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>LabelStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>ValueStmt</name><argument_list>(<argument>LabelStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getIdentLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>LabelStmtBits</name><operator>.</operator><name>IdentLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setIdentLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>LabelStmtBits</name><operator>.</operator><name>IdentLoc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>LabelDecl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheDecl</name></expr>;</return> }</block>
<name>void</name> <macro><name>setDecl</name><argument_list>(<argument>LabelDecl *D</argument>)</argument_list></macro> <block>{ <expr><name>TheDecl</name> <operator>=</operator> <name>D</name></expr>; }</block>

<specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>Stmt</name> <operator>*</operator><macro><name>getSubStmt</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>SubStmt</name></expr>;</return> }</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getSubStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SubStmt</name></expr>;</return> }</block>
<name>void</name> <macro><name>setSubStmt</name><argument_list>(<argument>Stmt *SS</argument>)</argument_list></macro> <block>{ <expr><name>SubStmt</name> <operator>=</operator> <name>SS</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getIdentLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>SubStmt</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return>}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubStmt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubStmt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>LabelStmtClass</name></expr>;</return>
}</block>
<name>bool</name> <macro><name>isSideEntry</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SideEntry</name></expr>;</return> }</block>
<name>void</name> <macro><name>setSideEntry</name><argument_list>(<argument>bool SE</argument>)</argument_list></macro> <block>{ <expr><name>SideEntry</name> <operator>=</operator> <name>SE</name></expr>; }</block>
}</expr>;





<expr><name>class</name> <name>AttributedStmt</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>ValueStmt</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>AttributedStmt</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

<expr><name>Stmt</name> <operator>*</operator><name>SubStmt</name></expr>;

<macro><name>AttributedStmt</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>ArrayRef&lt;const Attr *&gt; Attrs</argument>,
<argument>Stmt *SubStmt</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>ValueStmt</name><argument_list>(<argument><expr><name>AttributedStmtClass</name></expr></argument>)</argument_list></call></expr>, <macro><name>SubStmt</name><argument_list>(<argument>SubStmt</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>AttributedStmtBits</name><operator>.</operator><name>NumAttrs</name></name> <operator>=</operator> <call><name><name>Attrs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;
<expr><name><name>AttributedStmtBits</name><operator>.</operator><name>AttrLoc</name></name> <operator>=</operator> <name>Loc</name></expr>;
<expr><name>std</name><operator>::</operator><call><name>copy</name><argument_list>(<argument><expr><call><name><name>Attrs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Attrs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getAttrArrayPtr</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>explicit</name> <macro><name>AttributedStmt</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumAttrs</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>ValueStmt</name><argument_list>(<argument>AttributedStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{
<expr><name><name>AttributedStmtBits</name><operator>.</operator><name>NumAttrs</name></name> <operator>=</operator> <name>NumAttrs</name></expr>;
<expr><name><name>AttributedStmtBits</name><operator>.</operator><name>AttrLoc</name></name> <operator>=</operator> <name>SourceLocation</name><block>{}</block></expr>;
<expr><name>std</name><operator>::</operator><call><name>fill_n</name><argument_list>(<argument><expr><call><name>getAttrArrayPtr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NumAttrs</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>const</specifier> <name>Attr</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><macro><name>getAttrArrayPtr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>Attr</name> <operator>*</operator><operator>*</operator><macro><name>getAttrArrayPtr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>AttributedStmt</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation Loc</argument>,
<argument>ArrayRef&lt;const Attr *&gt; Attrs</argument>, <argument>Stmt *SubStmt</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>AttributedStmt</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumAttrs</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getAttrLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>AttributedStmtBits</name><operator>.</operator><name>AttrLoc</name></name></expr>;</return> }</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getAttrs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getAttrArrayPtr</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>AttributedStmtBits</name><operator>.</operator><name>NumAttrs</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Stmt</name> <operator>*</operator><macro><name>getSubStmt</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>SubStmt</name></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getSubStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SubStmt</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getAttrLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>SubStmt</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return>}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubStmt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>SubStmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SubStmt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>AttributedStmtClass</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>IfStmt</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Stmt</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>IfStmt</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>TrailingObjects</name></expr>;























enum <expr><block>{ <expr><name>InitOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><name>ThenOffsetFromCond</name> <operator>=</operator> <literal type="number">1</literal></expr>, <expr><name>ElseOffsetFromCond</name> <operator>=</operator> <literal type="number">2</literal></expr> }</block></expr>;
enum <expr><block>{ <expr><name>NumMandatoryStmtPtr</name> <operator>=</operator> <literal type="number">2</literal></expr> }</block></expr>;
<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;
<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;

<expr><name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Stmt *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumMandatoryStmtPtr</name> <operator>+</operator> <call><name>hasElseStorage</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>hasVarStorage</name><argument_list>()</argument_list></call> <operator>+</operator>
<call><name>hasInitStorage</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;SourceLocation&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasElseStorage</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>initOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>InitOffset</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>varOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>InitOffset</name> <operator>+</operator> <call><name>hasInitStorage</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>unsigned</name> <macro><name>condOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>InitOffset</name> <operator>+</operator> <call><name>hasInitStorage</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>hasVarStorage</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>unsigned</name> <macro><name>thenOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>condOffset</name><argument_list>()</argument_list></call> <operator>+</operator> <name>ThenOffsetFromCond</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>elseOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>condOffset</name><argument_list>()</argument_list></call> <operator>+</operator> <name>ElseOffsetFromCond</name></expr>;</return> }</block>


<macro><name>IfStmt</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>SourceLocation IL</argument>, <argument>bool IsConstexpr</argument>, <argument>Stmt *Init</argument>,
<argument>VarDecl *Var</argument>, <argument>Expr *Cond</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation RParenLoc</argument>, <argument>Stmt *Then</argument>, <argument>SourceLocation EL</argument>, <argument>Stmt *Else</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>IfStmt</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>bool HasElse</argument>, <argument>bool HasVar</argument>, <argument>bool HasInit</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>

<specifier>static</specifier> <name>IfStmt</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>SourceLocation IL</argument>,
<argument>bool IsConstexpr</argument>, <argument>Stmt *Init</argument>, <argument>VarDecl *Var</argument>, <argument>Expr *Cond</argument>,
<argument>SourceLocation LPL</argument>, <argument>SourceLocation RPL</argument>, <argument>Stmt *Then</argument>,
<argument>SourceLocation EL = SourceLocation()</argument>,
<argument>Stmt *Else = nullptr</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>IfStmt</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>bool HasElse</argument>, <argument>bool HasVar</argument>,
<argument>bool HasInit</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>hasInitStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>IfStmtBits</name><operator>.</operator><name>HasInit</name></name></expr>;</return> }</block>


<name>bool</name> <macro><name>hasVarStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>IfStmtBits</name><operator>.</operator><name>HasVar</name></name></expr>;</return> }</block>


<name>bool</name> <macro><name>hasElseStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>IfStmtBits</name><operator>.</operator><name>HasElse</name></name></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>condOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>condOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setCond</name><argument_list>(<argument>Expr *Cond</argument>)</argument_list></macro> <block>{
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>condOffset</name><argument_list>()</argument_list></call></expr>]</index> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Cond</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>Stmt</name> <operator>*</operator><macro><name>getThen</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>thenOffset</name><argument_list>()</argument_list></call></expr>]</index></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getThen</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>thenOffset</name><argument_list>()</argument_list></call></expr>]</index></expr>;</return>
}</block>

<name>void</name> <macro><name>setThen</name><argument_list>(<argument>Stmt *Then</argument>)</argument_list></macro> <block>{
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>thenOffset</name><argument_list>()</argument_list></call></expr>]</index> <operator>=</operator> <name>Then</name></expr>;
}</block>

<name>Stmt</name> <operator>*</operator><macro><name>getElse</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>hasElseStorage</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>elseOffset</name><argument_list>()</argument_list></call></expr>]</index>
<operator>:</operator> <name>nullptr</name></expr>;</return>
}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getElse</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasElseStorage</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>elseOffset</name><argument_list>()</argument_list></call></expr>]</index></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<name>void</name> <macro><name>setElse</name><argument_list>(<argument>Stmt *Else</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasElseStorage</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"This if statement has no storage for an else statement!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>elseOffset</name><argument_list>()</argument_list></call></expr>]</index> <operator>=</operator> <name>Else</name></expr>;
}</block>









<name>VarDecl</name> <operator>*</operator><call><name>getConditionVariable</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getConditionVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>IfStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getConditionVariable</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>void</name> <call><name>setConditionVariable</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>, <argument><expr><name>VarDecl</name> <operator>*</operator><name>V</name></expr></argument>)</argument_list></call></expr>;



<expr><name>DeclStmt</name> <operator>*</operator><macro><name>getConditionVariableDeclStmt</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasVarStorage</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>varOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<specifier>const</specifier> <name>DeclStmt</name> <operator>*</operator><macro><name>getConditionVariableDeclStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasVarStorage</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>varOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<name>Stmt</name> <operator>*</operator><macro><name>getInit</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasInitStorage</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>initOffset</name><argument_list>()</argument_list></call></expr>]</index></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasInitStorage</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>initOffset</name><argument_list>()</argument_list></call></expr>]</index></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<name>void</name> <macro><name>setInit</name><argument_list>(<argument>Stmt *Init</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasInitStorage</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"This if statement has no storage for an init statement!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>initOffset</name><argument_list>()</argument_list></call></expr>]</index> <operator>=</operator> <name>Init</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getIfLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>IfStmtBits</name><operator>.</operator><name>IfLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setIfLoc</name><argument_list>(<argument>SourceLocation IfLoc</argument>)</argument_list></macro> <block>{ <expr><name><name>IfStmtBits</name><operator>.</operator><name>IfLoc</name></name> <operator>=</operator> <name>IfLoc</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getElseLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasElseStorage</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<name>void</name> <macro><name>setElseLoc</name><argument_list>(<argument>SourceLocation ElseLoc</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasElseStorage</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"This if statement has no storage for an else statement!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>=</operator> <name>ElseLoc</name></expr>;
}</block>

<name>bool</name> <macro><name>isConstexpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>IfStmtBits</name><operator>.</operator><name>IsConstexpr</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setConstexpr</name><argument_list>(<argument>bool C</argument>)</argument_list></macro> <block>{ <expr><name><name>IfStmtBits</name><operator>.</operator><name>IsConstexpr</name></name> <operator>=</operator> <name>C</name></expr>; }</block>



<name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Stmt</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getNondiscardedCase</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <call><name>getNondiscardedCase</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list></call></expr>;

<expr><name>bool</name> <macro><name>isObjCAvailabilityCheck</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getIfLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getElse</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getElse</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>getThen</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>



<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>IfStmtClass</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>SwitchStmt</name> <name>final</name> <operator>:</operator> <name>public</name> <name>Stmt</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SwitchStmt</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>SwitchCase</name> <operator>*</operator><name>FirstCase</name> <operator>=</operator> <name>nullptr</name></expr>;


















enum <expr><block>{ <expr><name>InitOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><name>BodyOffsetFromCond</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
enum <expr><block>{ <expr><name>NumMandatoryStmtPtr</name> <operator>=</operator> <literal type="number">2</literal></expr> }</block></expr>;
<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;
<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;

<expr><name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Stmt *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumMandatoryStmtPtr</name> <operator>+</operator> <call><name>hasInitStorage</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>hasVarStorage</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>initOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>InitOffset</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>varOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>InitOffset</name> <operator>+</operator> <call><name>hasInitStorage</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>unsigned</name> <macro><name>condOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>InitOffset</name> <operator>+</operator> <call><name>hasInitStorage</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>hasVarStorage</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>unsigned</name> <macro><name>bodyOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>condOffset</name><argument_list>()</argument_list></call> <operator>+</operator> <name>BodyOffsetFromCond</name></expr>;</return> }</block>


<macro><name>SwitchStmt</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>Stmt *Init</argument>, <argument>VarDecl *Var</argument>, <argument>Expr *Cond</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation RParenLoc</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>SwitchStmt</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>bool HasInit</argument>, <argument>bool HasVar</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>

<specifier>static</specifier> <name>SwitchStmt</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>Stmt *Init</argument>, <argument>VarDecl *Var</argument>,
<argument>Expr *Cond</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation RParenLoc</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>SwitchStmt</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>bool HasInit</argument>,
<argument>bool HasVar</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>hasInitStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>SwitchStmtBits</name><operator>.</operator><name>HasInit</name></name></expr>;</return> }</block>


<name>bool</name> <macro><name>hasVarStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>SwitchStmtBits</name><operator>.</operator><name>HasVar</name></name></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>condOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>condOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setCond</name><argument_list>(<argument>Expr *Cond</argument>)</argument_list></macro> <block>{
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>condOffset</name><argument_list>()</argument_list></call></expr>]</index> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Cond</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>bodyOffset</name><argument_list>()</argument_list></call></expr>]</index></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>bodyOffset</name><argument_list>()</argument_list></call></expr>]</index></expr>;</return>
}</block>

<name>void</name> <macro><name>setBody</name><argument_list>(<argument>Stmt *Body</argument>)</argument_list></macro> <block>{
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>bodyOffset</name><argument_list>()</argument_list></call></expr>]</index> <operator>=</operator> <name>Body</name></expr>;
}</block>

<name>Stmt</name> <operator>*</operator><macro><name>getInit</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>hasInitStorage</name><argument_list>()</argument_list></call> <operator>?</operator> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>initOffset</name><argument_list>()</argument_list></call></expr>]</index>
<operator>:</operator> <name>nullptr</name></expr>;</return>
}</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasInitStorage</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>initOffset</name><argument_list>()</argument_list></call></expr>]</index></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<name>void</name> <macro><name>setInit</name><argument_list>(<argument>Stmt *Init</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasInitStorage</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"This switch statement has no storage for an init statement!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>initOffset</name><argument_list>()</argument_list></call></expr>]</index> <operator>=</operator> <name>Init</name></expr>;
}</block>










<name>VarDecl</name> <operator>*</operator><call><name>getConditionVariable</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getConditionVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>SwitchStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getConditionVariable</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>void</name> <call><name>setConditionVariable</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>, <argument><expr><name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list></call></expr>;



<expr><name>DeclStmt</name> <operator>*</operator><macro><name>getConditionVariableDeclStmt</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasVarStorage</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>varOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<specifier>const</specifier> <name>DeclStmt</name> <operator>*</operator><macro><name>getConditionVariableDeclStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasVarStorage</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>varOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<name>SwitchCase</name> <operator>*</operator><macro><name>getSwitchCaseList</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>FirstCase</name></expr>;</return> }</block>
<specifier>const</specifier> <name>SwitchCase</name> <operator>*</operator><macro><name>getSwitchCaseList</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FirstCase</name></expr>;</return> }</block>
<name>void</name> <macro><name>setSwitchCaseList</name><argument_list>(<argument>SwitchCase *SC</argument>)</argument_list></macro> <block>{ <expr><name>FirstCase</name> <operator>=</operator> <name>SC</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getSwitchLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>SwitchStmtBits</name><operator>.</operator><name>SwitchLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setSwitchLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>SwitchStmtBits</name><operator>.</operator><name>SwitchLoc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>void</name> <macro><name>setBody</name><argument_list>(<argument>Stmt *S</argument>, <argument>SourceLocation SL</argument>)</argument_list></macro> <block>{
<expr><call><name>setBody</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setSwitchLoc</name><argument_list>(<argument><expr><name>SL</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>addSwitchCase</name><argument_list>(<argument>SwitchCase *SC</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>SC</name><operator>-&gt;</operator><name>getNextSwitchCase</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"case/default already added to a switch"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>SC</name><operator>-&gt;</operator><name>setNextSwitchCase</name></name><argument_list>(<argument><expr><name>FirstCase</name></expr></argument>)</argument_list></call></expr>;
<expr><name>FirstCase</name> <operator>=</operator> <name>SC</name></expr>;
}</block>



<name>void</name> <macro><name>setAllEnumCasesCovered</name><argument_list>()</argument_list></macro> <block>{ <expr><name><name>SwitchStmtBits</name><operator>.</operator><name>AllEnumCasesCovered</name></name> <operator>=</operator> <name>true</name></expr>; }</block>



<name>bool</name> <macro><name>isAllEnumCasesCovered</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>SwitchStmtBits</name><operator>.</operator><name>AllEnumCasesCovered</name></name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getSwitchLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><ternary><condition><expr><call><name>getBody</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name>getBody</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getCond</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SwitchStmtClass</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>WhileStmt</name> <name>final</name> <operator>:</operator> <name>public</name> <name>Stmt</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>WhileStmt</name></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>TrailingObjects</name></expr>;
















enum <expr><block>{ <expr><name>VarOffset</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><name>BodyOffsetFromCond</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;
enum <expr><block>{ <expr><name>NumMandatoryStmtPtr</name> <operator>=</operator> <literal type="number">2</literal></expr> }</block></expr>;

<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>, <expr><name>RParenLoc</name></expr>;

<expr><name>unsigned</name> <macro><name>varOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VarOffset</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>condOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VarOffset</name> <operator>+</operator> <call><name>hasVarStorage</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>unsigned</name> <macro><name>bodyOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>condOffset</name><argument_list>()</argument_list></call> <operator>+</operator> <name>BodyOffsetFromCond</name></expr>;</return> }</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Stmt *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumMandatoryStmtPtr</name> <operator>+</operator> <call><name>hasVarStorage</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<macro><name>WhileStmt</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>VarDecl *Var</argument>, <argument>Expr *Cond</argument>, <argument>Stmt *Body</argument>,
<argument>SourceLocation WL</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation RParenLoc</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>WhileStmt</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>bool HasVar</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>

<specifier>static</specifier> <name>WhileStmt</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>VarDecl *Var</argument>, <argument>Expr *Cond</argument>,
<argument>Stmt *Body</argument>, <argument>SourceLocation WL</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation RParenLoc</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>WhileStmt</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>bool HasVar</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>hasVarStorage</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>WhileStmtBits</name><operator>.</operator><name>HasVar</name></name></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>condOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>condOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setCond</name><argument_list>(<argument>Expr *Cond</argument>)</argument_list></macro> <block>{
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>condOffset</name><argument_list>()</argument_list></call></expr>]</index> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Cond</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>bodyOffset</name><argument_list>()</argument_list></call></expr>]</index></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>bodyOffset</name><argument_list>()</argument_list></call></expr>]</index></expr>;</return>
}</block>

<name>void</name> <macro><name>setBody</name><argument_list>(<argument>Stmt *Body</argument>)</argument_list></macro> <block>{
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>bodyOffset</name><argument_list>()</argument_list></call></expr>]</index> <operator>=</operator> <name>Body</name></expr>;
}</block>









<name>VarDecl</name> <operator>*</operator><call><name>getConditionVariable</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getConditionVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>WhileStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getConditionVariable</name><argument_list>()</argument_list></call></expr>;</return>
}</block>



<name>void</name> <call><name>setConditionVariable</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>, <argument><expr><name>VarDecl</name> <operator>*</operator><name>V</name></expr></argument>)</argument_list></call></expr>;



<expr><name>DeclStmt</name> <operator>*</operator><macro><name>getConditionVariableDeclStmt</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasVarStorage</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>varOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<specifier>const</specifier> <name>DeclStmt</name> <operator>*</operator><macro><name>getConditionVariableDeclStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasVarStorage</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>varOffset</name><argument_list>()</argument_list></call></expr>]</index></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getWhileLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>WhileStmtBits</name><operator>.</operator><name>WhileLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setWhileLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>WhileStmtBits</name><operator>.</operator><name>WhileLoc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getWhileLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getBody</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>WhileStmtClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<call><name>numTrailingObjects</name><argument_list>(<argument><expr><call><name><name>OverloadToken</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>DoStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
enum <expr><block>{ <expr><name>BODY</name></expr>, <expr><name>COND</name></expr>, <expr><name>END_EXPR</name></expr> }</block></expr>;
<expr><name>Stmt</name> <operator>*</operator><name><name>SubExprs</name><index>[<expr><name>END_EXPR</name></expr>]</index></name></expr>;
<expr><name>SourceLocation</name> <name>WhileLoc</name></expr>;
<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>DoStmt</name><argument_list>(<argument>Stmt *Body</argument>, <argument>Expr *Cond</argument>, <argument>SourceLocation DL</argument>, <argument>SourceLocation WL</argument>,
<argument>SourceLocation RP</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Stmt</name><argument_list>(<argument><expr><name>DoStmtClass</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>WhileLoc</name><argument_list>(<argument><expr><name>WL</name></expr></argument>)</argument_list></call></expr>, <macro><name>RParenLoc</name><argument_list>(<argument>RP</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setCond</name><argument_list>(<argument><expr><name>Cond</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setBody</name><argument_list>(<argument><expr><name>Body</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setDoLoc</name><argument_list>(<argument><expr><name>DL</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>DoStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>DoStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>COND</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>COND</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setCond</name><argument_list>(<argument>Expr *Cond</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>COND</name></expr>]</index></name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Cond</name></expr></argument>)</argument_list></call></expr>; }</block>

<name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name><name>SubExprs</name><index>[<expr><name>BODY</name></expr>]</index></name></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>SubExprs</name><index>[<expr><name>BODY</name></expr>]</index></name></expr>;</return> }</block>
<name>void</name> <macro><name>setBody</name><argument_list>(<argument>Stmt *Body</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>BODY</name></expr>]</index></name> <operator>=</operator> <name>Body</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getDoLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>DoStmtBits</name><operator>.</operator><name>DoLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setDoLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>DoStmtBits</name><operator>.</operator><name>DoLoc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getWhileLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>WhileLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setWhileLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>WhileLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getDoLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getRParenLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DoStmtClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>ForStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
enum <expr><block>{ <expr><name>INIT</name></expr>, <expr><name>CONDVAR</name></expr>, <expr><name>COND</name></expr>, <expr><name>INC</name></expr>, <expr><name>BODY</name></expr>, <expr><name>END_EXPR</name></expr> }</block></expr>;
<expr><name>Stmt</name><operator>*</operator> <name><name>SubExprs</name><index>[<expr><name>END_EXPR</name></expr>]</index></name></expr>;
<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>, <expr><name>RParenLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ForStmt</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>Stmt *Init</argument>, <argument>Expr *Cond</argument>, <argument>VarDecl *condVar</argument>,
<argument>Expr *Inc</argument>, <argument>Stmt *Body</argument>, <argument>SourceLocation FL</argument>, <argument>SourceLocation LP</argument>,
<argument>SourceLocation RP</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>ForStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>ForStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>Stmt</name> <operator>*</operator><macro><name>getInit</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name><name>SubExprs</name><index>[<expr><name>INIT</name></expr>]</index></name></expr>;</return> }</block>









<name>VarDecl</name> <operator>*</operator><macro><name>getConditionVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>void</name> <call><name>setConditionVariable</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><name>VarDecl</name> <operator>*</operator><name>V</name></expr></argument>)</argument_list></call></expr>;



<expr><specifier>const</specifier> <name>DeclStmt</name> <operator>*</operator><macro><name>getConditionVariableDeclStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclStmt</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>CONDVAR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>COND</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getInc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>INC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name><name>SubExprs</name><index>[<expr><name>BODY</name></expr>]</index></name></expr>;</return> }</block>

<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getInit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>SubExprs</name><index>[<expr><name>INIT</name></expr>]</index></name></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getCond</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>COND</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>}</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getInc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>SubExprs</name><index>[<expr><name>INC</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getBody</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>SubExprs</name><index>[<expr><name>BODY</name></expr>]</index></name></expr>;</return> }</block>

<name>void</name> <macro><name>setInit</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>INIT</name></expr>]</index></name> <operator>=</operator> <name>S</name></expr>; }</block>
<name>void</name> <macro><name>setCond</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>COND</name></expr>]</index></name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>; }</block>
<name>void</name> <macro><name>setInc</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>INC</name></expr>]</index></name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>; }</block>
<name>void</name> <macro><name>setBody</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{ <expr><name><name>SubExprs</name><index>[<expr><name>BODY</name></expr>]</index></name> <operator>=</operator> <name>S</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getForLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ForStmtBits</name><operator>.</operator><name>ForLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setForLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>ForStmtBits</name><operator>.</operator><name>ForLoc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getForLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getBody</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ForStmtClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>+</operator><name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>SubExprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>END_EXPR</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>GotoStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>LabelDecl</name> <operator>*</operator><name>Label</name></expr>;
<expr><name>SourceLocation</name> <name>LabelLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>GotoStmt</name><argument_list>(<argument>LabelDecl *label</argument>, <argument>SourceLocation GL</argument>, <argument>SourceLocation LL</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Stmt</name><argument_list>(<argument><expr><name>GotoStmtClass</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Label</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>, <macro><name>LabelLoc</name><argument_list>(<argument>LL</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setGotoLoc</name><argument_list>(<argument><expr><name>GL</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>GotoStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>GotoStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>LabelDecl</name> <operator>*</operator><macro><name>getLabel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Label</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLabel</name><argument_list>(<argument>LabelDecl *D</argument>)</argument_list></macro> <block>{ <expr><name>Label</name> <operator>=</operator> <name>D</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getGotoLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>GotoStmtBits</name><operator>.</operator><name>GotoLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setGotoLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>GotoStmtBits</name><operator>.</operator><name>GotoLoc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getLabelLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LabelLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLabelLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LabelLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getGotoLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getLabelLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>GotoStmtClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>IndirectGotoStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>SourceLocation</name> <name>StarLoc</name></expr>;
<expr><name>Stmt</name> <operator>*</operator><name>Target</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>IndirectGotoStmt</name><argument_list>(<argument>SourceLocation gotoLoc</argument>, <argument>SourceLocation starLoc</argument>, <argument>Expr *target</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Stmt</name><argument_list>(<argument><expr><name>IndirectGotoStmtClass</name></expr></argument>)</argument_list></call></expr>, <macro><name>StarLoc</name><argument_list>(<argument>starLoc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setTarget</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>setGotoLoc</name><argument_list>(<argument><expr><name>gotoLoc</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>IndirectGotoStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>IndirectGotoStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>void</name> <macro><name>setGotoLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>GotoStmtBits</name><operator>.</operator><name>GotoLoc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getGotoLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>GotoStmtBits</name><operator>.</operator><name>GotoLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setStarLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>StarLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getStarLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>StarLoc</name></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getTarget</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Target</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getTarget</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Target</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>void</name> <macro><name>setTarget</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Target</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>; }</block>



<name>LabelDecl</name> <operator>*</operator><call><name>getConstantTarget</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>LabelDecl</name> <operator>*</operator><macro><name>getConstantTarget</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>IndirectGotoStmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getConstantTarget</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getGotoLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Target</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>IndirectGotoStmtClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Target</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Target</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Target</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Target</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>ContinueStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>ContinueStmt</name><argument_list>(<argument>SourceLocation CL</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>ContinueStmtClass</argument>)</argument_list></macro> <block>{
<expr><call><name>setContinueLoc</name><argument_list>(<argument><expr><name>CL</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>ContinueStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>ContinueStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getContinueLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ContinueStmtBits</name><operator>.</operator><name>ContinueLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setContinueLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>ContinueStmtBits</name><operator>.</operator><name>ContinueLoc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getContinueLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getContinueLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ContinueStmtClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>BreakStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>BreakStmt</name><argument_list>(<argument>SourceLocation BL</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>BreakStmtClass</argument>)</argument_list></macro> <block>{
<expr><call><name>setBreakLoc</name><argument_list>(<argument><expr><name>BL</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <macro><name>BreakStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>BreakStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getBreakLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>BreakStmtBits</name><operator>.</operator><name>BreakLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setBreakLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>BreakStmtBits</name><operator>.</operator><name>BreakLoc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getBreakLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getBreakLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>BreakStmtClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>ReturnStmt</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>Stmt</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ReturnStmt</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>RetExpr</name></expr>;





<expr><name>bool</name> <macro><name>hasNRVOCandidate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ReturnStmtBits</name><operator>.</operator><name>HasNRVOCandidate</name></name></expr>;</return> }</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;const VarDecl *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>hasNRVOCandidate</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<macro><name>ReturnStmt</name><argument_list>(<argument>SourceLocation RL</argument>, <argument>Expr *E</argument>, <argument>const VarDecl *NRVOCandidate</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>ReturnStmt</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>bool HasNRVOCandidate</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>

<specifier>static</specifier> <name>ReturnStmt</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>SourceLocation RL</argument>, <argument>Expr *E</argument>,
<argument>const VarDecl *NRVOCandidate</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>ReturnStmt</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>bool HasNRVOCandidate</argument>)</argument_list></macro></expr>;

<expr><name>Expr</name> <operator>*</operator><macro><name>getRetValue</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RetExpr</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getRetValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RetExpr</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>void</name> <macro><name>setRetValue</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>RetExpr</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>; }</block>






<specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><macro><name>getNRVOCandidate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><ternary><condition><expr><call><name>hasNRVOCandidate</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>
</then><else>: <expr><name>nullptr</name></expr></else></ternary></expr>;</return>
}</block>




<name>void</name> <macro><name>setNRVOCandidate</name><argument_list>(<argument>const VarDecl *Var</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasNRVOCandidate</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"This return statement has no storage for an NRVO candidate!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>=</operator> <name>Var</name></expr>;
}</block>

<name>SourceLocation</name> <macro><name>getReturnLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>ReturnStmtBits</name><operator>.</operator><name>RetLoc</name></name></expr>;</return> }</block>
<name>void</name> <macro><name>setReturnLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name><name>ReturnStmtBits</name><operator>.</operator><name>RetLoc</name></name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getReturnLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><ternary><condition><expr><name>RetExpr</name></expr> ?</condition><then> <expr><call><name><name>RetExpr</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>getReturnLoc</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ReturnStmtClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>RetExpr</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RetExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RetExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>RetExpr</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>RetExpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>RetExpr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>AsmStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>SourceLocation</name> <name>AsmLoc</name></expr>;



<expr><name>bool</name> <name>IsSimple</name></expr>;



<expr><name>bool</name> <name>IsVolatile</name></expr>;

<expr><name>unsigned</name> <name>NumOutputs</name></expr>;
<expr><name>unsigned</name> <name>NumInputs</name></expr>;
<expr><name>unsigned</name> <name>NumClobbers</name></expr>;

<expr><name>Stmt</name> <operator>*</operator><operator>*</operator><name>Exprs</name> <operator>=</operator> <name>nullptr</name></expr>;

<macro><name>AsmStmt</name><argument_list>(<argument>StmtClass SC</argument>, <argument>SourceLocation asmloc</argument>, <argument>bool issimple</argument>, <argument>bool isvolatile</argument>,
<argument>unsigned numoutputs</argument>, <argument>unsigned numinputs</argument>, <argument>unsigned numclobbers</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>Stmt</name> <argument_list>(<argument><expr><name>SC</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>AsmLoc</name><argument_list>(<argument><expr><name>asmloc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>IsSimple</name><argument_list>(<argument><expr><name>issimple</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>IsVolatile</name><argument_list>(<argument><expr><name>isvolatile</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NumOutputs</name><argument_list>(<argument><expr><name>numoutputs</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NumInputs</name><argument_list>(<argument><expr><name>numinputs</name></expr></argument>)</argument_list></call></expr>,
<macro><name>NumClobbers</name><argument_list>(<argument>numclobbers</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>

<name>explicit</name> <macro><name>AsmStmt</name><argument_list>(<argument>StmtClass SC</argument>, <argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>SC</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getAsmLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AsmLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAsmLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>AsmLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>bool</name> <macro><name>isSimple</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsSimple</name></expr>;</return> }</block>
<name>void</name> <macro><name>setSimple</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{ <expr><name>IsSimple</name> <operator>=</operator> <name>V</name></expr>; }</block>

<name>bool</name> <macro><name>isVolatile</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsVolatile</name></expr>;</return> }</block>
<name>void</name> <macro><name>setVolatile</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{ <expr><name>IsVolatile</name> <operator>=</operator> <name>V</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><block>{}</block></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><block>{}</block></expr>;</return> }</block>




<name>std</name><operator>::</operator><name>string</name> <macro><name>generateAsmString</name><argument_list>(<argument>const ASTContext &amp;C</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>unsigned</name> <macro><name>getNumOutputs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumOutputs</name></expr>;</return> }</block>




<name>StringRef</name> <macro><name>getOutputConstraint</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier></expr>;




<expr><name>bool</name> <macro><name>isOutputPlusConstraint</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getOutputConstraint</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="char">'+'</literal></expr>;</return>
}</block>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getOutputExpr</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>unsigned</name> <macro><name>getNumPlusOperands</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>unsigned</name> <macro><name>getNumInputs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumInputs</name></expr>;</return> }</block>



<name>StringRef</name> <macro><name>getInputConstraint</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getInputExpr</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>unsigned</name> <macro><name>getNumClobbers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumClobbers</name></expr>;</return> }</block>
<name>StringRef</name> <macro><name>getClobber</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>GCCAsmStmtClass</name> <operator>||</operator>
<call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MSAsmStmtClass</name></expr>;</return>
}</block>



<name>using</name> <name>inputs_iterator</name> <operator>=</operator> <name>ExprIterator</name></expr>;
<expr><name>using</name> <name>const_inputs_iterator</name> <operator>=</operator> <name>ConstExprIterator</name></expr>;
<expr><name>using</name> <name>inputs_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>inputs_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>inputs_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_inputs_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>inputs_iterator</name> <macro><name>begin_inputs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NumOutputs</name></expr>;</return>
}</block>

<name>inputs_iterator</name> <macro><name>end_inputs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NumOutputs</name> <operator>+</operator> <name>NumInputs</name></expr>;</return>
}</block>

<name>inputs_range</name> <macro><name>inputs</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>inputs_range</name><argument_list>(<argument><expr><call><name>begin_inputs</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>end_inputs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_inputs_iterator</name> <macro><name>begin_inputs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NumOutputs</name></expr>;</return>
}</block>

<name>const_inputs_iterator</name> <macro><name>end_inputs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NumOutputs</name> <operator>+</operator> <name>NumInputs</name></expr>;</return>
}</block>

<name>inputs_const_range</name> <macro><name>inputs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>inputs_const_range</name><argument_list>(<argument><expr><call><name>begin_inputs</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>end_inputs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>using</name> <name>outputs_iterator</name> <operator>=</operator> <name>ExprIterator</name></expr>;
<expr><name>using</name> <name>const_outputs_iterator</name> <operator>=</operator> <name>ConstExprIterator</name></expr>;
<expr><name>using</name> <name>outputs_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>outputs_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>outputs_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_outputs_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>outputs_iterator</name> <macro><name>begin_outputs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
}</block>

<name>outputs_iterator</name> <macro><name>end_outputs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NumOutputs</name></expr>;</return>
}</block>

<name>outputs_range</name> <macro><name>outputs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>outputs_range</name><argument_list>(<argument><expr><call><name>begin_outputs</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>end_outputs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_outputs_iterator</name> <macro><name>begin_outputs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
}</block>

<name>const_outputs_iterator</name> <macro><name>end_outputs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NumOutputs</name></expr>;</return>
}</block>

<name>outputs_const_range</name> <macro><name>outputs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>outputs_const_range</name><argument_list>(<argument><expr><call><name>begin_outputs</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>end_outputs</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NumOutputs</name> <operator>+</operator> <name>NumInputs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NumOutputs</name> <operator>+</operator> <name>NumInputs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>GCCAsmStmt</name> <operator>:</operator> <name>public</name> <name>AsmStmt</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>SourceLocation</name> <name>RParenLoc</name></expr>;
<expr><name>StringLiteral</name> <operator>*</operator><name>AsmStr</name></expr>;


<expr><name>StringLiteral</name> <operator>*</operator><operator>*</operator><name>Constraints</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>StringLiteral</name> <operator>*</operator><operator>*</operator><name>Clobbers</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>IdentifierInfo</name> <operator>*</operator><operator>*</operator><name>Names</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>unsigned</name> <name>NumLabels</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>GCCAsmStmt</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation asmloc</argument>, <argument>bool issimple</argument>,
<argument>bool isvolatile</argument>, <argument>unsigned numoutputs</argument>, <argument>unsigned numinputs</argument>,
<argument>IdentifierInfo **names</argument>, <argument>StringLiteral **constraints</argument>, <argument>Expr **exprs</argument>,
<argument>StringLiteral *asmstr</argument>, <argument>unsigned numclobbers</argument>,
<argument>StringLiteral **clobbers</argument>, <argument>unsigned numlabels</argument>,
<argument>SourceLocation rparenloc</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>GCCAsmStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>AsmStmt</name><argument_list>(<argument>GCCAsmStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setRParenLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>RParenLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>



<specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><macro><name>getAsmString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AsmStr</name></expr>;</return> }</block>
<name>StringLiteral</name> <operator>*</operator><macro><name>getAsmString</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>AsmStr</name></expr>;</return> }</block>
<name>void</name> <macro><name>setAsmString</name><argument_list>(<argument>StringLiteral *E</argument>)</argument_list></macro> <block>{ <expr><name>AsmStr</name> <operator>=</operator> <name>E</name></expr>; }</block>




<name>class</name> <name>AsmStringPiece</name> <block>{
<expr><name>public</name><operator>:</operator>
enum <name>Kind</name> <block>{
<expr><name>String</name></expr>,
<expr><name>Operand</name></expr>
}</block></expr>;

<expr><name>private</name><operator>:</operator>
<name>Kind</name> <name>MyKind</name></expr>;
<expr><name>std</name><operator>::</operator><name>string</name> <name>Str</name></expr>;
<expr><name>unsigned</name> <name>OperandNo</name></expr>;


<expr><name>CharSourceRange</name> <name>Range</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>AsmStringPiece</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>S</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>MyKind</name><argument_list>(<argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>, <macro><name>Str</name><argument_list>(<argument>S</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>AsmStringPiece</name><argument_list>(<argument>unsigned OpNo</argument>, <argument>const std::string &amp;S</argument>, <argument>SourceLocation Begin</argument>,
<argument>SourceLocation End</argument>)</argument_list></macro>
<operator>:</operator> <call><name>MyKind</name><argument_list>(<argument><expr><name>Operand</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Str</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>OperandNo</name><argument_list>(<argument><expr><name>OpNo</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Range</name><argument_list>(<argument>CharSourceRange::getCharRange(Begin, End)</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>isString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MyKind</name> <operator>==</operator> <name>String</name></expr>;</return> }</block>
<name>bool</name> <macro><name>isOperand</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MyKind</name> <operator>==</operator> <name>Operand</name></expr>;</return> }</block>

<specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><macro><name>getString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Str</name></expr>;</return> }</block>

<name>unsigned</name> <macro><name>getOperandNo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOperand</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>OperandNo</name></expr>;</return>
}</block>

<name>CharSourceRange</name> <macro><name>getRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isOperand</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Range is currently used only for Operands."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Range</name></expr>;</return>
}</block>



<name>char</name> <macro><name>getModifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;






<expr><name>unsigned</name> <macro><name>AnalyzeAsmString</name><argument_list>(<argument>SmallVectorImpl&lt;AsmStringPiece&gt; &amp;Pieces</argument>,
<argument>const ASTContext &amp;C</argument>, <argument>unsigned &amp;DiagOffs</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>std</name><operator>::</operator><name>string</name> <macro><name>generateAsmString</name><argument_list>(<argument>const ASTContext &amp;C</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>IdentifierInfo</name> <operator>*</operator><macro><name>getOutputIdentifier</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Names</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return> }</block>

<name>StringRef</name> <macro><name>getOutputName</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name> <init>= <expr><call><name>getOutputIdentifier</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>II</name><operator>-&gt;</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><block>{}</block></expr>;</return>
}</block>

<name>StringRef</name> <macro><name>getOutputConstraint</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><macro><name>getOutputConstraintLiteral</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Constraints</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
}</block>
<name>StringLiteral</name> <operator>*</operator><macro><name>getOutputConstraintLiteral</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>Constraints</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getOutputExpr</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getOutputExpr</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>GCCAsmStmt</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getOutputExpr</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>IdentifierInfo</name> <operator>*</operator><macro><name>getInputIdentifier</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Names</name><index>[<expr><name>i</name> <operator>+</operator> <name>NumOutputs</name></expr>]</index></name></expr>;</return>
}</block>

<name>StringRef</name> <macro><name>getInputName</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name> <init>= <expr><call><name>getInputIdentifier</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>II</name><operator>-&gt;</operator><name>getName</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>

<return>return <expr><block>{}</block></expr>;</return>
}</block>

<name>StringRef</name> <macro><name>getInputConstraint</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><macro><name>getInputConstraintLiteral</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Constraints</name><index>[<expr><name>i</name> <operator>+</operator> <name>NumOutputs</name></expr>]</index></name></expr>;</return>
}</block>
<name>StringLiteral</name> <operator>*</operator><macro><name>getInputConstraintLiteral</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>Constraints</name><index>[<expr><name>i</name> <operator>+</operator> <name>NumOutputs</name></expr>]</index></name></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getInputExpr</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>setInputExpr</name><argument_list>(<argument>unsigned i</argument>, <argument>Expr *E</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getInputExpr</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>GCCAsmStmt</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getInputExpr</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>bool</name> <macro><name>isAsmGoto</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumLabels</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumLabels</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumLabels</name></expr>;</return>
}</block>

<name>IdentifierInfo</name> <operator>*</operator><macro><name>getLabelIdentifier</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Names</name><index>[<expr><name>i</name> <operator>+</operator> <name>NumOutputs</name> <operator>+</operator> <name>NumInputs</name></expr>]</index></name></expr>;</return>
}</block>

<name>AddrLabelExpr</name> <operator>*</operator><macro><name>getLabelExpr</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>StringRef</name> <macro><name>getLabelName</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>using</name> <name>labels_iterator</name> <operator>=</operator> <name><name>CastIterator</name><argument_list type="generic">&lt;<argument><expr><name>AddrLabelExpr</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>const_labels_iterator</name> <operator>=</operator> <name><name>ConstCastIterator</name><argument_list type="generic">&lt;<argument><expr><name>AddrLabelExpr</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>labels_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>labels_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>labels_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_labels_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>labels_iterator</name> <macro><name>begin_labels</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NumOutputs</name> <operator>+</operator> <name>NumInputs</name></expr>;</return>
}</block>

<name>labels_iterator</name> <macro><name>end_labels</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NumOutputs</name> <operator>+</operator> <name>NumInputs</name> <operator>+</operator> <name>NumLabels</name></expr>;</return>
}</block>

<name>labels_range</name> <macro><name>labels</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>labels_range</name><argument_list>(<argument><expr><call><name>begin_labels</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>end_labels</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_labels_iterator</name> <macro><name>begin_labels</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NumOutputs</name> <operator>+</operator> <name>NumInputs</name></expr>;</return>
}</block>

<name>const_labels_iterator</name> <macro><name>end_labels</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>NumOutputs</name> <operator>+</operator> <name>NumInputs</name> <operator>+</operator> <name>NumLabels</name></expr>;</return>
}</block>

<name>labels_const_range</name> <macro><name>labels</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>labels_const_range</name><argument_list>(<argument><expr><call><name>begin_labels</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>end_labels</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>void</name> <macro><name>setOutputsAndInputsAndClobbers</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>IdentifierInfo **Names</argument>,
<argument>StringLiteral **Constraints</argument>,
<argument>Stmt **Exprs</argument>,
<argument>unsigned NumOutputs</argument>,
<argument>unsigned NumInputs</argument>,
<argument>unsigned NumLabels</argument>,
<argument>StringLiteral **Clobbers</argument>,
<argument>unsigned NumClobbers</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>





<name>int</name> <macro><name>getNamedOperand</name><argument_list>(<argument>StringRef SymbolicName</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>StringRef</name> <macro><name>getClobber</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>StringLiteral</name> <operator>*</operator><macro><name>getClobberStringLiteral</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <block>{ <return>return <expr><name><name>Clobbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return> }</block>
<specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><macro><name>getClobberStringLiteral</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Clobbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>AsmLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>GCCAsmStmtClass</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>MSAsmStmt</name> <operator>:</operator> <name>public</name> <name>AsmStmt</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>SourceLocation</name> <name>LBraceLoc</name></expr>, <expr><name>EndLoc</name></expr>;
<expr><name>StringRef</name> <name>AsmStr</name></expr>;

<expr><name>unsigned</name> <name>NumAsmToks</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>Token</name> <operator>*</operator><name>AsmToks</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>StringRef</name> <operator>*</operator><name>Constraints</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>StringRef</name> <operator>*</operator><name>Clobbers</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>MSAsmStmt</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation asmloc</argument>,
<argument>SourceLocation lbraceloc</argument>, <argument>bool issimple</argument>, <argument>bool isvolatile</argument>,
<argument>ArrayRef&lt;Token&gt; asmtoks</argument>, <argument>unsigned numoutputs</argument>, <argument>unsigned numinputs</argument>,
<argument>ArrayRef&lt;StringRef&gt; constraints</argument>,
<argument>ArrayRef&lt;Expr*&gt; exprs</argument>, <argument>StringRef asmstr</argument>,
<argument>ArrayRef&lt;StringRef&gt; clobbers</argument>, <argument>SourceLocation endloc</argument>)</argument_list></macro></expr>;


<expr><name>explicit</name> <macro><name>MSAsmStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>AsmStmt</name><argument_list>(<argument>MSAsmStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getLBraceLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LBraceLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLBraceLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LBraceLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EndLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setEndLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>EndLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>bool</name> <macro><name>hasBraces</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>LBraceLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>unsigned</name> <macro><name>getNumAsmToks</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>NumAsmToks</name></expr>;</return> }</block>
<name>Token</name> <operator>*</operator><macro><name>getAsmToks</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>AsmToks</name></expr>;</return> }</block>


<name>StringRef</name> <macro><name>getAsmString</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AsmStr</name></expr>;</return> }</block>


<name>std</name><operator>::</operator><name>string</name> <macro><name>generateAsmString</name><argument_list>(<argument>const ASTContext &amp;C</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>StringRef</name> <macro><name>getOutputConstraint</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name>NumOutputs</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Constraints</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getOutputExpr</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getOutputExpr</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>MSAsmStmt</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getOutputExpr</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>StringRef</name> <macro><name>getInputConstraint</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name>NumInputs</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Constraints</name><index>[<expr><name>i</name> <operator>+</operator> <name>NumOutputs</name></expr>]</index></name></expr>;</return>
}</block>

<name>Expr</name> <operator>*</operator><macro><name>getInputExpr</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro></expr>;
<expr><name>void</name> <macro><name>setInputExpr</name><argument_list>(<argument>unsigned i</argument>, <argument>Expr *E</argument>)</argument_list></macro></expr>;

<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getInputExpr</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>MSAsmStmt</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getInputExpr</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>getAllConstraints</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>Constraints</name></expr></argument>, <argument><expr><name>NumInputs</name> <operator>+</operator> <name>NumOutputs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>getClobbers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>Clobbers</name></expr></argument>, <argument><expr><name>NumClobbers</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getAllExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Exprs</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NumInputs</name> <operator>+</operator> <name>NumOutputs</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>StringRef</name> <macro><name>getClobber</name><argument_list>(<argument>unsigned i</argument>)</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getClobbers</name><argument_list>()</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</return> }</block>

<name>private</name><operator>:</operator>
<name>void</name> <macro><name>initialize</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>StringRef AsmString</argument>,
<argument>ArrayRef&lt;Token&gt; AsmToks</argument>, <argument>ArrayRef&lt;StringRef&gt; Constraints</argument>,
<argument>ArrayRef&lt;Expr*&gt; Exprs</argument>, <argument>ArrayRef&lt;StringRef&gt; Clobbers</argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>AsmLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>MSAsmStmtClass</name></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><name>NumInputs</name> <operator>+</operator> <name>NumOutputs</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>Exprs</name><index>[<expr><name>NumInputs</name> <operator>+</operator> <name>NumOutputs</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>SEHExceptStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>SourceLocation</name> <name>Loc</name></expr>;
<expr><name>Stmt</name> <operator>*</operator><name><name>Children</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;

enum <expr><block>{ <expr><name>FILTER_EXPR</name></expr>, <expr><name>BLOCK</name></expr> }</block></expr>;

<macro><name>SEHExceptStmt</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>Expr *FilterExpr</argument>, <argument>Stmt *Block</argument>)</argument_list></macro>;
<expr><name>explicit</name> <macro><name>SEHExceptStmt</name><argument_list>(<argument>EmptyShell E</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>SEHExceptStmtClass</argument>, <argument>E</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>SEHExceptStmt</name><operator>*</operator> <macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>SourceLocation ExceptLoc</argument>,
<argument>Expr *FilterExpr</argument>,
<argument>Stmt *Block</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name>getExceptLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getExceptLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getBlock</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>Expr</name> <operator>*</operator><macro><name>getFilterExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>Children</name><index>[<expr><name>FILTER_EXPR</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>CompoundStmt</name> <operator>*</operator><macro><name>getBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CompoundStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>Children</name><index>[<expr><name>BLOCK</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>Children</name></expr></argument>, <argument><expr><name>Children</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>Children</name></expr></argument>, <argument><expr><name>Children</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SEHExceptStmtClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>SEHFinallyStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>SourceLocation</name> <name>Loc</name></expr>;
<expr><name>Stmt</name> <operator>*</operator><name>Block</name></expr>;

<macro><name>SEHFinallyStmt</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>Stmt *Block</argument>)</argument_list></macro>;
<expr><name>explicit</name> <macro><name>SEHFinallyStmt</name><argument_list>(<argument>EmptyShell E</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>SEHFinallyStmtClass</argument>, <argument>E</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>SEHFinallyStmt</name><operator>*</operator> <macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>SourceLocation FinallyLoc</argument>,
<argument>Stmt *Block</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name>getFinallyLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getFinallyLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Block</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>CompoundStmt</name> <operator>*</operator><macro><name>getBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CompoundStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Block</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Block</name></expr></argument>,<argument><expr><operator>&amp;</operator><name>Block</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Block</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Block</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SEHFinallyStmtClass</name></expr>;</return>
}</block>
}</expr>;

<expr><name>class</name> <name>SEHTryStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>friend</name> <name>class</name> <name>ASTReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><name>bool</name> <name>IsCXXTry</name></expr>;
<expr><name>SourceLocation</name> <name>TryLoc</name></expr>;
<expr><name>Stmt</name> <operator>*</operator><name><name>Children</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;

enum <expr><block>{ <expr><name>TRY</name> <operator>=</operator> <literal type="number">0</literal></expr>, <expr><name>HANDLER</name> <operator>=</operator> <literal type="number">1</literal></expr> }</block></expr>;

<macro><name>SEHTryStmt</name><argument_list>(<argument>bool isCXXTry</argument>,
<argument>SourceLocation TryLoc</argument>,
<argument>Stmt *TryBlock</argument>,
<argument>Stmt *Handler</argument>)</argument_list></macro>;

<expr><name>explicit</name> <macro><name>SEHTryStmt</name><argument_list>(<argument>EmptyShell E</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>SEHTryStmtClass</argument>, <argument>E</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>SEHTryStmt</name><operator>*</operator> <macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>bool isCXXTry</argument>,
<argument>SourceLocation TryLoc</argument>, <argument>Stmt *TryBlock</argument>,
<argument>Stmt *Handler</argument>)</argument_list></macro></expr>;

<expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name>getTryLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getTryLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TryLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Children</name><index>[<expr><name>HANDLER</name></expr>]</index></name><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>getIsCXXTry</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsCXXTry</name></expr>;</return> }</block>

<name>CompoundStmt</name><operator>*</operator> <macro><name>getTryBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CompoundStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>Children</name><index>[<expr><name>TRY</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Stmt</name> <operator>*</operator><macro><name>getHandler</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Children</name><index>[<expr><name>HANDLER</name></expr>]</index></name></expr>;</return> }</block>


<name>SEHExceptStmt</name> <operator>*</operator><macro><name>getExceptHandler</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
<expr><name>SEHFinallyStmt</name> <operator>*</operator><macro><name>getFinallyHandler</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>Children</name></expr></argument>, <argument><expr><name>Children</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><name>Children</name></expr></argument>, <argument><expr><name>Children</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SEHTryStmtClass</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>SEHLeaveStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>SourceLocation</name> <name>LeaveLoc</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>SEHLeaveStmt</name><argument_list>(<argument>SourceLocation LL</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Stmt</name><argument_list>(<argument><expr><name>SEHLeaveStmtClass</name></expr></argument>)</argument_list></call></expr>, <macro><name>LeaveLoc</name><argument_list>(<argument>LL</argument>)</argument_list></macro> <expr><block>{}</block>


<name>explicit</name> <macro><name>SEHLeaveStmt</name><argument_list>(<argument>EmptyShell Empty</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Stmt</name><argument_list>(<argument>SEHLeaveStmtClass</argument>, <argument>Empty</argument>)</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getLeaveLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LeaveLoc</name></expr>;</return> }</block>
<name>void</name> <macro><name>setLeaveLoc</name><argument_list>(<argument>SourceLocation L</argument>)</argument_list></macro> <block>{ <expr><name>LeaveLoc</name> <operator>=</operator> <name>L</name></expr>; }</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>LeaveLoc</name></expr>;</return> }</block>
<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>LeaveLoc</name></expr>;</return> }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>SEHLeaveStmtClass</name></expr>;</return>
}</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>CapturedStmt</name> <operator>:</operator> <name>public</name> <name>Stmt</name> <block>{
<expr><name>public</name><operator>:</operator>


enum <name>VariableCaptureKind</name> <block>{
<expr><name>VCK_This</name></expr>,
<expr><name>VCK_ByRef</name></expr>,
<expr><name>VCK_ByCopy</name></expr>,
<expr><name>VCK_VLAType</name></expr>,
}</block></expr>;



<expr><name>class</name> <name>Capture</name> <block>{
<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>VariableCaptureKind</name></expr></argument>&gt;</argument_list></name> <name>VarAndKind</name></expr>;
<expr><name>SourceLocation</name> <name>Loc</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;








<macro><name>Capture</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>VariableCaptureKind Kind</argument>,
<argument>VarDecl *Var = nullptr</argument>)</argument_list></macro>;


<expr><name>VariableCaptureKind</name> <macro><name>getCaptureKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block>


<name>bool</name> <macro><name>capturesThis</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getCaptureKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>VCK_This</name></expr>;</return> }</block>


<name>bool</name> <macro><name>capturesVariable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getCaptureKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>VCK_ByRef</name></expr>;</return> }</block>


<name>bool</name> <macro><name>capturesVariableByCopy</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCaptureKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>VCK_ByCopy</name></expr>;</return>
}</block>



<name>bool</name> <macro><name>capturesVariableArrayType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getCaptureKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>VCK_VLAType</name></expr>;</return>
}</block>




<name>VarDecl</name> <operator>*</operator><macro><name>getCapturedVar</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;

<expr><name>private</name><operator>:</operator>

<name>unsigned</name> <name>NumCaptures</name></expr>;



<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>CapturedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>CapturedRegionKind</name></expr></argument>&gt;</argument_list></name> <name>CapDeclAndKind</name></expr>;


<expr><name>RecordDecl</name> <operator>*</operator><name>TheRecordDecl</name> <operator>=</operator> <name>nullptr</name></expr>;


<macro><name>CapturedStmt</name><argument_list>(<argument>Stmt *S</argument>, <argument>CapturedRegionKind Kind</argument>, <argument>ArrayRef&lt;Capture&gt; Captures</argument>,
<argument>ArrayRef&lt;Expr *&gt; CaptureInits</argument>, <argument>CapturedDecl *CD</argument>, <argument>RecordDecl *RD</argument>)</argument_list></macro>;


<macro><name>CapturedStmt</name><argument_list>(<argument>EmptyShell Empty</argument>, <argument>unsigned NumCaptures</argument>)</argument_list></macro>;

<expr><name>Stmt</name> <operator>*</operator><operator>*</operator><macro><name>getStoredStmts</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><macro><name>getStoredStmts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>Capture</name> <operator>*</operator><macro><name>getStoredCaptures</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>void</name> <macro><name>setCapturedStmt</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{ <expr><call><name>getStoredStmts</name><argument_list>()</argument_list></call><index>[<expr><name>NumCaptures</name></expr>]</index> <operator>=</operator> <name>S</name></expr>; }</block>

<name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>ASTStmtReader</name></expr>;

<expr><specifier>static</specifier> <name>CapturedStmt</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;Context</argument>, <argument>Stmt *S</argument>,
<argument>CapturedRegionKind Kind</argument>,
<argument>ArrayRef&lt;Capture&gt; Captures</argument>,
<argument>ArrayRef&lt;Expr *&gt; CaptureInits</argument>,
<argument>CapturedDecl *CD</argument>, <argument>RecordDecl *RD</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>CapturedStmt</name> <operator>*</operator><macro><name>CreateDeserialized</name><argument_list>(<argument>const ASTContext &amp;Context</argument>,
<argument>unsigned NumCaptures</argument>)</argument_list></macro></expr>;


<expr><name>Stmt</name> <operator>*</operator><macro><name>getCapturedStmt</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>getStoredStmts</name><argument_list>()</argument_list></call><index>[<expr><name>NumCaptures</name></expr>]</index></expr>;</return> }</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getCapturedStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getStoredStmts</name><argument_list>()</argument_list></call><index>[<expr><name>NumCaptures</name></expr>]</index></expr>;</return> }</block>


<name>CapturedDecl</name> <operator>*</operator><call><name>getCapturedDecl</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>CapturedDecl</name> <operator>*</operator><macro><name>getCapturedDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>void</name> <call><name>setCapturedDecl</name><argument_list>(<argument><expr><name>CapturedDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;


<expr><name>CapturedRegionKind</name> <macro><name>getCapturedRegionKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>void</name> <macro><name>setCapturedRegionKind</name><argument_list>(<argument>CapturedRegionKind Kind</argument>)</argument_list></macro></expr>;


<expr><specifier>const</specifier> <name>RecordDecl</name> <operator>*</operator><macro><name>getCapturedRecordDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TheRecordDecl</name></expr>;</return> }</block>


<name>void</name> <macro><name>setCapturedRecordDecl</name><argument_list>(<argument>RecordDecl *D</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>D</name> <operator>&amp;&amp;</operator> <literal type="string">"null RecordDecl"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>TheRecordDecl</name> <operator>=</operator> <name>D</name></expr>;
}</block>


<name>bool</name> <macro><name>capturesVariable</name><argument_list>(<argument>const VarDecl *Var</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>using</name> <name>capture_iterator</name> <operator>=</operator> <name>Capture</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>const_capture_iterator</name> <operator>=</operator> <specifier>const</specifier> <name>Capture</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>capture_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>capture_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>capture_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_capture_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>capture_range</name> <macro><name>captures</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>capture_range</name><argument_list>(<argument><expr><call><name>capture_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>capture_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>capture_const_range</name> <macro><name>captures</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>capture_const_range</name><argument_list>(<argument><expr><call><name>capture_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>capture_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>capture_iterator</name> <macro><name>capture_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>getStoredCaptures</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_capture_iterator</name> <macro><name>capture_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getStoredCaptures</name><argument_list>()</argument_list></call></expr>;</return> }</block>



<name>capture_iterator</name> <macro><name>capture_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getStoredCaptures</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumCaptures</name></expr>;</return>
}</block>


<name>unsigned</name> <macro><name>capture_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumCaptures</name></expr>;</return> }</block>


<name>using</name> <name>capture_init_iterator</name> <operator>=</operator> <name>Expr</name> <operator>*</operator><operator>*</operator></expr>;
<expr><name>using</name> <name>capture_init_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>capture_init_iterator</name></expr></argument>&gt;</argument_list></name></expr>;



<expr><name>using</name> <name>const_capture_init_iterator</name> <operator>=</operator> <name>Expr</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr>;
<expr><name>using</name> <name>const_capture_init_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_capture_init_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>capture_init_range</name> <macro><name>capture_inits</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>capture_init_range</name><argument_list>(<argument><expr><call><name>capture_init_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>capture_init_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_capture_init_range</name> <macro><name>capture_inits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_capture_init_range</name><argument_list>(<argument><expr><call><name>capture_init_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>capture_init_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>capture_init_iterator</name> <macro><name>capture_init_begin</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getStoredStmts</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_capture_init_iterator</name> <macro><name>capture_init_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getStoredStmts</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>capture_init_iterator</name> <macro><name>capture_init_end</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>capture_init_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumCaptures</name></expr>;</return>
}</block>

<name>const_capture_init_iterator</name> <macro><name>capture_init_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>capture_init_begin</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumCaptures</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getCapturedStmt</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getCapturedStmt</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>getCapturedStmt</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getSourceRange</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Stmt *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getStmtClass</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>CapturedStmtClass</name></expr>;</return>
}</block>

<name>child_range</name> <call><name>children</name><argument_list>()</argument_list></call></expr>;

<expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;

}</block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt></block_content></block></function></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
