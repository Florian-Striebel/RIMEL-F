<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/OpenMPClause.h">














<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_OPENMPCLAUSE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_OPENMPCLAUSE_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTFwd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclarationName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/NestedNameSpecifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Stmt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtIterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenMPKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/MapVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMPConstants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMPContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/TrailingObjects.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iterator&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>class</name></type> <name>OMPClause</name> <block>{<block_content>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>OpenMPClauseKind</name></type> <name>Kind</name></decl>;</decl_stmt>

<label><name>protected</name>:</label>
<macro><name>OMPClause</name><argument_list>(<argument>OpenMPClauseKind K</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>StartLoc</name><argument_list>(<argument><expr><name>StartLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>EndLoc</name><argument_list>(<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Kind</name><argument_list>(<argument>K</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>

<name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>StartLoc</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EndLoc</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setLocStart</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>StartLoc</name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt> </block_content>}</block></function>


<function><type><name>void</name></type> <name>setLocEnd</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>EndLoc</name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt> </block_content>}</block></function>


<expr_stmt><expr><name>OpenMPClauseKind</name> <macro><name>getClauseKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isImplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>StartLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>child_iterator</name> <init>= <expr><name>StmtIterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>const_child_iterator</name> <init>= <expr><name>ConstStmtIterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>child_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>child_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>const_child_range</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_child_iterator</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<function_decl><type><name>child_range</name></type> <name>children</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<function_decl><type><name>child_range</name></type> <name>used_children</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>classof</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPClause</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>true</name></expr>;</return> </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>OMPClauseWithPreInit</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>OMPClauseReader</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>PreInit</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>OpenMPDirectiveKind</name></type> <name>CaptureRegion</name> <init>= <expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPD_unknown</name></expr></init></decl>;</decl_stmt>

<label><name>protected</name>:</label>
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>const OMPClause *This</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr><name>This</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"get is not tuned for pre-init."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<decl_stmt><decl><type><name>void</name></type>
<name>setPreInitStmt</name><argument_list>(<argument><expr><name>Stmt</name> <operator>*</operator><name>S</name></expr></argument>,
<argument><expr><name>OpenMPDirectiveKind</name> <name>ThisRegion</name> <operator>=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPD_unknown</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>PreInit</name> <operator>=</operator> <name>S</name></expr>;</expr_stmt>
<expr_stmt><expr><name>CaptureRegion</name> <operator>=</operator> <name>ThisRegion</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<label><name>public</name>:</label>

<expr_stmt><expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getPreInitStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PreInit</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>Stmt</name> <modifier>*</modifier></type><name>getPreInitStmt</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>PreInit</name></expr>;</return> </block_content>}</block></function>


<expr_stmt><expr><name>OpenMPDirectiveKind</name> <macro><name>getCaptureRegion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CaptureRegion</name></expr>;</return> }</block></expr></expr_stmt>

<function_decl><type><specifier>static</specifier> <name>OMPClauseWithPreInit</name> <modifier>*</modifier></type><name>get</name><parameter_list>(<parameter><decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>C</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>OMPClauseWithPreInit</name> <modifier>*</modifier></type><name>get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OMPClause</name> <modifier>*</modifier></type><name>C</name></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>OMPClauseWithPostUpdate</name> <range>: <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>PostUpdate</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>protected</name><operator>:</operator>
<call><name>OMPClauseWithPostUpdate</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPClause</name> <operator>*</operator><name>This</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>This</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>get</name><argument_list>(<argument><expr><name>This</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"get is not tuned for post-update."</literal></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>setPostUpdateExpr</name><argument_list>(<argument>Expr *S</argument>)</argument_list></macro> <block>{ <expr><name>PostUpdate</name> <operator>=</operator> <name>S</name></expr>; }</block>

<name>public</name><operator>:</operator>

<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getPostUpdateExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PostUpdate</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getPostUpdateExpr</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>PostUpdate</name></expr>;</return> }</block>

<specifier>static</specifier> <name>OMPClauseWithPostUpdate</name> <operator>*</operator><call><name>get</name><argument_list>(<argument><expr><name>OMPClause</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <specifier>const</specifier> <name>OMPClauseWithPostUpdate</name> <operator>*</operator><call><name>get</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPClause</name> <operator>*</operator><name>C</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<struct>struct <name>OMPVarListLocTy</name> <block>{

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>OMPVarListLocTy</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>OMPVarListLocTy</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>StartLoc</name><argument_list>(<argument><expr><name>StartLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>EndLoc</name><argument_list>(<argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>OMPVarListClause</name> <range>: <expr><name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>unsigned</name> <name>NumVars</name></expr>;

<expr><name>protected</name><operator>:</operator>







<macro><name>OMPVarListClause</name><argument_list>(<argument>OpenMPClauseKind K</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>K</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>NumVars</name><argument_list>(<argument>N</argument>)</argument_list></macro> <expr><block>{}</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getVarRefs</name><argument_list>()</argument_list></macro> <block>{
<return>return <macro><name>MutableArrayRef</name></macro><expr><operator>&lt;</operator><name>Expr</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>template</name> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>, <name>NumVars</name><operator>)</operator></expr>;</return>
}</block>


<name>void</name> <macro><name>setVarRefs</name><argument_list>(<argument>ArrayRef&lt;Expr *&gt; VL</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>VL</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NumVars</name> <operator>&amp;&amp;</operator>
<literal type="string">"Number of variables is not the same as the preallocated buffer"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><macro><name>copy</name><argument_list>(<argument>VL.begin()</argument>, <argument>VL.end()</argument>,
<argument>static_cast&lt;T *&gt;(this)-&gt;template getTrailingObjects&lt;Expr *&gt;()</argument>)</argument_list></macro></expr>;
}</block>

<name>public</name><operator>:</operator>
<name>using</name> <name>varlist_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>varlist_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>varlist_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>varlist_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>varlist_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>varlist_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>unsigned</name> <macro><name>varlist_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumVars</name></expr>;</return> }</block>
<name>bool</name> <macro><name>varlist_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumVars</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return> }</block>

<name>varlist_range</name> <macro><name>varlists</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>varlist_range</name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>varlist_const_range</name> <macro><name>varlists</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>varlist_const_range</name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>varlist_iterator</name> <macro><name>varlist_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>getVarRefs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>varlist_iterator</name> <macro><name>varlist_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>getVarRefs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>varlist_const_iterator</name> <macro><name>varlist_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getVarRefs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>varlist_const_iterator</name> <macro><name>varlist_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getVarRefs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getVarRefs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><macro><name>makeArrayRef</name><argument_list>(
<argument>static_cast&lt;const T *&gt;(this)-&gt;template getTrailingObjects&lt;Expr *&gt;()</argument>,
<argument>NumVars</argument>)</argument_list></macro></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPAllocatorClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Allocator</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setAllocator</name><argument_list>(<argument>Expr *A</argument>)</argument_list></macro> <block>{ <expr><name>Allocator</name> <operator>=</operator> <name>A</name></expr>; }</block>

<name>public</name><operator>:</operator>






<macro><name>OMPAllocatorClause</name><argument_list>(<argument>Expr *A</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_allocator</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Allocator</name><argument_list>(<argument>A</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>OMPAllocatorClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_allocator</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getAllocator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Allocator</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Allocator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Allocator</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Allocator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Allocator</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_allocator</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPAllocateClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPAllocateClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPAllocateClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;



<expr><name>Expr</name> <operator>*</operator><name>Allocator</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;









<macro><name>OMPAllocateClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>Expr *Allocator</argument>, <argument>SourceLocation ColonLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPAllocateClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_allocate</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>,
<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Allocator</name><argument_list>(<argument><expr><name>Allocator</name></expr></argument>)</argument_list></call></expr>, <macro><name>ColonLoc</name><argument_list>(<argument>ColonLoc</argument>)</argument_list></macro> <expr><block>{}</block>




<name>explicit</name> <macro><name>OMPAllocateClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><operator>&lt;</operator><name>OMPAllocateClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_allocate</name>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <name>N</name><operator>)</operator> <block>{}</block>


<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation CL</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>CL</name></expr>; }</block>

<name>void</name> <macro><name>setAllocator</name><argument_list>(<argument>Expr *A</argument>)</argument_list></macro> <block>{ <expr><name>Allocator</name> <operator>=</operator> <name>A</name></expr>; }</block>

<name>public</name><operator>:</operator>









<specifier>static</specifier> <name>OMPAllocateClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>Expr *Allocator</argument>,
<argument>SourceLocation ColonLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getAllocator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Allocator</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>





<specifier>static</specifier> <name>OMPAllocateClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;

<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPAllocateClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_allocate</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPIfClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>, <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Condition</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;


<expr><name>OpenMPDirectiveKind</name> <name>NameModifier</name> <operator>=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPD_unknown</name></expr>;


<expr><name>SourceLocation</name> <name>NameModifierLoc</name></expr>;


<expr><name>void</name> <macro><name>setCondition</name><argument_list>(<argument>Expr *Cond</argument>)</argument_list></macro> <block>{ <expr><name>Condition</name> <operator>=</operator> <name>Cond</name></expr>; }</block>


<name>void</name> <macro><name>setNameModifier</name><argument_list>(<argument>OpenMPDirectiveKind NM</argument>)</argument_list></macro> <block>{ <expr><name>NameModifier</name> <operator>=</operator> <name>NM</name></expr>; }</block>


<name>void</name> <macro><name>setNameModifierLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>NameModifierLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>public</name><operator>:</operator>












<macro><name>OMPIfClause</name><argument_list>(<argument>OpenMPDirectiveKind NameModifier</argument>, <argument>Expr *Cond</argument>, <argument>Stmt *HelperCond</argument>,
<argument>OpenMPDirectiveKind CaptureRegion</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation NameModifierLoc</argument>,
<argument>SourceLocation ColonLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_if</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Condition</name><argument_list>(<argument><expr><name>Cond</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ColonLoc</name><argument_list>(<argument><expr><name>ColonLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NameModifier</name><argument_list>(<argument><expr><name>NameModifier</name></expr></argument>)</argument_list></call></expr>,
<macro><name>NameModifierLoc</name><argument_list>(<argument>NameModifierLoc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperCond</name></expr></argument>, <argument><expr><name>CaptureRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>


<call><name>OMPIfClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_if</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getCondition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Condition</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>OpenMPDirectiveKind</name> <macro><name>getNameModifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NameModifier</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getNameModifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NameModifierLoc</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Condition</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Condition</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Condition</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Condition</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<expr><name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPIfClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_if</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPFinalClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>, <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Condition</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setCondition</name><argument_list>(<argument>Expr *Cond</argument>)</argument_list></macro> <block>{ <expr><name>Condition</name> <operator>=</operator> <name>Cond</name></expr>; }</block>

<name>public</name><operator>:</operator>









<macro><name>OMPFinalClause</name><argument_list>(<argument>Expr *Cond</argument>, <argument>Stmt *HelperCond</argument>,
<argument>OpenMPDirectiveKind CaptureRegion</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_final</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Condition</name><argument_list>(<argument>Cond</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperCond</name></expr></argument>, <argument><expr><name>CaptureRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>


<call><name>OMPFinalClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_final</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getCondition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Condition</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Condition</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Condition</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Condition</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Condition</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<expr><name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPFinalClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_final</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPNumThreadsClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>, <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>NumThreads</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setNumThreads</name><argument_list>(<argument>Expr *NThreads</argument>)</argument_list></macro> <block>{ <expr><name>NumThreads</name> <operator>=</operator> <name>NThreads</name></expr>; }</block>

<name>public</name><operator>:</operator>









<macro><name>OMPNumThreadsClause</name><argument_list>(<argument>Expr *NumThreads</argument>, <argument>Stmt *HelperNumThreads</argument>,
<argument>OpenMPDirectiveKind CaptureRegion</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_num_threads</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>NumThreads</name><argument_list>(<argument>NumThreads</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperNumThreads</name></expr></argument>, <argument><expr><name>CaptureRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>


<call><name>OMPNumThreadsClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_num_threads</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getNumThreads</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>NumThreads</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NumThreads</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NumThreads</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NumThreads</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NumThreads</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_num_threads</name></expr>;</return>
}</block>
}</expr>;













<expr><name>class</name> <name>OMPSafelenClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Safelen</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setSafelen</name><argument_list>(<argument>Expr *Len</argument>)</argument_list></macro> <block>{ <expr><name>Safelen</name> <operator>=</operator> <name>Len</name></expr>; }</block>

<name>public</name><operator>:</operator>





<macro><name>OMPSafelenClause</name><argument_list>(<argument>Expr *Len</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_safelen</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Safelen</name><argument_list>(<argument>Len</argument>)</argument_list></macro> <expr><block>{}</block>


<name>explicit</name> <call><name>OMPSafelenClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_safelen</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{
}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getSafelen</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Safelen</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Safelen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Safelen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Safelen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Safelen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_safelen</name></expr>;</return>
}</block>
}</expr>;












<expr><name>class</name> <name>OMPSimdlenClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Simdlen</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setSimdlen</name><argument_list>(<argument>Expr *Len</argument>)</argument_list></macro> <block>{ <expr><name>Simdlen</name> <operator>=</operator> <name>Len</name></expr>; }</block>

<name>public</name><operator>:</operator>





<macro><name>OMPSimdlenClause</name><argument_list>(<argument>Expr *Len</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_simdlen</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Simdlen</name><argument_list>(<argument>Len</argument>)</argument_list></macro> <expr><block>{}</block>


<name>explicit</name> <call><name>OMPSimdlenClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_simdlen</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{
}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getSimdlen</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Simdlen</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Simdlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Simdlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Simdlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Simdlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_simdlen</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPSizesClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>OMPClause</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPSizesClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPSizesClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>unsigned</name> <name>NumSizes</name></expr>;


<expr><name>explicit</name> <macro><name>OMPSizesClause</name><argument_list>(<argument>int NumSizes</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_sizes</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>NumSizes</name><argument_list>(<argument>NumSizes</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPSizesClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;Expr *&gt; Sizes</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPSizesClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumSizes</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>unsigned</name> <macro><name>getNumSizes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumSizes</name></expr>;</return> }</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getSizesRefs</name><argument_list>()</argument_list></macro> <block>{
<return>return <macro><name>MutableArrayRef</name></macro><expr><operator>&lt;</operator><name>Expr</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPSizesClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><name>template</name> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>,
<name>NumSizes</name><operator>)</operator></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getSizesRefs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <macro><name>ArrayRef</name></macro><expr><operator>&lt;</operator><name>Expr</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>OMPSizesClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><name>template</name> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>,
<name>NumSizes</name><operator>)</operator></expr>;</return>
}</block>


<name>void</name> <macro><name>setSizesRefs</name><argument_list>(<argument>ArrayRef&lt;Expr *&gt; VL</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>VL</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NumSizes</name></expr></argument>)</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><macro><name>copy</name><argument_list>(<argument>VL.begin()</argument>, <argument>VL.end()</argument>,
<argument>static_cast&lt;OMPSizesClause *&gt;(this)
-&gt;template getTrailingObjects&lt;Expr *&gt;()</argument>)</argument_list></macro></expr>;
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Sizes</name> <operator>=</operator> <call><name>getSizesRefs</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Sizes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Sizes</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Sizes</name> <operator>=</operator> <call><name>getSizesRefs</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Sizes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Sizes</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_sizes</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPFullClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>explicit</name> <call><name>OMPFullClause</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_full</argument>, <argument>{}</argument>, <argument>{}</argument>)</argument_list></macro> <block>{}</block>

<name>public</name><operator>:</operator>





<specifier>static</specifier> <name>OMPFullClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro></expr>;




<expr><specifier>static</specifier> <name>OMPFullClause</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list></call></expr>;

<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><block>{<expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr>, <macro><name>child_iterator</name><argument_list>()</argument_list></macro>}</block></expr>;</return> }</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr>, <macro><name>const_child_iterator</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_full</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPPartialClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Factor</name></expr>;


<expr><name>explicit</name> <call><name>OMPPartialClause</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_partial</argument>, <argument>{}</argument>, <argument>{}</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setFactor</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Factor</name> <operator>=</operator> <name>E</name></expr>; }</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPPartialClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>Expr *Factor</argument>)</argument_list></macro></expr>;




<expr><specifier>static</specifier> <name>OMPPartialClause</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list></call></expr>;


<expr><name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getFactor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Factor</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Factor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Factor</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Factor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Factor</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_partial</name></expr>;</return>
}</block>
}</expr>;












<expr><name>class</name> <name>OMPCollapseClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>NumForLoops</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setNumForLoops</name><argument_list>(<argument>Expr *Num</argument>)</argument_list></macro> <block>{ <expr><name>NumForLoops</name> <operator>=</operator> <name>Num</name></expr>; }</block>

<name>public</name><operator>:</operator>






<macro><name>OMPCollapseClause</name><argument_list>(<argument>Expr *Num</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_collapse</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>NumForLoops</name><argument_list>(<argument>Num</argument>)</argument_list></macro> <expr><block>{}</block>


<name>explicit</name> <call><name>OMPCollapseClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_collapse</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getNumForLoops</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>NumForLoops</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NumForLoops</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NumForLoops</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NumForLoops</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NumForLoops</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_collapse</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPDefaultClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>DefaultKind</name> <name>Kind</name> <operator>=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMP_DEFAULT_unknown</name></expr>;


<expr><name>SourceLocation</name> <name>KindKwLoc</name></expr>;




<expr><name>void</name> <macro><name>setDefaultKind</name><argument_list>(<argument>llvm::omp::DefaultKind K</argument>)</argument_list></macro> <block>{ <expr><name>Kind</name> <operator>=</operator> <name>K</name></expr>; }</block>




<name>void</name> <macro><name>setDefaultKindKwLoc</name><argument_list>(<argument>SourceLocation KLoc</argument>)</argument_list></macro> <block>{ <expr><name>KindKwLoc</name> <operator>=</operator> <name>KLoc</name></expr>; }</block>

<name>public</name><operator>:</operator>







<macro><name>OMPDefaultClause</name><argument_list>(<argument>llvm::omp::DefaultKind A</argument>, <argument>SourceLocation ALoc</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_default</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Kind</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <macro><name>KindKwLoc</name><argument_list>(<argument>ALoc</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>OMPDefaultClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_default</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{
}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>llvm</name><operator>::</operator>omp<operator>::</operator><name>DefaultKind</name> <macro><name>getDefaultKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getDefaultKindKwLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>KindKwLoc</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_default</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPProcBindClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>ProcBindKind</name> <name>Kind</name> <operator>=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMP_PROC_BIND_unknown</name></expr>;


<expr><name>SourceLocation</name> <name>KindKwLoc</name></expr>;




<expr><name>void</name> <macro><name>setProcBindKind</name><argument_list>(<argument>llvm::omp::ProcBindKind K</argument>)</argument_list></macro> <block>{ <expr><name>Kind</name> <operator>=</operator> <name>K</name></expr>; }</block>




<name>void</name> <macro><name>setProcBindKindKwLoc</name><argument_list>(<argument>SourceLocation KLoc</argument>)</argument_list></macro> <block>{ <expr><name>KindKwLoc</name> <operator>=</operator> <name>KLoc</name></expr>; }</block>

<name>public</name><operator>:</operator>








<macro><name>OMPProcBindClause</name><argument_list>(<argument>llvm::omp::ProcBindKind A</argument>, <argument>SourceLocation ALoc</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_proc_bind</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Kind</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <macro><name>KindKwLoc</name><argument_list>(<argument>ALoc</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>OMPProcBindClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_proc_bind</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>llvm</name><operator>::</operator>omp<operator>::</operator><name>ProcBindKind</name> <macro><name>getProcBindKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getProcBindKindKwLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>KindKwLoc</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_proc_bind</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPUnifiedAddressClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;




<macro><name>OMPUnifiedAddressClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_unified_address</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>OMPUnifiedAddressClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_unified_address</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_unified_address</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPUnifiedSharedMemoryClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;




<macro><name>OMPUnifiedSharedMemoryClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_unified_shared_memory</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>OMPUnifiedSharedMemoryClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_unified_shared_memory</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_unified_shared_memory</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPReverseOffloadClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;




<macro><name>OMPReverseOffloadClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_reverse_offload</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>OMPReverseOffloadClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_reverse_offload</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_reverse_offload</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPDynamicAllocatorsClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;




<macro><name>OMPDynamicAllocatorsClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_dynamic_allocators</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>OMPDynamicAllocatorsClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_dynamic_allocators</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_dynamic_allocators</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPAtomicDefaultMemOrderClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>OpenMPAtomicDefaultMemOrderClauseKind</name> <name>Kind</name> <operator>=</operator>
<name>OMPC_ATOMIC_DEFAULT_MEM_ORDER_unknown</name></expr>;


<expr><name>SourceLocation</name> <name>KindKwLoc</name></expr>;




<expr><name>void</name> <macro><name>setAtomicDefaultMemOrderKind</name><argument_list>(<argument>OpenMPAtomicDefaultMemOrderClauseKind K</argument>)</argument_list></macro> <block>{
<expr><name>Kind</name> <operator>=</operator> <name>K</name></expr>;
}</block>




<name>void</name> <macro><name>setAtomicDefaultMemOrderKindKwLoc</name><argument_list>(<argument>SourceLocation KLoc</argument>)</argument_list></macro> <block>{
<expr><name>KindKwLoc</name> <operator>=</operator> <name>KLoc</name></expr>;
}</block>

<name>public</name><operator>:</operator>








<macro><name>OMPAtomicDefaultMemOrderClause</name><argument_list>(<argument>OpenMPAtomicDefaultMemOrderClauseKind A</argument>,
<argument>SourceLocation ALoc</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_atomic_default_mem_order</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Kind</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <macro><name>KindKwLoc</name><argument_list>(<argument>ALoc</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>OMPAtomicDefaultMemOrderClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_atomic_default_mem_order</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>OpenMPAtomicDefaultMemOrderClauseKind</name> <macro><name>getAtomicDefaultMemOrderKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Kind</name></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getAtomicDefaultMemOrderKindKwLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>KindKwLoc</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_atomic_default_mem_order</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPScheduleClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>, <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>OpenMPScheduleClauseKind</name> <name>Kind</name> <operator>=</operator> <name>OMPC_SCHEDULE_unknown</name></expr>;


enum <expr><block>{<expr><name>FIRST</name></expr>, <expr><name>SECOND</name></expr>, <expr><name>NUM_MODIFIERS</name></expr>}</block></expr>;
<expr><name>OpenMPScheduleClauseModifier</name> <name><name>Modifiers</name><index>[<expr><name>NUM_MODIFIERS</name></expr>]</index></name></expr>;


<expr><name>SourceLocation</name> <name><name>ModifiersLoc</name><index>[<expr><name>NUM_MODIFIERS</name></expr>]</index></name></expr>;


<expr><name>SourceLocation</name> <name>KindLoc</name></expr>;


<expr><name>SourceLocation</name> <name>CommaLoc</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>ChunkSize</name> <operator>=</operator> <name>nullptr</name></expr>;




<expr><name>void</name> <macro><name>setScheduleKind</name><argument_list>(<argument>OpenMPScheduleClauseKind K</argument>)</argument_list></macro> <block>{ <expr><name>Kind</name> <operator>=</operator> <name>K</name></expr>; }</block>




<name>void</name> <macro><name>setFirstScheduleModifier</name><argument_list>(<argument>OpenMPScheduleClauseModifier M</argument>)</argument_list></macro> <block>{
<expr><name><name>Modifiers</name><index>[<expr><name>FIRST</name></expr>]</index></name> <operator>=</operator> <name>M</name></expr>;
}</block>




<name>void</name> <macro><name>setSecondScheduleModifier</name><argument_list>(<argument>OpenMPScheduleClauseModifier M</argument>)</argument_list></macro> <block>{
<expr><name><name>Modifiers</name><index>[<expr><name>SECOND</name></expr>]</index></name> <operator>=</operator> <name>M</name></expr>;
}</block>


<name>void</name> <macro><name>setFirstScheduleModifierLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><name><name>ModifiersLoc</name><index>[<expr><name>FIRST</name></expr>]</index></name> <operator>=</operator> <name>Loc</name></expr>;
}</block>


<name>void</name> <macro><name>setSecondScheduleModifierLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><name><name>ModifiersLoc</name><index>[<expr><name>SECOND</name></expr>]</index></name> <operator>=</operator> <name>Loc</name></expr>;
}</block>




<name>void</name> <macro><name>setScheduleModifer</name><argument_list>(<argument>OpenMPScheduleClauseModifier M</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name><name>Modifiers</name><index>[<expr><name>FIRST</name></expr>]</index></name> <operator>==</operator> <name>OMPC_SCHEDULE_MODIFIER_unknown</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>Modifiers</name><index>[<expr><name>FIRST</name></expr>]</index></name> <operator>=</operator> <name>M</name></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>Modifiers</name><index>[<expr><name>SECOND</name></expr>]</index></name> <operator>==</operator> <name>OMPC_SCHEDULE_MODIFIER_unknown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Modifiers</name><index>[<expr><name>SECOND</name></expr>]</index></name> <operator>=</operator> <name>M</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}




void setLParenLoc(SourceLocation Loc</block></else></if_stmt>) <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block></block>




<name>void</name> <macro><name>setScheduleKindLoc</name><argument_list>(<argument>SourceLocation KLoc</argument>)</argument_list></macro> <block>{ <expr><name>KindLoc</name> <operator>=</operator> <name>KLoc</name></expr>; }</block>




<name>void</name> <macro><name>setCommaLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>CommaLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>




<name>void</name> <macro><name>setChunkSize</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>ChunkSize</name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>public</name><operator>:</operator>















<macro><name>OMPScheduleClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation KLoc</argument>, <argument>SourceLocation CommaLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>OpenMPScheduleClauseKind Kind</argument>,
<argument>Expr *ChunkSize</argument>, <argument>Stmt *HelperChunkSize</argument>,
<argument>OpenMPScheduleClauseModifier M1</argument>, <argument>SourceLocation M1Loc</argument>,
<argument>OpenMPScheduleClauseModifier M2</argument>, <argument>SourceLocation M2Loc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_schedule</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>KindLoc</name><argument_list>(<argument><expr><name>KLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>CommaLoc</name><argument_list>(<argument><expr><name>CommaLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>ChunkSize</name><argument_list>(<argument>ChunkSize</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperChunkSize</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>Modifiers</name><index>[<expr><name>FIRST</name></expr>]</index></name> <operator>=</operator> <name>M1</name></expr>;
<expr><name><name>Modifiers</name><index>[<expr><name>SECOND</name></expr>]</index></name> <operator>=</operator> <name>M2</name></expr>;
<expr><name><name>ModifiersLoc</name><index>[<expr><name>FIRST</name></expr>]</index></name> <operator>=</operator> <name>M1Loc</name></expr>;
<expr><name><name>ModifiersLoc</name><index>[<expr><name>SECOND</name></expr>]</index></name> <operator>=</operator> <name>M2Loc</name></expr>;
}</block>


<name>explicit</name> <call><name>OMPScheduleClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_schedule</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>Modifiers</name><index>[<expr><name>FIRST</name></expr>]</index></name> <operator>=</operator> <name>OMPC_SCHEDULE_MODIFIER_unknown</name></expr>;
<expr><name><name>Modifiers</name><index>[<expr><name>SECOND</name></expr>]</index></name> <operator>=</operator> <name>OMPC_SCHEDULE_MODIFIER_unknown</name></expr>;
}</block>


<name>OpenMPScheduleClauseKind</name> <macro><name>getScheduleKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block>


<name>OpenMPScheduleClauseModifier</name> <macro><name>getFirstScheduleModifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Modifiers</name><index>[<expr><name>FIRST</name></expr>]</index></name></expr>;</return>
}</block>


<name>OpenMPScheduleClauseModifier</name> <macro><name>getSecondScheduleModifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Modifiers</name><index>[<expr><name>SECOND</name></expr>]</index></name></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getScheduleKindLoc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>KindLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getFirstScheduleModifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ModifiersLoc</name><index>[<expr><name>FIRST</name></expr>]</index></name></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getSecondScheduleModifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>ModifiersLoc</name><index>[<expr><name>SECOND</name></expr>]</index></name></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getCommaLoc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>CommaLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getChunkSize</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>ChunkSize</name></expr>;</return> }</block>


<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getChunkSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ChunkSize</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ChunkSize</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ChunkSize</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPScheduleClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_schedule</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPOrderedClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>OMPClause</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPOrderedClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>NumForLoops</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>unsigned</name> <name>NumberOfLoops</name> <operator>=</operator> <literal type="number">0</literal></expr>;








<macro><name>OMPOrderedClause</name><argument_list>(<argument>Expr *Num</argument>, <argument>unsigned NumLoops</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_ordered</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NumForLoops</name><argument_list>(<argument><expr><name>Num</name></expr></argument>)</argument_list></call></expr>, <macro><name>NumberOfLoops</name><argument_list>(<argument>NumLoops</argument>)</argument_list></macro> <expr><block>{}</block>


<name>explicit</name> <macro><name>OMPOrderedClause</name><argument_list>(<argument>unsigned NumLoops</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_ordered</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>NumberOfLoops</name><argument_list>(<argument>NumLoops</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setNumForLoops</name><argument_list>(<argument>Expr *Num</argument>)</argument_list></macro> <block>{ <expr><name>NumForLoops</name> <operator>=</operator> <name>Num</name></expr>; }</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPOrderedClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>Expr *Num</argument>,
<argument>unsigned NumLoops</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro></expr>;


<expr><specifier>static</specifier> <name>OMPOrderedClause</name><operator>*</operator> <macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumLoops</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getNumForLoops</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>NumForLoops</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>void</name> <macro><name>setLoopNumIterations</name><argument_list>(<argument>unsigned NumLoop</argument>, <argument>Expr *NumIterations</argument>)</argument_list></macro></expr>;

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getLoopNumIterations</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>void</name> <macro><name>setLoopCounter</name><argument_list>(<argument>unsigned NumLoop</argument>, <argument>Expr *Counter</argument>)</argument_list></macro></expr>;

<expr><name>Expr</name> <operator>*</operator><macro><name>getLoopCounter</name><argument_list>(<argument>unsigned NumLoop</argument>)</argument_list></macro></expr>;
<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getLoopCounter</name><argument_list>(<argument>unsigned NumLoop</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NumForLoops</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NumForLoops</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NumForLoops</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NumForLoops</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_ordered</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPNowaitClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPNowaitClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_nowait</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPNowaitClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_nowait</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_nowait</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPUntiedClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPUntiedClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_untied</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPUntiedClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_untied</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_untied</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPMergeableClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPMergeableClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_mergeable</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPMergeableClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_mergeable</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_mergeable</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPReadClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPReadClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_read</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPReadClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_read</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_read</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPWriteClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPWriteClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_write</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPWriteClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_write</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_write</name></expr>;</return>
}</block>
}</expr>;
















<expr><name>class</name> <name>OMPUpdateClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>OMPClause</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPUpdateClause</name></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>,
<argument><expr><name>OpenMPDependClauseKind</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>bool</name> <name>IsExtended</name> <operator>=</operator> <name>false</name></expr>;



<expr><name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;SourceLocation&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<return>return <expr><name>IsExtended</name> <operator>?</operator> <literal type="number">2</literal> <operator>:</operator> <literal type="number">0</literal></expr>;</return>
}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>IsExtended</name> <operator>&amp;&amp;</operator> <literal type="string">"Expected extended clause."</literal></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>=</operator> <name>Loc</name></expr>;
}</block>


<name>void</name> <macro><name>setArgumentLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>IsExtended</name> <operator>&amp;&amp;</operator> <literal type="string">"Expected extended clause."</literal></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><name>std</name><operator>::</operator><call><name>next</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>=</operator> <name>Loc</name></expr>;
}</block>


<name>void</name> <macro><name>setDependencyKind</name><argument_list>(<argument>OpenMPDependClauseKind DK</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>IsExtended</name> <operator>&amp;&amp;</operator> <literal type="string">"Expected extended clause."</literal></expr></argument>)</argument_list></call></expr>;
<expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPDependClauseKind</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>=</operator> <name>DK</name></expr>;
}</block>





<macro><name>OMPUpdateClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>bool IsExtended</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_update</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>IsExtended</name><argument_list>(<argument>IsExtended</argument>)</argument_list></macro> <expr><block>{}</block>


<macro><name>OMPUpdateClause</name><argument_list>(<argument>bool IsExtended</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_update</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>IsExtended</name><argument_list>(<argument>IsExtended</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>





<specifier>static</specifier> <name>OMPUpdateClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro></expr>;









<expr><specifier>static</specifier> <name>OMPUpdateClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation ArgumentLoc</argument>,
<argument>OpenMPDependClauseKind DK</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro></expr>;






<expr><specifier>static</specifier> <name>OMPUpdateClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>bool IsExtended</argument>)</argument_list></macro></expr>;


<expr><name>bool</name> <macro><name>isExtended</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsExtended</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>IsExtended</name> <operator>&amp;&amp;</operator> <literal type="string">"Expected extended clause."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getArgumentLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>IsExtended</name> <operator>&amp;&amp;</operator> <literal type="string">"Expected extended clause."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>std</name><operator>::</operator><call><name>next</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>OpenMPDependClauseKind</name> <macro><name>getDependencyKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>IsExtended</name> <operator>&amp;&amp;</operator> <literal type="string">"Expected extended clause."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPDependClauseKind</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_update</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPCaptureClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPCaptureClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_capture</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPCaptureClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_capture</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_capture</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPSeqCstClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPSeqCstClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_seq_cst</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPSeqCstClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_seq_cst</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_seq_cst</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPAcqRelClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPAcqRelClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_acq_rel</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPAcqRelClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_acq_rel</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_acq_rel</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPAcquireClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPAcquireClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_acquire</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPAcquireClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_acquire</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_acquire</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPReleaseClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPReleaseClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_release</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPReleaseClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_release</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_release</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPRelaxedClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPRelaxedClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_relaxed</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPRelaxedClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_relaxed</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_relaxed</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPPrivateClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPPrivateClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPPrivateClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;







<macro><name>OMPPrivateClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><expr><operator>&lt;</operator><name>OMPPrivateClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_private</name>, <name>StartLoc</name>,
<name>LParenLoc</name>, <name>EndLoc</name>, <name>N</name><operator>)</operator> <block>{}</block>




<name>explicit</name> <macro><name>OMPPrivateClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><operator>&lt;</operator><name>OMPPrivateClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_private</name>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <name>N</name><operator>)</operator> <block>{}</block>




<name>void</name> <call><name>setPrivateCopies</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>VL</name></expr></argument>)</argument_list></call></expr>;



<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivateCopies</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivateCopies</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPPrivateClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>,
<argument>ArrayRef&lt;Expr *&gt; PrivateVL</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPPrivateClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;

<expr><name>using</name> <name>private_copies_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>private_copies_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>private_copies_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>private_copies_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>private_copies_const_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>private_copies_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>private_copies_range</name> <macro><name>private_copies</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>private_copies_range</name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private_copies_const_range</name> <macro><name>private_copies</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>private_copies_const_range</name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPPrivateClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_private</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPFirstprivateClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPFirstprivateClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>public</name> <name>OMPClauseWithPreInit</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPFirstprivateClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;







<macro><name>OMPFirstprivateClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPFirstprivateClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_firstprivate</name></expr></argument>,
<argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>




<name>explicit</name> <macro><name>OMPFirstprivateClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPFirstprivateClause</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_firstprivate</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>




<name>void</name> <call><name>setPrivateCopies</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>VL</name></expr></argument>)</argument_list></call></expr>;



<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivateCopies</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivateCopies</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>void</name> <call><name>setInits</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>VL</name></expr></argument>)</argument_list></call></expr>;



<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getInits</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getInits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>













<specifier>static</specifier> <name>OMPFirstprivateClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>, <argument>ArrayRef&lt;Expr *&gt; PrivateVL</argument>,
<argument>ArrayRef&lt;Expr *&gt; InitVL</argument>, <argument>Stmt *PreInit</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPFirstprivateClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;

<expr><name>using</name> <name>private_copies_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>private_copies_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>private_copies_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>private_copies_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>private_copies_const_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>private_copies_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>private_copies_range</name> <macro><name>private_copies</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>private_copies_range</name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>private_copies_const_range</name> <macro><name>private_copies</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>private_copies_const_range</name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>inits_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>inits_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>inits_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>inits_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>inits_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>inits_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>inits_range</name> <macro><name>inits</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>inits_range</name><argument_list>(<argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>inits_const_range</name> <macro><name>inits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>inits_const_range</name><argument_list>(<argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPFirstprivateClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPFirstprivateClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_firstprivate</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPLastprivateClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPLastprivateClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>public</name> <name>OMPClauseWithPostUpdate</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPLastprivateClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
















<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>OpenMPLastprivateModifier</name> <name>LPKind</name></expr>;

<expr><name>SourceLocation</name> <name>LPKindLoc</name></expr>;

<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;







<macro><name>OMPLastprivateClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>OpenMPLastprivateModifier LPKind</argument>,
<argument>SourceLocation LPKindLoc</argument>, <argument>SourceLocation ColonLoc</argument>,
<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPLastprivateClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_lastprivate</name></expr></argument>,
<argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPostUpdate</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LPKind</name><argument_list>(<argument><expr><name>LPKind</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LPKindLoc</name><argument_list>(<argument><expr><name>LPKindLoc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>ColonLoc</name><argument_list>(<argument>ColonLoc</argument>)</argument_list></macro> <expr><block>{}</block>




<name>explicit</name> <macro><name>OMPLastprivateClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPLastprivateClause</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_lastprivate</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPostUpdate</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>



<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivateCopies</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivateCopies</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name>void</name> <call><name>setSourceExprs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>SrcExprs</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getSourceExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getSourceExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name>void</name> <call><name>setDestinationExprs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>DstExprs</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getDestinationExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getDestinationExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>void</name> <call><name>setAssignmentOps</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>AssignmentOps</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getAssignmentOps</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getAssignmentOps</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>void</name> <macro><name>setKind</name><argument_list>(<argument>OpenMPLastprivateModifier Kind</argument>)</argument_list></macro> <block>{ <expr><name>LPKind</name> <operator>=</operator> <name>Kind</name></expr>; }</block>

<name>void</name> <macro><name>setKindLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LPKindLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>public</name><operator>:</operator>



























<specifier>static</specifier> <name>OMPLastprivateClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>, <argument>ArrayRef&lt;Expr *&gt; SrcExprs</argument>,
<argument>ArrayRef&lt;Expr *&gt; DstExprs</argument>, <argument>ArrayRef&lt;Expr *&gt; AssignmentOps</argument>,
<argument>OpenMPLastprivateModifier LPKind</argument>, <argument>SourceLocation LPKindLoc</argument>,
<argument>SourceLocation ColonLoc</argument>, <argument>Stmt *PreInit</argument>, <argument>Expr *PostUpdate</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPLastprivateClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;


<expr><name>OpenMPLastprivateModifier</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LPKind</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getKindLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LPKindLoc</name></expr>;</return> }</block>

<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>

<name>using</name> <name>helper_expr_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>helper_expr_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>helper_expr_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>helper_expr_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>helper_expr_const_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>helper_expr_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;



<expr><name>void</name> <call><name>setPrivateCopies</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>PrivateCopies</name></expr></argument>)</argument_list></call></expr>;

<expr><name>helper_expr_const_range</name> <macro><name>private_copies</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>private_copies</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>source_exprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>source_exprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>destination_exprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>destination_exprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>assignment_ops</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getAssignmentOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getAssignmentOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>assignment_ops</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getAssignmentOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getAssignmentOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPLastprivateClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_lastprivate</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPSharedClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPSharedClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPSharedClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;







<macro><name>OMPSharedClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><expr><operator>&lt;</operator><name>OMPSharedClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_shared</name>, <name>StartLoc</name>,
<name>LParenLoc</name>, <name>EndLoc</name>, <name>N</name><operator>)</operator> <block>{}</block>




<name>explicit</name> <macro><name>OMPSharedClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><operator>&lt;</operator><name>OMPSharedClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_shared</name>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <name>N</name><operator>)</operator> <block>{}</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPSharedClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPSharedClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;

<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPSharedClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_shared</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPReductionClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPReductionClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>public</name> <name>OMPClauseWithPostUpdate</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPReductionClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>OpenMPReductionClauseModifier</name> <name>Modifier</name> <operator>=</operator> <name>OMPC_REDUCTION_unknown</name></expr>;


<expr><name>SourceLocation</name> <name>ModifierLoc</name></expr>;


<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;


<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;


<expr><name>DeclarationNameInfo</name> <name>NameInfo</name></expr>;











<macro><name>OMPReductionClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation ModifierLoc</argument>, <argument>SourceLocation ColonLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>OpenMPReductionClauseModifier Modifier</argument>, <argument>unsigned N</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPReductionClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_reduction</name></expr></argument>,
<argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPostUpdate</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Modifier</name><argument_list>(<argument><expr><name>Modifier</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ModifierLoc</name><argument_list>(<argument><expr><name>ModifierLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ColonLoc</name><argument_list>(<argument><expr><name>ColonLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>QualifierLoc</name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>NameInfo</name><argument_list>(<argument>NameInfo</argument>)</argument_list></macro> <expr><block>{}</block>




<name>explicit</name> <macro><name>OMPReductionClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPReductionClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_reduction</name></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPostUpdate</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setModifier</name><argument_list>(<argument>OpenMPReductionClauseModifier M</argument>)</argument_list></macro> <block>{ <expr><name>Modifier</name> <operator>=</operator> <name>M</name></expr>; }</block>


<name>void</name> <macro><name>setModifierLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>ModifierLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation CL</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>CL</name></expr>; }</block>


<name>void</name> <macro><name>setNameInfo</name><argument_list>(<argument>DeclarationNameInfo DNI</argument>)</argument_list></macro> <block>{ <expr><name>NameInfo</name> <operator>=</operator> <name>DNI</name></expr>; }</block>


<name>void</name> <macro><name>setQualifierLoc</name><argument_list>(<argument>NestedNameSpecifierLoc NSL</argument>)</argument_list></macro> <block>{ <expr><name>QualifierLoc</name> <operator>=</operator> <name>NSL</name></expr>; }</block>




<name>void</name> <call><name>setPrivates</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Privates</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivates</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>void</name> <call><name>setLHSExprs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>LHSExprs</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getLHSExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getLHSExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>






<name>void</name> <call><name>setRHSExprs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>RHSExprs</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getRHSExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getRHSExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name>void</name> <call><name>setReductionOps</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ReductionOps</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getReductionOps</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getReductionOps</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>void</name> <call><name>setInscanCopyOps</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Ops</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getInscanCopyOps</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getInscanCopyOps</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>void</name> <call><name>setInscanCopyArrayTemps</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CopyArrayTemps</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getInscanCopyArrayTemps</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getInscanCopyOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getInscanCopyArrayTemps</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getInscanCopyOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>void</name> <call><name>setInscanCopyArrayElems</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>CopyArrayElems</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getInscanCopyArrayElems</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getInscanCopyArrayTemps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getInscanCopyArrayElems</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getInscanCopyArrayTemps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>







































<specifier>static</specifier> <name>OMPReductionClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation ModifierLoc</argument>, <argument>SourceLocation ColonLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>OpenMPReductionClauseModifier Modifier</argument>,
<argument>ArrayRef&lt;Expr *&gt; VL</argument>, <argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>ArrayRef&lt;Expr *&gt; Privates</argument>,
<argument>ArrayRef&lt;Expr *&gt; LHSExprs</argument>, <argument>ArrayRef&lt;Expr *&gt; RHSExprs</argument>,
<argument>ArrayRef&lt;Expr *&gt; ReductionOps</argument>, <argument>ArrayRef&lt;Expr *&gt; CopyOps</argument>,
<argument>ArrayRef&lt;Expr *&gt; CopyArrayTemps</argument>, <argument>ArrayRef&lt;Expr *&gt; CopyArrayElems</argument>,
<argument>Stmt *PreInit</argument>, <argument>Expr *PostUpdate</argument>)</argument_list></macro></expr>;






<expr><specifier>static</specifier> <name>OMPReductionClause</name> <operator>*</operator>
<macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>,
<argument>OpenMPReductionClauseModifier Modifier</argument>)</argument_list></macro></expr>;


<expr><name>OpenMPReductionClauseModifier</name> <macro><name>getModifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Modifier</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getModifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ModifierLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>


<specifier>const</specifier> <name>DeclarationNameInfo</name> <operator>&amp;</operator><macro><name>getNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NameInfo</name></expr>;</return> }</block>


<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualifierLoc</name></expr>;</return> }</block>

<name>using</name> <name>helper_expr_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>helper_expr_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>helper_expr_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>helper_expr_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>helper_expr_const_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>helper_expr_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>helper_expr_const_range</name> <macro><name>privates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>privates</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>lhs_exprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>lhs_exprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>rhs_exprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>rhs_exprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>reduction_ops</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>reduction_ops</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>copy_ops</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getInscanCopyOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getInscanCopyOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>copy_ops</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getInscanCopyOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getInscanCopyOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>copy_array_temps</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getInscanCopyArrayTemps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getInscanCopyArrayTemps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>copy_array_temps</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getInscanCopyArrayTemps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getInscanCopyArrayTemps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>copy_array_elems</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getInscanCopyArrayElems</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getInscanCopyArrayElems</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>copy_array_elems</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getInscanCopyArrayElems</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getInscanCopyArrayElems</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPReductionClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPReductionClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_reduction</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPTaskReductionClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPTaskReductionClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>public</name> <name>OMPClauseWithPostUpdate</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPTaskReductionClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;


<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;


<expr><name>DeclarationNameInfo</name> <name>NameInfo</name></expr>;










<macro><name>OMPTaskReductionClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation ColonLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned N</argument>, <argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPTaskReductionClause</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_task_reduction</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPostUpdate</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ColonLoc</name><argument_list>(<argument><expr><name>ColonLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>QualifierLoc</name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>NameInfo</name><argument_list>(<argument>NameInfo</argument>)</argument_list></macro> <expr><block>{}</block>




<name>explicit</name> <macro><name>OMPTaskReductionClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPTaskReductionClause</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_task_reduction</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPostUpdate</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation CL</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>CL</name></expr>; }</block>


<name>void</name> <macro><name>setNameInfo</name><argument_list>(<argument>DeclarationNameInfo DNI</argument>)</argument_list></macro> <block>{ <expr><name>NameInfo</name> <operator>=</operator> <name>DNI</name></expr>; }</block>


<name>void</name> <macro><name>setQualifierLoc</name><argument_list>(<argument>NestedNameSpecifierLoc NSL</argument>)</argument_list></macro> <block>{ <expr><name>QualifierLoc</name> <operator>=</operator> <name>NSL</name></expr>; }</block>



<name>void</name> <call><name>setPrivates</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Privates</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivates</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>void</name> <call><name>setLHSExprs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>LHSExprs</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getLHSExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getLHSExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name>void</name> <call><name>setRHSExprs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>RHSExprs</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getRHSExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getRHSExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name>void</name> <call><name>setReductionOps</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ReductionOps</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getReductionOps</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getReductionOps</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
































<specifier>static</specifier> <name>OMPTaskReductionClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation ColonLoc</argument>, <argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>ArrayRef&lt;Expr *&gt; Privates</argument>,
<argument>ArrayRef&lt;Expr *&gt; LHSExprs</argument>, <argument>ArrayRef&lt;Expr *&gt; RHSExprs</argument>,
<argument>ArrayRef&lt;Expr *&gt; ReductionOps</argument>, <argument>Stmt *PreInit</argument>, <argument>Expr *PostUpdate</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPTaskReductionClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;


<expr><name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>


<specifier>const</specifier> <name>DeclarationNameInfo</name> <operator>&amp;</operator><macro><name>getNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NameInfo</name></expr>;</return> }</block>


<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualifierLoc</name></expr>;</return> }</block>

<name>using</name> <name>helper_expr_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>helper_expr_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>helper_expr_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>helper_expr_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>helper_expr_const_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>helper_expr_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>helper_expr_const_range</name> <macro><name>privates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>privates</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>lhs_exprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>lhs_exprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>rhs_exprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>rhs_exprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>reduction_ops</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>reduction_ops</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPTaskReductionClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_task_reduction</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPInReductionClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPInReductionClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>public</name> <name>OMPClauseWithPostUpdate</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPInReductionClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;


<expr><name>NestedNameSpecifierLoc</name> <name>QualifierLoc</name></expr>;


<expr><name>DeclarationNameInfo</name> <name>NameInfo</name></expr>;










<macro><name>OMPInReductionClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation ColonLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned N</argument>, <argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPInReductionClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_in_reduction</name></expr></argument>,
<argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPostUpdate</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ColonLoc</name><argument_list>(<argument><expr><name>ColonLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>QualifierLoc</name><argument_list>(<argument><expr><name>QualifierLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>NameInfo</name><argument_list>(<argument>NameInfo</argument>)</argument_list></macro> <expr><block>{}</block>




<name>explicit</name> <macro><name>OMPInReductionClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPInReductionClause</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_in_reduction</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPostUpdate</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation CL</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>CL</name></expr>; }</block>


<name>void</name> <macro><name>setNameInfo</name><argument_list>(<argument>DeclarationNameInfo DNI</argument>)</argument_list></macro> <block>{ <expr><name>NameInfo</name> <operator>=</operator> <name>DNI</name></expr>; }</block>


<name>void</name> <macro><name>setQualifierLoc</name><argument_list>(<argument>NestedNameSpecifierLoc NSL</argument>)</argument_list></macro> <block>{ <expr><name>QualifierLoc</name> <operator>=</operator> <name>NSL</name></expr>; }</block>



<name>void</name> <call><name>setPrivates</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Privates</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivates</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>void</name> <call><name>setLHSExprs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>LHSExprs</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getLHSExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getLHSExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name>void</name> <call><name>setRHSExprs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>RHSExprs</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getRHSExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getRHSExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name>void</name> <call><name>setReductionOps</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ReductionOps</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getReductionOps</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getReductionOps</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>void</name> <call><name>setTaskgroupDescriptors</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ReductionOps</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getTaskgroupDescriptors</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getTaskgroupDescriptors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>


































<specifier>static</specifier> <name>OMPInReductionClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation ColonLoc</argument>, <argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>,
<argument>NestedNameSpecifierLoc QualifierLoc</argument>,
<argument>const DeclarationNameInfo &amp;NameInfo</argument>, <argument>ArrayRef&lt;Expr *&gt; Privates</argument>,
<argument>ArrayRef&lt;Expr *&gt; LHSExprs</argument>, <argument>ArrayRef&lt;Expr *&gt; RHSExprs</argument>,
<argument>ArrayRef&lt;Expr *&gt; ReductionOps</argument>, <argument>ArrayRef&lt;Expr *&gt; TaskgroupDescriptors</argument>,
<argument>Stmt *PreInit</argument>, <argument>Expr *PostUpdate</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPInReductionClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;


<expr><name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>


<specifier>const</specifier> <name>DeclarationNameInfo</name> <operator>&amp;</operator><macro><name>getNameInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NameInfo</name></expr>;</return> }</block>


<name>NestedNameSpecifierLoc</name> <macro><name>getQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualifierLoc</name></expr>;</return> }</block>

<name>using</name> <name>helper_expr_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>helper_expr_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>helper_expr_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>helper_expr_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>helper_expr_const_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>helper_expr_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>helper_expr_const_range</name> <macro><name>privates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>privates</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>lhs_exprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>lhs_exprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getLHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>rhs_exprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>rhs_exprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getRHSExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>reduction_ops</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>reduction_ops</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getReductionOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>taskgroup_descriptors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getTaskgroupDescriptors</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getTaskgroupDescriptors</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>taskgroup_descriptors</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getTaskgroupDescriptors</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getTaskgroupDescriptors</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPInReductionClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_in_reduction</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPLinearClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPLinearClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>public</name> <name>OMPClauseWithPostUpdate</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPLinearClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>OpenMPLinearClauseKind</name> <name>Modifier</name> <operator>=</operator> <name>OMPC_LINEAR_val</name></expr>;


<expr><name>SourceLocation</name> <name>ModifierLoc</name></expr>;


<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;


<expr><name>void</name> <macro><name>setStep</name><argument_list>(<argument>Expr *Step</argument>)</argument_list></macro> <block>{ <expr><operator>*</operator><operator>(</operator><call><name>getFinals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call><operator>)</operator> <operator>=</operator> <name>Step</name></expr>; }</block>


<name>void</name> <macro><name>setCalcStep</name><argument_list>(<argument>Expr *CalcStep</argument>)</argument_list></macro> <block>{ <expr><operator>*</operator><operator>(</operator><call><name>getFinals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <name>CalcStep</name></expr>; }</block>








<macro><name>OMPLinearClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>OpenMPLinearClauseKind Modifier</argument>, <argument>SourceLocation ModifierLoc</argument>,
<argument>SourceLocation ColonLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned NumVars</argument>)</argument_list></macro>
<operator>:</operator> <call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPLinearClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_linear</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>,
<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>NumVars</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPostUpdate</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Modifier</name><argument_list>(<argument><expr><name>Modifier</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ModifierLoc</name><argument_list>(<argument><expr><name>ModifierLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>ColonLoc</name><argument_list>(<argument>ColonLoc</argument>)</argument_list></macro> <expr><block>{}</block>




<name>explicit</name> <macro><name>OMPLinearClause</name><argument_list>(<argument>unsigned NumVars</argument>)</argument_list></macro>
<operator>:</operator> <call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPLinearClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_linear</name></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NumVars</name></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPostUpdate</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>













<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivates</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getInits</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getInits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getUpdates</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getUpdates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getFinals</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getUpdates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getFinals</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getUpdates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getUsedExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getFinals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getUsedExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getFinals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>void</name> <call><name>setPrivates</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>PL</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <call><name>setInits</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>IL</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>



















<specifier>static</specifier> <name>OMPLinearClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>OpenMPLinearClauseKind Modifier</argument>, <argument>SourceLocation ModifierLoc</argument>,
<argument>SourceLocation ColonLoc</argument>, <argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>,
<argument>ArrayRef&lt;Expr *&gt; PL</argument>, <argument>ArrayRef&lt;Expr *&gt; IL</argument>, <argument>Expr *Step</argument>, <argument>Expr *CalcStep</argument>,
<argument>Stmt *PreInit</argument>, <argument>Expr *PostUpdate</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPLinearClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumVars</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <macro><name>setModifier</name><argument_list>(<argument>OpenMPLinearClauseKind Kind</argument>)</argument_list></macro> <block>{ <expr><name>Modifier</name> <operator>=</operator> <name>Kind</name></expr>; }</block>


<name>OpenMPLinearClauseKind</name> <macro><name>getModifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Modifier</name></expr>;</return> }</block>


<name>void</name> <macro><name>setModifierLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>ModifierLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getModifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ModifierLoc</name></expr>;</return> }</block>


<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getStep</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><operator>*</operator><operator>(</operator><call><name>getFinals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return> }</block>


<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getStep</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><operator>(</operator><call><name>getFinals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getCalcStep</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><operator>*</operator><operator>(</operator><call><name>getFinals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return> }</block>


<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getCalcStep</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><operator>(</operator><call><name>getFinals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return> }</block>



<name>void</name> <call><name>setUpdates</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>UL</name></expr></argument>)</argument_list></call></expr>;



<expr><name>void</name> <call><name>setFinals</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>FL</name></expr></argument>)</argument_list></call></expr>;


<expr><name>void</name> <call><name>setUsedExprs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>UE</name></expr></argument>)</argument_list></call></expr>;

<expr><name>using</name> <name>privates_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>privates_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>privates_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>privates_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>privates_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>privates_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>privates_range</name> <macro><name>privates</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>privates_range</name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>privates_const_range</name> <macro><name>privates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>privates_const_range</name><argument_list>(<argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getPrivates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>inits_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>inits_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>inits_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>inits_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>inits_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>inits_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>inits_range</name> <macro><name>inits</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>inits_range</name><argument_list>(<argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>inits_const_range</name> <macro><name>inits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>inits_const_range</name><argument_list>(<argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>updates_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>updates_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>updates_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>updates_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>updates_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>updates_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>updates_range</name> <macro><name>updates</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>updates_range</name><argument_list>(<argument><expr><call><name>getUpdates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getUpdates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>updates_const_range</name> <macro><name>updates</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>updates_const_range</name><argument_list>(<argument><expr><call><name>getUpdates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getUpdates</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>finals_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>finals_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>finals_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>finals_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>finals_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>finals_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>finals_range</name> <macro><name>finals</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>finals_range</name><argument_list>(<argument><expr><call><name>getFinals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getFinals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>finals_const_range</name> <macro><name>finals</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>finals_const_range</name><argument_list>(<argument><expr><call><name>getFinals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getFinals</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>used_expressions_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>used_expressions_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>used_expressions_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>used_expressions_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>used_expressions_const_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>used_expressions_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>used_expressions_range</name> <macro><name>used_expressions</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>finals_range</name><argument_list>(<argument><expr><call><name>getUsedExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getUsedExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>used_expressions_const_range</name> <macro><name>used_expressions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>finals_const_range</name><argument_list>(<argument><expr><call><name>getUsedExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getUsedExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPLinearClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <call><name>used_children</name><argument_list>()</argument_list></call></expr>;

<expr><name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPLinearClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_linear</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPAlignedClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPAlignedClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPAlignedClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;


<expr><name>void</name> <macro><name>setAlignment</name><argument_list>(<argument>Expr *A</argument>)</argument_list></macro> <block>{ <expr><operator>*</operator><call><name>varlist_end</name><argument_list>()</argument_list></call> <operator>=</operator> <name>A</name></expr>; }</block>








<macro><name>OMPAlignedClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation ColonLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>unsigned NumVars</argument>)</argument_list></macro>
<operator>:</operator> <call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPAlignedClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_aligned</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>,
<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>NumVars</name></expr></argument>)</argument_list></call></expr>,
<macro><name>ColonLoc</name><argument_list>(<argument>ColonLoc</argument>)</argument_list></macro> <expr><block>{}</block>




<name>explicit</name> <macro><name>OMPAlignedClause</name><argument_list>(<argument>unsigned NumVars</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><operator>&lt;</operator><name>OMPAlignedClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_aligned</name>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <name>NumVars</name><operator>)</operator> <block>{}</block>

<name>public</name><operator>:</operator>









<specifier>static</specifier> <name>OMPAlignedClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation ColonLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>,
<argument>Expr *A</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPAlignedClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned NumVars</argument>)</argument_list></macro></expr>;


<expr><name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getAlignment</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><operator>*</operator><call><name>varlist_end</name><argument_list>()</argument_list></call></expr>;</return> }</block>


<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getAlignment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><call><name>varlist_end</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPAlignedClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_aligned</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPCopyinClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPCopyinClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPCopyinClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{













<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;







<macro><name>OMPCopyinClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><expr><operator>&lt;</operator><name>OMPCopyinClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_copyin</name>, <name>StartLoc</name>,
<name>LParenLoc</name>, <name>EndLoc</name>, <name>N</name><operator>)</operator> <block>{}</block>




<name>explicit</name> <macro><name>OMPCopyinClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><operator>&lt;</operator><name>OMPCopyinClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_copyin</name>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <name>N</name><operator>)</operator> <block>{}</block>




<name>void</name> <call><name>setSourceExprs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>SrcExprs</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getSourceExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getSourceExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>void</name> <call><name>setDestinationExprs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>DstExprs</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getDestinationExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getDestinationExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name>void</name> <call><name>setAssignmentOps</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>AssignmentOps</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getAssignmentOps</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getAssignmentOps</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>





















<specifier>static</specifier> <name>OMPCopyinClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>, <argument>ArrayRef&lt;Expr *&gt; SrcExprs</argument>,
<argument>ArrayRef&lt;Expr *&gt; DstExprs</argument>, <argument>ArrayRef&lt;Expr *&gt; AssignmentOps</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPCopyinClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;

<expr><name>using</name> <name>helper_expr_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>helper_expr_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>helper_expr_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>helper_expr_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>helper_expr_const_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>helper_expr_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>helper_expr_const_range</name> <macro><name>source_exprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>source_exprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>destination_exprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>destination_exprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>assignment_ops</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getAssignmentOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getAssignmentOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>assignment_ops</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getAssignmentOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getAssignmentOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPCopyinClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_copyin</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPCopyprivateClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPCopyprivateClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPCopyprivateClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;







<macro><name>OMPCopyprivateClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><expr><operator>&lt;</operator><name>OMPCopyprivateClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_copyprivate</name>,
<name>StartLoc</name>, <name>LParenLoc</name>, <name>EndLoc</name>, <name>N</name><operator>)</operator> <block>{
}</block>




<name>explicit</name> <macro><name>OMPCopyprivateClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><operator>&lt;</operator><name>OMPCopyprivateClause</name><operator>&gt;</operator><operator>(</operator>
<name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_copyprivate</name>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <name>N</name><operator>)</operator> <block>{}</block>




<name>void</name> <call><name>setSourceExprs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>SrcExprs</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getSourceExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getSourceExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>void</name> <call><name>setDestinationExprs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>DstExprs</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getDestinationExprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getDestinationExprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>





<name>void</name> <call><name>setAssignmentOps</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>AssignmentOps</name></expr></argument>)</argument_list></call></expr>;


<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getAssignmentOps</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getAssignmentOps</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>




















<specifier>static</specifier> <name>OMPCopyprivateClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>, <argument>ArrayRef&lt;Expr *&gt; SrcExprs</argument>,
<argument>ArrayRef&lt;Expr *&gt; DstExprs</argument>, <argument>ArrayRef&lt;Expr *&gt; AssignmentOps</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPCopyprivateClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;

<expr><name>using</name> <name>helper_expr_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>helper_expr_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>helper_expr_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>helper_expr_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>helper_expr_const_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>helper_expr_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>helper_expr_const_range</name> <macro><name>source_exprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>source_exprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getSourceExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>destination_exprs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>destination_exprs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getDestinationExprs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_const_range</name> <macro><name>assignment_ops</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>helper_expr_const_range</name><argument_list>(<argument><expr><call><name>getAssignmentOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getAssignmentOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>helper_expr_range</name> <macro><name>assignment_ops</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>helper_expr_range</name><argument_list>(<argument><expr><call><name>getAssignmentOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getAssignmentOps</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPCopyprivateClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_copyprivate</name></expr>;</return>
}</block>
}</expr>;













<expr><name>class</name> <name>OMPFlushClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPFlushClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPFlushClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;







<macro><name>OMPFlushClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><expr><operator>&lt;</operator><name>OMPFlushClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_flush</name>, <name>StartLoc</name>,
<name>LParenLoc</name>, <name>EndLoc</name>, <name>N</name><operator>)</operator> <block>{}</block>




<name>explicit</name> <macro><name>OMPFlushClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><operator>&lt;</operator><name>OMPFlushClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_flush</name>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <name>N</name><operator>)</operator> <block>{}</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPFlushClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation EndLoc</argument>,
<argument>ArrayRef&lt;Expr *&gt; VL</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPFlushClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;

<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPFlushClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_flush</name></expr>;</return>
}</block>
}</expr>;













<expr><name>class</name> <name>OMPDepobjClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>Depobj</name> <operator>=</operator> <name>nullptr</name></expr>;






<macro><name>OMPDepobjClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_depobj</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>LParenLoc</name><argument_list>(<argument>LParenLoc</argument>)</argument_list></macro> <expr><block>{}</block>



<name>explicit</name> <call><name>OMPDepobjClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_depobj</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>void</name> <macro><name>setDepobj</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Depobj</name> <operator>=</operator> <name>E</name></expr>; }</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPDepobjClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>Expr *Depobj</argument>)</argument_list></macro></expr>;




<expr><specifier>static</specifier> <name>OMPDepobjClause</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>)</argument_list></call></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getDepobj</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Depobj</name></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getDepobj</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Depobj</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Depobj</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Depobj</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPDepobjClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_depobj</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPDependClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPDependClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPDependClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>OpenMPDependClauseKind</name> <name>DepKind</name> <operator>=</operator> <name>OMPC_DEPEND_unknown</name></expr>;


<expr><name>SourceLocation</name> <name>DepLoc</name></expr>;


<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;


<expr><name>unsigned</name> <name>NumLoops</name> <operator>=</operator> <literal type="number">0</literal></expr>;









<macro><name>OMPDependClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>, <argument>unsigned NumLoops</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPDependClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_depend</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>,
<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<macro><name>NumLoops</name><argument_list>(<argument>NumLoops</argument>)</argument_list></macro> <expr><block>{}</block>






<name>explicit</name> <macro><name>OMPDependClause</name><argument_list>(<argument>unsigned N</argument>, <argument>unsigned NumLoops</argument>)</argument_list></macro>
<operator>:</operator> <call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPDependClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_depend</name></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<macro><name>NumLoops</name><argument_list>(<argument>NumLoops</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setDependencyKind</name><argument_list>(<argument>OpenMPDependClauseKind K</argument>)</argument_list></macro> <block>{ <expr><name>DepKind</name> <operator>=</operator> <name>K</name></expr>; }</block>


<name>void</name> <macro><name>setDependencyLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>DepLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>void</name> <call><name>setModifier</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>DepModifier</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>












<specifier>static</specifier> <name>OMPDependClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>Expr *DepModifier</argument>,
<argument>OpenMPDependClauseKind DepKind</argument>,
<argument>SourceLocation DepLoc</argument>, <argument>SourceLocation ColonLoc</argument>,
<argument>ArrayRef&lt;Expr *&gt; VL</argument>, <argument>unsigned NumLoops</argument>)</argument_list></macro></expr>;







<expr><specifier>static</specifier> <name>OMPDependClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>,
<argument>unsigned NumLoops</argument>)</argument_list></macro></expr>;


<expr><name>OpenMPDependClauseKind</name> <macro><name>getDependencyKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DepKind</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><call><name>getModifier</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getModifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPDependClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getModifier</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getDependencyLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DepLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>


<name>unsigned</name> <macro><name>getNumLoops</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumLoops</name></expr>;</return> }</block>



<name>void</name> <macro><name>setLoopData</name><argument_list>(<argument>unsigned NumLoop</argument>, <argument>Expr *Cnt</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getLoopData</name><argument_list>(<argument>unsigned NumLoop</argument>)</argument_list></macro></expr>;
<expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getLoopData</name><argument_list>(<argument>unsigned NumLoop</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPDependClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_depend</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPDeviceClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>, <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>OpenMPDeviceClauseModifier</name> <name>Modifier</name> <operator>=</operator> <name>OMPC_DEVICE_unknown</name></expr>;


<expr><name>SourceLocation</name> <name>ModifierLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Device</name> <operator>=</operator> <name>nullptr</name></expr>;




<expr><name>void</name> <macro><name>setDevice</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Device</name> <operator>=</operator> <name>E</name></expr>; }</block>


<name>void</name> <macro><name>setModifier</name><argument_list>(<argument>OpenMPDeviceClauseModifier M</argument>)</argument_list></macro> <block>{ <expr><name>Modifier</name> <operator>=</operator> <name>M</name></expr>; }</block>


<name>void</name> <macro><name>setModifierLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>ModifierLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>public</name><operator>:</operator>










<macro><name>OMPDeviceClause</name><argument_list>(<argument>OpenMPDeviceClauseModifier Modifier</argument>, <argument>Expr *E</argument>, <argument>Stmt *HelperE</argument>,
<argument>OpenMPDirectiveKind CaptureRegion</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation ModifierLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_device</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Modifier</name><argument_list>(<argument><expr><name>Modifier</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ModifierLoc</name><argument_list>(<argument><expr><name>ModifierLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Device</name><argument_list>(<argument>E</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperE</name></expr></argument>, <argument><expr><name>CaptureRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>


<call><name>OMPDeviceClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_device</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getDevice</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Device</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getDevice</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Device</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>OpenMPDeviceClauseModifier</name> <macro><name>getModifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Modifier</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getModifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ModifierLoc</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Device</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Device</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Device</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Device</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_device</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPThreadsClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPThreadsClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_threads</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPThreadsClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_threads</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_threads</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPSIMDClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPSIMDClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_simd</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPSIMDClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_simd</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_simd</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>OMPClauseMappableExprCommon</name> <block>{
<expr><name>public</name><operator>:</operator>






<name>class</name> <name>MappableComponent</name> <block>{


<expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>AssociatedExpressionNonContiguousPr</name></expr>;




<expr><name>ValueDecl</name> <operator>*</operator><name>AssociatedDeclaration</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <call><name>MappableComponent</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<expr><name>explicit</name> <macro><name>MappableComponent</name><argument_list>(<argument>Expr *AssociatedExpression</argument>,
<argument>ValueDecl *AssociatedDeclaration</argument>,
<argument>bool IsNonContiguous</argument>)</argument_list></macro>
<operator>:</operator> <call><name>AssociatedExpressionNonContiguousPr</name><argument_list>(<argument><expr><name>AssociatedExpression</name></expr></argument>,
<argument><expr><name>IsNonContiguous</name></expr></argument>)</argument_list></call></expr>,
<macro><name>AssociatedDeclaration</name><argument_list>(
<argument>AssociatedDeclaration
? cast&lt;ValueDecl&gt;(AssociatedDeclaration-&gt;getCanonicalDecl())
: nullptr</argument>)</argument_list></macro> <expr><block>{}</block>

<name>Expr</name> <operator>*</operator><macro><name>getAssociatedExpression</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>AssociatedExpressionNonContiguousPr</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isNonContiguous</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>AssociatedExpressionNonContiguousPr</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ValueDecl</name> <operator>*</operator><macro><name>getAssociatedDeclaration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>AssociatedDeclaration</name></expr>;</return>
}</block>
}</expr>;



<expr><name>using</name> <name>MappableExprComponentList</name> <operator>=</operator> <name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>MappableComponent</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>MappableExprComponentListRef</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>MappableComponent</name></expr></argument>&gt;</argument_list></name></expr>;




<expr><name>using</name> <name>MappableExprComponentLists</name> <operator>=</operator> <name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>MappableExprComponentList</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>MappableExprComponentListsRef</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>MappableExprComponentList</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>protected</name><operator>:</operator>

<specifier>static</specifier> <name>unsigned</name>
<macro><name>getComponentsTotalNumber</name><argument_list>(<argument>MappableExprComponentListsRef ComponentLists</argument>)</argument_list></macro></expr>;



<expr><specifier>static</specifier> <name>unsigned</name>
<call><name>getUniqueDeclarationsTotalNumber</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Declarations</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;



struct <expr><name>OMPMappableExprListSizeTy</name> <block>{

<expr><name>unsigned</name> <name>NumVars</name></expr>;

<expr><name>unsigned</name> <name>NumUniqueDeclarations</name></expr>;

<expr><name>unsigned</name> <name>NumComponentLists</name></expr>;

<expr><name>unsigned</name> <name>NumComponents</name></expr>;
<expr><call><name>OMPMappableExprListSizeTy</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;
<macro><name>OMPMappableExprListSizeTy</name><argument_list>(<argument>unsigned NumVars</argument>, <argument>unsigned NumUniqueDeclarations</argument>,
<argument>unsigned NumComponentLists</argument>, <argument>unsigned NumComponents</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>NumVars</name><argument_list>(<argument><expr><name>NumVars</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NumUniqueDeclarations</name><argument_list>(<argument><expr><name>NumUniqueDeclarations</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NumComponentLists</name><argument_list>(<argument><expr><name>NumComponentLists</name></expr></argument>)</argument_list></call></expr>, <macro><name>NumComponents</name><argument_list>(<argument>NumComponents</argument>)</argument_list></macro> <expr><block>{}</block></expr>
}</block></expr>;





<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>OMPMappableExprListClause</name> <operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>public</name> <name>OMPClauseMappableExprCommon</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>unsigned</name> <name>NumUniqueDeclarations</name></expr>;


<expr><name>unsigned</name> <name>NumComponentLists</name></expr>;


<expr><name>unsigned</name> <name>NumComponents</name></expr>;




<expr><specifier>const</specifier> <name>bool</name> <name>SupportsMapper</name></expr>;


<expr><name>NestedNameSpecifierLoc</name> <name>MapperQualifierLoc</name></expr>;


<expr><name>DeclarationNameInfo</name> <name>MapperIdInfo</name></expr>;

<expr><name>protected</name><operator>:</operator>


















<macro><name>OMPMappableExprListClause</name><argument_list>(
<argument>OpenMPClauseKind K</argument>, <argument>const OMPVarListLocTy &amp;Locs</argument>,
<argument>const OMPMappableExprListSizeTy &amp;Sizes</argument>, <argument>bool SupportsMapper = false</argument>,
<argument>NestedNameSpecifierLoc *MapperQualifierLocPtr = nullptr</argument>,
<argument>DeclarationNameInfo *MapperIdInfoPtr = nullptr</argument>)</argument_list></macro>
<operator>:</operator> <call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>K</name></expr></argument>, <argument><expr><name><name>Locs</name><operator>.</operator><name>StartLoc</name></name></expr></argument>, <argument><expr><name><name>Locs</name><operator>.</operator><name>LParenLoc</name></name></expr></argument>, <argument><expr><name><name>Locs</name><operator>.</operator><name>EndLoc</name></name></expr></argument>,
<argument><expr><name><name>Sizes</name><operator>.</operator><name>NumVars</name></name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NumUniqueDeclarations</name><argument_list>(<argument><expr><name><name>Sizes</name><operator>.</operator><name>NumUniqueDeclarations</name></name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NumComponentLists</name><argument_list>(<argument><expr><name><name>Sizes</name><operator>.</operator><name>NumComponentLists</name></name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>NumComponents</name><argument_list>(<argument><expr><name><name>Sizes</name><operator>.</operator><name>NumComponents</name></name></expr></argument>)</argument_list></call></expr>, <macro><name>SupportsMapper</name><argument_list>(<argument>SupportsMapper</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><name>MapperQualifierLocPtr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>MapperQualifierLoc</name> <operator>=</operator> <operator>*</operator><name>MapperQualifierLocPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><name>MapperIdInfoPtr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>MapperIdInfo</name> <operator>=</operator> <operator>*</operator><name>MapperIdInfoPtr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>



<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getUniqueDeclsRef</name><argument_list>()</argument_list></macro> <block>{
<return>return <macro><name>MutableArrayRef</name></macro><expr><operator>&lt;</operator><name>ValueDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>template</name> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>,
<name>NumUniqueDeclarations</name><operator>)</operator></expr>;</return>
}</block>



<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getUniqueDeclsRef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <macro><name>ArrayRef</name></macro><expr><operator>&lt;</operator><name>ValueDecl</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><name>template</name> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>,
<name>NumUniqueDeclarations</name><operator>)</operator></expr>;</return>
}</block>



<name>void</name> <macro><name>setUniqueDecls</name><argument_list>(<argument>ArrayRef&lt;ValueDecl *&gt; UDs</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>UDs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NumUniqueDeclarations</name> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected amount of unique declarations."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><call><name>copy</name><argument_list>(<argument><expr><call><name><name>UDs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>UDs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getUniqueDeclsRef</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>



<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <macro><name>getDeclNumListsRef</name><argument_list>()</argument_list></macro> <block>{
<return>return <macro><name>MutableArrayRef</name></macro><expr><operator>&lt;</operator><name>unsigned</name><operator>&gt;</operator><operator>(</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>template</name> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>,
<name>NumUniqueDeclarations</name><operator>)</operator></expr>;</return>
}</block>



<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <macro><name>getDeclNumListsRef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <macro><name>ArrayRef</name></macro><expr><operator>&lt;</operator><name>unsigned</name><operator>&gt;</operator><operator>(</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>template</name> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>,
<name>NumUniqueDeclarations</name><operator>)</operator></expr>;</return>
}</block>



<name>void</name> <macro><name>setDeclNumLists</name><argument_list>(<argument>ArrayRef&lt;unsigned&gt; DNLs</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>DNLs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NumUniqueDeclarations</name> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected amount of list numbers."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><call><name>copy</name><argument_list>(<argument><expr><call><name><name>DNLs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>DNLs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getDeclNumListsRef</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>



<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <macro><name>getComponentListSizesRef</name><argument_list>()</argument_list></macro> <block>{
<return>return <macro><name>MutableArrayRef</name></macro><expr><operator>&lt;</operator><name>unsigned</name><operator>&gt;</operator><operator>(</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>template</name> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<name>NumUniqueDeclarations</name>,
<name>NumComponentLists</name><operator>)</operator></expr>;</return>
}</block>



<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <macro><name>getComponentListSizesRef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <macro><name>ArrayRef</name></macro><expr><operator>&lt;</operator><name>unsigned</name><operator>&gt;</operator><operator>(</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>template</name> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<name>NumUniqueDeclarations</name>,
<name>NumComponentLists</name><operator>)</operator></expr>;</return>
}</block>



<name>void</name> <macro><name>setComponentListSizes</name><argument_list>(<argument>ArrayRef&lt;unsigned&gt; CLSs</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>CLSs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NumComponentLists</name> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected amount of component lists."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><call><name>copy</name><argument_list>(<argument><expr><call><name><name>CLSs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>CLSs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getComponentListSizesRef</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>MappableComponent</name></expr></argument>&gt;</argument_list></name> <macro><name>getComponentsRef</name><argument_list>()</argument_list></macro> <block>{
<return>return <macro><name>MutableArrayRef</name></macro><expr><operator>&lt;</operator><name>MappableComponent</name><operator>&gt;</operator><operator>(</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><name>template</name> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>MappableComponent</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>,
<name>NumComponents</name><operator>)</operator></expr>;</return>
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>MappableComponent</name></expr></argument>&gt;</argument_list></name> <macro><name>getComponentsRef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <macro><name>ArrayRef</name></macro><expr><operator>&lt;</operator><name>MappableComponent</name><operator>&gt;</operator><operator>(</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><name>template</name> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>MappableComponent</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call>,
<name>NumComponents</name><operator>)</operator></expr>;</return>
}</block>




<name>void</name> <macro><name>setComponents</name><argument_list>(<argument>ArrayRef&lt;MappableComponent&gt; Components</argument>,
<argument>ArrayRef&lt;unsigned&gt; CLSs</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Components</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NumComponents</name> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected amount of component lists."</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>CLSs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NumComponentLists</name> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected amount of list sizes."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><call><name>copy</name><argument_list>(<argument><expr><call><name><name>Components</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Components</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getComponentsRef</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>



<name>void</name> <macro><name>setClauseInfo</name><argument_list>(<argument>ArrayRef&lt;ValueDecl *&gt; Declarations</argument>,
<argument>MappableExprComponentListsRef ComponentLists</argument>)</argument_list></macro> <block>{


<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getUniqueDeclarationsTotalNumber</name><argument_list>(<argument><expr><name>Declarations</name></expr></argument>)</argument_list></call> <operator>==</operator>
<name>NumUniqueDeclarations</name> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected number of mappable expression info entries!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getComponentsTotalNumber</name><argument_list>(<argument><expr><name>ComponentLists</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NumComponents</name> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected total number of components!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Declarations</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>ComponentLists</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Declaration and component lists size is not consistent!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Declarations</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NumComponentLists</name> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected declaration and component lists size!"</literal></expr></argument>)</argument_list></call></expr>;




<expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>MappableExprComponentListRef</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>ComponentListMap</name></expr>;
<expr><block>{
<expr><name>auto</name> <name>CI</name> <operator>=</operator> <call><name><name>ComponentLists</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;
<for>for <control>(<init><decl><type><name>auto</name></type> <name>DI</name> <init>= <expr><call><name><name>Declarations</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>DE</name> <init>= <expr><call><name><name>Declarations</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>DI</name> <operator>!=</operator> <name>DE</name></expr>;</condition>
<incr><expr><operator>++</operator><name>DI</name></expr>, <expr><operator>++</operator><name>CI</name></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>CI</name><operator>-&gt;</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid component list!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ComponentListMap</name><index>[<expr><operator>*</operator><name>DI</name></expr>]</index></name><operator>.</operator><call><name>push_back</name><argument_list>(<argument><expr><operator>*</operator><name>CI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}


auto UniqueDeclarations = getUniqueDeclsRef(</block></for>)</block></expr>;
<expr><name>auto</name> <name>UDI</name> <operator>=</operator> <call><name><name>UniqueDeclarations</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;

<expr><name>auto</name> <name>DeclNumLists</name> <operator>=</operator> <call><name>getDeclNumListsRef</name><argument_list>()</argument_list></call></expr>;
<expr><name>auto</name> <name>DNLI</name> <operator>=</operator> <call><name><name>DeclNumLists</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;

<expr><name>auto</name> <name>ComponentListSizes</name> <operator>=</operator> <call><name>getComponentListSizesRef</name><argument_list>()</argument_list></call></expr>;
<expr><name>auto</name> <name>CLSI</name> <operator>=</operator> <call><name><name>ComponentListSizes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;

<expr><name>auto</name> <name>Components</name> <operator>=</operator> <call><name>getComponentsRef</name><argument_list>()</argument_list></call></expr>;
<expr><name>auto</name> <name>CI</name> <operator>=</operator> <call><name><name>Components</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;


<expr><name>unsigned</name> <name>PrevSize</name> <operator>=</operator> <literal type="number">0u</literal></expr>;


<for>for <control>(<init><expr><name>auto</name> <operator>&amp;</operator><name>M</name> <operator>:</operator> <name>ComponentListMap</name></expr></init>)</control> <block>{<block_content>

<expr_stmt><expr><name>auto</name> <operator>*</operator><name>D</name> <operator>=</operator> <name><name>M</name><operator>.</operator><name>first</name></name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>auto</name></type> <name>CL</name> <init>= <expr><name><name>M</name><operator>.</operator><name>second</name></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><operator>*</operator><name>UDI</name> <operator>=</operator> <name>D</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>UDI</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>DNLI</name> <operator>=</operator> <call><name><name>CL</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>DNLI</name></expr>;</expr_stmt>



<for>for <control>(<init><decl><type><name>auto</name></type> <name>C</name> <range>: <expr><name>CL</name></expr></range></decl></init>)</control> <block>{<block_content>

<expr_stmt><expr><name>PrevSize</name> <operator>+=</operator> <call><name><name>C</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><operator>*</operator><name>CLSI</name> <operator>=</operator> <name>PrevSize</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>CLSI</name></expr>;</expr_stmt>


<expr_stmt><expr><name>CI</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>copy</name><argument_list>(<argument><expr><call><name><name>C</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>C</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>CI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
}


void setMapperQualifierLoc(NestedNameSpecifierLoc NNSL</block></for>)</block_content> <block>{<block_content>
<expr_stmt><expr><name>MapperQualifierLoc</name> <operator>=</operator> <name>NNSL</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>


void setMapperIdInfo(DeclarationNameInfo MapperId</block></block></for>) <block>{
<expr><name>MapperIdInfo</name> <operator>=</operator> <name>MapperId</name></expr>;
}</block></block>



<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getUDMapperRefs</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>SupportsMapper</name> <operator>&amp;&amp;</operator>
<literal type="string">"Must be a clause that is possible to have user-defined mappers"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><macro><name>makeMutableArrayRef</name></macro><operator>&lt;</operator><name>Expr</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>template</name> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>varlist_size</name><argument_list>()</argument_list></call>,
<name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>varlist_size</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block>



<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getUDMapperRefs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>SupportsMapper</name> <operator>&amp;&amp;</operator>
<literal type="string">"Must be a clause that is possible to have user-defined mappers"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><macro><name>makeArrayRef</name></macro><operator>&lt;</operator><name>Expr</name> <operator>*</operator><operator>&gt;</operator><operator>(</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>template</name> <call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call> <operator>+</operator>
<name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>varlist_size</name><argument_list>()</argument_list></call>,
<name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>varlist_size</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block>



<name>void</name> <macro><name>setUDMapperRefs</name><argument_list>(<argument>ArrayRef&lt;Expr *&gt; DMDs</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>DMDs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>varlist_size</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected number of user-defined mappers."</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><name>SupportsMapper</name> <operator>&amp;&amp;</operator>
<literal type="string">"Must be a clause that is possible to have user-defined mappers"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><call><name>copy</name><argument_list>(<argument><expr><call><name><name>DMDs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>DMDs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getUDMapperRefs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>public</name><operator>:</operator>

<name>unsigned</name> <macro><name>getUniqueDeclarationsNum</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumUniqueDeclarations</name></expr>;</return> }</block>


<name>unsigned</name> <macro><name>getTotalComponentListNum</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumComponentLists</name></expr>;</return> }</block>



<name>unsigned</name> <macro><name>getTotalComponentsNum</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumComponents</name></expr>;</return> }</block>


<name>NestedNameSpecifierLoc</name> <macro><name>getMapperQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>MapperQualifierLoc</name></expr>;</return>
}</block>


<specifier>const</specifier> <name>DeclarationNameInfo</name> <operator>&amp;</operator><macro><name>getMapperIdInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MapperIdInfo</name></expr>;</return> }</block>



<name>class</name> <name>const_component_lists_iterator</name>
<operator>:</operator> <name>public</name> <name>llvm</name><operator>::</operator><name><name>iterator_adaptor_base</name><argument_list type="generic">&lt;
<argument><expr><name>const_component_lists_iterator</name></expr></argument>,
<argument><expr><name>MappableExprComponentListRef</name><operator>::</operator><name>const_iterator</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name>forward_iterator_tag</name></expr></argument>, <argument><expr><name>MappableComponent</name></expr></argument>, <argument><expr><name>ptrdiff_t</name></expr></argument>,
<argument><expr><name>MappableComponent</name></expr></argument>, <argument><expr><name>MappableComponent</name></expr></argument>&gt;</argument_list></name> <block>{

<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name> <name>DeclCur</name></expr>;


<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name> <name>NumListsCur</name></expr>;


<expr><specifier>const</specifier> <name>bool</name> <name>SupportsMapper</name></expr>;


<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name> <name>MapperCur</name></expr>;


<expr><name>unsigned</name> <name>RemainingLists</name> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name>unsigned</name> <name>PrevListSize</name> <operator>=</operator> <literal type="number">0</literal></expr>;



<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name> <name>ListSizeCur</name></expr>;
<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name> <name>ListSizeEnd</name></expr>;


<expr><name>MappableExprComponentListRef</name><operator>::</operator><name>const_iterator</name> <name>End</name></expr>;

<expr><name>public</name><operator>:</operator>

<name>explicit</name> <macro><name>const_component_lists_iterator</name><argument_list>(
<argument>ArrayRef&lt;ValueDecl *&gt; UniqueDecls</argument>, <argument>ArrayRef&lt;unsigned&gt; DeclsListNum</argument>,
<argument>ArrayRef&lt;unsigned&gt; CumulativeListSizes</argument>,
<argument>MappableExprComponentListRef Components</argument>, <argument>bool SupportsMapper</argument>,
<argument>ArrayRef&lt;Expr *&gt; Mappers</argument>)</argument_list></macro>
<operator>:</operator> <name>const_component_lists_iterator</name><operator>::</operator><call><name>iterator_adaptor_base</name><argument_list>(
<argument><expr><call><name><name>Components</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>DeclCur</name><argument_list>(<argument><expr><call><name><name>UniqueDecls</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <expr><call><name>NumListsCur</name><argument_list>(<argument><expr><call><name><name>DeclsListNum</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SupportsMapper</name><argument_list>(<argument><expr><name>SupportsMapper</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ListSizeCur</name><argument_list>(<argument><expr><call><name><name>CumulativeListSizes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ListSizeEnd</name><argument_list>(<argument><expr><call><name><name>CumulativeListSizes</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <macro><name>End</name><argument_list>(<argument>Components.end()</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>UniqueDecls</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>DeclsListNum</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Inconsistent number of declarations and list sizes!"</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>DeclsListNum</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>RemainingLists</name> <operator>=</operator> <operator>*</operator><name>NumListsCur</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<if_stmt><if>if <condition>(<expr><name>SupportsMapper</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>MapperCur</name> <operator>=</operator> <call><name><name>Mappers</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>



<name>explicit</name> <macro><name>const_component_lists_iterator</name><argument_list>(
<argument>const ValueDecl *Declaration</argument>, <argument>ArrayRef&lt;ValueDecl *&gt; UniqueDecls</argument>,
<argument>ArrayRef&lt;unsigned&gt; DeclsListNum</argument>, <argument>ArrayRef&lt;unsigned&gt; CumulativeListSizes</argument>,
<argument>MappableExprComponentListRef Components</argument>, <argument>bool SupportsMapper</argument>,
<argument>ArrayRef&lt;Expr *&gt; Mappers</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>const_component_lists_iterator</name><argument_list>(<argument>UniqueDecls</argument>, <argument>DeclsListNum</argument>,
<argument>CumulativeListSizes</argument>, <argument>Components</argument>,
<argument>SupportsMapper</argument>, <argument>Mappers</argument>)</argument_list></macro> <block>{



<for>for <control>(<init>;</init> <condition><expr><name>DeclCur</name> <operator>!=</operator> <call><name><name>UniqueDecls</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>DeclCur</name></expr>, <expr><operator>++</operator><name>NumListsCur</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>DeclCur</name> <operator>==</operator> <name>Declaration</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><name>NumListsCur</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"No lists associated with declaration??"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><call><name>advance</name><argument_list>(<argument><expr><name>ListSizeCur</name></expr></argument>, <argument><expr><operator>*</operator><name>NumListsCur</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>PrevListSize</name> <operator>=</operator> <operator>*</operator><name>ListSizeCur</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ListSizeCur</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>SupportsMapper</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>MapperCur</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>



if (ListSizeCur == CumulativeListSizes.end(</block></for>))</block> <block>{
<expr><name><name>this</name><operator>-&gt;</operator><name>I</name></name> <operator>=</operator> <name>End</name></expr>;
<expr><name>RemainingLists</name> <operator>=</operator> <literal type="number">0u</literal></expr>;
<return>return;</return>
}</block>



<name>RemainingLists</name> <operator>=</operator> <operator>*</operator><name>NumListsCur</name></expr>;


<expr><name>ListSizeEnd</name> <operator>=</operator> <name>ListSizeCur</name></expr>;
<expr><name>std</name><operator>::</operator><call><name>advance</name><argument_list>(<argument><expr><name>ListSizeEnd</name></expr></argument>, <argument><expr><name>RemainingLists</name></expr></argument>)</argument_list></call></expr>;



<expr><name>std</name><operator>::</operator><call><name>advance</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr></argument>, <argument><expr><name>PrevListSize</name></expr></argument>)</argument_list></call></expr>;
}</block>



<name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>MappableExprComponentListRef</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ListSizeCur</name> <operator>!=</operator> <name>ListSizeEnd</name> <operator>&amp;&amp;</operator> <literal type="string">"Invalid iterator!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>Mapper</name> <operator>=</operator> <name>nullptr</name></expr>;
<if_stmt><if>if <condition>(<expr><name>SupportsMapper</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>MapperCur</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Mapper</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>*</operator><name>MapperCur</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>std</name><operator>::</operator><call><name>make_tuple</name><argument_list>(
<argument><expr><operator>*</operator><name>DeclCur</name></expr></argument>,
<argument><expr><call><name>MappableExprComponentListRef</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>*</operator><name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr></argument>, <argument><expr><operator>*</operator><name>ListSizeCur</name> <operator>-</operator> <name>PrevListSize</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>Mapper</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>MappableExprComponentListRef</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr>) <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><operator>*</operator><name>this</name></expr>;</return>
}</block></block>


<name>const_component_lists_iterator</name> <operator>&amp;</operator><name>operator</name><operator>++</operator><operator>(</operator><operator>)</operator> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ListSizeCur</name> <operator>!=</operator> <name>ListSizeEnd</name> <operator>&amp;&amp;</operator> <name>RemainingLists</name> <operator>&amp;&amp;</operator>
<literal type="string">"Invalid iterator!"</literal></expr></argument>)</argument_list></call></expr>;



<if_stmt><if>if <condition>(<expr><name>std</name><operator>::</operator><call><name>next</name><argument_list>(<argument><expr><name>ListSizeCur</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ListSizeEnd</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>I</name></name> <operator>=</operator> <name>End</name></expr>;</expr_stmt>
<expr_stmt><expr><name>RemainingLists</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else <block>{<block_content>
<expr_stmt><expr><name>std</name><operator>::</operator><call><name>advance</name><argument_list>(<argument><expr><name><name>this</name><operator>-&gt;</operator><name>I</name></name></expr></argument>, <argument><expr><operator>*</operator><name>ListSizeCur</name> <operator>-</operator> <name>PrevListSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>PrevListSize</name> <operator>=</operator> <operator>*</operator><name>ListSizeCur</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>--</operator><name>RemainingLists</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>DeclCur</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>NumListsCur</name></expr>;</expr_stmt>
<expr_stmt><expr><name>RemainingLists</name> <operator>=</operator> <operator>*</operator><name>NumListsCur</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>RemainingLists</name> <operator>&amp;&amp;</operator> <literal type="string">"No lists in the following declaration??"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}

++ListSizeCur</block><empty_stmt>;</empty_stmt></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>SupportsMapper</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>MapperCur</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
<expr_stmt/>}</block_content>
}</block></block><empty_stmt>;</empty_stmt></if></if_stmt>

<name>using</name> <name>const_component_lists_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_component_lists_iterator</name></expr></argument>&gt;</argument_list></name></block></expr>;


<expr><name>const_component_lists_iterator</name> <macro><name>component_lists_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_component_lists_iterator</name><argument_list>(
<argument><expr><call><name>getUniqueDeclsRef</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getDeclNumListsRef</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getComponentListSizesRef</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getComponentsRef</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SupportsMapper</name></expr></argument>,
<argument><expr><name>SupportsMapper</name> <operator>?</operator> <call><name>getUDMapperRefs</name><argument_list>()</argument_list></call> <operator>:</operator> <name>llvm</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_component_lists_iterator</name> <macro><name>component_lists_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_component_lists_iterator</name><argument_list>(
<argument><expr><call><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>MappableExprComponentListRef</name><argument_list>(<argument><expr><call><name>getComponentsRef</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getComponentsRef</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>SupportsMapper</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_component_lists_range</name> <macro><name>component_lists</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>component_lists_begin</name><argument_list>()</argument_list></call></expr>, <macro><name>component_lists_end</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>



<name>const_component_lists_iterator</name>
<macro><name>decl_component_lists_begin</name><argument_list>(<argument>const ValueDecl *VD</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_component_lists_iterator</name><argument_list>(
<argument><expr><name>VD</name></expr></argument>, <argument><expr><call><name>getUniqueDeclsRef</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getDeclNumListsRef</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getComponentListSizesRef</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getComponentsRef</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SupportsMapper</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>SupportsMapper</name></expr> ?</condition><then> <expr><call><name>getUDMapperRefs</name><argument_list>()</argument_list></call></expr> </then><else>: <expr><name>llvm</name><operator>::</operator><name>None</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_component_lists_iterator</name> <macro><name>decl_component_lists_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>component_lists_end</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>const_component_lists_range</name> <macro><name>decl_component_lists</name><argument_list>(<argument>const ValueDecl *VD</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><block>{<expr><call><name>decl_component_lists_begin</name><argument_list>(<argument><expr><name>VD</name></expr></argument>)</argument_list></call></expr>, <macro><name>decl_component_lists_end</name><argument_list>()</argument_list></macro>}</block></expr>;</return>
}</block>



<name>using</name> <name>const_all_decls_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_all_decls_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_all_decls_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>const_all_decls_range</name> <macro><name>all_decls</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>A</name> <operator>=</operator> <call><name>getUniqueDeclsRef</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_all_decls_range</name><argument_list>(<argument><expr><call><name><name>A</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>const_all_num_lists_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_all_num_lists_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_all_num_lists_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>const_all_num_lists_range</name> <macro><name>all_num_lists</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>A</name> <operator>=</operator> <call><name>getDeclNumListsRef</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_all_num_lists_range</name><argument_list>(<argument><expr><call><name><name>A</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>const_all_lists_sizes_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_all_lists_sizes_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_all_lists_sizes_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>const_all_lists_sizes_range</name> <macro><name>all_lists_sizes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>A</name> <operator>=</operator> <call><name>getComponentListSizesRef</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_all_lists_sizes_range</name><argument_list>(<argument><expr><call><name><name>A</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>const_all_components_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>MappableComponent</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_all_components_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_all_components_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>const_all_components_range</name> <macro><name>all_components</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>A</name> <operator>=</operator> <call><name>getComponentsRef</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_all_components_range</name><argument_list>(<argument><expr><call><name><name>A</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>A</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>mapperlist_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>mapperlist_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>mapperlist_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>mapperlist_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>mapperlist_const_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>mapperlist_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>mapperlist_iterator</name> <macro><name>mapperlist_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>getUDMapperRefs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>mapperlist_iterator</name> <macro><name>mapperlist_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>getUDMapperRefs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>mapperlist_const_iterator</name> <macro><name>mapperlist_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUDMapperRefs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>mapperlist_const_iterator</name> <macro><name>mapperlist_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUDMapperRefs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>mapperlist_range</name> <macro><name>mapperlists</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>mapperlist_range</name><argument_list>(<argument><expr><call><name>mapperlist_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>mapperlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>mapperlist_const_range</name> <macro><name>mapperlists</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>mapperlist_const_range</name><argument_list>(<argument><expr><call><name>mapperlist_begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>mapperlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPMapClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name><name>OMPMappableExprListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPMapClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;
<argument><expr><name>OMPMapClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>,
<argument><expr><name>OMPClauseMappableExprCommon</name><operator>::</operator><name>MappableComponent</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPMappableExprListClause</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;



<expr><name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Expr *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><literal type="number">2</literal> <operator>*</operator> <call><name>varlist_size</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ValueDecl *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUniqueDeclarationsNum</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;unsigned&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUniqueDeclarationsNum</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getTotalComponentListNum</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>private</name><operator>:</operator>

<name>OpenMPMapModifierKind</name> <name><name>MapTypeModifiers</name><index>[<expr><name>NumberOfOMPMapClauseModifiers</name></expr>]</index></name> <operator>=</operator> <block>{
<expr><name>OMPC_MAP_MODIFIER_unknown</name></expr>, <expr><name>OMPC_MAP_MODIFIER_unknown</name></expr>,
<expr><name>OMPC_MAP_MODIFIER_unknown</name></expr>, <expr><name>OMPC_MAP_MODIFIER_unknown</name></expr>}</block></expr>;


<expr><name>SourceLocation</name> <name><name>MapTypeModifiersLoc</name><index>[<expr><name>NumberOfOMPMapClauseModifiers</name></expr>]</index></name></expr>;


<expr><name>OpenMPMapClauseKind</name> <name>MapType</name> <operator>=</operator> <name>OMPC_MAP_unknown</name></expr>;


<expr><name>bool</name> <name>MapTypeIsImplicit</name> <operator>=</operator> <name>false</name></expr>;


<expr><name>SourceLocation</name> <name>MapLoc</name></expr>;


<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;





















<expr><name>explicit</name> <macro><name>OMPMapClause</name><argument_list>(<argument>ArrayRef&lt;OpenMPMapModifierKind&gt; MapModifiers</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; MapModifiersLoc</argument>,
<argument>NestedNameSpecifierLoc MapperQualifierLoc</argument>,
<argument>DeclarationNameInfo MapperIdInfo</argument>,
<argument>OpenMPMapClauseKind MapType</argument>, <argument>bool MapTypeIsImplicit</argument>,
<argument>SourceLocation MapLoc</argument>, <argument>const OMPVarListLocTy &amp;Locs</argument>,
<argument>const OMPMappableExprListSizeTy &amp;Sizes</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPMappableExprListClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_map</name></expr></argument>, <argument><expr><name>Locs</name></expr></argument>, <argument><expr><name>Sizes</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>MapperQualifierLoc</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>MapperIdInfo</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>MapType</name><argument_list>(<argument><expr><name>MapType</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>MapTypeIsImplicit</name><argument_list>(<argument><expr><name>MapTypeIsImplicit</name></expr></argument>)</argument_list></call></expr>, <macro><name>MapLoc</name><argument_list>(<argument>MapLoc</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>array_lengthof</name><argument_list>(<argument><expr><name>MapTypeModifiers</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name><name>MapModifiers</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected number of map type modifiers."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><call><name>copy</name><argument_list>(<argument><expr><name>MapModifiers</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name>begin</name><argument_list>(<argument><expr><name>MapTypeModifiers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><call><name>assert</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>array_lengthof</name><argument_list>(<argument><expr><name>MapTypeModifiersLoc</name></expr></argument>)</argument_list></call> <operator>==</operator>
<call><name><name>MapModifiersLoc</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected number of map type modifier locations."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><call><name>copy</name><argument_list>(<argument><expr><name>MapModifiersLoc</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name>begin</name><argument_list>(<argument><expr><name>MapTypeModifiersLoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>








<name>explicit</name> <call><name>OMPMapClause</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>OMPMappableExprListClause</name><argument_list>(<argument>llvm::omp::OMPC_map</argument>, <argument>OMPVarListLocTy()</argument>, <argument>Sizes</argument>,
<argument>true</argument>)</argument_list></macro> <block>{}</block>





<name>void</name> <macro><name>setMapTypeModifier</name><argument_list>(<argument>unsigned I</argument>, <argument>OpenMPMapModifierKind T</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <name>NumberOfOMPMapClauseModifiers</name> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected index to store map type modifier, exceeds array size."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>MapTypeModifiers</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>T</name></expr>;
}</block>





<name>void</name> <macro><name>setMapTypeModifierLoc</name><argument_list>(<argument>unsigned I</argument>, <argument>SourceLocation TLoc</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <name>NumberOfOMPMapClauseModifiers</name> <operator>&amp;&amp;</operator>
<literal type="string">"Index to store map type modifier location exceeds array size."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>MapTypeModifiersLoc</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>TLoc</name></expr>;
}</block>




<name>void</name> <macro><name>setMapType</name><argument_list>(<argument>OpenMPMapClauseKind T</argument>)</argument_list></macro> <block>{ <expr><name>MapType</name> <operator>=</operator> <name>T</name></expr>; }</block>




<name>void</name> <macro><name>setMapLoc</name><argument_list>(<argument>SourceLocation TLoc</argument>)</argument_list></macro> <block>{ <expr><name>MapLoc</name> <operator>=</operator> <name>TLoc</name></expr>; }</block>


<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>public</name><operator>:</operator>



















<specifier>static</specifier> <name>OMPMapClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const OMPVarListLocTy &amp;Locs</argument>,
<argument>ArrayRef&lt;Expr *&gt; Vars</argument>, <argument>ArrayRef&lt;ValueDecl *&gt; Declarations</argument>,
<argument>MappableExprComponentListsRef ComponentLists</argument>,
<argument>ArrayRef&lt;Expr *&gt; UDMapperRefs</argument>,
<argument>ArrayRef&lt;OpenMPMapModifierKind&gt; MapModifiers</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; MapModifiersLoc</argument>,
<argument>NestedNameSpecifierLoc UDMQualifierLoc</argument>, <argument>DeclarationNameInfo MapperId</argument>,
<argument>OpenMPMapClauseKind Type</argument>, <argument>bool TypeIsImplicit</argument>, <argument>SourceLocation TypeLoc</argument>)</argument_list></macro></expr>;











<expr><specifier>static</specifier> <name>OMPMapClause</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call></expr>;


<expr><name>OpenMPMapClauseKind</name> <macro><name>getMapType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>MapType</name></expr>;</return> }</block>






<name>bool</name> <macro><name>isImplicitMapType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>MapTypeIsImplicit</name></expr>;</return> }</block>




<name>OpenMPMapModifierKind</name> <macro><name>getMapTypeModifier</name><argument_list>(<argument>unsigned Cnt</argument>)</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Cnt</name> <operator>&lt;</operator> <name>NumberOfOMPMapClauseModifiers</name> <operator>&amp;&amp;</operator>
<literal type="string">"Requested modifier exceeds the total number of modifiers."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>MapTypeModifiers</name><index>[<expr><name>Cnt</name></expr>]</index></name></expr>;</return>
}</block>





<name>SourceLocation</name> <macro><name>getMapTypeModifierLoc</name><argument_list>(<argument>unsigned Cnt</argument>)</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Cnt</name> <operator>&lt;</operator> <name>NumberOfOMPMapClauseModifiers</name> <operator>&amp;&amp;</operator>
<literal type="string">"Requested modifier location exceeds total number of modifiers."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>MapTypeModifiersLoc</name><index>[<expr><name>Cnt</name></expr>]</index></name></expr>;</return>
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPMapModifierKind</name></expr></argument>&gt;</argument_list></name> <macro><name>getMapTypeModifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>MapTypeModifiers</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <macro><name>getMapTypeModifiersLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>MapTypeModifiersLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getMapLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>MapLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPMapClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>MapType</name> <operator>==</operator> <name>OMPC_MAP_to</name> <operator>||</operator> <name>MapType</name> <operator>==</operator> <name>OMPC_MAP_tofrom</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPMapClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_map</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPNumTeamsClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>, <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>NumTeams</name> <operator>=</operator> <name>nullptr</name></expr>;




<expr><name>void</name> <macro><name>setNumTeams</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>NumTeams</name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>public</name><operator>:</operator>









<macro><name>OMPNumTeamsClause</name><argument_list>(<argument>Expr *E</argument>, <argument>Stmt *HelperE</argument>, <argument>OpenMPDirectiveKind CaptureRegion</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_num_teams</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>NumTeams</name><argument_list>(<argument>E</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperE</name></expr></argument>, <argument><expr><name>CaptureRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>


<call><name>OMPNumTeamsClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_num_teams</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getNumTeams</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>NumTeams</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getNumTeams</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>NumTeams</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NumTeams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NumTeams</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NumTeams</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NumTeams</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_num_teams</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPThreadLimitClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>, <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>ThreadLimit</name> <operator>=</operator> <name>nullptr</name></expr>;




<expr><name>void</name> <macro><name>setThreadLimit</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>ThreadLimit</name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>public</name><operator>:</operator>









<macro><name>OMPThreadLimitClause</name><argument_list>(<argument>Expr *E</argument>, <argument>Stmt *HelperE</argument>,
<argument>OpenMPDirectiveKind CaptureRegion</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_thread_limit</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>ThreadLimit</name><argument_list>(<argument>E</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperE</name></expr></argument>, <argument><expr><name>CaptureRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>


<call><name>OMPThreadLimitClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_thread_limit</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getThreadLimit</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ThreadLimit</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getThreadLimit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ThreadLimit</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ThreadLimit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ThreadLimit</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ThreadLimit</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ThreadLimit</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_thread_limit</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPPriorityClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>, <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Priority</name> <operator>=</operator> <name>nullptr</name></expr>;




<expr><name>void</name> <macro><name>setPriority</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Priority</name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>public</name><operator>:</operator>









<macro><name>OMPPriorityClause</name><argument_list>(<argument>Expr *Priority</argument>, <argument>Stmt *HelperPriority</argument>,
<argument>OpenMPDirectiveKind CaptureRegion</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_priority</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Priority</name><argument_list>(<argument>Priority</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperPriority</name></expr></argument>, <argument><expr><name>CaptureRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>


<call><name>OMPPriorityClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_priority</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getPriority</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Priority</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getPriority</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Priority</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Priority</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Priority</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Priority</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Priority</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<expr><name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPPriorityClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_priority</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPGrainsizeClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>, <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Grainsize</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setGrainsize</name><argument_list>(<argument>Expr *Size</argument>)</argument_list></macro> <block>{ <expr><name>Grainsize</name> <operator>=</operator> <name>Size</name></expr>; }</block>

<name>public</name><operator>:</operator>








<macro><name>OMPGrainsizeClause</name><argument_list>(<argument>Expr *Size</argument>, <argument>Stmt *HelperSize</argument>,
<argument>OpenMPDirectiveKind CaptureRegion</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_grainsize</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Grainsize</name><argument_list>(<argument>Size</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperSize</name></expr></argument>, <argument><expr><name>CaptureRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <call><name>OMPGrainsizeClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_grainsize</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getGrainsize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Grainsize</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Grainsize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Grainsize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Grainsize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Grainsize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<expr><name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPGrainsizeClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_grainsize</name></expr>;</return>
}</block>
}</expr>;







<expr><name>class</name> <name>OMPNogroupClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>public</name><operator>:</operator>




<macro><name>OMPNogroupClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_nogroup</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPNogroupClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_nogroup</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_nogroup</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPNumTasksClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>, <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>NumTasks</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setNumTasks</name><argument_list>(<argument>Expr *Size</argument>)</argument_list></macro> <block>{ <expr><name>NumTasks</name> <operator>=</operator> <name>Size</name></expr>; }</block>

<name>public</name><operator>:</operator>








<macro><name>OMPNumTasksClause</name><argument_list>(<argument>Expr *Size</argument>, <argument>Stmt *HelperSize</argument>,
<argument>OpenMPDirectiveKind CaptureRegion</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_num_tasks</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>NumTasks</name><argument_list>(<argument>Size</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperSize</name></expr></argument>, <argument><expr><name>CaptureRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <call><name>OMPNumTasksClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_num_tasks</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getNumTasks</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>NumTasks</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NumTasks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NumTasks</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>NumTasks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>NumTasks</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<expr><name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPNumTasksClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_num_tasks</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPHintClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Hint</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setHint</name><argument_list>(<argument>Expr *H</argument>)</argument_list></macro> <block>{ <expr><name>Hint</name> <operator>=</operator> <name>H</name></expr>; }</block>

<name>public</name><operator>:</operator>






<macro><name>OMPHintClause</name><argument_list>(<argument>Expr *Hint</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_hint</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Hint</name><argument_list>(<argument>Hint</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>OMPHintClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_hint</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getHint</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Hint</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Hint</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Hint</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_hint</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPDistScheduleClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>, <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>OpenMPDistScheduleClauseKind</name> <name>Kind</name> <operator>=</operator> <name>OMPC_DIST_SCHEDULE_unknown</name></expr>;


<expr><name>SourceLocation</name> <name>KindLoc</name></expr>;


<expr><name>SourceLocation</name> <name>CommaLoc</name></expr>;


<expr><name>Expr</name> <operator>*</operator><name>ChunkSize</name> <operator>=</operator> <name>nullptr</name></expr>;




<expr><name>void</name> <macro><name>setDistScheduleKind</name><argument_list>(<argument>OpenMPDistScheduleClauseKind K</argument>)</argument_list></macro> <block>{ <expr><name>Kind</name> <operator>=</operator> <name>K</name></expr>; }</block>




<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>




<name>void</name> <macro><name>setDistScheduleKindLoc</name><argument_list>(<argument>SourceLocation KLoc</argument>)</argument_list></macro> <block>{ <expr><name>KindLoc</name> <operator>=</operator> <name>KLoc</name></expr>; }</block>




<name>void</name> <macro><name>setCommaLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>CommaLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>




<name>void</name> <macro><name>setChunkSize</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>ChunkSize</name> <operator>=</operator> <name>E</name></expr>; }</block>

<name>public</name><operator>:</operator>











<macro><name>OMPDistScheduleClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation KLoc</argument>, <argument>SourceLocation CommaLoc</argument>,
<argument>SourceLocation EndLoc</argument>,
<argument>OpenMPDistScheduleClauseKind Kind</argument>, <argument>Expr *ChunkSize</argument>,
<argument>Stmt *HelperChunkSize</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_dist_schedule</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>KindLoc</name><argument_list>(<argument><expr><name>KLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>CommaLoc</name><argument_list>(<argument><expr><name>CommaLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>ChunkSize</name><argument_list>(<argument>ChunkSize</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperChunkSize</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>explicit</name> <call><name>OMPDistScheduleClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_dist_schedule</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>OpenMPDistScheduleClauseKind</name> <macro><name>getDistScheduleKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getDistScheduleKindLoc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>KindLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getCommaLoc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>CommaLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getChunkSize</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>ChunkSize</name></expr>;</return> }</block>


<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getChunkSize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ChunkSize</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ChunkSize</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>ChunkSize</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPDistScheduleClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_dist_schedule</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPDefaultmapClause</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>OpenMPDefaultmapClauseModifier</name> <name>Modifier</name> <operator>=</operator> <name>OMPC_DEFAULTMAP_MODIFIER_unknown</name></expr>;


<expr><name>SourceLocation</name> <name>ModifierLoc</name></expr>;


<expr><name>OpenMPDefaultmapClauseKind</name> <name>Kind</name> <operator>=</operator> <name>OMPC_DEFAULTMAP_unknown</name></expr>;


<expr><name>SourceLocation</name> <name>KindLoc</name></expr>;




<expr><name>void</name> <macro><name>setDefaultmapKind</name><argument_list>(<argument>OpenMPDefaultmapClauseKind K</argument>)</argument_list></macro> <block>{ <expr><name>Kind</name> <operator>=</operator> <name>K</name></expr>; }</block>




<name>void</name> <macro><name>setDefaultmapModifier</name><argument_list>(<argument>OpenMPDefaultmapClauseModifier M</argument>)</argument_list></macro> <block>{
<expr><name>Modifier</name> <operator>=</operator> <name>M</name></expr>;
}</block>


<name>void</name> <macro><name>setDefaultmapModifierLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{
<expr><name>ModifierLoc</name> <operator>=</operator> <name>Loc</name></expr>;
}</block>




<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>




<name>void</name> <macro><name>setDefaultmapKindLoc</name><argument_list>(<argument>SourceLocation KLoc</argument>)</argument_list></macro> <block>{ <expr><name>KindLoc</name> <operator>=</operator> <name>KLoc</name></expr>; }</block>

<name>public</name><operator>:</operator>









<macro><name>OMPDefaultmapClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation MLoc</argument>, <argument>SourceLocation KLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>OpenMPDefaultmapClauseKind Kind</argument>,
<argument>OpenMPDefaultmapClauseModifier M</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_defaultmap</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Modifier</name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>ModifierLoc</name><argument_list>(<argument><expr><name>MLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>,
<macro><name>KindLoc</name><argument_list>(<argument>KLoc</argument>)</argument_list></macro> <expr><block>{}</block>


<name>explicit</name> <call><name>OMPDefaultmapClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_defaultmap</argument>, <argument>SourceLocation()</argument>,
<argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>OpenMPDefaultmapClauseKind</name> <macro><name>getDefaultmapKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block>


<name>OpenMPDefaultmapClauseModifier</name> <macro><name>getDefaultmapModifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Modifier</name></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getDefaultmapKindLoc</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>KindLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getDefaultmapModifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ModifierLoc</name></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_defaultmap</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPToClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name><name>OMPMappableExprListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPToClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;
<argument><expr><name>OMPToClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>,
<argument><expr><name>OMPClauseMappableExprCommon</name><operator>::</operator><name>MappableComponent</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPMappableExprListClause</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>OpenMPMotionModifierKind</name> <name><name>MotionModifiers</name><index>[<expr><name>NumberOfOMPMotionModifiers</name></expr>]</index></name> <operator>=</operator> <block>{
<expr><name>OMPC_MOTION_MODIFIER_unknown</name></expr>, <expr><name>OMPC_MOTION_MODIFIER_unknown</name></expr>}</block></expr>;


<expr><name>SourceLocation</name> <name><name>MotionModifiersLoc</name><index>[<expr><name>NumberOfOMPMotionModifiers</name></expr>]</index></name></expr>;


<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;
















<expr><name>explicit</name> <macro><name>OMPToClause</name><argument_list>(<argument>ArrayRef&lt;OpenMPMotionModifierKind&gt; TheMotionModifiers</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; TheMotionModifiersLoc</argument>,
<argument>NestedNameSpecifierLoc MapperQualifierLoc</argument>,
<argument>DeclarationNameInfo MapperIdInfo</argument>,
<argument>const OMPVarListLocTy &amp;Locs</argument>,
<argument>const OMPMappableExprListSizeTy &amp;Sizes</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPMappableExprListClause</name><argument_list>(<argument>llvm::omp::OMPC_to</argument>, <argument>Locs</argument>, <argument>Sizes</argument>,
<argument>true</argument>, <argument>&amp;MapperQualifierLoc</argument>,
<argument>&amp;MapperIdInfo</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>array_lengthof</name><argument_list>(<argument><expr><name>MotionModifiers</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name><name>TheMotionModifiers</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected number of motion modifiers."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><call><name>copy</name><argument_list>(<argument><expr><name>TheMotionModifiers</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name>begin</name><argument_list>(<argument><expr><name>MotionModifiers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><call><name>assert</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>array_lengthof</name><argument_list>(<argument><expr><name>MotionModifiersLoc</name></expr></argument>)</argument_list></call> <operator>==</operator>
<call><name><name>TheMotionModifiersLoc</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected number of motion modifier locations."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><call><name>copy</name><argument_list>(<argument><expr><name>TheMotionModifiersLoc</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name>begin</name><argument_list>(<argument><expr><name>MotionModifiersLoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>








<name>explicit</name> <call><name>OMPToClause</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>OMPMappableExprListClause</name><argument_list>(<argument>llvm::omp::OMPC_to</argument>, <argument>OMPVarListLocTy()</argument>, <argument>Sizes</argument>,
<argument>true</argument>)</argument_list></macro> <block>{}</block>





<name>void</name> <macro><name>setMotionModifier</name><argument_list>(<argument>unsigned I</argument>, <argument>OpenMPMotionModifierKind T</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <name>NumberOfOMPMotionModifiers</name> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected index to store motion modifier, exceeds array size."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>MotionModifiers</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>T</name></expr>;
}</block>





<name>void</name> <macro><name>setMotionModifierLoc</name><argument_list>(<argument>unsigned I</argument>, <argument>SourceLocation TLoc</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <name>NumberOfOMPMotionModifiers</name> <operator>&amp;&amp;</operator>
<literal type="string">"Index to store motion modifier location exceeds array size."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>MotionModifiersLoc</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>TLoc</name></expr>;
}</block>


<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>



<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Expr *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><literal type="number">2</literal> <operator>*</operator> <call><name>varlist_size</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ValueDecl *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUniqueDeclarationsNum</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;unsigned&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUniqueDeclarationsNum</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getTotalComponentListNum</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
















<specifier>static</specifier> <name>OMPToClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const OMPVarListLocTy &amp;Locs</argument>,
<argument>ArrayRef&lt;Expr *&gt; Vars</argument>,
<argument>ArrayRef&lt;ValueDecl *&gt; Declarations</argument>,
<argument>MappableExprComponentListsRef ComponentLists</argument>,
<argument>ArrayRef&lt;Expr *&gt; UDMapperRefs</argument>,
<argument>ArrayRef&lt;OpenMPMotionModifierKind&gt; MotionModifiers</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; MotionModifiersLoc</argument>,
<argument>NestedNameSpecifierLoc UDMQualifierLoc</argument>,
<argument>DeclarationNameInfo MapperId</argument>)</argument_list></macro></expr>;









<expr><specifier>static</specifier> <name>OMPToClause</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call></expr>;




<expr><name>OpenMPMotionModifierKind</name> <macro><name>getMotionModifier</name><argument_list>(<argument>unsigned Cnt</argument>)</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Cnt</name> <operator>&lt;</operator> <name>NumberOfOMPMotionModifiers</name> <operator>&amp;&amp;</operator>
<literal type="string">"Requested modifier exceeds the total number of modifiers."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>MotionModifiers</name><index>[<expr><name>Cnt</name></expr>]</index></name></expr>;</return>
}</block>





<name>SourceLocation</name> <macro><name>getMotionModifierLoc</name><argument_list>(<argument>unsigned Cnt</argument>)</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Cnt</name> <operator>&lt;</operator> <name>NumberOfOMPMotionModifiers</name> <operator>&amp;&amp;</operator>
<literal type="string">"Requested modifier location exceeds total number of modifiers."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>MotionModifiersLoc</name><index>[<expr><name>Cnt</name></expr>]</index></name></expr>;</return>
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPMotionModifierKind</name></expr></argument>&gt;</argument_list></name> <macro><name>getMotionModifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>MotionModifiers</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <macro><name>getMotionModifiersLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>MotionModifiersLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPToClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_to</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPFromClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPMappableExprListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPFromClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;
<argument><expr><name>OMPFromClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>,
<argument><expr><name>OMPClauseMappableExprCommon</name><operator>::</operator><name>MappableComponent</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPMappableExprListClause</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>OpenMPMotionModifierKind</name> <name><name>MotionModifiers</name><index>[<expr><name>NumberOfOMPMotionModifiers</name></expr>]</index></name> <operator>=</operator> <block>{
<expr><name>OMPC_MOTION_MODIFIER_unknown</name></expr>, <expr><name>OMPC_MOTION_MODIFIER_unknown</name></expr>}</block></expr>;


<expr><name>SourceLocation</name> <name><name>MotionModifiersLoc</name><index>[<expr><name>NumberOfOMPMotionModifiers</name></expr>]</index></name></expr>;


<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;
















<expr><name>explicit</name> <macro><name>OMPFromClause</name><argument_list>(<argument>ArrayRef&lt;OpenMPMotionModifierKind&gt; TheMotionModifiers</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; TheMotionModifiersLoc</argument>,
<argument>NestedNameSpecifierLoc MapperQualifierLoc</argument>,
<argument>DeclarationNameInfo MapperIdInfo</argument>,
<argument>const OMPVarListLocTy &amp;Locs</argument>,
<argument>const OMPMappableExprListSizeTy &amp;Sizes</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPMappableExprListClause</name><argument_list>(<argument>llvm::omp::OMPC_from</argument>, <argument>Locs</argument>, <argument>Sizes</argument>,
<argument>true</argument>, <argument>&amp;MapperQualifierLoc</argument>,
<argument>&amp;MapperIdInfo</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>array_lengthof</name><argument_list>(<argument><expr><name>MotionModifiers</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name><name>TheMotionModifiers</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected number of motion modifiers."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><call><name>copy</name><argument_list>(<argument><expr><name>TheMotionModifiers</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name>begin</name><argument_list>(<argument><expr><name>MotionModifiers</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;

<expr><call><name>assert</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>array_lengthof</name><argument_list>(<argument><expr><name>MotionModifiersLoc</name></expr></argument>)</argument_list></call> <operator>==</operator>
<call><name><name>TheMotionModifiersLoc</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected number of motion modifier locations."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><call><name>copy</name><argument_list>(<argument><expr><name>TheMotionModifiersLoc</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name>begin</name><argument_list>(<argument><expr><name>MotionModifiersLoc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>








<name>explicit</name> <call><name>OMPFromClause</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>OMPMappableExprListClause</name><argument_list>(<argument>llvm::omp::OMPC_from</argument>, <argument>OMPVarListLocTy()</argument>,
<argument>Sizes</argument>, <argument>true</argument>)</argument_list></macro> <block>{}</block>





<name>void</name> <macro><name>setMotionModifier</name><argument_list>(<argument>unsigned I</argument>, <argument>OpenMPMotionModifierKind T</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <name>NumberOfOMPMotionModifiers</name> <operator>&amp;&amp;</operator>
<literal type="string">"Unexpected index to store motion modifier, exceeds array size."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>MotionModifiers</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>T</name></expr>;
}</block>





<name>void</name> <macro><name>setMotionModifierLoc</name><argument_list>(<argument>unsigned I</argument>, <argument>SourceLocation TLoc</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <name>NumberOfOMPMotionModifiers</name> <operator>&amp;&amp;</operator>
<literal type="string">"Index to store motion modifier location exceeds array size."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>MotionModifiersLoc</name><index>[<expr><name>I</name></expr>]</index></name> <operator>=</operator> <name>TLoc</name></expr>;
}</block>


<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>



<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Expr *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><literal type="number">2</literal> <operator>*</operator> <call><name>varlist_size</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ValueDecl *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUniqueDeclarationsNum</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;unsigned&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUniqueDeclarationsNum</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getTotalComponentListNum</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>
















<specifier>static</specifier> <name>OMPFromClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const OMPVarListLocTy &amp;Locs</argument>,
<argument>ArrayRef&lt;Expr *&gt; Vars</argument>, <argument>ArrayRef&lt;ValueDecl *&gt; Declarations</argument>,
<argument>MappableExprComponentListsRef ComponentLists</argument>,
<argument>ArrayRef&lt;Expr *&gt; UDMapperRefs</argument>,
<argument>ArrayRef&lt;OpenMPMotionModifierKind&gt; MotionModifiers</argument>,
<argument>ArrayRef&lt;SourceLocation&gt; MotionModifiersLoc</argument>,
<argument>NestedNameSpecifierLoc UDMQualifierLoc</argument>, <argument>DeclarationNameInfo MapperId</argument>)</argument_list></macro></expr>;









<expr><specifier>static</specifier> <name>OMPFromClause</name> <operator>*</operator><call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call></expr>;




<expr><name>OpenMPMotionModifierKind</name> <macro><name>getMotionModifier</name><argument_list>(<argument>unsigned Cnt</argument>)</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Cnt</name> <operator>&lt;</operator> <name>NumberOfOMPMotionModifiers</name> <operator>&amp;&amp;</operator>
<literal type="string">"Requested modifier exceeds the total number of modifiers."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>MotionModifiers</name><index>[<expr><name>Cnt</name></expr>]</index></name></expr>;</return>
}</block>





<name>SourceLocation</name> <macro><name>getMotionModifierLoc</name><argument_list>(<argument>unsigned Cnt</argument>)</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Cnt</name> <operator>&lt;</operator> <name>NumberOfOMPMotionModifiers</name> <operator>&amp;&amp;</operator>
<literal type="string">"Requested modifier location exceeds total number of modifiers."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>MotionModifiersLoc</name><index>[<expr><name>Cnt</name></expr>]</index></name></expr>;</return>
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPMotionModifierKind</name></expr></argument>&gt;</argument_list></name> <macro><name>getMotionModifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>MotionModifiers</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <macro><name>getMotionModifiersLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>MotionModifiersLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPFromClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_from</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPUseDevicePtrClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPMappableExprListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPUseDevicePtrClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;
<argument><expr><name>OMPUseDevicePtrClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>,
<argument><expr><name>OMPClauseMappableExprCommon</name><operator>::</operator><name>MappableComponent</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPMappableExprListClause</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;











<expr><name>explicit</name> <call><name>OMPUseDevicePtrClause</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPVarListLocTy</name> <operator>&amp;</operator><name>Locs</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>OMPMappableExprListClause</name><argument_list>(<argument>llvm::omp::OMPC_use_device_ptr</argument>, <argument>Locs</argument>, <argument>Sizes</argument>)</argument_list></macro> <block>{
}</block>








<name>explicit</name> <call><name>OMPUseDevicePtrClause</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>OMPMappableExprListClause</name><argument_list>(<argument>llvm::omp::OMPC_use_device_ptr</argument>,
<argument>OMPVarListLocTy()</argument>, <argument>Sizes</argument>)</argument_list></macro> <block>{}</block>



<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Expr *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><literal type="number">3</literal> <operator>*</operator> <call><name>varlist_size</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ValueDecl *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUniqueDeclarationsNum</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;unsigned&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUniqueDeclarationsNum</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getTotalComponentListNum</name><argument_list>()</argument_list></call></expr>;</return>
}</block>




<name>void</name> <call><name>setPrivateCopies</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>VL</name></expr></argument>)</argument_list></call></expr>;



<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivateCopies</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivateCopies</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>




<name>void</name> <call><name>setInits</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>VL</name></expr></argument>)</argument_list></call></expr>;



<expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getInits</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getInits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>











<specifier>static</specifier> <name>OMPUseDevicePtrClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const OMPVarListLocTy &amp;Locs</argument>,
<argument>ArrayRef&lt;Expr *&gt; Vars</argument>, <argument>ArrayRef&lt;Expr *&gt; PrivateVars</argument>,
<argument>ArrayRef&lt;Expr *&gt; Inits</argument>, <argument>ArrayRef&lt;ValueDecl *&gt; Declarations</argument>,
<argument>MappableExprComponentListsRef ComponentLists</argument>)</argument_list></macro></expr>;









<expr><specifier>static</specifier> <name>OMPUseDevicePtrClause</name> <operator>*</operator>
<call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call></expr>;

<expr><name>using</name> <name>private_copies_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>private_copies_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>private_copies_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>private_copies_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>private_copies_const_range</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>private_copies_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>private_copies_range</name> <macro><name>private_copies</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>private_copies_range</name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>private_copies_const_range</name> <macro><name>private_copies</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>private_copies_const_range</name><argument_list>(<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getPrivateCopies</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>inits_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>inits_const_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>inits_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>inits_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>inits_const_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>inits_const_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>inits_range</name> <macro><name>inits</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>inits_range</name><argument_list>(<argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>inits_const_range</name> <macro><name>inits</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>inits_const_range</name><argument_list>(<argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getInits</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPUseDevicePtrClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_use_device_ptr</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPUseDeviceAddrClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPMappableExprListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPUseDeviceAddrClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;
<argument><expr><name>OMPUseDeviceAddrClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>,
<argument><expr><name>OMPClauseMappableExprCommon</name><operator>::</operator><name>MappableComponent</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPMappableExprListClause</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;











<expr><name>explicit</name> <call><name>OMPUseDeviceAddrClause</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPVarListLocTy</name> <operator>&amp;</operator><name>Locs</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>OMPMappableExprListClause</name><argument_list>(<argument>llvm::omp::OMPC_use_device_addr</argument>, <argument>Locs</argument>,
<argument>Sizes</argument>)</argument_list></macro> <block>{}</block>








<name>explicit</name> <call><name>OMPUseDeviceAddrClause</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>OMPMappableExprListClause</name><argument_list>(<argument>llvm::omp::OMPC_use_device_addr</argument>,
<argument>OMPVarListLocTy()</argument>, <argument>Sizes</argument>)</argument_list></macro> <block>{}</block>



<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Expr *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ValueDecl *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUniqueDeclarationsNum</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;unsigned&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUniqueDeclarationsNum</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getTotalComponentListNum</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>









<specifier>static</specifier> <name>OMPUseDeviceAddrClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const OMPVarListLocTy &amp;Locs</argument>,
<argument>ArrayRef&lt;Expr *&gt; Vars</argument>, <argument>ArrayRef&lt;ValueDecl *&gt; Declarations</argument>,
<argument>MappableExprComponentListsRef ComponentLists</argument>)</argument_list></macro></expr>;









<expr><specifier>static</specifier> <name>OMPUseDeviceAddrClause</name> <operator>*</operator>
<call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call></expr>;

<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPUseDeviceAddrClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_use_device_addr</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPIsDevicePtrClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPMappableExprListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPIsDevicePtrClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;
<argument><expr><name>OMPIsDevicePtrClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>,
<argument><expr><name>OMPClauseMappableExprCommon</name><operator>::</operator><name>MappableComponent</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPMappableExprListClause</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;











<expr><name>explicit</name> <call><name>OMPIsDevicePtrClause</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPVarListLocTy</name> <operator>&amp;</operator><name>Locs</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>OMPMappableExprListClause</name><argument_list>(<argument>llvm::omp::OMPC_is_device_ptr</argument>, <argument>Locs</argument>, <argument>Sizes</argument>)</argument_list></macro> <block>{}</block>








<name>explicit</name> <call><name>OMPIsDevicePtrClause</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>OMPMappableExprListClause</name><argument_list>(<argument>llvm::omp::OMPC_is_device_ptr</argument>,
<argument>OMPVarListLocTy()</argument>, <argument>Sizes</argument>)</argument_list></macro> <block>{}</block>



<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Expr *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;ValueDecl *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUniqueDeclarationsNum</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;unsigned&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getUniqueDeclarationsNum</name><argument_list>()</argument_list></call> <operator>+</operator> <call><name>getTotalComponentListNum</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>









<specifier>static</specifier> <name>OMPIsDevicePtrClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>const OMPVarListLocTy &amp;Locs</argument>,
<argument>ArrayRef&lt;Expr *&gt; Vars</argument>, <argument>ArrayRef&lt;ValueDecl *&gt; Declarations</argument>,
<argument>MappableExprComponentListsRef ComponentLists</argument>)</argument_list></macro></expr>;









<expr><specifier>static</specifier> <name>OMPIsDevicePtrClause</name> <operator>*</operator>
<call><name>CreateEmpty</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>C</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>OMPMappableExprListSizeTy</name> <operator>&amp;</operator><name>Sizes</name></expr></argument>)</argument_list></call></expr>;

<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPIsDevicePtrClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_is_device_ptr</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPNontemporalClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPNontemporalClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPNontemporalClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;







<macro><name>OMPNontemporalClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><expr><operator>&lt;</operator><name>OMPNontemporalClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_nontemporal</name>,
<name>StartLoc</name>, <name>LParenLoc</name>, <name>EndLoc</name>, <name>N</name><operator>)</operator> <block>{
}</block>




<name>explicit</name> <macro><name>OMPNontemporalClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><operator>&lt;</operator><name>OMPNontemporalClause</name><operator>&gt;</operator><operator>(</operator>
<name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_nontemporal</name>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <name>N</name><operator>)</operator> <block>{}</block>



<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivateRefs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getPrivateRefs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPNontemporalClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPNontemporalClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;



<expr><name>void</name> <call><name>setPrivateRefs</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>VL</name></expr></argument>)</argument_list></call></expr>;

<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPNontemporalClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>private_refs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPrivateRefs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getPrivateRefs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>private_refs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPNontemporalClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>private_refs</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_nontemporal</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPOrderClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>OpenMPOrderClauseKind</name> <name>Kind</name> <operator>=</operator> <name>OMPC_ORDER_unknown</name></expr>;


<expr><name>SourceLocation</name> <name>KindKwLoc</name></expr>;




<expr><name>void</name> <macro><name>setKind</name><argument_list>(<argument>OpenMPOrderClauseKind K</argument>)</argument_list></macro> <block>{ <expr><name>Kind</name> <operator>=</operator> <name>K</name></expr>; }</block>




<name>void</name> <macro><name>setKindKwLoc</name><argument_list>(<argument>SourceLocation KLoc</argument>)</argument_list></macro> <block>{ <expr><name>KindKwLoc</name> <operator>=</operator> <name>KLoc</name></expr>; }</block>

<name>public</name><operator>:</operator>







<macro><name>OMPOrderClause</name><argument_list>(<argument>OpenMPOrderClauseKind A</argument>, <argument>SourceLocation ALoc</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_order</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Kind</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>, <macro><name>KindKwLoc</name><argument_list>(<argument>ALoc</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>OMPOrderClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_order</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>OpenMPOrderClauseKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getKindKwLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>KindKwLoc</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_order</name></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>OMPInitClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPInitClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPInitClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>SourceLocation</name> <name>VarLoc</name></expr>;

<expr><name>bool</name> <name>IsTarget</name> <operator>=</operator> <name>false</name></expr>;
<expr><name>bool</name> <name>IsTargetSync</name> <operator>=</operator> <name>false</name></expr>;

<expr><name>void</name> <macro><name>setInteropVar</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><call><name>varlist_begin</name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>=</operator> <name>E</name></expr>; }</block>

<name>void</name> <macro><name>setIsTarget</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{ <expr><name>IsTarget</name> <operator>=</operator> <name>V</name></expr>; }</block>

<name>void</name> <macro><name>setIsTargetSync</name><argument_list>(<argument>bool V</argument>)</argument_list></macro> <block>{ <expr><name>IsTargetSync</name> <operator>=</operator> <name>V</name></expr>; }</block>


<name>void</name> <macro><name>setVarLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>VarLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>










<macro><name>OMPInitClause</name><argument_list>(<argument>bool IsTarget</argument>, <argument>bool IsTargetSync</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation VarLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <call><name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPInitClause</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_init</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>,
<argument><expr><name>LParenLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>VarLoc</name><argument_list>(<argument><expr><name>VarLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>IsTarget</name><argument_list>(<argument><expr><name>IsTarget</name></expr></argument>)</argument_list></call></expr>, <macro><name>IsTargetSync</name><argument_list>(<argument>IsTargetSync</argument>)</argument_list></macro> <expr><block>{}</block>


<macro><name>OMPInitClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><operator>&lt;</operator><name>OMPInitClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_init</name>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>, <name>N</name><operator>)</operator> <block>{
}</block>

<name>public</name><operator>:</operator>











<specifier>static</specifier> <name>OMPInitClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>Expr *InteropVar</argument>,
<argument>ArrayRef&lt;Expr *&gt; PrefExprs</argument>, <argument>bool IsTarget</argument>,
<argument>bool IsTargetSync</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation VarLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPInitClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;


<expr><name>SourceLocation</name> <macro><name>getVarLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VarLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getInteropVar</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>varlist_begin</name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</return> }</block>
<specifier>const</specifier> <name>Expr</name> <operator>*</operator><macro><name>getInteropVar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>varlist_begin</name><argument_list>()</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</return> }</block>


<name>bool</name> <macro><name>getIsTarget</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsTarget</name></expr>;</return> }</block>


<name>bool</name> <macro><name>getIsTargetSync</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsTargetSync</name></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPInitClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>using</name> <name>prefs_iterator</name> <operator>=</operator> <name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_prefs_iterator</name> <operator>=</operator> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>prefs_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>prefs_iterator</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>const_prefs_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_prefs_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>prefs_range</name> <macro><name>prefs</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>prefs_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>next</name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_prefs_range</name> <macro><name>prefs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Prefs</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPInitClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>prefs</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_prefs_range</name><argument_list>(<argument><expr><call><name><name>Prefs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Prefs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_init</name></expr>;</return>
}</block>
}</expr>;






<expr><name>class</name> <name>OMPUseClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>SourceLocation</name> <name>VarLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>InteropVar</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setInteropVar</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>InteropVar</name> <operator>=</operator> <name>E</name></expr>; }</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>void</name> <macro><name>setVarLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>VarLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>public</name><operator>:</operator>







<macro><name>OMPUseClause</name><argument_list>(<argument>Expr *InteropVar</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation VarLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_use</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>VarLoc</name><argument_list>(<argument><expr><name>VarLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>InteropVar</name><argument_list>(<argument>InteropVar</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>OMPUseClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_use</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getVarLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VarLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getInteropVar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>InteropVar</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>InteropVar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>InteropVar</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>InteropVar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>InteropVar</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_use</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPDestroyClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>SourceLocation</name> <name>VarLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>InteropVar</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setInteropVar</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>InteropVar</name> <operator>=</operator> <name>E</name></expr>; }</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>void</name> <macro><name>setVarLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>VarLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>public</name><operator>:</operator>







<macro><name>OMPDestroyClause</name><argument_list>(<argument>Expr *InteropVar</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation VarLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_destroy</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>VarLoc</name><argument_list>(<argument><expr><name>VarLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>InteropVar</name><argument_list>(<argument>InteropVar</argument>)</argument_list></macro> <expr><block>{}</block>





<macro><name>OMPDestroyClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_destroy</argument>, <argument>StartLoc</argument>, <argument>EndLoc</argument>)</argument_list></macro> <block>{}</block>


<call><name>OMPDestroyClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_destroy</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{
}</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>SourceLocation</name> <macro><name>getVarLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VarLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getInteropVar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>InteropVar</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>InteropVar</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>InteropVar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>InteropVar</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name>InteropVar</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>InteropVar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>InteropVar</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_destroy</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPNovariantsClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>,
<expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Condition</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setCondition</name><argument_list>(<argument>Expr *Cond</argument>)</argument_list></macro> <block>{ <expr><name>Condition</name> <operator>=</operator> <name>Cond</name></expr>; }</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>public</name><operator>:</operator>









<macro><name>OMPNovariantsClause</name><argument_list>(<argument>Expr *Cond</argument>, <argument>Stmt *HelperCond</argument>,
<argument>OpenMPDirectiveKind CaptureRegion</argument>,
<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_novariants</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Condition</name><argument_list>(<argument>Cond</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperCond</name></expr></argument>, <argument><expr><name>CaptureRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>


<call><name>OMPNovariantsClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_novariants</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getCondition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Condition</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Condition</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Condition</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Condition</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Condition</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<expr><name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPNovariantsClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_novariants</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPNocontextClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>, <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Condition</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setCondition</name><argument_list>(<argument>Expr *Cond</argument>)</argument_list></macro> <block>{ <expr><name>Condition</name> <operator>=</operator> <name>Cond</name></expr>; }</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>public</name><operator>:</operator>









<macro><name>OMPNocontextClause</name><argument_list>(<argument>Expr *Cond</argument>, <argument>Stmt *HelperCond</argument>,
<argument>OpenMPDirectiveKind CaptureRegion</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_nocontext</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Condition</name><argument_list>(<argument>Cond</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperCond</name></expr></argument>, <argument><expr><name>CaptureRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>


<call><name>OMPNocontextClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_nocontext</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getCondition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Condition</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Condition</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Condition</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Condition</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Condition</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<expr><name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPNocontextClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>used_children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_nocontext</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPDetachClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>Evt</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setEventHandler</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{ <expr><name>Evt</name> <operator>=</operator> <name>E</name></expr>; }</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>public</name><operator>:</operator>






<macro><name>OMPDetachClause</name><argument_list>(<argument>Expr *Evt</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_detach</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>Evt</name><argument_list>(<argument>Evt</argument>)</argument_list></macro> <expr><block>{}</block>


<call><name>OMPDetachClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>OMPClause</name><argument_list>(<argument>llvm::omp::OMPC_detach</argument>, <argument>SourceLocation()</argument>, <argument>SourceLocation()</argument>)</argument_list></macro> <block>{}</block>


<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getEventHandler</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Evt</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Evt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Evt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Evt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Evt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_detach</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPInclusiveClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPInclusiveClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPInclusiveClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;







<macro><name>OMPInclusiveClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><expr><operator>&lt;</operator><name>OMPInclusiveClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_inclusive</name>,
<name>StartLoc</name>, <name>LParenLoc</name>, <name>EndLoc</name>, <name>N</name><operator>)</operator> <block>{}</block>




<name>explicit</name> <macro><name>OMPInclusiveClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><operator>&lt;</operator><name>OMPInclusiveClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_inclusive</name>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <name>N</name><operator>)</operator> <block>{}</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPInclusiveClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPInclusiveClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;

<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPInclusiveClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_inclusive</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPExclusiveClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPExclusiveClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPExclusiveClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;







<macro><name>OMPExclusiveClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><expr><operator>&lt;</operator><name>OMPExclusiveClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_exclusive</name>,
<name>StartLoc</name>, <name>LParenLoc</name>, <name>EndLoc</name>, <name>N</name><operator>)</operator> <block>{}</block>




<name>explicit</name> <macro><name>OMPExclusiveClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><operator>&lt;</operator><name>OMPExclusiveClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_exclusive</name>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <name>N</name><operator>)</operator> <block>{}</block>

<name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPExclusiveClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>,
<argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;Expr *&gt; VL</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPExclusiveClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;

<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPExclusiveClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_exclusive</name></expr>;</return>
}</block>
}</expr>;









<expr><name>class</name> <name>OMPUsesAllocatorsClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name>OMPClause</name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPUsesAllocatorsClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>,
<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>

struct <name>Data</name> <block>{

<expr><name>Expr</name> <operator>*</operator><name>Allocator</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>Expr</name> <operator>*</operator><name>AllocatorTraits</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>, <expr><name>RParenLoc</name></expr>;
}</block></expr>;

<expr><name>private</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;

enum <expr><name>class</name> <name>ExprOffsets</name> <block>{
<expr><name>Allocator</name></expr>,
<expr><name>AllocatorTraits</name></expr>,
<expr><name>Total</name></expr>,
}</block></expr>;

enum <expr><name>class</name> <name>ParenLocsOffsets</name> <block>{
<expr><name>LParen</name></expr>,
<expr><name>RParen</name></expr>,
<expr><name>Total</name></expr>,
}</block></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;

<expr><name>unsigned</name> <name>NumOfAllocators</name> <operator>=</operator> <literal type="number">0</literal></expr>;







<macro><name>OMPUsesAllocatorsClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_uses_allocators</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>NumOfAllocators</name><argument_list>(<argument>N</argument>)</argument_list></macro> <expr><block>{}</block>




<name>explicit</name> <macro><name>OMPUsesAllocatorsClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_uses_allocators</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>NumOfAllocators</name><argument_list>(<argument>N</argument>)</argument_list></macro> <expr><block>{}</block>

<name>unsigned</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;Expr *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumOfAllocators</name> <operator>*</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ExprOffsets</name><operator>::</operator><name>Total</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>


<name>void</name> <call><name>setAllocatorsData</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPUsesAllocatorsClause</name><operator>::</operator><name>Data</name></expr></argument>&gt;</argument_list></name> <name>Data</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>







<specifier>static</specifier> <name>OMPUsesAllocatorsClause</name> <operator>*</operator>
<macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>ArrayRef&lt;OMPUsesAllocatorsClause::Data&gt; Data</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPUsesAllocatorsClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;


<expr><name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>unsigned</name> <macro><name>getNumberOfAllocators</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumOfAllocators</name></expr>;</return> }</block>


<name>OMPUsesAllocatorsClause</name><operator>::</operator><name>Data</name> <macro><name>getAllocatorData</name><argument_list>(<argument>unsigned I</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<expr><name>Stmt</name> <operator>*</operator><operator>*</operator><name>Begin</name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><name>Begin</name></expr></argument>, <argument><expr><name>Begin</name> <operator>+</operator> <name>NumOfAllocators</name> <operator>*</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ExprOffsets</name><operator>::</operator><name>Total</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><name>Begin</name> <operator>=</operator>
<call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(
<argument><expr><name>Begin</name></expr></argument>, <argument><expr><name>Begin</name> <operator>+</operator> <name>NumOfAllocators</name> <operator>*</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ExprOffsets</name><operator>::</operator><name>Total</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_uses_allocators</name></expr>;</return>
}</block>
}</expr>;










<expr><name>class</name> <name>OMPAffinityClause</name> <name>final</name>
<operator>:</operator> <name>public</name> <name><name>OMPVarListClause</name><argument_list type="generic">&lt;<argument><expr><name>OMPAffinityClause</name></expr></argument>&gt;</argument_list></name></expr>,
<expr><name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPAffinityClause</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>OMPVarListClause</name></expr>;
<expr><name>friend</name> <name>TrailingObjects</name></expr>;


<expr><name>SourceLocation</name> <name>ColonLoc</name></expr>;








<macro><name>OMPAffinityClause</name><argument_list>(<argument>SourceLocation StartLoc</argument>, <argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation ColonLoc</argument>, <argument>SourceLocation EndLoc</argument>, <argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><expr><operator>&lt;</operator><name>OMPAffinityClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_affinity</name>, <name>StartLoc</name>,
<name>LParenLoc</name>, <name>EndLoc</name>, <name>N</name><operator>)</operator> <block>{}</block>




<name>explicit</name> <macro><name>OMPAffinityClause</name><argument_list>(<argument>unsigned N</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>OMPVarListClause</name></macro><operator>&lt;</operator><name>OMPAffinityClause</name><operator>&gt;</operator><operator>(</operator><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_affinity</name>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <call><name>SourceLocation</name><argument_list>()</argument_list></call>,
<call><name>SourceLocation</name><argument_list>()</argument_list></call>, <name>N</name><operator>)</operator> <block>{}</block>


<name>void</name> <macro><name>setModifier</name><argument_list>(<argument>Expr *E</argument>)</argument_list></macro> <block>{
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr>]</index> <operator>=</operator> <name>E</name></expr>;
}</block>


<name>void</name> <macro><name>setColonLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>ColonLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>public</name><operator>:</operator>








<specifier>static</specifier> <name>OMPAffinityClause</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>,
<argument>SourceLocation ColonLoc</argument>,
<argument>SourceLocation EndLoc</argument>, <argument>Expr *Modifier</argument>,
<argument>ArrayRef&lt;Expr *&gt; Locators</argument>)</argument_list></macro></expr>;





<expr><specifier>static</specifier> <name>OMPAffinityClause</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>const ASTContext &amp;C</argument>, <argument>unsigned N</argument>)</argument_list></macro></expr>;


<expr><name>Expr</name> <operator>*</operator><macro><name>getModifier</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr>]</index></expr>;</return> }</block>
<name>Expr</name> <operator>*</operator><macro><name>getModifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><call><name>varlist_size</name><argument_list>()</argument_list></call></expr>]</index></expr>;</return>
}</block>


<name>SourceLocation</name> <macro><name>getColonLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ColonLoc</name></expr>;</return> }</block>


<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{
<expr><name>int</name> <name>Offset</name> <operator>=</operator> <call><name>getModifier</name><argument_list>()</argument_list></call> <operator>?</operator> <literal type="number">1</literal> <operator>:</operator> <literal type="number">0</literal></expr>;
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_begin</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>varlist_end</name><argument_list>()</argument_list></call> <operator>+</operator> <name>Offset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>auto</name> <name>Children</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPAffinityClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>children</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name><name>Children</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Children</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_affinity</name></expr>;</return>
}</block>
}</expr>;








<expr><name>class</name> <name>OMPFilterClause</name> <name>final</name> <operator>:</operator> <name>public</name> <name>OMPClause</name></expr>, <expr><name>public</name> <name>OMPClauseWithPreInit</name> <block>{
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;


<expr><name>SourceLocation</name> <name>LParenLoc</name></expr>;


<expr><name>Stmt</name> <operator>*</operator><name>ThreadID</name> <operator>=</operator> <name>nullptr</name></expr>;


<expr><name>void</name> <macro><name>setThreadID</name><argument_list>(<argument>Expr *TID</argument>)</argument_list></macro> <block>{ <expr><name>ThreadID</name> <operator>=</operator> <name>TID</name></expr>; }</block>


<name>void</name> <macro><name>setLParenLoc</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <block>{ <expr><name>LParenLoc</name> <operator>=</operator> <name>Loc</name></expr>; }</block>

<name>public</name><operator>:</operator>









<macro><name>OMPFilterClause</name><argument_list>(<argument>Expr *ThreadID</argument>, <argument>Stmt *HelperE</argument>,
<argument>OpenMPDirectiveKind CaptureRegion</argument>, <argument>SourceLocation StartLoc</argument>,
<argument>SourceLocation LParenLoc</argument>, <argument>SourceLocation EndLoc</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_filter</name></expr></argument>, <argument><expr><name>StartLoc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>OMPClauseWithPreInit</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>LParenLoc</name><argument_list>(<argument><expr><name>LParenLoc</name></expr></argument>)</argument_list></call></expr>, <macro><name>ThreadID</name><argument_list>(<argument>ThreadID</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setPreInitStmt</name><argument_list>(<argument><expr><name>HelperE</name></expr></argument>, <argument><expr><name>CaptureRegion</name></expr></argument>)</argument_list></call></expr>;
}</block>


<call><name>OMPFilterClause</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OMPClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_filter</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>OMPClauseWithPreInit</name><argument_list>(<argument>this</argument>)</argument_list></macro> <expr><block>{}</block>

<name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getThreadID</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ThreadID</name></expr></argument>)</argument_list></call></expr>;</return> }</block>


<name>Expr</name> <operator>*</operator><macro><name>getThreadID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ThreadID</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ThreadID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ThreadID</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>const_child_range</name> <macro><name>children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ThreadID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ThreadID</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>child_range</name><argument_list>(<argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name>const_child_range</name> <macro><name>used_children</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>const_child_range</name><argument_list>(<argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>const_child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const OMPClause *T</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>T</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPC_filter</name></expr>;</return>
}</block>
}</expr>;



<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ImplClass</name></expr></argument>, <argument><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name></expr></argument>&gt;</argument_list></name> <name>class</name> <name>Ptr</name></expr></argument>, <argument><expr><name>typename</name> <name>RetTy</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>OMPClauseVisitorBase</name> <block>{
<expr><name>public</name><operator>:</operator>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PTR</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Ptr&lt;CLASS&gt;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPATCH</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>return static_cast&lt;ImplClass*&gt;(this)-&gt;Visit##CLASS(static_cast&lt;PTR(CLASS)&gt;(S))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_CLANG_CLAUSE_CLASS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAUSE_CLASS</name><parameter_list>(<parameter><type><name>Enum</name></type></parameter>, <parameter><type><name>Str</name></type></parameter>, <parameter><type><name>Class</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RetTy Visit##Class(PTR(Class) S) { DISPATCH(Class); }</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMP.inc"</cpp:file></cpp:include>

<name>RetTy</name> <macro><name>Visit</name><argument_list>(<argument>PTR(OMPClause) S</argument>)</argument_list></macro> <block>{

<switch>switch <condition>(<expr><call><name><name>S</name><operator>-&gt;</operator><name>getClauseKind</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_CLANG_CLAUSE_CLASS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAUSE_CLASS</name><parameter_list>(<parameter><type><name>Enum</name></type></parameter>, <parameter><type><name>Str</name></type></parameter>, <parameter><type><name>Class</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case llvm::omp::Clause::Enum: return Visit##Class(static_cast&lt;PTR(Class)&gt;(S));</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAUSE_NO_CLASS</name><parameter_list>(<parameter><type><name>Enum</name></type></parameter>, <parameter><type><name>Str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case llvm::omp::Clause::Enum: break;</cpp:value></cpp:define>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMP.inc"</cpp:file></cpp:include>
<expr_stmt/>}</block_content>
}

RetTy VisitOMPClause(PTR(OMPClause</block></switch>) <name>Node</name>)</block> <block>{ <return>return <expr><call><name>RetTy</name><argument_list>()</argument_list></call></expr>;</return> }</block>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>PTR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DISPATCH</name></cpp:undef>
}</expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>using</name> <name>const_ptr</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>add_pointer_t</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>add_const_t</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ImplClass</name></expr></argument>, <argument><expr><name>typename</name> <name>RetTy</name> <operator>=</operator> <name>void</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>OMPClauseVisitor</name>
<operator>:</operator> <name>public</name> <name><name>OMPClauseVisitorBase</name><argument_list type="generic">&lt;<argument><expr><name>ImplClass</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>add_pointer_t</name></expr></argument>, <argument><expr><name>RetTy</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;
<expr><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>class</name> <name>ImplClass</name></expr></argument>, <argument><expr><name>typename</name> <name>RetTy</name> <operator>=</operator> <name>void</name></expr></argument>&gt;</argument_list></name>
<name>class</name> <name>ConstOMPClauseVisitor</name> <operator>:</operator>
<name>public</name> <name><name>OMPClauseVisitorBase</name> <argument_list type="generic">&lt;<argument><expr><name>ImplClass</name></expr></argument>, <argument><expr><name>const_ptr</name></expr></argument>, <argument><expr><name>RetTy</name></expr></argument>&gt;</argument_list></name> <block>{}</block></expr>;

<expr><name>class</name> <name>OMPClausePrinter</name> <name>final</name> <operator>:</operator> <name>public</name> <name><name>OMPClauseVisitor</name><argument_list type="generic">&lt;<argument><expr><name>OMPClausePrinter</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr>;
<expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr>;


<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>void</name> <macro><name>VisitOMPClauseList</name><argument_list>(<argument>T *Node</argument>, <argument>char StartSym</argument>)</argument_list></macro></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>void</name> <call><name>VisitOMPMotionClause</name><argument_list>(<argument><expr><name>T</name> <operator>*</operator><name>Node</name></expr></argument>)</argument_list></call></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>OMPClausePrinter</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>OS</name><argument_list>(<argument><expr><name>OS</name></expr></argument>)</argument_list></call></expr>, <macro><name>Policy</name><argument_list>(<argument>Policy</argument>)</argument_list></macro> <expr><block>{}</block></expr>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_CLANG_CLAUSE_CLASS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLAUSE_CLASS</name><parameter_list>(<parameter><type><name>Enum</name></type></parameter>, <parameter><type><name>Str</name></type></parameter>, <parameter><type><name>Class</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>void Visit##Class(Class *S);</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMP.inc"</cpp:file></cpp:include>
}</block></expr>;

struct <expr><name>OMPTraitProperty</name> <block>{
<expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitProperty</name> <name>Kind</name> <operator>=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitProperty</name><operator>::</operator><name>invalid</name></expr>;



<expr><name>StringRef</name> <name>RawString</name></expr>;
}</block></expr>;
struct <expr><name>OMPTraitSelector</name> <block>{
<expr><name>Expr</name> <operator>*</operator><name>ScoreOrCondition</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitSelector</name> <name>Kind</name> <operator>=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitSelector</name><operator>::</operator><name>invalid</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>OMPTraitProperty</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name> <name>Properties</name></expr>;
}</block></expr>;
struct <expr><name>OMPTraitSet</name> <block>{
<expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitSet</name> <name>Kind</name> <operator>=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitSet</name><operator>::</operator><name>invalid</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>OMPTraitSelector</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>Selectors</name></expr>;
}</block></expr>;






<expr><name>class</name> <name>OMPTraitInfo</name> <block>{

<macro><name>OMPTraitInfo</name><argument_list>()</argument_list></macro> <expr><block>{}</block>
<name>friend</name> <name>class</name> <name>ASTContext</name></expr>;

<expr><name>public</name><operator>:</operator>

<macro><name>OMPTraitInfo</name><argument_list>(<argument>StringRef MangledName</argument>)</argument_list></macro></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>OMPTraitSet</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>Sets</name></expr>;

<expr><name>bool</name> <macro><name>anyScoreOrCondition</name><argument_list>(
<argument>llvm::function_ref&lt;bool(Expr *&amp;, bool )&gt; Cond</argument>)</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>any_of</name><argument_list>(<argument><expr><name>Sets</name></expr></argument>, <argument><expr><index>[<expr><operator>&amp;</operator></expr>]</index><operator>(</operator><name>OMPTraitSet</name> <operator>&amp;</operator><name>Set</name><operator>)</operator> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>any_of</name><argument_list>(
<argument><expr><name><name>Set</name><operator>.</operator><name>Selectors</name></name></expr></argument>, <argument><expr><index>[<expr><operator>&amp;</operator></expr>]</index><operator>(</operator><name>OMPTraitSelector</name> <operator>&amp;</operator><name>Selector</name><operator>)</operator> <block>{
<return>return <expr><call><name>Cond</name><argument_list>(<argument><expr><name><name>Selector</name><operator>.</operator><name>ScoreOrCondition</name></name></expr></argument>,
<argument><expr><name><name>Selector</name><operator>.</operator><name>Kind</name></name> <operator>!=</operator>
<name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitSelector</name><operator>::</operator><name>user_condition</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></argument>)</argument_list></call></expr>;</return>
}</block>






<name>void</name> <macro><name>getAsVariantMatchInfo</name><argument_list>(<argument>ASTContext &amp;ASTCtx</argument>,
<argument>llvm::omp::VariantMatchInfo &amp;VMI</argument>)</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getMangledName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;


<expr><name>bool</name> <macro><name>isExtensionActive</name><argument_list>(<argument>llvm::omp::TraitProperty TP</argument>)</argument_list></macro> <block>{
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>OMPTraitSet</name> <modifier>&amp;</modifier></type><name>Set</name> <range>: <expr><name>Sets</name></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>Set</name><operator>.</operator><name>Kind</name></name> <operator>!=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitSet</name><operator>::</operator><name>implementation</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>OMPTraitSelector</name> <modifier>&amp;</modifier></type><name>Selector</name> <range>: <expr><name><name>Set</name><operator>.</operator><name>Selectors</name></name></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>Selector</name><operator>.</operator><name>Kind</name></name> <operator>!=</operator> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>TraitSelector</name><operator>::</operator><name>implementation_extension</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>OMPTraitProperty</name> <modifier>&amp;</modifier></type><name>Property</name> <range>: <expr><name><name>Selector</name><operator>.</operator><name>Properties</name></name></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>Property</name><operator>.</operator><name>Kind</name></name> <operator>==</operator> <name>TP</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>
}
}
return false</block><empty_stmt>;</empty_stmt></for>
<expr_stmt/>}</block_content>


void print(llvm::raw_ostream &amp;OS</block><operator>,</operator> <expr_stmt><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></expr_stmt></for>)</block_content> const</block><empty_stmt>;</empty_stmt></for>
}</block></expr>;
<expr><name>llvm</name><operator>::</operator><name>raw_ostream</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>llvm</name><operator>::</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name>, <specifier>const</specifier> <name>OMPTraitInfo</name> <operator>&amp;</operator><name>TI</name><operator>)</operator></expr>;
<expr><name>llvm</name><operator>::</operator><name>raw_ostream</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>llvm</name><operator>::</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name>, <specifier>const</specifier> <name>OMPTraitInfo</name> <operator>*</operator><name>TI</name><operator>)</operator></expr>;


struct <expr><name>TargetOMPContext</name> <name>final</name> <operator>:</operator> <name>public</name> <name>llvm</name><operator>::</operator>omp<operator>::</operator><name>OMPContext</name> <block>{

<expr><call><name>TargetOMPContext</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>ASTCtx</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>StringRef</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;&amp;</operator><name>DiagUnknownTrait</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator><name>CurrentFunctionDecl</name></expr></argument>)</argument_list></call></expr>;
<expr><name>virtual</name> <operator>~</operator><call><name>TargetOMPContext</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;


<expr><name>bool</name> <macro><name>matchesISATrait</name><argument_list>(<argument>StringRef RawString</argument>)</argument_list></macro> <specifier>const</specifier> <name>override</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>std</name><operator>::</operator><name><name>function</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><name>StringRef</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>FeatureValidityCheck</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>StringRef</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>DiagUnknownTrait</name></expr>;
<expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>FeatureMap</name></expr>;
}</block></expr>;




<expr><name>class</name> <name>OMPChildren</name> <name>final</name>
<operator>:</operator> <name>private</name> <name>llvm</name><operator>::</operator><name><name>TrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPChildren</name></expr></argument>, <argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>, <argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>friend</name> <name>TrailingObjects</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPClauseReader</name></expr>;
<expr><name>friend</name> <name>class</name> <name>OMPExecutableDirective</name></expr>;
<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>OMPDeclarativeDirective</name></expr>;


<expr><name>unsigned</name> <name>NumClauses</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>unsigned</name> <name>NumChildren</name> <operator>=</operator> <literal type="number">0</literal></expr>;

<expr><name>bool</name> <name>HasAssociatedStmt</name> <operator>=</operator> <name>false</name></expr>;



<expr><name>size_t</name> <macro><name>numTrailingObjects</name><argument_list>(<argument>OverloadToken&lt;OMPClause *&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>NumClauses</name></expr>;</return>
}</block>

<call><name>OMPChildren</name><argument_list>()</argument_list></call> <operator>=</operator> <name>delete</name></expr>;

<macro><name>OMPChildren</name><argument_list>(<argument>unsigned NumClauses</argument>, <argument>unsigned NumChildren</argument>, <argument>bool HasAssociatedStmt</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>NumClauses</name><argument_list>(<argument><expr><name>NumClauses</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>NumChildren</name><argument_list>(<argument><expr><name>NumChildren</name></expr></argument>)</argument_list></call></expr>,
<macro><name>HasAssociatedStmt</name><argument_list>(<argument>HasAssociatedStmt</argument>)</argument_list></macro> <expr><block>{}</block>

<specifier>static</specifier> <name>size_t</name> <macro><name>size</name><argument_list>(<argument>unsigned NumClauses</argument>, <argument>bool HasAssociatedStmt</argument>,
<argument>unsigned NumChildren</argument>)</argument_list></macro></expr>;

<expr><specifier>static</specifier> <name>OMPChildren</name> <operator>*</operator><call><name>Create</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator><name>Mem</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Clauses</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>OMPChildren</name> <operator>*</operator><macro><name>Create</name><argument_list>(<argument>void *Mem</argument>, <argument>ArrayRef&lt;OMPClause *&gt; Clauses</argument>, <argument>Stmt *S</argument>,
<argument>unsigned NumChildren = <literal type="number">0</literal></argument>)</argument_list></macro></expr>;
<expr><specifier>static</specifier> <name>OMPChildren</name> <operator>*</operator><macro><name>CreateEmpty</name><argument_list>(<argument>void *Mem</argument>, <argument>unsigned NumClauses</argument>,
<argument>bool HasAssociatedStmt = false</argument>,
<argument>unsigned NumChildren = <literal type="number">0</literal></argument>)</argument_list></macro></expr>;

<expr><name>public</name><operator>:</operator>
<name>unsigned</name> <macro><name>getNumClauses</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumClauses</name></expr>;</return> }</block>
<name>unsigned</name> <macro><name>getNumChildren</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumChildren</name></expr>;</return> }</block>
<name>bool</name> <macro><name>hasAssociatedStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasAssociatedStmt</name></expr>;</return> }</block>


<name>void</name> <macro><name>setAssociatedStmt</name><argument_list>(<argument>Stmt *S</argument>)</argument_list></macro> <block>{
<expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>NumChildren</name></expr>]</index> <operator>=</operator> <name>S</name></expr>;
}</block>

<name>void</name> <call><name>setChildren</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Children</name></expr></argument>)</argument_list></call></expr>;





<expr><name>void</name> <call><name>setClauses</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Clauses</name></expr></argument>)</argument_list></call></expr>;


<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getAssociatedStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPChildren</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getAssociatedStmt</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>Stmt</name> <operator>*</operator><macro><name>getAssociatedStmt</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>HasAssociatedStmt</name> <operator>&amp;&amp;</operator>
<literal type="string">"Expected directive with the associated statement."</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>NumChildren</name></expr>]</index></expr>;</return>
}</block>


<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getClauses</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeMutableArrayRef</name><argument_list>(<argument><expr><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>NumClauses</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getClauses</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPChildren</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getClauses</name><argument_list>()</argument_list></call></expr>;</return>
}</block>





<specifier>const</specifier> <name>CapturedStmt</name> <operator>*</operator>
<macro><name>getCapturedStmt</name><argument_list>(<argument>OpenMPDirectiveKind RegionKind</argument>,
<argument>ArrayRef&lt;OpenMPDirectiveKind&gt; CaptureRegions</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>any_of</name><argument_list>(
<argument><expr><name>CaptureRegions</name></expr></argument>,
<argument><expr><index>[<expr><operator>=</operator></expr>]</index><operator>(</operator><specifier>const</specifier> <name>OpenMPDirectiveKind</name> <name>K</name><operator>)</operator> <block>{ <return>return <expr><name>K</name> <operator>==</operator> <name>RegionKind</name></expr>;</return> }</block></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"RegionKind not found in OpenMP CaptureRegions."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <operator>*</operator><name>CS</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CapturedStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getAssociatedStmt</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><decl><type><name>auto</name></type> <name>ThisCaptureRegion</name> <range>: <expr><name>CaptureRegions</name></expr></range></decl></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ThisCaptureRegion</name> <operator>==</operator> <name>RegionKind</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CS</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>CS</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CapturedStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>CS</name><operator>-&gt;</operator><name>getCapturedStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
llvm_unreachable("Incorrect RegionKind specified for directive."</block></for>)</block></expr>;
}</block>


<name>CapturedStmt</name> <operator>*</operator>
<macro><name>getInnermostCapturedStmt</name><argument_list>(<argument>ArrayRef&lt;OpenMPDirectiveKind&gt; CaptureRegions</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasAssociatedStmt</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Must have associated captured statement."</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>CaptureRegions</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"At least one captured statement must be provided."</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>auto</name> <operator>*</operator><name>CS</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CapturedStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getAssociatedStmt</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>Level</name> <init>= <expr><call><name><name>CaptureRegions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>Level</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>--</operator><name>Level</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>CS</name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>CapturedStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>CS</name><operator>-&gt;</operator><name>getCapturedStmt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block></expr>
<return>return <expr><name>CS</name></expr>;</return>
}</block>

<specifier>const</specifier> <name>CapturedStmt</name> <operator>*</operator>
<macro><name>getInnermostCapturedStmt</name><argument_list>(<argument>ArrayRef&lt;OpenMPDirectiveKind&gt; CaptureRegions</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPChildren</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getInnermostCapturedStmt</name><argument_list>(
<argument><expr><name>CaptureRegions</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <call><name>getChildren</name><argument_list>()</argument_list></call></expr>;
<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getChildren</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPChildren</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getChildren</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>Stmt</name> <operator>*</operator><macro><name>getRawStmt</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>HasAssociatedStmt</name> <operator>&amp;&amp;</operator>
<literal type="string">"Expected directive with the associated statement."</literal></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>CS</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CapturedStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>getAssociatedStmt</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>S</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<do>do <block>{<block_content>
<expr_stmt><expr><name>S</name> <operator>=</operator> <call><name><name>CS</name><operator>-&gt;</operator><name>getCapturedStmt</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>CS</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CapturedStmt</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content> while (CS</block></do>)</block_content></block><empty_stmt>;</empty_stmt></if></if_stmt></block></expr>
<return>return <expr><name>S</name></expr>;</return>
}</block></expr>
<return>return <expr><call><name>getAssociatedStmt</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getRawStmt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>OMPChildren</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getRawStmt</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>Stmt</name><operator>::</operator><name>child_range</name> <macro><name>getAssociatedStmtAsRange</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HasAssociatedStmt</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Stmt</name><operator>::</operator><call><name>child_range</name><argument_list>(<argument><expr><name>Stmt</name><operator>::</operator><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Stmt</name><operator>::</operator><call><name>child_iterator</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>Stmt</name><operator>::</operator><call><name>child_range</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>NumChildren</name></expr>]</index></expr></argument>,
<argument><expr><operator>&amp;</operator><call><name><name>getTrailingObjects</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call><index>[<expr><name>NumChildren</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

}</block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
