<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Sema/Overload.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_SEMA_OVERLOAD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_SEMA_OVERLOAD_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Decl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclAccessPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclBase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclTemplate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/SemaFixItUtils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/TemplateDeduction.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallPtrSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/AlignOf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Casting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/ErrorHandling.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>APValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Sema</name></decl>;</decl_stmt>



<enum>enum <name>OverloadingResult</name> <block>{

<decl><name>OR_Success</name></decl>,


<decl><name>OR_No_Viable_Function</name></decl>,


<decl><name>OR_Ambiguous</name></decl>,


<decl><name>OR_Deleted</name></decl>
}</block>;</enum>

<enum>enum <name>OverloadCandidateDisplayKind</name> <block>{


<decl><name>OCD_AllCandidates</name></decl>,


<decl><name>OCD_ViableCandidates</name></decl>,


<decl><name>OCD_AmbiguousCandidates</name></decl>
}</block>;</enum>









<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>OverloadCandidateParamOrder</name> <range>: <expr><name>char</name> <block>{ <expr><name>Normal</name></expr>, <expr><name>Reversed</name></expr> }</block></expr></range></decl>;</decl_stmt>




<enum>enum <name>OverloadCandidateRewriteKind</name> : <type><name>unsigned</name></type> <block>{

<decl><name>CRK_None</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>,


<decl><name>CRK_DifferentOperator</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,


<decl><name>CRK_Reversed</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,
}</block>;</enum>





<enum>enum <name>ImplicitConversionKind</name> <block>{

<decl><name>ICK_Identity</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,


<decl><name>ICK_Lvalue_To_Rvalue</name></decl>,


<decl><name>ICK_Array_To_Pointer</name></decl>,


<decl><name>ICK_Function_To_Pointer</name></decl>,


<decl><name>ICK_Function_Conversion</name></decl>,


<decl><name>ICK_Qualification</name></decl>,


<decl><name>ICK_Integral_Promotion</name></decl>,


<decl><name>ICK_Floating_Promotion</name></decl>,


<decl><name>ICK_Complex_Promotion</name></decl>,


<decl><name>ICK_Integral_Conversion</name></decl>,


<decl><name>ICK_Floating_Conversion</name></decl>,


<decl><name>ICK_Complex_Conversion</name></decl>,


<decl><name>ICK_Floating_Integral</name></decl>,


<decl><name>ICK_Pointer_Conversion</name></decl>,


<decl><name>ICK_Pointer_Member</name></decl>,


<decl><name>ICK_Boolean_Conversion</name></decl>,


<decl><name>ICK_Compatible_Conversion</name></decl>,


<decl><name>ICK_Derived_To_Base</name></decl>,


<decl><name>ICK_Vector_Conversion</name></decl>,


<decl><name>ICK_SVE_Vector_Conversion</name></decl>,


<decl><name>ICK_Vector_Splat</name></decl>,


<decl><name>ICK_Complex_Real</name></decl>,


<decl><name>ICK_Block_Pointer_Conversion</name></decl>,


<decl><name>ICK_TransparentUnionConversion</name></decl>,


<decl><name>ICK_Writeback_Conversion</name></decl>,


<decl><name>ICK_Zero_Event_Conversion</name></decl>,


<decl><name>ICK_Zero_Queue_Conversion</name></decl>,


<decl><name>ICK_C_Only_Conversion</name></decl>,


<decl><name>ICK_Incompatible_Pointer_Conversion</name></decl>,


<decl><name>ICK_Num_Conversion_Kinds</name></decl>,
}</block>;</enum>





<enum>enum <name>ImplicitConversionRank</name> <block>{

<decl><name>ICR_Exact_Match</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,


<decl><name>ICR_Promotion</name></decl>,


<decl><name>ICR_Conversion</name></decl>,


<decl><name>ICR_OCL_Scalar_Widening</name></decl>,


<decl><name>ICR_Complex_Real_Conversion</name></decl>,


<decl><name>ICR_Writeback_Conversion</name></decl>,


<decl><name>ICR_C_Conversion</name></decl>,



<decl><name>ICR_C_Conversion_Extension</name></decl>
}</block>;</enum>

<function_decl><type><name>ImplicitConversionRank</name></type> <name>GetConversionRank</name><parameter_list>(<parameter><decl><type><name>ImplicitConversionKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>NarrowingKind</name> <block>{

<decl><name>NK_Not_Narrowing</name></decl>,


<decl><name>NK_Type_Narrowing</name></decl>,


<decl><name>NK_Constant_Narrowing</name></decl>,



<decl><name>NK_Variable_Narrowing</name></decl>,



<decl><name>NK_Dependent_Narrowing</name></decl>,
}</block>;</enum>









<decl_stmt><decl><type><name>class</name></type> <name>StandardConversionSequence</name> <block>{<block_content>
<label><name>public</name>:</label>



<decl_stmt><decl><type><name>ImplicitConversionKind</name></type> <name>First</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>ImplicitConversionKind</name></type> <name>Second</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>ImplicitConversionKind</name></type> <name>Third</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>DeprecatedStringLiteralToCharPtr</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>QualificationIncludesObjCLifetime</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>IncompatibleObjC</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>ReferenceBinding</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>DirectBinding</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>IsLvalueReference</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>BindsToFunctionLvalue</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>BindsToRvalue</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>BindsImplicitObjectArgumentWithoutRefQualifier</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>ObjCLifetimeConversionBinding</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>FromTypePtr</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>ToTypePtrs</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>CopyConstructor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclAccessPair</name></type> <name>FoundCopyConstructor</name></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>setFromType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>FromTypePtr</name> <operator>=</operator> <call><name><name>T</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>void</name></type> <name>setToType</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Idx</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <literal type="string">"To type index is out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ToTypePtrs</name><index>[<expr><name>Idx</name></expr>]</index></name> <operator>=</operator> <call><name><name>T</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setAllToTypes</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>ToTypePtrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name><name>T</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ToTypePtrs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>ToTypePtrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ToTypePtrs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>ToTypePtrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>QualType</name> <macro><name>getFromType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>QualType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name>FromTypePtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>getToType</name><argument_list>(<argument><expr><name>unsigned</name> <name>Idx</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>Idx</name> <operator>&lt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <literal type="string">"To type index is out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>QualType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name><name>ToTypePtrs</name><index>[<expr><name>Idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function_decl><type><name>void</name></type> <name>setAsIdentityConversion</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>bool</name> <macro><name>isIdentityConversion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Second</name> <operator>==</operator> <name>ICK_Identity</name> <operator>&amp;&amp;</operator> <name>Third</name> <operator>==</operator> <name>ICK_Identity</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>ImplicitConversionRank</name> <macro><name>getRank</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<decl_stmt><decl><type><name>NarrowingKind</name></type>
<name>getNarrowingKind</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Converted</name></expr></argument>,
<argument><expr><name>APValue</name> <operator>&amp;</operator><name>ConstantValue</name></expr></argument>, <argument><expr><name>QualType</name> <operator>&amp;</operator><name>ConstantType</name></expr></argument>,
<argument><expr><name>bool</name> <name>IgnoreFloatToIntegralConversion</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isPointerConversionToBool</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isPointerConversionToVoidPointer</name><argument_list>(<argument><expr><name>ASTContext</name><operator>&amp;</operator> <name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<struct>struct <name>UserDefinedConversionSequence</name> <block>{











<decl_stmt><decl><type><name>StandardConversionSequence</name></type> <name>Before</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>bool</name></type> <name>EllipsisConversion</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>HadMultipleCandidates</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>StandardConversionSequence</name></type> <name>After</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>FunctionDecl</name><modifier>*</modifier></type> <name>ConversionFunction</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>DeclAccessPair</name></type> <name>FoundConversionFunction</name></decl>;</decl_stmt>

<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
}</block>;</struct>


<struct>struct <name>AmbiguousConversionSequence</name> <block>{
<decl_stmt><decl><type><name>using</name></type> <name>ConversionSet</name> <init>=
<expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>FromTypePtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ToTypePtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>Buffer</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>ConversionSet</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>QualType</name> <macro><name>getFromType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>QualType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name>FromTypePtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>QualType</name> <macro><name>getToType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>QualType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name>ToTypePtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setFromType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>FromTypePtr</name> <operator>=</operator> <call><name><name>T</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setToType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>ToTypePtr</name> <operator>=</operator> <call><name><name>T</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>ConversionSet</name> <modifier>&amp;</modifier></type><name>conversions</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><operator>*</operator><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>ConversionSet</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Buffer</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>ConversionSet</name> <operator>&amp;</operator><macro><name>conversions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ConversionSet</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Buffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>addConversion</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Found</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>conversions</name><argument_list>()</argument_list></call><operator>.</operator><call><name>push_back</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><name>Found</name></expr></argument>, <argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>using</name></type> <name>iterator</name> <init>= <expr><name>ConversionSet</name><operator>::</operator><name>iterator</name></expr></init></decl>;</decl_stmt>

<function><type><name>iterator</name></type> <name>begin</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>conversions</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>iterator</name></type> <name>end</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>conversions</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<decl_stmt><decl><type><name>using</name></type> <name>const_iterator</name> <init>= <expr><name>ConversionSet</name><operator>::</operator><name>const_iterator</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>const_iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>conversions</name><argument_list>()</argument_list></call><operator>.</operator><call><name>begin</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>const_iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>conversions</name><argument_list>()</argument_list></call><operator>.</operator><call><name>end</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function_decl><type><name>void</name></type> <name>construct</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>destruct</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>copyFrom</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AmbiguousConversionSequence</name> <modifier>&amp;</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
}</block>;</struct>



<struct>struct <name>BadConversionSequence</name> <block>{
<enum>enum <name>FailureKind</name> <block>{
<decl><name>no_conversion</name></decl>,
<decl><name>unrelated_class</name></decl>,
<decl><name>bad_qualifiers</name></decl>,
<decl><name>lvalue_ref_to_rvalue</name></decl>,
<decl><name>rvalue_ref_to_lvalue</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>FromExpr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FailureKind</name></type> <name>Kind</name></decl>;</decl_stmt>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>FromTy</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ToTy</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<function><type><name>void</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name>FailureKind</name></type> <name>K</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>To</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>init</name><argument_list>(<argument><expr><name>K</name></expr></argument>, <argument><expr><call><name><name>From</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>To</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FromExpr</name> <operator>=</operator> <name>From</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>init</name><parameter_list>(<parameter><decl><type><name>FailureKind</name></type> <name>K</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>To</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>K</name></expr>;</expr_stmt>
<expr_stmt><expr><name>FromExpr</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setFromType</name><argument_list>(<argument><expr><name>From</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setToType</name><argument_list>(<argument><expr><name>To</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>QualType</name> <macro><name>getFromType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name>FromTy</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>QualType</name> <macro><name>getToType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>QualType</name><operator>::</operator><call><name>getFromOpaquePtr</name><argument_list>(<argument><expr><name>ToTy</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setFromExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>FromExpr</name> <operator>=</operator> <name>E</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setFromType</name><argument_list>(<argument><expr><call><name><name>E</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setFromType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>FromTy</name> <operator>=</operator> <call><name><name>T</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setToType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>ToTy</name> <operator>=</operator> <call><name><name>T</name><operator>.</operator><name>getAsOpaquePtr</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
}</block>;</struct>





<decl_stmt><decl><type><name>class</name></type> <name>ImplicitConversionSequence</name> <block>{<block_content>
<label><name>public</name>:</label>




<enum>enum <name>Kind</name> <block>{
<decl><name>StandardConversion</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>UserDefinedConversion</name></decl>,
<decl><name>AmbiguousConversion</name></decl>,
<decl><name>EllipsisConversion</name></decl>,
<decl><name>BadConversion</name></decl>
}</block>;</enum>

<label><name>private</name>:</label>
<enum>enum <block>{
<decl><name>Uninitialized</name> <init>= <expr><name>BadConversion</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ConversionKind</name> <range>: <expr><literal type="number">30</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>StdInitializerListElement</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>setKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>destruct</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ConversionKind</name> <operator>=</operator> <name>K</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>destruct</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ConversionKind</name> <operator>==</operator> <name>AmbiguousConversion</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>Ambiguous</name><operator>.</operator><name>destruct</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<label><name>public</name>:</label>
<union>union <block>{


<decl_stmt><decl><type><name>StandardConversionSequence</name></type> <name>Standard</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>UserDefinedConversionSequence</name></type> <name>UserDefined</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>AmbiguousConversionSequence</name></type> <name>Ambiguous</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>BadConversionSequence</name></type> <name>Bad</name></decl>;</decl_stmt>
}</block>;</union>

<expr_stmt><expr><call><name>ImplicitConversionSequence</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>ConversionKind</name><argument_list>(<argument><expr><name>Uninitialized</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>StdInitializerListElement</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{
<expr><call><name><name>Standard</name><operator>.</operator><name>setAsIdentityConversion</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<call><name>ImplicitConversionSequence</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ImplicitConversionSequence</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>ConversionKind</name><argument_list>(<argument><expr><name><name>Other</name><operator>.</operator><name>ConversionKind</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>StdInitializerListElement</name><argument_list>(<argument>Other.StdInitializerListElement</argument>)</argument_list></macro> <expr><block>{
<switch>switch <condition>(<expr><name>ConversionKind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>Uninitialized</name></expr>:</case> <break>break;</break>
<case>case <expr><name>StandardConversion</name></expr>:</case> <expr_stmt><expr><name>Standard</name> <operator>=</operator> <name><name>Other</name><operator>.</operator><name>Standard</name></name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>UserDefinedConversion</name></expr>:</case> <expr_stmt><expr><name>UserDefined</name> <operator>=</operator> <name><name>Other</name><operator>.</operator><name>UserDefined</name></name></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>AmbiguousConversion</name></expr>:</case> <expr_stmt><expr><call><name><name>Ambiguous</name><operator>.</operator><name>copyFrom</name></name><argument_list>(<argument><expr><name><name>Other</name><operator>.</operator><name>Ambiguous</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
<case>case <expr><name>EllipsisConversion</name></expr>:</case> <break>break;</break>
<case>case <expr><name>BadConversion</name></expr>:</case> <expr_stmt><expr><name>Bad</name> <operator>=</operator> <name><name>Other</name><operator>.</operator><name>Bad</name></name></expr>;</expr_stmt> <break>break;</break>
<expr_stmt/>}</block_content>
}

ImplicitConversionSequence &amp;
operator=(const ImplicitConversionSequence &amp;Other</block></switch>) <block>{
<expr><call><name>destruct</name><argument_list>()</argument_list></call></expr>;
<macro><name>new</name> <argument_list>(<argument>this</argument>)</argument_list></macro> <expr><call><name>ImplicitConversionSequence</name><argument_list>(<argument><expr><name>Other</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block>

<operator>~</operator><macro><name>ImplicitConversionSequence</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>destruct</name><argument_list>()</argument_list></call></expr>;
}</block></block>

<name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isInitialized</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"querying uninitialized conversion"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>Kind</name><argument_list>(<argument><expr><name>ConversionKind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>








<expr_stmt><expr><name>unsigned</name> <macro><name>getKindRank</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><call><name>getKind</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<case>case <expr><name>StandardConversion</name></expr>:</case>
<return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><name>UserDefinedConversion</name></expr>:</case>
<case>case <expr><name>AmbiguousConversion</name></expr>:</case>
<return>return <expr><literal type="number">1</literal></expr>;</return>

<case>case <expr><name>EllipsisConversion</name></expr>:</case>
<return>return <expr><literal type="number">2</literal></expr>;</return>

<case>case <expr><name>BadConversion</name></expr>:</case>
<return>return <expr><literal type="number">3</literal></expr>;</return>
<expr_stmt/>}</block_content>

llvm_unreachable("Invalid ImplicitConversionSequence::Kind!"</block></switch>)</block></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isBad</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>BadConversion</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isStandard</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>StandardConversion</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isEllipsis</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>EllipsisConversion</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isAmbiguous</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>AmbiguousConversion</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isUserDefined</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>UserDefinedConversion</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isFailure</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isBad</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isAmbiguous</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isInitialized</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ConversionKind</name> <operator>!=</operator> <name>Uninitialized</name></expr>;</return> }</block></expr></expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>setBad</name><argument_list>(<argument><expr><name>BadConversionSequence</name><operator>::</operator><name>FailureKind</name> <name>Failure</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>FromExpr</name></expr></argument>, <argument><expr><name>QualType</name> <name>ToType</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>setKind</name><argument_list>(<argument><expr><name>BadConversion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Bad</name><operator>.</operator><name>init</name></name><argument_list>(<argument><expr><name>Failure</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>, <argument><expr><name>ToType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>setBad</name><argument_list>(<argument><expr><name>BadConversionSequence</name><operator>::</operator><name>FailureKind</name> <name>Failure</name></expr></argument>,
<argument><expr><name>QualType</name> <name>FromType</name></expr></argument>, <argument><expr><name>QualType</name> <name>ToType</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>setKind</name><argument_list>(<argument><expr><name>BadConversion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Bad</name><operator>.</operator><name>init</name></name><argument_list>(<argument><expr><name>Failure</name></expr></argument>, <argument><expr><name>FromType</name></expr></argument>, <argument><expr><name>ToType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>setStandard</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>setKind</name><argument_list>(<argument><expr><name>StandardConversion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setEllipsis</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>setKind</name><argument_list>(<argument><expr><name>EllipsisConversion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setUserDefined</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>setKind</name><argument_list>(<argument><expr><name>UserDefinedConversion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>void</name></type> <name>setAmbiguous</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>ConversionKind</name> <operator>==</operator> <name>AmbiguousConversion</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ConversionKind</name> <operator>=</operator> <name>AmbiguousConversion</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Ambiguous</name><operator>.</operator><name>construct</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setAsIdentityConversion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>setStandard</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Standard</name><operator>.</operator><name>setAsIdentityConversion</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Standard</name><operator>.</operator><name>setFromType</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Standard</name><operator>.</operator><name>setAllToTypes</name></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>isStdInitializerListElement</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>StdInitializerListElement</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setStdInitializerListElement</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>V</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>StdInitializerListElement</name> <operator>=</operator> <name>V</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>ImplicitConversionSequence</name></type> <name>getNullptrToBool</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>SourceType</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>DestType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>NeedLValToRVal</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ImplicitConversionSequence</name></type> <name>ICS</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>ICS</name><operator>.</operator><name>setStandard</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ICS</name><operator>.</operator><name>Standard</name><operator>.</operator><name>setAsIdentityConversion</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ICS</name><operator>.</operator><name>Standard</name><operator>.</operator><name>setFromType</name></name><argument_list>(<argument><expr><name>SourceType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>NeedLValToRVal</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ICS</name><operator>.</operator><name>Standard</name><operator>.</operator><name>First</name></name> <operator>=</operator> <name>ICK_Lvalue_To_Rvalue</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>ICS</name><operator>.</operator><name>Standard</name><operator>.</operator><name>setToType</name></name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SourceType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ICS</name><operator>.</operator><name>Standard</name><operator>.</operator><name>Second</name></name> <operator>=</operator> <name>ICK_Boolean_Conversion</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ICS</name><operator>.</operator><name>Standard</name><operator>.</operator><name>setToType</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>DestType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ICS</name><operator>.</operator><name>Standard</name><operator>.</operator><name>setToType</name></name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>DestType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ICS</name></expr>;</return>
</block_content>}</block></function>




<enum>enum <name>CompareKind</name> <block>{
<decl><name>Better</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
<decl><name>Indistinguishable</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>Worse</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>
}</block>;</enum>

<decl_stmt><decl><type><name>void</name></type> <name>DiagnoseAmbiguousConversion</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>CaretLoc</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PartialDiagnostic</name> <operator>&amp;</operator><name>PDiag</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<enum>enum <name>OverloadFailureKind</name> <block>{
<decl><name>ovl_fail_too_many_arguments</name></decl>,
<decl><name>ovl_fail_too_few_arguments</name></decl>,
<decl><name>ovl_fail_bad_conversion</name></decl>,
<decl><name>ovl_fail_bad_deduction</name></decl>,




<decl><name>ovl_fail_trivial_conversion</name></decl>,










<decl><name>ovl_fail_illegal_constructor</name></decl>,



<decl><name>ovl_fail_bad_final_conversion</name></decl>,



<decl><name>ovl_fail_final_conversion_not_exact</name></decl>,




<decl><name>ovl_fail_bad_target</name></decl>,



<decl><name>ovl_fail_enable_if</name></decl>,



<decl><name>ovl_fail_explicit</name></decl>,


<decl><name>ovl_fail_addr_not_available</name></decl>,



<decl><name>ovl_fail_inhctor_slice</name></decl>,



<decl><name>ovl_non_default_multiversion_function</name></decl>,




<decl><name>ovl_fail_object_addrspace_mismatch</name></decl>,



<decl><name>ovl_fail_constraints_not_satisfied</name></decl>,
}</block>;</enum>



<decl_stmt><decl><type><name>using</name></type> <name>ConversionSequenceList</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ImplicitConversionSequence</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<struct>struct <name>OverloadCandidate</name> <block>{




<decl_stmt><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Function</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name><name>BuiltinParamTypes</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>CXXConversionDecl</name> <modifier>*</modifier></type><name>Surrogate</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>ConversionSequenceList</name></type> <name>Conversions</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ConversionFixItGenerator</name></type> <name>Fix</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>Viable</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>Best</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>IsSurrogate</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>








<decl_stmt><decl><type><name>bool</name></type> <name>IgnoreObjectArgument</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<expr_stmt><expr><name>CallExpr</name><operator>::</operator><name>ADLCallKind</name> <name>IsADLCandidate</name> <operator>:</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>RewriteKind</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>FailureKind</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>ExplicitCallArguments</name></decl>;</decl_stmt>

<union>union <block>{
<decl_stmt><decl><type><name>DeductionFailureInfo</name></type> <name>DeductionFailure</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>StandardConversionSequence</name></type> <name>FinalConversion</name></decl>;</decl_stmt>
}</block>;</union>



<expr_stmt><expr><name>OverloadCandidateRewriteKind</name> <macro><name>getRewriteKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>OverloadCandidateRewriteKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>RewriteKind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isReversed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getRewriteKind</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>CRK_Reversed</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasAmbiguousConversion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<for>for <control>(<init><expr><name>auto</name> <operator>&amp;</operator><name>C</name> <operator>:</operator> <name>Conversions</name></expr></init>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>C</name><operator>.</operator><name>isInitialized</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>C</name><operator>.</operator><name>isAmbiguous</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
}</block>

<decl><name>bool</name> <name>TryToFixBadConversion</name><argument_list>(<argument><expr><name>unsigned</name> <name>Idx</name></expr></argument>, <argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>CanFix</name> <init>= <expr><call><name><name>Fix</name><operator>.</operator><name>tryToFixConversion</name></name><argument_list>(
<argument><expr><name><name>Conversions</name><index>[<expr><name>Idx</name></expr>]</index></name><operator>.</operator><name><name>Bad</name><operator>.</operator><name>FromExpr</name></name></expr></argument>,
<argument><expr><name><name>Conversions</name><index>[<expr><name>Idx</name></expr>]</index></name><operator>.</operator><call><name><name>Bad</name><operator>.</operator><name>getFromType</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name><name>Conversions</name><index>[<expr><name>Idx</name></expr>]</index></name><operator>.</operator><call><name><name>Bad</name><operator>.</operator><name>getToType</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>S</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CanFix</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Fix</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>CanFix</name></expr>;</return>
</block_content>}</block></decl>

<decl><name>unsigned</name> <name>getNumParams</name><argument_list>()</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>IsSurrogate</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>STy</name> <init>= <expr><call><name><name>Surrogate</name><operator>-&gt;</operator><name>getConversionType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name><name>STy</name><operator>-&gt;</operator><name>isPointerType</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>STy</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>STy</name> <operator>=</operator> <call><name><name>STy</name><operator>-&gt;</operator><name>getPointeeType</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<return>return <expr><name><name>STy</name><operator>-&gt;</operator><name>castAs</name></name><operator>&lt;</operator><name>FunctionProtoType</name><operator>&gt;</operator><operator>(</operator><operator>)</operator><operator>-&gt;</operator><call><name>getNumParams</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>Function</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Function</name><operator>-&gt;</operator><name>getNumParams</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>ExplicitCallArguments</name></expr>;</return>
</block_content>}</block></decl>

<decl><name>private</name><range>:
<expr><name>friend</name> <name>class</name> <name>OverloadCandidateSet</name></expr></range></decl>;</struct>
<expr_stmt><expr><call><name>OverloadCandidate</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>IsSurrogate</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IsADLCandidate</name><argument_list>(<argument><expr><name>CallExpr</name><operator>::</operator><name>NotADL</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>RewriteKind</name><argument_list>(<argument>CRK_None</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
};



<decl_stmt><decl><type><name>class</name></type> <name>OverloadCandidateSet</name> <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>CandidateSetKind</name> <block>{

<decl><name>CSK_Normal</name></decl>,






<decl><name>CSK_Operator</name></decl>,




<decl><name>CSK_InitByUserDefinedConversion</name></decl>,




<decl><name>CSK_InitByConstructor</name></decl>,
}</block>;</enum>



<struct>struct <name>OperatorRewriteInfo</name> <block>{
<expr_stmt><expr><call><name>OperatorRewriteInfo</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>OriginalOperator</name><argument_list>(<argument><expr><name>OO_None</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>AllowRewrittenCandidates</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>OperatorRewriteInfo</name><argument_list>(<argument>OverloadedOperatorKind Op</argument>, <argument>bool AllowRewritten</argument>)</argument_list></macro>
<operator>:</operator> <call><name>OriginalOperator</name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>AllowRewrittenCandidates</name><argument_list>(<argument>AllowRewritten</argument>)</argument_list></macro> <expr><block>{}</block>


<name>OverloadedOperatorKind</name> <name>OriginalOperator</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>AllowRewrittenCandidates</name></decl>;</decl_stmt>



<function><type><name>bool</name></type> <name>isRewrittenOperator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>OriginalOperator</name> <operator>&amp;&amp;</operator>
<call><name><name>FD</name><operator>-&gt;</operator><name>getDeclName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCXXOverloadedOperator</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>OriginalOperator</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>isAcceptableCandidate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>OriginalOperator</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>




<decl_stmt><decl><type><name>OverloadedOperatorKind</name></type> <name>OO</name> <init>=
<expr><call><name><name>FD</name><operator>-&gt;</operator><name>getDeclName</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getCXXOverloadedOperator</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><name>OO</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>OO</name> <operator>==</operator> <name>OriginalOperator</name> <operator>||</operator>
<operator>(</operator><name>AllowRewrittenCandidates</name> <operator>&amp;&amp;</operator>
<name>OO</name> <operator>==</operator> <call><name>getRewrittenOverloadedOperator</name><argument_list>(<argument><expr><name>OriginalOperator</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function><type><name>OverloadCandidateRewriteKind</name></type>
<name>getRewriteKind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><name>OverloadCandidateParamOrder</name></type> <name>PO</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>OverloadCandidateRewriteKind</name></type> <name>CRK</name> <init>= <expr><name>CRK_None</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name>isRewrittenOperator</name><argument_list>(<argument><expr><name>FD</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>CRK</name> <operator>=</operator> <call><name>OverloadCandidateRewriteKind</name><argument_list>(<argument><expr><name>CRK</name> <operator>|</operator> <name>CRK_DifferentOperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>PO</name> <operator>==</operator> <name>OverloadCandidateParamOrder</name><operator>::</operator><name>Reversed</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>CRK</name> <operator>=</operator> <call><name>OverloadCandidateRewriteKind</name><argument_list>(<argument><expr><name>CRK</name> <operator>|</operator> <name>CRK_Reversed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>CRK</name></expr>;</return>
</block_content>}</block></function>



<function><type><name>bool</name></type> <name>isReversible</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>AllowRewrittenCandidates</name> <operator>&amp;&amp;</operator> <name>OriginalOperator</name> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name>getRewrittenOverloadedOperator</name><argument_list>(<argument><expr><name>OriginalOperator</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OO_None</name> <operator>||</operator>
<call><name>shouldAddReversed</name><argument_list>(<argument><expr><name>OriginalOperator</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function_decl><type><name>bool</name></type> <name>shouldAddReversed</name><parameter_list>(<parameter><decl><type><name>OverloadedOperatorKind</name></type> <name>Op</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>shouldAddReversed</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>
}</block>;</struct>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>OverloadCandidate</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>Candidates</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Functions</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <name>SlabAllocator</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CandidateSetKind</name></type> <name>Kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OperatorRewriteInfo</name></type> <name>RewriteInfo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>constexpr</name> <specifier>static</specifier> <name>unsigned</name></type> <name>NumInlineBytes</name> <init>=
<expr><literal type="number">24</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ImplicitConversionSequence</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumInlineBytesUsed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<macro><name>alignas</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <decl_stmt><decl><type><name>char</name></type> <name><name>InlineSpace</name><index>[<expr><name>NumInlineBytes</name></expr>]</index></name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>LangAS</name></type> <name>DestAS</name> <init>= <expr><name>LangAS</name><operator>::</operator><name>Default</name></expr></init></decl>;</decl_stmt>







<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <modifier>*</modifier></type><name>slabAllocate</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><call><name>alignof</name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>alignof</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><literal type="string">"Only works for pointer-aligned types."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>is_trivial</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name> <operator>||</operator>
<name>std</name><operator>::</operator><name><name>is_same</name><argument_list type="generic">&lt;<argument><expr><name>ImplicitConversionSequence</name></expr></argument>, <argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>,
<argument><expr><literal type="string">"Add destruction logic to OverloadCandidateSet::clear()."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>NBytes</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>N</name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>NBytes</name> <operator>&gt;</operator> <name>NumInlineBytes</name> <operator>-</operator> <name>NumInlineBytesUsed</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>SlabAllocator</name><operator>.</operator><name>Allocate</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><name>N</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>FreeSpaceStart</name> <init>= <expr><name>InlineSpace</name> <operator>+</operator> <name>NumInlineBytesUsed</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>uintptr_t</name><argument_list>(<argument><expr><name>FreeSpaceStart</name></expr></argument>)</argument_list></call> <operator>%</operator> <call><name>alignof</name><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
<literal type="string">"Misaligned storage!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>NumInlineBytesUsed</name> <operator>+=</operator> <name>NBytes</name></expr>;</expr_stmt>
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>T</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>FreeSpaceStart</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>destroyCandidates</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<macro><name>OverloadCandidateSet</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>CandidateSetKind CSK</argument>,
<argument>OperatorRewriteInfo RewriteInfo = {}</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Loc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Kind</name><argument_list>(<argument><expr><name>CSK</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>RewriteInfo</name><argument_list>(<argument>RewriteInfo</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>OverloadCandidateSet</name><argument_list>(<argument><expr><specifier>const</specifier> <name>OverloadCandidateSet</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>OverloadCandidateSet</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>OverloadCandidateSet</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>~</operator><macro><name>OverloadCandidateSet</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>destroyCandidates</name><argument_list>()</argument_list></call></expr>; }</block>

<name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>CandidateSetKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>OperatorRewriteInfo</name> <macro><name>getRewriteInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RewriteInfo</name></expr>;</return> }</block></expr></expr_stmt>


<function_decl><type><name>bool</name></type> <name>shouldDeferDiags</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<function><type><name>bool</name></type> <name>isNewCandidate</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><name>OverloadCandidateParamOrder</name></type> <name>PO</name> <init>=
<expr><name>OverloadCandidateParamOrder</name><operator>::</operator><name>Normal</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>uintptr_t</name></type> <name>Key</name> <init>= <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>F</name><operator>-&gt;</operator><name>getCanonicalDecl</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Key</name> <operator>|=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>PO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>Functions</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>Key</name></expr></argument>)</argument_list></call><operator>.</operator><name>second</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>exclude</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>F</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>isNewCandidate</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>OverloadCandidateParamOrder</name><operator>::</operator><name>Normal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>isNewCandidate</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>OverloadCandidateParamOrder</name><operator>::</operator><name>Reversed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>clear</name><parameter_list>(<parameter><decl><type><name>CandidateSetKind</name></type> <name>CSK</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>using</name></type> <name>iterator</name> <init>= <expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>OverloadCandidate</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>iterator</name></expr></init></decl>;</decl_stmt>

<function><type><name>iterator</name></type> <name>begin</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>Candidates</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><name>iterator</name></type> <name>end</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>Candidates</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name>size_t</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Candidates</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Candidates</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<function><type><name>ConversionSequenceList</name></type>
<name>allocateConversionSequences</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>NumConversions</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ImplicitConversionSequence</name> <modifier>*</modifier></type><name>Conversions</name> <init>=
<expr><call><name><name>slabAllocate</name><argument_list type="generic">&lt;<argument><expr><name>ImplicitConversionSequence</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>NumConversions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>NumConversions</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control><block type="pseudo"><block_content>
<macro><name>new</name> <argument_list>(<argument>&amp;Conversions[I]</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ImplicitConversionSequence</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><call><name>ConversionSequenceList</name><argument_list>(<argument><expr><name>Conversions</name></expr></argument>, <argument><expr><name>NumConversions</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name>OverloadCandidate</name> <modifier>&amp;</modifier></type><name>addCandidate</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>NumConversions</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>,
<parameter><decl><type><name>ConversionSequenceList</name></type> <name>Conversions</name> <init>= <expr><name>None</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name><name>Conversions</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>Conversions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>NumConversions</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"preallocated conversion sequence has wrong length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>Candidates</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>OverloadCandidate</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>OverloadCandidate</name> <modifier>&amp;</modifier></type><name>C</name> <init>= <expr><call><name><name>Candidates</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>C</name><operator>.</operator><name>Conversions</name></name> <operator>=</operator> <ternary><condition><expr><call><name><name>Conversions</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><call><name>allocateConversionSequences</name><argument_list>(<argument><expr><name>NumConversions</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><name>Conversions</name></expr></else></ternary></expr>;</expr_stmt>
<return>return <expr><name>C</name></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>OverloadingResult</name></type> <name>BestViableFunction</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>OverloadCandidateSet</name><operator>::</operator><name>iterator</name><operator>&amp;</operator> <name>Best</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>OverloadCandidate</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>&gt;</argument_list></name></type> <name>CompleteCandidates</name><argument_list>(
<argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>, <argument><expr><name>OverloadCandidateDisplayKind</name> <name>OCD</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>OpLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><name>OverloadCandidate</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>Filter</name> <operator>=</operator>
<index>[]</index><operator>(</operator><name>OverloadCandidate</name> <operator>&amp;</operator><operator>)</operator> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block></expr></argument></argument_list></decl></decl_stmt>)</block_content></block></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>NoteCandidates</name><argument_list>(
<argument><expr><name>PartialDiagnosticAt</name> <name>PA</name></expr></argument>, <argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>, <argument><expr><name>OverloadCandidateDisplayKind</name> <name>OCD</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>, <argument><expr><name>StringRef</name> <name>Opc</name> <operator>=</operator> <literal type="string">""</literal></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><name>OverloadCandidate</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>Filter</name> <operator>=</operator>
<index>[]</index><operator>(</operator><name>OverloadCandidate</name> <operator>&amp;</operator><operator>)</operator> <block>{ <return>return <expr><name>true</name></expr>;</return> }</block></expr></argument></argument_list></decl></decl_stmt>)<empty_stmt>;</empty_stmt>

<function_decl><type><name>void</name></type> <name>NoteCandidates</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OverloadCandidate</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Cands</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Opc</name> <init>= <expr><literal type="string">""</literal></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>LangAS</name></type> <name>getDestAS</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>DestAS</name></expr>;</return> </block_content>}</block></function>

<function><type><name>void</name></type> <name>setDestAS</name><parameter_list>(<parameter><decl><type><name>LangAS</name></type> <name>AS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>Kind</name> <operator>==</operator> <name>CSK_InitByConstructor</name> <operator>||</operator>
<name>Kind</name> <operator>==</operator> <name>CSK_InitByUserDefinedConversion</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"can't set the destination address space when not constructing an "</literal>
<literal type="string">"object"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>DestAS</name> <operator>=</operator> <name>AS</name></expr>;</expr_stmt>
</block_content>}</block></function>

};

<decl_stmt><decl><type><name>bool</name></type> <name>isBetterOverloadCandidate</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OverloadCandidate</name> <operator>&amp;</operator><name>Cand1</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>OverloadCandidate</name> <operator>&amp;</operator><name>Cand2</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>OverloadCandidateSet</name><operator>::</operator><name>CandidateSetKind</name> <name>Kind</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<struct>struct <name>ConstructorInfo</name> <block>{
<decl_stmt><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FunctionTemplateDecl</name> <modifier>*</modifier></type><name>ConstructorTmpl</name></decl>;</decl_stmt>

<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Constructor</name></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>



<function><type><specifier>inline</specifier> <name>ConstructorInfo</name></type> <name>getConstructorInfo</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>UsingDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ND</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ConstructorInfo</name><block>{}</block></expr>;</return></block_content></block></if></if_stmt>



<expr_stmt><expr><name>auto</name> <operator>*</operator><name>D</name> <operator>=</operator> <call><name><name>ND</name><operator>-&gt;</operator><name>getUnderlyingDecl</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ConstructorInfo</name></type> <name>Info</name> <init>= <expr><block>{<expr><name>DeclAccessPair</name><operator>::</operator><call><name>make</name><argument_list>(<argument><expr><name>ND</name></expr></argument>, <argument><expr><call><name><name>D</name><operator>-&gt;</operator><name>getAccess</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <expr><name>nullptr</name></expr>,
<expr><name>nullptr</name></expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Info</name><operator>.</operator><name>ConstructorTmpl</name></name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionTemplateDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>Info</name><operator>.</operator><name>ConstructorTmpl</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>D</name> <operator>=</operator> <call><name><name>Info</name><operator>.</operator><name>ConstructorTmpl</name><operator>-&gt;</operator><name>getTemplatedDecl</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>Info</name><operator>.</operator><name>Constructor</name></name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Info</name></expr>;</return>
</block_content>}</block></function>

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
