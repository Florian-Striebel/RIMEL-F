<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SMTConv.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SMTCONV_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SMTCONV_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/APSIntType.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/SymbolManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/SMTAPI.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>ento</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>SMTConv</name> <block>{<block_content>
<label><name>public</name>:</label>

<expr_stmt><expr><specifier>static</specifier> <specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTSortRef</name> <macro><name>mkSort</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>,
<argument>const QualType &amp;Ty</argument>, <argument>unsigned BitWidth</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Ty</name><operator>-&gt;</operator><name>isBooleanType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>getBoolSort</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Ty</name><operator>-&gt;</operator><name>isRealFloatingType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>getFloatSort</name></name><argument_list>(<argument><expr><name>BitWidth</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>getBitvectorSort</name></name><argument_list>(<argument><expr><name>BitWidth</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><specifier>static</specifier> <specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name> <macro><name>fromUnOp</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>,
<argument>const UnaryOperator::Opcode Op</argument>,
<argument>const llvm::SMTExprRef &amp;Exp</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>Op</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UO_Minus</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVNeg</name></name><argument_list>(<argument><expr><name>Exp</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>UO_Not</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVNot</name></name><argument_list>(<argument><expr><name>Exp</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>UO_LNot</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkNot</name></name><argument_list>(<argument><expr><name>Exp</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default><empty_stmt>;</empty_stmt>
<expr_stmt/>}</block_content>
llvm_unreachable("Unimplemented opcode"</block></switch>)</block></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><specifier>static</specifier> <specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name> <macro><name>fromFloatUnOp</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>,
<argument>const UnaryOperator::Opcode Op</argument>,
<argument>const llvm::SMTExprRef &amp;Exp</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>Op</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>UO_Minus</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPNeg</name></name><argument_list>(<argument><expr><name>Exp</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>UO_LNot</name></expr>:</case>
<return>return <expr><call><name>fromUnOp</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Op</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default><empty_stmt>;</empty_stmt>
<expr_stmt/>}</block_content>
llvm_unreachable("Unimplemented opcode"</block></switch>)</block></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><specifier>static</specifier> <specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name>
<macro><name>fromNBinOp</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>, <argument>const BinaryOperator::Opcode Op</argument>,
<argument>const std::vector&lt;llvm::SMTExprRef&gt; &amp;ASTs</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>ASTs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;

<if_stmt><if>if <condition>(<expr><name>Op</name> <operator>!=</operator> <name>BO_LAnd</name> <operator>&amp;&amp;</operator> <name>Op</name> <operator>!=</operator> <name>BO_LOr</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unimplemented opcode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>res</name> <operator>=</operator> <call><name><name>ASTs</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>std</name><operator>::</operator><name>size_t</name> <name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name><name>ASTs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>Op</name> <operator>==</operator> <name>BO_LAnd</name><operator>)</operator></expr> ?</condition><then> <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkAnd</name></name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>ASTs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkOr</name></name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>ASTs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt></block_content></block></for>
<return>return <expr><name>res</name></expr>;</return>
}


static <expr_stmt><expr><specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name> <macro><name>fromBinOp</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>,
<argument>const llvm::SMTExprRef &amp;LHS</argument>,
<argument>const BinaryOperator::Opcode Op</argument>,
<argument>const llvm::SMTExprRef &amp;RHS</argument>,
<argument>bool isSigned</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Solver</name><operator>-&gt;</operator><name>getSort</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>*</operator><call><name><name>Solver</name><operator>-&gt;</operator><name>getSort</name></name><argument_list>(<argument><expr><name>RHS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"AST's must have the same sort!"</literal></expr></argument>)</argument_list></call></expr>;

<switch>switch <condition>(<expr><name>Op</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BO_Mul</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVMul</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_Div</name></expr>:</case>
<return>return <expr><ternary><condition><expr><name>isSigned</name></expr> ?</condition><then> <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVSDiv</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVUDiv</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

<case>case <expr><name>BO_Rem</name></expr>:</case>
<return>return <expr><ternary><condition><expr><name>isSigned</name></expr> ?</condition><then> <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVSRem</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVURem</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>


<case>case <expr><name>BO_Add</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVAdd</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_Sub</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVSub</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>BO_Shl</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVShl</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_Shr</name></expr>:</case>
<return>return <expr><ternary><condition><expr><name>isSigned</name></expr> ?</condition><then> <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVAshr</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVLshr</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>


<case>case <expr><name>BO_LT</name></expr>:</case>
<return>return <expr><ternary><condition><expr><name>isSigned</name></expr> ?</condition><then> <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVSlt</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVUlt</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

<case>case <expr><name>BO_GT</name></expr>:</case>
<return>return <expr><ternary><condition><expr><name>isSigned</name></expr> ?</condition><then> <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVSgt</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVUgt</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

<case>case <expr><name>BO_LE</name></expr>:</case>
<return>return <expr><ternary><condition><expr><name>isSigned</name></expr> ?</condition><then> <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVSle</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVUle</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

<case>case <expr><name>BO_GE</name></expr>:</case>
<return>return <expr><ternary><condition><expr><name>isSigned</name></expr> ?</condition><then> <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVSge</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVUge</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>


<case>case <expr><name>BO_EQ</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkEqual</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_NE</name></expr>:</case>
<return>return <expr><call><name>fromUnOp</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>UO_LNot</name></expr></argument>,
<argument><expr><call><name>fromBinOp</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>BO_EQ</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>isSigned</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>BO_And</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVAnd</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_Xor</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVXor</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_Or</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVOr</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>BO_LAnd</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkAnd</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_LOr</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkOr</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default><empty_stmt>;</empty_stmt>
<expr_stmt/></block_content></block></switch>}</block>
<call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unimplemented opcode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}



static <expr_stmt><expr><specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name>
<macro><name>fromFloatSpecialBinOp</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>, <argument>const llvm::SMTExprRef &amp;LHS</argument>,
<argument>const BinaryOperator::Opcode Op</argument>,
<argument>const llvm::APFloat::fltCategory &amp;RHS</argument>)</argument_list></macro> <block>{
<switch>switch <condition>(<expr><name>Op</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BO_EQ</name></expr>:</case>
<switch>switch <condition>(<expr><name>RHS</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>llvm</name><operator>::</operator><name>APFloat</name><operator>::</operator><name>fcInfinity</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPIsInfinite</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>llvm</name><operator>::</operator><name>APFloat</name><operator>::</operator><name>fcNaN</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPIsNaN</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>llvm</name><operator>::</operator><name>APFloat</name><operator>::</operator><name>fcNormal</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPIsNormal</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>llvm</name><operator>::</operator><name>APFloat</name><operator>::</operator><name>fcZero</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPIsZero</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></switch></block_content></block></switch>}</block></expr></expr_stmt>
<break>break;</break>

<case>case <expr><name>BO_NE</name></expr>:</case>
<return>return <expr><call><name>fromFloatUnOp</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>UO_LNot</name></expr></argument>,
<argument><expr><call><name>fromFloatSpecialBinOp</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>BO_EQ</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default><empty_stmt>;</empty_stmt>
}

llvm_unreachable<expr_stmt><expr><operator>(</operator><literal type="string">"Unimplemented opcode"</literal><operator>)</operator></expr>;</expr_stmt>
}


static <expr_stmt><expr><specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name> <macro><name>fromFloatBinOp</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>,
<argument>const llvm::SMTExprRef &amp;LHS</argument>,
<argument>const BinaryOperator::Opcode Op</argument>,
<argument>const llvm::SMTExprRef &amp;RHS</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><call><name><name>Solver</name><operator>-&gt;</operator><name>getSort</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>*</operator><call><name><name>Solver</name><operator>-&gt;</operator><name>getSort</name></name><argument_list>(<argument><expr><name>RHS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"AST's must have the same sort!"</literal></expr></argument>)</argument_list></call></expr>;

<switch>switch <condition>(<expr><name>Op</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BO_Mul</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPMul</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_Div</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPDiv</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_Rem</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPRem</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>BO_Add</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPAdd</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_Sub</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPSub</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>BO_LT</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPLt</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_GT</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPGt</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_LE</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPLe</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_GE</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPGe</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>BO_EQ</name></expr>:</case>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPEqual</name></name><argument_list>(<argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>BO_NE</name></expr>:</case>
<return>return <expr><call><name>fromFloatUnOp</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>UO_LNot</name></expr></argument>,
<argument><expr><call><name>fromFloatBinOp</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>BO_EQ</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>


<case>case <expr><name>BO_LAnd</name></expr>:</case>
<case>case <expr><name>BO_LOr</name></expr>:</case>
<return>return <expr><call><name>fromBinOp</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>Op</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default><empty_stmt>;</empty_stmt>
<expr_stmt/></block_content></block></switch>}</block>

<call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unimplemented opcode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}



static <expr_stmt><expr><specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name> <macro><name>fromCast</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>,
<argument>const llvm::SMTExprRef &amp;Exp</argument>,
<argument>QualType ToTy</argument>, <argument>uint64_t ToBitWidth</argument>,
<argument>QualType FromTy</argument>,
<argument>uint64_t FromBitWidth</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name><name>FromTy</name><operator>-&gt;</operator><name>isIntegralOrEnumerationType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>ToTy</name><operator>-&gt;</operator><name>isIntegralOrEnumerationType</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name><name>FromTy</name><operator>-&gt;</operator><name>isAnyPointerType</name></name><argument_list>()</argument_list></call> <operator>^</operator> <call><name><name>ToTy</name><operator>-&gt;</operator><name>isAnyPointerType</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name><name>FromTy</name><operator>-&gt;</operator><name>isBlockPointerType</name></name><argument_list>()</argument_list></call> <operator>^</operator> <call><name><name>ToTy</name><operator>-&gt;</operator><name>isBlockPointerType</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name><name>FromTy</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call> <operator>^</operator> <call><name><name>ToTy</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name><name>FromTy</name><operator>-&gt;</operator><name>isBooleanType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ToBitWidth</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"BitWidth must be positive!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkIte</name></name><argument_list>(
<argument><expr><name>Exp</name></expr></argument>, <argument><expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBitvector</name></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>APSInt</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ToBitWidth</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBitvector</name></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>APSInt</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ToBitWidth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ToBitWidth</name> <operator>&gt;</operator> <name>FromBitWidth</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><call><name><name>FromTy</name><operator>-&gt;</operator><name>isSignedIntegerOrEnumerationType</name></name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVSignExt</name></name><argument_list>(<argument><expr><name>ToBitWidth</name> <operator>-</operator> <name>FromBitWidth</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVZeroExt</name></name><argument_list>(<argument><expr><name>ToBitWidth</name> <operator>-</operator> <name>FromBitWidth</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ToBitWidth</name> <operator>&lt;</operator> <name>FromBitWidth</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBVExtract</name></name><argument_list>(<argument><expr><name>ToBitWidth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>Exp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><name>Exp</name></expr>;</return>
}

if <expr_stmt><expr><operator>(</operator><call><name><name>FromTy</name><operator>-&gt;</operator><name>isRealFloatingType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>ToTy</name><operator>-&gt;</operator><name>isRealFloatingType</name></name><argument_list>()</argument_list></call><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><name>ToBitWidth</name> <operator>!=</operator> <name>FromBitWidth</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPtoFP</name></name><argument_list>(<argument><expr><name>Exp</name></expr></argument>, <argument><expr><call><name><name>Solver</name><operator>-&gt;</operator><name>getFloatSort</name></name><argument_list>(<argument><expr><name>ToBitWidth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><name>Exp</name></expr>;</return>
}

if <expr_stmt><expr><operator>(</operator><call><name><name>FromTy</name><operator>-&gt;</operator><name>isIntegralOrEnumerationType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>ToTy</name><operator>-&gt;</operator><name>isRealFloatingType</name></name><argument_list>()</argument_list></call><operator>)</operator> <block>{
<expr><name>llvm</name><operator>::</operator><name>SMTSortRef</name> <name>Sort</name> <operator>=</operator> <call><name><name>Solver</name><operator>-&gt;</operator><name>getFloatSort</name></name><argument_list>(<argument><expr><name>ToBitWidth</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><ternary><condition><expr><call><name><name>FromTy</name><operator>-&gt;</operator><name>isSignedIntegerOrEnumerationType</name></name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkSBVtoFP</name></name><argument_list>(<argument><expr><name>Exp</name></expr></argument>, <argument><expr><name>Sort</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkUBVtoFP</name></name><argument_list>(<argument><expr><name>Exp</name></expr></argument>, <argument><expr><name>Sort</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>FromTy</name><operator>-&gt;</operator><name>isRealFloatingType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>ToTy</name><operator>-&gt;</operator><name>isIntegralOrEnumerationType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><call><name><name>ToTy</name><operator>-&gt;</operator><name>isSignedIntegerOrEnumerationType</name></name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPtoSBV</name></name><argument_list>(<argument><expr><name>Exp</name></expr></argument>, <argument><expr><name>ToBitWidth</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFPtoUBV</name></name><argument_list>(<argument><expr><name>Exp</name></expr></argument>, <argument><expr><name>ToBitWidth</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unsupported explicit type cast!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}


static <expr_stmt><expr><specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>APSInt</name> <macro><name>castAPSInt</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>,
<argument>const llvm::APSInt &amp;V</argument>, <argument>QualType ToTy</argument>,
<argument>uint64_t ToWidth</argument>, <argument>QualType FromTy</argument>,
<argument>uint64_t FromWidth</argument>)</argument_list></macro> <block>{
<expr><name>APSIntType</name> <call><name>TargetType</name><argument_list>(<argument><expr><name>ToWidth</name></expr></argument>, <argument><expr><operator>!</operator><call><name><name>ToTy</name><operator>-&gt;</operator><name>isSignedIntegerOrEnumerationType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>TargetType</name><operator>.</operator><name>convert</name></name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>static</specifier> <specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name>
<macro><name>fromData</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>, <argument>ASTContext &amp;Ctx</argument>, <argument>const SymbolData *Sym</argument>)</argument_list></macro> <block>{
<expr><specifier>const</specifier> <name>SymbolID</name> <name>ID</name> <operator>=</operator> <call><name><name>Sym</name><operator>-&gt;</operator><name>getSymbolID</name></name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>QualType</name> <name>Ty</name> <operator>=</operator> <call><name><name>Sym</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;
<expr><specifier>const</specifier> <name>uint64_t</name> <name>BitWidth</name> <operator>=</operator> <call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr>;

<expr><name>llvm</name><operator>::</operator><name><name>SmallString</name><argument_list type="generic">&lt;<argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>Str</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>raw_svector_ostream</name> <call><name>OS</name><argument_list>(<argument><expr><name>Str</name></expr></argument>)</argument_list></call></expr>;
<expr><name>OS</name> <operator>&lt;&lt;</operator> <call><name><name>Sym</name><operator>-&gt;</operator><name>getKindStr</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <name>ID</name></expr>;
<return>return <expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkSymbol</name></name><argument_list>(<argument><expr><call><name><name>Str</name><operator>.</operator><name>c_str</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>mkSort</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ty</name></expr></argument>, <argument><expr><name>BitWidth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>static</specifier> <specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name> <macro><name>getCastExpr</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>,
<argument>ASTContext &amp;Ctx</argument>,
<argument>const llvm::SMTExprRef &amp;Exp</argument>,
<argument>QualType FromTy</argument>, <argument>QualType ToTy</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>fromCast</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>, <argument><expr><name>ToTy</name></expr></argument>, <argument><expr><call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>ToTy</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FromTy</name></expr></argument>,
<argument><expr><call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>FromTy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>static</specifier> <specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name>
<macro><name>getBinExpr</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>, <argument>ASTContext &amp;Ctx</argument>,
<argument>const llvm::SMTExprRef &amp;LHS</argument>, <argument>QualType LTy</argument>,
<argument>BinaryOperator::Opcode Op</argument>, <argument>const llvm::SMTExprRef &amp;RHS</argument>,
<argument>QualType RTy</argument>, <argument>QualType *RetTy</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>NewLHS</name> <operator>=</operator> <name>LHS</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>NewRHS</name> <operator>=</operator> <name>RHS</name></expr>;
<expr><call><name>doTypeConversion</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>NewLHS</name></expr></argument>, <argument><expr><name>NewRHS</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>)</argument_list></call></expr>;


<if_stmt><if>if <condition>(<expr><name>RetTy</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>BinaryOperator</name><operator>::</operator><call><name>isComparisonOp</name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call> <operator>||</operator>
<name>BinaryOperator</name><operator>::</operator><call><name>isLogicalOp</name><argument_list>(<argument><expr><name>Op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>RetTy</name> <operator>=</operator> <name><name>Ctx</name><operator>.</operator><name>BoolTy</name></name></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><else>else <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>RetTy</name> <operator>=</operator> <name>LTy</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name><name>LTy</name><operator>-&gt;</operator><name>isAnyPointerType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>RTy</name><operator>-&gt;</operator><name>isAnyPointerType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>Op</name> <operator>==</operator> <name>BO_Sub</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>RetTy</name> <operator>=</operator> <call><name><name>Ctx</name><operator>.</operator><name>getPointerDiffType</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
}

return <expr_stmt><expr><ternary><condition><expr><call><name><name>LTy</name><operator>-&gt;</operator><name>isRealFloatingType</name></name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><call><name>fromFloatBinOp</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>NewLHS</name></expr></argument>, <argument><expr><name>Op</name></expr></argument>, <argument><expr><name>NewRHS</name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><call><name>fromBinOp</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>NewLHS</name></expr></argument>, <argument><expr><name>Op</name></expr></argument>, <argument><expr><name>NewRHS</name></expr></argument>,
<argument><expr><call><name><name>LTy</name><operator>-&gt;</operator><name>isSignedIntegerOrEnumerationType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
}



static <expr_stmt><expr><specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name> <macro><name>getSymBinExpr</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>,
<argument>ASTContext &amp;Ctx</argument>,
<argument>const BinarySymExpr *BSE</argument>,
<argument>bool *hasComparison</argument>,
<argument>QualType *RetTy</argument>)</argument_list></macro> <block>{
<expr><name>QualType</name> <name>LTy</name></expr>, <expr><name>RTy</name></expr>;
<expr><name>BinaryOperator</name><operator>::</operator><name>Opcode</name> <name>Op</name> <operator>=</operator> <call><name><name>BSE</name><operator>-&gt;</operator><name>getOpcode</name></name><argument_list>()</argument_list></call></expr>;

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>SymIntExpr</name> <modifier>*</modifier></type><name>SIE</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>SymIntExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>BSE</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>LHS</name> <operator>=</operator>
<call><name>getSymExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><call><name><name>SIE</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>LTy</name></expr></argument>, <argument><expr><name>hasComparison</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <name>NewRInt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><call><name>tie</name><argument_list>(<argument><expr><name>NewRInt</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>fixAPSInt</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>, <argument><expr><call><name><name>SIE</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>RHS</name> <operator>=</operator>
<call><name><name>Solver</name><operator>-&gt;</operator><name>mkBitvector</name></name><argument_list>(<argument><expr><name>NewRInt</name></expr></argument>, <argument><expr><call><name><name>NewRInt</name><operator>.</operator><name>getBitWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getBinExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>Op</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RetTy</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>IntSymExpr</name> <modifier>*</modifier></type><name>ISE</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>IntSymExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>BSE</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <name>NewLInt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><call><name>tie</name><argument_list>(<argument><expr><name>NewLInt</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>fixAPSInt</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>, <argument><expr><call><name><name>ISE</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>LHS</name> <operator>=</operator>
<call><name><name>Solver</name><operator>-&gt;</operator><name>mkBitvector</name></name><argument_list>(<argument><expr><name>NewLInt</name></expr></argument>, <argument><expr><call><name><name>NewLInt</name><operator>.</operator><name>getBitWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>RHS</name> <operator>=</operator>
<call><name>getSymExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><call><name><name>ISE</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>RTy</name></expr></argument>, <argument><expr><name>hasComparison</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getBinExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>Op</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RetTy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>SymSymExpr</name> <modifier>*</modifier></type><name>SSM</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>SymSymExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>BSE</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>LHS</name> <operator>=</operator>
<call><name>getSymExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><call><name><name>SSM</name><operator>-&gt;</operator><name>getLHS</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>LTy</name></expr></argument>, <argument><expr><name>hasComparison</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>RHS</name> <operator>=</operator>
<call><name>getSymExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><call><name><name>SSM</name><operator>-&gt;</operator><name>getRHS</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>RTy</name></expr></argument>, <argument><expr><name>hasComparison</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>getBinExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>Op</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RetTy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unsupported BinarySymExpr type!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}



static <expr_stmt><expr><specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name> <macro><name>getSymExpr</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>,
<argument>ASTContext &amp;Ctx</argument>, <argument>SymbolRef Sym</argument>,
<argument>QualType *RetTy</argument>,
<argument>bool *hasComparison</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>SymbolData</name> <modifier>*</modifier></type><name>SD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>SymbolData</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>RetTy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>RetTy</name> <operator>=</operator> <call><name><name>Sym</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>fromData</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>SD</name></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>SymbolCast</name> <modifier>*</modifier></type><name>SC</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>SymbolCast</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>RetTy</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>RetTy</name> <operator>=</operator> <call><name><name>Sym</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>FromTy</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>Exp</name> <operator>=</operator>
<call><name>getSymExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><call><name><name>SC</name><operator>-&gt;</operator><name>getOperand</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>FromTy</name></expr></argument>, <argument><expr><name>hasComparison</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name>hasComparison</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>hasComparison</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>getCastExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>, <argument><expr><name>FromTy</name></expr></argument>, <argument><expr><call><name><name>Sym</name><operator>-&gt;</operator><name>getType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>BinarySymExpr</name> <modifier>*</modifier></type><name>BSE</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>BinarySymExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>Exp</name> <operator>=</operator>
<call><name>getSymBinExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>BSE</name></expr></argument>, <argument><expr><name>hasComparison</name></expr></argument>, <argument><expr><name>RetTy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hasComparison</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>hasComparison</name> <operator>=</operator> <name>BinaryOperator</name><operator>::</operator><call><name>isComparisonOp</name><argument_list>(<argument><expr><call><name><name>BSE</name><operator>-&gt;</operator><name>getOpcode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>Exp</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unsupported SymbolRef type!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}





static <expr_stmt><expr><specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name> <macro><name>getExpr</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>,
<argument>ASTContext &amp;Ctx</argument>, <argument>SymbolRef Sym</argument>,
<argument>QualType *RetTy = nullptr</argument>,
<argument>bool *hasComparison = nullptr</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>hasComparison</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>hasComparison</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<return>return <expr><call><name>getSymExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>Sym</name></expr></argument>, <argument><expr><name>RetTy</name></expr></argument>, <argument><expr><name>hasComparison</name></expr></argument>)</argument_list></call></expr>;</return>
}


static <expr_stmt><expr><specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name> <macro><name>getZeroExpr</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>,
<argument>ASTContext &amp;Ctx</argument>,
<argument>const llvm::SMTExprRef &amp;Exp</argument>,
<argument>QualType Ty</argument>, <argument>bool Assumption</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Ty</name><operator>-&gt;</operator><name>isRealFloatingType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>APFloat</name> <name>Zero</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name>APFloat</name><operator>::</operator><call><name>getZero</name><argument_list>(<argument><expr><call><name><name>Ctx</name><operator>.</operator><name>getFloatTypeSemantics</name></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>fromFloatBinOp</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>, <argument><expr><ternary><condition><expr><name>Assumption</name></expr> ?</condition><then> <expr><name>BO_EQ</name></expr> </then><else>: <expr><name>BO_NE</name></expr></else></ternary></expr></argument>,
<argument><expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkFloat</name></name><argument_list>(<argument><expr><name>Zero</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Ty</name><operator>-&gt;</operator><name>isIntegralOrEnumerationType</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>Ty</name><operator>-&gt;</operator><name>isAnyPointerType</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>Ty</name><operator>-&gt;</operator><name>isBlockPointerType</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>Ty</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>bool</name></type> <name>isSigned</name> <init>= <expr><call><name><name>Ty</name><operator>-&gt;</operator><name>isSignedIntegerOrEnumerationType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Ty</name><operator>-&gt;</operator><name>isBooleanType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><ternary><condition><expr><name>Assumption</name></expr> ?</condition><then> <expr><call><name>fromUnOp</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>UO_LNot</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>Exp</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>fromBinOp</name><argument_list>(
<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>, <argument><expr><ternary><condition><expr><name>Assumption</name></expr> ?</condition><then> <expr><name>BO_EQ</name></expr> </then><else>: <expr><name>BO_NE</name></expr></else></ternary></expr></argument>,
<argument><expr><call><name><name>Solver</name><operator>-&gt;</operator><name>mkBitvector</name></name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>APSInt</name><argument_list>(<argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>Ty</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>isSigned</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unsupported type for zero value!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}



static <expr_stmt><expr><specifier>inline</specifier> <name>llvm</name><operator>::</operator><name>SMTExprRef</name>
<macro><name>getRangeExpr</name><argument_list>(<argument>llvm::SMTSolverRef &amp;Solver</argument>, <argument>ASTContext &amp;Ctx</argument>, <argument>SymbolRef Sym</argument>,
<argument>const llvm::APSInt &amp;From</argument>, <argument>const llvm::APSInt &amp;To</argument>, <argument>bool InRange</argument>)</argument_list></macro> <block>{

<expr><name>QualType</name> <name>FromTy</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>APSInt</name> <name>NewFromInt</name></expr>;
<expr><name>std</name><operator>::</operator><call><name>tie</name><argument_list>(<argument><expr><name>NewFromInt</name></expr></argument>, <argument><expr><name>FromTy</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>fixAPSInt</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>From</name></expr></argument>)</argument_list></call></expr>;
<expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>FromExp</name> <operator>=</operator>
<call><name><name>Solver</name><operator>-&gt;</operator><name>mkBitvector</name></name><argument_list>(<argument><expr><name>NewFromInt</name></expr></argument>, <argument><expr><call><name><name>NewFromInt</name><operator>.</operator><name>getBitWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;


<expr><name>QualType</name> <name>SymTy</name></expr>;
<expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>Exp</name> <operator>=</operator> <call><name>getExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>Sym</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>SymTy</name></expr></argument>)</argument_list></call></expr>;


<if_stmt><if>if <condition>(<expr><name>From</name> <operator>==</operator> <name>To</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>getBinExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>, <argument><expr><name>SymTy</name></expr></argument>, <argument><expr><ternary><condition><expr><name>InRange</name></expr> ?</condition><then> <expr><name>BO_EQ</name></expr> </then><else>: <expr><name>BO_NE</name></expr></else></ternary></expr></argument>,
<argument><expr><name>FromExp</name></expr></argument>, <argument><expr><name>FromTy</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<name>QualType</name> <name>ToTy</name></block></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <name>NewToInt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><call><name>tie</name><argument_list>(<argument><expr><name>NewToInt</name></expr></argument>, <argument><expr><name>ToTy</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>fixAPSInt</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>To</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>ToExp</name> <operator>=</operator>
<call><name><name>Solver</name><operator>-&gt;</operator><name>mkBitvector</name></name><argument_list>(<argument><expr><name>NewToInt</name></expr></argument>, <argument><expr><call><name><name>NewToInt</name><operator>.</operator><name>getBitWidth</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>FromTy</name> <operator>==</operator> <name>ToTy</name> <operator>&amp;&amp;</operator> <literal type="string">"Range values have different types!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>LHS</name> <operator>=</operator>
<call><name>getBinExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>, <argument><expr><name>SymTy</name></expr></argument>, <argument><expr><ternary><condition><expr><name>InRange</name></expr> ?</condition><then> <expr><name>BO_GE</name></expr> </then><else>: <expr><name>BO_LT</name></expr></else></ternary></expr></argument>, <argument><expr><name>FromExp</name></expr></argument>,
<argument><expr><name>FromTy</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <name>RHS</name> <operator>=</operator> <call><name>getBinExpr</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>, <argument><expr><name>SymTy</name></expr></argument>,
<argument><expr><ternary><condition><expr><name>InRange</name></expr> ?</condition><then> <expr><name>BO_LE</name></expr> </then><else>: <expr><name>BO_GT</name></expr></else></ternary></expr></argument>, <argument><expr><name>ToExp</name></expr></argument>, <argument><expr><name>ToTy</name></expr></argument>,
<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>fromBinOp</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><ternary><condition><expr><name>InRange</name></expr> ?</condition><then> <expr><name>BO_LAnd</name></expr> </then><else>: <expr><name>BO_LOr</name></expr></else></ternary></expr></argument>, <argument><expr><name>RHS</name></expr></argument>,
<argument><expr><call><name><name>SymTy</name><operator>-&gt;</operator><name>isSignedIntegerOrEnumerationType</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}



static <decl_stmt><decl><type><specifier>inline</specifier> <name>QualType</name></type> <name>getAPSIntType</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APSInt</name> <operator>&amp;</operator><name>Int</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name><name>Ctx</name><operator>.</operator><name>getIntTypeForBitwidth</name></name><argument_list>(<argument><expr><call><name><name>Int</name><operator>.</operator><name>getBitWidth</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Int</name><operator>.</operator><name>isSigned</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><specifier>static</specifier> <specifier>inline</specifier> <name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>APSInt</name></expr></argument>, <argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name>
<macro><name>fixAPSInt</name><argument_list>(<argument>ASTContext &amp;Ctx</argument>, <argument>const llvm::APSInt &amp;Int</argument>)</argument_list></macro> <block>{
<expr><name>llvm</name><operator>::</operator><name>APSInt</name> <name>NewInt</name></expr>;




<if_stmt><if>if <condition>(<expr><call><name><name>Int</name><operator>.</operator><name>getBitWidth</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>getAPSIntType</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>Int</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>isNull</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>NewInt</name> <operator>=</operator> <call><name><name>Int</name><operator>.</operator><name>extend</name></name><argument_list>(<argument><expr><call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name><name>Ctx</name><operator>.</operator><name>BoolTy</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/></block_content></block></if></if_stmt>}</block></expr></expr_stmt> <if_stmt><else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>NewInt</name> <operator>=</operator> <name>Int</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><name>NewInt</name></expr></argument>, <argument><expr><call><name>getAPSIntType</name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>NewInt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}




static <decl_stmt><decl><type><specifier>inline</specifier> <name>void</name></type> <name>doTypeConversion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>SMTSolverRef</name> <operator>&amp;</operator><name>Solver</name></expr></argument>,
<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <operator>&amp;</operator><name>LHS</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name> <operator>&amp;</operator><name>RHS</name></expr></argument>, <argument><expr><name>QualType</name> <operator>&amp;</operator><name>LTy</name></expr></argument>,
<argument><expr><name>QualType</name> <operator>&amp;</operator><name>RTy</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>LTy</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>RTy</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Input type is null!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name><name>LTy</name><operator>-&gt;</operator><name>isIntegralOrEnumerationType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>RTy</name><operator>-&gt;</operator><name>isIntegralOrEnumerationType</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><call><name><name>LTy</name><operator>-&gt;</operator><name>isArithmeticType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>RTy</name><operator>-&gt;</operator><name>isArithmeticType</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>SMTConv</name><operator>::</operator><call><name><name>doIntTypeConversion</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fromCast</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>LTy</name><operator>-&gt;</operator><name>isRealFloatingType</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>RTy</name><operator>-&gt;</operator><name>isRealFloatingType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>SMTConv</name><operator>::</operator><call><name><name>doFloatTypeConversion</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>SMTExprRef</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fromCast</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>Ctx</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name><name>LTy</name><operator>-&gt;</operator><name>isAnyPointerType</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>RTy</name><operator>-&gt;</operator><name>isAnyPointerType</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name><name>LTy</name><operator>-&gt;</operator><name>isBlockPointerType</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>RTy</name><operator>-&gt;</operator><name>isBlockPointerType</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name><name>LTy</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>RTy</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>uint64_t</name></type> <name>LBitWidth</name> <init>= <expr><call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>LTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>RBitWidth</name> <init>= <expr><call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>RTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name><name>LTy</name><operator>-&gt;</operator><name>isAnyPointerType</name></name><argument_list>()</argument_list></call> <operator>^</operator> <call><name><name>RTy</name><operator>-&gt;</operator><name>isAnyPointerType</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name><name>LTy</name><operator>-&gt;</operator><name>isBlockPointerType</name></name><argument_list>()</argument_list></call> <operator>^</operator> <call><name><name>RTy</name><operator>-&gt;</operator><name>isBlockPointerType</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name><name>LTy</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call> <operator>^</operator> <call><name><name>RTy</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>LTy</name><operator>-&gt;</operator><name>isNullPtrType</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>LTy</name><operator>-&gt;</operator><name>isBlockPointerType</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>LTy</name><operator>-&gt;</operator><name>isReferenceType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LHS</name> <operator>=</operator> <call><name>fromCast</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RBitWidth</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>LBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>LTy</name> <operator>=</operator> <name>RTy</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>RHS</name> <operator>=</operator> <call><name>fromCast</name><argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>LBitWidth</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>RTy</name> <operator>=</operator> <name>LTy</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><call><name><name>LTy</name><operator>-&gt;</operator><name>isVoidPointerType</name></name><argument_list>()</argument_list></call> <operator>^</operator> <call><name><name>RTy</name><operator>-&gt;</operator><name>isVoidPointerType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>LTy</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>RTy</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Pointer types have different bitwidths!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>RTy</name><operator>-&gt;</operator><name>isVoidPointerType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>RTy</name> <operator>=</operator> <name>LTy</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>LTy</name> <operator>=</operator> <name>RTy</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>LTy</name> <operator>==</operator> <name>RTy</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name><name>LTy</name><operator>.</operator><name>getCanonicalType</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>RTy</name><operator>.</operator><name>getCanonicalType</name></name><argument_list>()</argument_list></call><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name><name>LTy</name><operator>-&gt;</operator><name>isObjCObjectPointerType</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name><name>RTy</name><operator>-&gt;</operator><name>isObjCObjectPointerType</name></name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LTy</name> <operator>=</operator> <name>RTy</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>T</name> <operator>(</operator><operator>*</operator><name>doCast</name><operator>)</operator><operator>(</operator><name>llvm</name><operator>::</operator><name>SMTSolverRef</name> <operator>&amp;</operator><name>Solver</name>, <specifier>const</specifier> <name>T</name> <operator>&amp;</operator>,
<name>QualType</name>, <name>uint64_t</name>, <name>QualType</name>, <name>uint64_t</name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>doIntTypeConversion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>SMTSolverRef</name> <operator>&amp;</operator><name>Solver</name></expr></argument>,
<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>, <argument><expr><name>T</name> <operator>&amp;</operator><name>LHS</name></expr></argument>, <argument><expr><name>QualType</name> <operator>&amp;</operator><name>LTy</name></expr></argument>,
<argument><expr><name>T</name> <operator>&amp;</operator><name>RHS</name></expr></argument>, <argument><expr><name>QualType</name> <operator>&amp;</operator><name>RTy</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>LBitWidth</name> <init>= <expr><call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>LTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>RBitWidth</name> <init>= <expr><call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>RTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>LTy</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>RTy</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Input type is null!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>LTy</name><operator>-&gt;</operator><name>isPromotableIntegerType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>NewTy</name> <init>= <expr><call><name><name>Ctx</name><operator>.</operator><name>getPromotedIntegerType</name></name><argument_list>(<argument><expr><name>LTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>NewBitWidth</name> <init>= <expr><call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>NewTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>LHS</name> <operator>=</operator> <call>(<modifier>*</modifier><name>doCast</name>)<argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>NewTy</name></expr></argument>, <argument><expr><name>NewBitWidth</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>LBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>LTy</name> <operator>=</operator> <name>NewTy</name></expr>;</expr_stmt>
<expr_stmt><expr><name>LBitWidth</name> <operator>=</operator> <name>NewBitWidth</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>RTy</name><operator>-&gt;</operator><name>isPromotableIntegerType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>QualType</name></type> <name>NewTy</name> <init>= <expr><call><name><name>Ctx</name><operator>.</operator><name>getPromotedIntegerType</name></name><argument_list>(<argument><expr><name>RTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>NewBitWidth</name> <init>= <expr><call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>NewTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>RHS</name> <operator>=</operator> <call>(<modifier>*</modifier><name>doCast</name>)<argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>NewTy</name></expr></argument>, <argument><expr><name>NewBitWidth</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>RTy</name> <operator>=</operator> <name>NewTy</name></expr>;</expr_stmt>
<expr_stmt><expr><name>RBitWidth</name> <operator>=</operator> <name>NewBitWidth</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>LTy</name> <operator>==</operator> <name>RTy</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isLSignedTy</name> <init>= <expr><call><name><name>LTy</name><operator>-&gt;</operator><name>isSignedIntegerOrEnumerationType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isRSignedTy</name> <init>= <expr><call><name><name>RTy</name><operator>-&gt;</operator><name>isSignedIntegerOrEnumerationType</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>order</name> <init>= <expr><call><name><name>Ctx</name><operator>.</operator><name>getIntegerTypeOrder</name></name><argument_list>(<argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>isLSignedTy</name> <operator>==</operator> <name>isRSignedTy</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>order</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>RHS</name> <operator>=</operator> <call>(<modifier>*</modifier><name>doCast</name>)<argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>LBitWidth</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>RTy</name> <operator>=</operator> <name>LTy</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>LHS</name> <operator>=</operator> <call>(<modifier>*</modifier><name>doCast</name>)<argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RBitWidth</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>LBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>LTy</name> <operator>=</operator> <name>RTy</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>order</name> <operator>!=</operator> <operator>(</operator><ternary><condition><expr><name>isLSignedTy</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>isRSignedTy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>RHS</name> <operator>=</operator> <call>(<modifier>*</modifier><name>doCast</name>)<argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>LBitWidth</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>RTy</name> <operator>=</operator> <name>LTy</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>LHS</name> <operator>=</operator> <call>(<modifier>*</modifier><name>doCast</name>)<argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RBitWidth</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>LBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>LTy</name> <operator>=</operator> <name>RTy</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>LBitWidth</name> <operator>!=</operator> <name>RBitWidth</name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>isLSignedTy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>RHS</name> <operator>=</operator> <operator>(</operator><name>doCast</name><operator>)</operator><operator>(</operator><name>Solver</name><operator>,</operator> <name>RHS</name><operator>,</operator> <name>LTy</name><operator>,</operator> <name>LBitWidth</name><operator>,</operator> <name>RTy</name><operator>,</operator> <name>RBitWidth</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>RTy</name> <operator>=</operator> <name>LTy</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>LHS</name> <operator>=</operator> <call>(<modifier>*</modifier><name>doCast</name>)<argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RBitWidth</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>LBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>LTy</name> <operator>=</operator> <name>RTy</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>




<decl_stmt><decl><type><name>QualType</name></type> <name>NewTy</name> <init>=
<expr><call><name><name>Ctx</name><operator>.</operator><name>getCorrespondingUnsignedType</name></name><argument_list>(<argument><expr><ternary><condition><expr><name>isLSignedTy</name></expr> ?</condition><then> <expr><name>LTy</name></expr> </then><else>: <expr><name>RTy</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>RHS</name> <operator>=</operator> <call>(<modifier>*</modifier><name>doCast</name>)<argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>LBitWidth</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>RTy</name> <operator>=</operator> <name>NewTy</name></expr>;</expr_stmt>
<expr_stmt><expr><name>LHS</name> <operator>=</operator> <operator>(</operator><name>doCast</name><operator>)</operator><operator>(</operator><name>Solver</name><operator>,</operator> <name>LHS</name><operator>,</operator> <name>RTy</name><operator>,</operator> <name>RBitWidth</name><operator>,</operator> <name>LTy</name><operator>,</operator> <name>LBitWidth</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>LTy</name> <operator>=</operator> <name>NewTy</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>T</name> <operator>(</operator><operator>*</operator><name>doCast</name><operator>)</operator><operator>(</operator><name>llvm</name><operator>::</operator><name>SMTSolverRef</name> <operator>&amp;</operator><name>Solver</name>, <specifier>const</specifier> <name>T</name> <operator>&amp;</operator>,
<name>QualType</name>, <name>uint64_t</name>, <name>QualType</name>, <name>uint64_t</name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>doFloatTypeConversion</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>SMTSolverRef</name> <operator>&amp;</operator><name>Solver</name></expr></argument>, <argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>, <argument><expr><name>T</name> <operator>&amp;</operator><name>LHS</name></expr></argument>,
<argument><expr><name>QualType</name> <operator>&amp;</operator><name>LTy</name></expr></argument>, <argument><expr><name>T</name> <operator>&amp;</operator><name>RHS</name></expr></argument>, <argument><expr><name>QualType</name> <operator>&amp;</operator><name>RTy</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>LBitWidth</name> <init>= <expr><call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>LTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>RBitWidth</name> <init>= <expr><call><name><name>Ctx</name><operator>.</operator><name>getTypeSize</name></name><argument_list>(<argument><expr><name>RTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>LTy</name><operator>-&gt;</operator><name>isRealFloatingType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LHS</name> <operator>=</operator> <call>(<modifier>*</modifier><name>doCast</name>)<argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RBitWidth</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>LBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>LTy</name> <operator>=</operator> <name>RTy</name></expr>;</expr_stmt>
<expr_stmt><expr><name>LBitWidth</name> <operator>=</operator> <name>RBitWidth</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>RTy</name><operator>-&gt;</operator><name>isRealFloatingType</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>RHS</name> <operator>=</operator> <call>(<modifier>*</modifier><name>doCast</name>)<argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>LBitWidth</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>RTy</name> <operator>=</operator> <name>LTy</name></expr>;</expr_stmt>
<expr_stmt><expr><name>RBitWidth</name> <operator>=</operator> <name>LBitWidth</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>LTy</name> <operator>==</operator> <name>RTy</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>




<decl_stmt><decl><type><name>int</name></type> <name>order</name> <init>= <expr><call><name><name>Ctx</name><operator>.</operator><name>getFloatingTypeOrder</name></name><argument_list>(<argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>order</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>RHS</name> <operator>=</operator> <call>(<modifier>*</modifier><name>doCast</name>)<argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>RHS</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>LBitWidth</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>RTy</name> <operator>=</operator> <name>LTy</name></expr>;</expr_stmt>
</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>order</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>LHS</name> <operator>=</operator> <call>(<modifier>*</modifier><name>doCast</name>)<argument_list>(<argument><expr><name>Solver</name></expr></argument>, <argument><expr><name>LHS</name></expr></argument>, <argument><expr><name>RTy</name></expr></argument>, <argument><expr><name>RBitWidth</name></expr></argument>, <argument><expr><name>LTy</name></expr></argument>, <argument><expr><name>LBitWidth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>LTy</name> <operator>=</operator> <name>RTy</name></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Unsupported floating-point type cast!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></decl></decl_stmt>
};
}
}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
