<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Sema/DeclSpec.h">




















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_SEMA_DECLSPEC_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_SEMA_DECLSPEC_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclObjCCommon.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/NestedNameSpecifier.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/ExceptionSpecificationType.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Lambda.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OperatorKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/Token.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/Ownership.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/ParsedAttr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/ErrorHandling.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXRecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypeLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LangOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NamespaceAliasDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NamespaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCDeclSpec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Sema</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Declarator</name></decl>;</decl_stmt>
<struct_decl>struct <name>TemplateIdAnnotation</name>;</struct_decl>













<decl_stmt><decl><type><name>class</name></type> <name>CXXScopeSpec</name> <block>{<block_content>
<decl_stmt><decl><type><name>SourceRange</name></type> <name>Range</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NestedNameSpecifierLocBuilder</name></type> <name>Builder</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><name>SourceRange</name> <macro><name>getRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setRange</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Range</name> <operator>=</operator> <name>R</name></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setBeginLoc</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Range</name><operator>.</operator><name>setBegin</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>setEndLoc</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Range</name><operator>.</operator><name>setEnd</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>NestedNameSpecifier</name> <operator>*</operator><macro><name>getScopeRep</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Builder</name><operator>.</operator><name>getRepresentation</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>












<function_decl><type><name>void</name></type> <name>Extend</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>, <parameter><decl><type><name>TypeLoc</name></type> <name>TL</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonColonLoc</name></decl></parameter>)</parameter_list>;</function_decl>












<function_decl><type><name>void</name></type> <name>Extend</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Identifier</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdentifierLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonColonLoc</name></decl></parameter>)</parameter_list>;</function_decl>












<function_decl><type><name>void</name></type> <name>Extend</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>NamespaceDecl</name> <modifier>*</modifier></type><name>Namespace</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NamespaceLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonColonLoc</name></decl></parameter>)</parameter_list>;</function_decl>













<function_decl><type><name>void</name></type> <name>Extend</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>NamespaceAliasDecl</name> <modifier>*</modifier></type><name>Alias</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AliasLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonColonLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>MakeGlobal</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonColonLoc</name></decl></parameter>)</parameter_list>;</function_decl>














<function_decl><type><name>void</name></type> <name>MakeSuper</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonColonLoc</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>void</name></type> <name>MakeTrivial</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl></parameter>, <parameter><decl><type><name>NestedNameSpecifier</name> <modifier>*</modifier></type><name>Qualifier</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>Adopt</name><parameter_list>(<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>Other</name></decl></parameter>)</parameter_list>;</function_decl>






<decl_stmt><decl><type><name>NestedNameSpecifierLoc</name></type> <name>getWithLocInContext</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>










<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLastQualifierNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isEmpty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>getScopeRep</name><argument_list>()</argument_list></call> <operator>==</operator> <name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isNotEmpty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isEmpty</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isInvalid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <call><name>getScopeRep</name><argument_list>()</argument_list></call> <operator>==</operator> <name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getScopeRep</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>SetInvalid</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>R</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Must have a valid source range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isInvalid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Range</name><operator>.</operator><name>setBegin</name></name><argument_list>(<argument><expr><call><name><name>R</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>Range</name><operator>.</operator><name>setEnd</name></name><argument_list>(<argument><expr><call><name><name>R</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Builder</name><operator>.</operator><name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>isSet</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getScopeRep</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>nullptr</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Range</name> <operator>=</operator> <call><name>SourceRange</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Builder</name><operator>.</operator><name>Clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>char</name> <operator>*</operator><macro><name>location_data</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Builder</name><operator>.</operator><name>getBuffer</name></name><argument_list>()</argument_list></call><operator>.</operator><name>first</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>location_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Builder</name><operator>.</operator><name>getBuffer</name></name><argument_list>()</argument_list></call><operator>.</operator><name>second</name></expr>;</return> }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>DeclSpec</name> <block>{<block_content>
<label><name>public</name>:</label>


<enum>enum <name>SCS</name> <block>{
<decl><name>SCS_unspecified</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>SCS_typedef</name></decl>,
<decl><name>SCS_extern</name></decl>,
<decl><name>SCS_static</name></decl>,
<decl><name>SCS_auto</name></decl>,
<decl><name>SCS_register</name></decl>,
<decl><name>SCS_private_extern</name></decl>,
<decl><name>SCS_mutable</name></decl>
}</block>;</enum>



<typedef>typedef <type><name>ThreadStorageClassSpecifier</name></type> <name>TSCS</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TSCS</name></type> <name>TSCS_unspecified</name> <init>= <expr><name>clang</name><operator>::</operator><name>TSCS_unspecified</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TSCS</name></type> <name>TSCS___thread</name> <init>= <expr><name>clang</name><operator>::</operator><name>TSCS___thread</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TSCS</name></type> <name>TSCS_thread_local</name> <init>= <expr><name>clang</name><operator>::</operator><name>TSCS_thread_local</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TSCS</name></type> <name>TSCS__Thread_local</name> <init>= <expr><name>clang</name><operator>::</operator><name>TSCS__Thread_local</name></expr></init></decl>;</decl_stmt>

<enum>enum <name>TSC</name> <block>{
<decl><name>TSC_unspecified</name></decl>,
<decl><name>TSC_imaginary</name></decl>,
<decl><name>TSC_complex</name></decl>
}</block>;</enum>


<typedef>typedef <type><name>TypeSpecifierType</name></type> <name>TST</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_unspecified</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_unspecified</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_void</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_void</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_char</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_char</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_wchar</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_wchar</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_char8</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_char8</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_char16</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_char16</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_char32</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_char32</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_int</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_int</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_int128</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_int128</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_extint</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_extint</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_half</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_half</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_BFloat16</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_BFloat16</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_float</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_float</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_double</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_double</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_float16</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_Float16</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_accum</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_Accum</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_fract</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_Fract</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_float128</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_float128</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_bool</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_bool</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_decimal32</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_decimal32</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_decimal64</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_decimal64</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_decimal128</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_decimal128</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_enum</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_enum</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_union</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_union</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_struct</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_struct</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_interface</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_interface</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_class</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_class</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_typename</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_typename</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_typeofType</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_typeofType</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_typeofExpr</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_typeofExpr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_decltype</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_decltype</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_decltype_auto</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_decltype_auto</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_underlyingType</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_underlyingType</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_auto</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_auto</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_auto_type</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_auto_type</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_unknown_anytype</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_unknown_anytype</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_atomic</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_atomic</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GENERIC_IMAGE_TYPE</name><parameter_list>(<parameter><type><name>ImgType</name></type></parameter>, <parameter><type><name>Id</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>static const TST TST_##ImgType##_t = clang::TST_##ImgType##_t;</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLImageTypes.def"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>TST</name></type> <name>TST_error</name> <init>= <expr><name>clang</name><operator>::</operator><name>TST_error</name></expr></init></decl>;</decl_stmt>


<enum>enum <name>TQ</name> <block>{
<decl><name>TQ_unspecified</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>TQ_const</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>TQ_restrict</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>TQ_volatile</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
<decl><name>TQ_unaligned</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>,


<decl><name>TQ_atomic</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>
}</block>;</enum>



<enum>enum <name>ParsedSpecifiers</name> <block>{
<decl><name>PQ_None</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>PQ_StorageClassSpecifier</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>PQ_TypeSpecifier</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>PQ_TypeQualifier</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
<decl><name>PQ_FunctionSpecifier</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>

}</block>;</enum>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>unsigned</name></type> <name>StorageClassSpec</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ThreadStorageClassSpec</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>SCS_extern_in_linkage_spec</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeSpecWidth</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeSpecComplex</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeSpecSign</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeSpecType</name> <range>: <expr><literal type="number">6</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeAltiVecVector</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeAltiVecPixel</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeAltiVecBool</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeSpecOwned</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeSpecPipe</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeSpecSat</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ConstrainedAuto</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeQualifiers</name> <range>: <expr><literal type="number">5</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>FS_inline_specified</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>FS_forceinline_specified</name><range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>FS_virtual_specified</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>FS_noreturn_specified</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>Friend_specified</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ConstexprSpecifier</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>

<union>union <block>{
<decl_stmt><decl><type><name>UnionParsedType</name></type> <name>TypeRep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>DeclRep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ExprRep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TemplateIdAnnotation</name> <modifier>*</modifier></type><name>TemplateIdRep</name></decl>;</decl_stmt>
}</block>;</union>


<decl_stmt><decl><type><name>ExplicitSpecifier</name></type> <name>FS_explicit_specifier</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ParsedAttributes</name></type> <name>Attrs</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>TypeScope</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>SourceRange</name></type> <name>Range</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>StorageClassSpecLoc</name></decl>, <decl><type ref="prev"/><name>ThreadStorageClassSpecLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceRange</name></type> <name>TSWRange</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TSCLoc</name></decl>, <decl><type ref="prev"/><name>TSSLoc</name></decl>, <decl><type ref="prev"/><name>TSTLoc</name></decl>, <decl><type ref="prev"/><name>AltiVecLoc</name></decl>, <decl><type ref="prev"/><name>TSSatLoc</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TSTNameLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceRange</name></type> <name>TypeofParensRange</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TQ_constLoc</name></decl>, <decl><type ref="prev"/><name>TQ_restrictLoc</name></decl>, <decl><type ref="prev"/><name>TQ_volatileLoc</name></decl>, <decl><type ref="prev"/><name>TQ_atomicLoc</name></decl>,
<decl><type ref="prev"/><name>TQ_unalignedLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FS_inlineLoc</name></decl>, <decl><type ref="prev"/><name>FS_virtualLoc</name></decl>, <decl><type ref="prev"/><name>FS_explicitLoc</name></decl>, <decl><type ref="prev"/><name>FS_noreturnLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FS_explicitCloseParenLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FS_forceinlineLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FriendLoc</name></decl>, <decl><type ref="prev"/><name>ModulePrivateLoc</name></decl>, <decl><type ref="prev"/><name>ConstexprLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TQ_pipeLoc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>WrittenBuiltinSpecs</name></type> <name>writtenBS</name></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>SaveWrittenBuiltinSpecs</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>ObjCDeclSpec</name> <modifier>*</modifier></type><name>ObjCQualifiers</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isTypeRep</name><parameter_list>(<parameter><decl><type><name>TST</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name>T</name> <operator>==</operator> <name>TST_typename</name> <operator>||</operator> <name>T</name> <operator>==</operator> <name>TST_typeofType</name> <operator>||</operator>
<name>T</name> <operator>==</operator> <name>TST_underlyingType</name> <operator>||</operator> <name>T</name> <operator>==</operator> <name>TST_atomic</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>isExprRep</name><parameter_list>(<parameter><decl><type><name>TST</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name>T</name> <operator>==</operator> <name>TST_typeofExpr</name> <operator>||</operator> <name>T</name> <operator>==</operator> <name>TST_decltype</name> <operator>||</operator> <name>T</name> <operator>==</operator> <name>TST_extint</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>isTemplateIdRep</name><parameter_list>(<parameter><decl><type><name>TST</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name>T</name> <operator>==</operator> <name>TST_auto</name> <operator>||</operator> <name>T</name> <operator>==</operator> <name>TST_decltype_auto</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>DeclSpec</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclSpec</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>DeclSpec</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
<label><name>public</name>:</label>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>isDeclRep</name><parameter_list>(<parameter><decl><type><name>TST</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name>T</name> <operator>==</operator> <name>TST_enum</name> <operator>||</operator> <name>T</name> <operator>==</operator> <name>TST_struct</name> <operator>||</operator>
<name>T</name> <operator>==</operator> <name>TST_interface</name> <operator>||</operator> <name>T</name> <operator>==</operator> <name>TST_union</name> <operator>||</operator>
<name>T</name> <operator>==</operator> <name>TST_class</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><call><name>DeclSpec</name><argument_list>(<argument><expr><name>AttributeFactory</name> <operator>&amp;</operator><name>attrFactory</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>StorageClassSpec</name><argument_list>(<argument><expr><name>SCS_unspecified</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>ThreadStorageClassSpec</name><argument_list>(<argument><expr><name>TSCS_unspecified</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>SCS_extern_in_linkage_spec</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>TypeSpecWidth</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TypeSpecifierWidth</name><operator>::</operator><name>Unspecified</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>TypeSpecComplex</name><argument_list>(<argument><expr><name>TSC_unspecified</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>TypeSpecSign</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TypeSpecifierSign</name><operator>::</operator><name>Unspecified</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>TypeSpecType</name><argument_list>(<argument><expr><name>TST_unspecified</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>TypeAltiVecVector</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>TypeAltiVecPixel</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>TypeAltiVecBool</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>TypeSpecOwned</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>TypeSpecPipe</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>TypeSpecSat</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ConstrainedAuto</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>TypeQualifiers</name><argument_list>(<argument><expr><name>TQ_unspecified</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>FS_inline_specified</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>FS_forceinline_specified</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>FS_virtual_specified</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>FS_noreturn_specified</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Friend_specified</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>ConstexprSpecifier</name><argument_list>(
<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ConstexprSpecKind</name><operator>::</operator><name>Unspecified</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>FS_explicit_specifier</name><argument_list>()</argument_list></call></expr><operator>,</operator> <expr><call><name>Attrs</name><argument_list>(<argument><expr><name>attrFactory</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>writtenBS</name><argument_list>()</argument_list></call></expr><operator>,</operator>
<macro><name>ObjCQualifiers</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>


<name>SCS</name> <macro><name>getStorageClassSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>SCS</name><operator>)</operator><name>StorageClassSpec</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>TSCS</name> <macro><name>getThreadStorageClassSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>TSCS</name><operator>)</operator><name>ThreadStorageClassSpec</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isExternInLinkageSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SCS_extern_in_linkage_spec</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setExternInLinkageSpec</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SCS_extern_in_linkage_spec</name> <operator>=</operator> <name>Value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getStorageClassSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>StorageClassSpecLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getThreadStorageClassSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ThreadStorageClassSpecLoc</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>ClearStorageClassSpecs</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>StorageClassSpec</name> <operator>=</operator> <name>DeclSpec</name><operator>::</operator><name>SCS_unspecified</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ThreadStorageClassSpec</name> <operator>=</operator> <name>DeclSpec</name><operator>::</operator><name>TSCS_unspecified</name></expr>;</expr_stmt>
<expr_stmt><expr><name>SCS_extern_in_linkage_spec</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>StorageClassSpecLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ThreadStorageClassSpecLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>ClearTypeSpecType</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>TypeSpecType</name> <operator>=</operator> <name>DeclSpec</name><operator>::</operator><name>TST_unspecified</name></expr>;</expr_stmt>
<expr_stmt><expr><name>TypeSpecOwned</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>TSTLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>TypeSpecifierWidth</name> <macro><name>getTypeSpecWidth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecifierWidth</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TypeSpecWidth</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>TSC</name> <macro><name>getTypeSpecComplex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>TSC</name><operator>)</operator><name>TypeSpecComplex</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>TypeSpecifierSign</name> <macro><name>getTypeSpecSign</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TypeSpecifierSign</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TypeSpecSign</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>TST</name> <macro><name>getTypeSpecType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>TST</name><operator>)</operator><name>TypeSpecType</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isTypeAltiVecVector</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypeAltiVecVector</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isTypeAltiVecPixel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypeAltiVecPixel</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isTypeAltiVecBool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypeAltiVecBool</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isTypeSpecOwned</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypeSpecOwned</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isTypeRep</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isTypeRep</name><argument_list>(<argument><expr><operator>(</operator><name>TST</name><operator>)</operator> <name>TypeSpecType</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isTypeSpecPipe</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypeSpecPipe</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isTypeSpecSat</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypeSpecSat</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isConstrainedAuto</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ConstrainedAuto</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>ParsedType</name> <macro><name>getRepAsType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isTypeRep</name><argument_list>(<argument><expr><operator>(</operator><name>TST</name><operator>)</operator> <name>TypeSpecType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"DeclSpec does not store a type"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>TypeRep</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Decl</name> <operator>*</operator><macro><name>getRepAsDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isDeclRep</name><argument_list>(<argument><expr><operator>(</operator><name>TST</name><operator>)</operator> <name>TypeSpecType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"DeclSpec does not store a decl"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>DeclRep</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getRepAsExpr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isExprRep</name><argument_list>(<argument><expr><operator>(</operator><name>TST</name><operator>)</operator> <name>TypeSpecType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"DeclSpec does not store an expr"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>ExprRep</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>TemplateIdAnnotation</name> <operator>*</operator><macro><name>getRepAsTemplateId</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isTemplateIdRep</name><argument_list>(<argument><expr><operator>(</operator><name>TST</name><operator>)</operator> <name>TypeSpecType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"DeclSpec does not store a template id"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>TemplateIdRep</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>getTypeSpecScope</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>TypeScope</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>CXXScopeSpec</name> <operator>&amp;</operator><macro><name>getTypeSpecScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypeScope</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getTypeSpecWidthLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>TSWRange</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceRange</name> <macro><name>getTypeSpecWidthRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TSWRange</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getTypeSpecComplexLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TSCLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getTypeSpecSignLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TSSLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getTypeSpecTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TSTLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getAltiVecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AltiVecLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getTypeSpecSatLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TSSatLoc</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getTypeSpecTypeNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isDeclRep</name><argument_list>(<argument><expr><operator>(</operator><name>TST</name><operator>)</operator> <name>TypeSpecType</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>TypeSpecType</name> <operator>==</operator> <name>TST_typename</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>TSTNameLoc</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getTypeofParensRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypeofParensRange</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setTypeofParensRange</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>range</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>TypeofParensRange</name> <operator>=</operator> <name>range</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>hasAutoTypeSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>TypeSpecType</name> <operator>==</operator> <name>TST_auto</name> <operator>||</operator> <name>TypeSpecType</name> <operator>==</operator> <name>TST_auto_type</name> <operator>||</operator>
<name>TypeSpecType</name> <operator>==</operator> <name>TST_decltype_auto</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasTagDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getSpecifierName</name><argument_list>(<argument><expr><name>DeclSpec</name><operator>::</operator><name>TST</name> <name>T</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getSpecifierName</name><argument_list>(<argument><expr><name>DeclSpec</name><operator>::</operator><name>TQ</name> <name>Q</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getSpecifierName</name><parameter_list>(<parameter><decl><type><name>TypeSpecifierSign</name></type> <name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getSpecifierName</name><argument_list>(<argument><expr><name>DeclSpec</name><operator>::</operator><name>TSC</name> <name>C</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getSpecifierName</name><parameter_list>(<parameter><decl><type><name>TypeSpecifierWidth</name></type> <name>W</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getSpecifierName</name><argument_list>(<argument><expr><name>DeclSpec</name><operator>::</operator><name>SCS</name> <name>S</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getSpecifierName</name><argument_list>(<argument><expr><name>DeclSpec</name><operator>::</operator><name>TSCS</name> <name>S</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getSpecifierName</name><parameter_list>(<parameter><decl><type><name>ConstexprSpecKind</name></type> <name>C</name></decl></parameter>)</parameter_list>;</function_decl>




<expr_stmt><expr><name>unsigned</name> <macro><name>getTypeQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TypeQualifiers</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getConstSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TQ_constLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getRestrictSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TQ_restrictLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getVolatileSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TQ_volatileLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getAtomicSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TQ_atomicLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getUnalignedSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TQ_unalignedLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getPipeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TQ_pipeLoc</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>ClearTypeQualifiers</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>TypeQualifiers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>TQ_constLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>TQ_restrictLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>TQ_volatileLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>TQ_atomicLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>TQ_unalignedLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>TQ_pipeLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>isInlineSpecified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>FS_inline_specified</name> <operator>|</operator> <name>FS_forceinline_specified</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getInlineSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>FS_inline_specified</name> <operator>?</operator> <name>FS_inlineLoc</name> <operator>:</operator> <name>FS_forceinlineLoc</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>ExplicitSpecifier</name> <macro><name>getExplicitSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>FS_explicit_specifier</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isVirtualSpecified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FS_virtual_specified</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getVirtualSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FS_virtualLoc</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasExplicitSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>FS_explicit_specifier</name><operator>.</operator><name>isSpecified</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getExplicitSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FS_explicitLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceRange</name> <macro><name>getExplicitSpecRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>FS_explicit_specifier</name><operator>.</operator><name>getExpr</name></name><argument_list>()</argument_list></call>
<operator>?</operator> <call><name>SourceRange</name><argument_list>(<argument><expr><name>FS_explicitLoc</name></expr></argument>, <argument><expr><name>FS_explicitCloseParenLoc</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SourceRange</name><argument_list>(<argument><expr><name>FS_explicitLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isNoreturnSpecified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FS_noreturn_specified</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getNoreturnSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FS_noreturnLoc</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>ClearFunctionSpecs</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>FS_inline_specified</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>FS_inlineLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FS_forceinline_specified</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>FS_forceinlineLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FS_virtual_specified</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>FS_virtualLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FS_explicit_specifier</name> <operator>=</operator> <call><name>ExplicitSpecifier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FS_explicitLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FS_explicitCloseParenLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>FS_noreturn_specified</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>FS_noreturnLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<decl_stmt><decl><type><name>void</name></type> <name>forEachCVRUQualifier</name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>TQ</name>, <name>StringRef</name>, <name>SourceLocation</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>Handle</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<decl_stmt><decl><type><name>void</name></type> <name>forEachQualifier</name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>TQ</name>, <name>StringRef</name>, <name>SourceLocation</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>Handle</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasTypeSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getTypeSpecType</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>DeclSpec</name><operator>::</operator><name>TST_unspecified</name> <operator>||</operator>
<call><name>getTypeSpecWidth</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TypeSpecifierWidth</name><operator>::</operator><name>Unspecified</name> <operator>||</operator>
<call><name>getTypeSpecComplex</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>DeclSpec</name><operator>::</operator><name>TSC_unspecified</name> <operator>||</operator>
<call><name>getTypeSpecSign</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TypeSpecifierSign</name><operator>::</operator><name>Unspecified</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getParsedSpecifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isEmpty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getParsedSpecifiers</name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclSpec</name><operator>::</operator><name>PQ_None</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>SetRangeStart</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Range</name><operator>.</operator><name>setBegin</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
<function><type><name>void</name></type> <name>SetRangeEnd</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Range</name><operator>.</operator><name>setEnd</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>











<function_decl><type><name>bool</name></type> <name>SetStorageClassSpec</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SCS</name></type> <name>SC</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetStorageClassSpecThread</name><parameter_list>(<parameter><decl><type><name>TSCS</name></type> <name>TSC</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypeSpecWidth</name><parameter_list>(<parameter><decl><type><name>TypeSpecifierWidth</name></type> <name>W</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypeSpecComplex</name><parameter_list>(<parameter><decl><type><name>TSC</name></type> <name>C</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypeSpecSign</name><parameter_list>(<parameter><decl><type><name>TypeSpecifierSign</name></type> <name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypeSpecType</name><parameter_list>(<parameter><decl><type><name>TST</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypeSpecType</name><parameter_list>(<parameter><decl><type><name>TST</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>, <parameter><decl><type><name>ParsedType</name></type> <name>Rep</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>bool</name></type> <name>SetTypeSpecType</name><parameter_list>(<parameter><decl><type><name>TST</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>, <parameter><decl><type><name>TypeResult</name></type> <name>Rep</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>Rep</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SetTypeSpecError</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>SetTypeSpecType</name><argument_list>(<argument><expr><name>T</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>PrevSpec</name></expr></argument>, <argument><expr><name>DiagID</name></expr></argument>, <argument><expr><call><name><name>Rep</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>Policy</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function_decl><type><name>bool</name></type> <name>SetTypeSpecType</name><parameter_list>(<parameter><decl><type><name>TST</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Rep</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Owned</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypeSpecType</name><parameter_list>(<parameter><decl><type><name>TST</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TagKwLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TagNameLoc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>, <parameter><decl><type><name>ParsedType</name></type> <name>Rep</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypeSpecType</name><parameter_list>(<parameter><decl><type><name>TST</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TagKwLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TagNameLoc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Rep</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Owned</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypeSpecType</name><parameter_list>(<parameter><decl><type><name>TST</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>, <parameter><decl><type><name>TemplateIdAnnotation</name> <modifier>*</modifier></type><name>Rep</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>SetTypeSpecType</name><parameter_list>(<parameter><decl><type><name>TST</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Rep</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>policy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypeAltiVecVector</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isAltiVecVector</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypeAltiVecPixel</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isAltiVecPixel</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypeAltiVecBool</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isAltiVecBool</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypePipe</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isPipe</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetExtIntType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BitWidth</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypeSpecSat</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetTypeSpecError</name><parameter_list>()</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>UpdateDeclRep</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Rep</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isDeclRep</name><argument_list>(<argument><expr><operator>(</operator><name>TST</name><operator>)</operator> <name>TypeSpecType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>DeclRep</name> <operator>=</operator> <name>Rep</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>UpdateTypeRep</name><parameter_list>(<parameter><decl><type><name>ParsedType</name></type> <name>Rep</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isTypeRep</name><argument_list>(<argument><expr><operator>(</operator><name>TST</name><operator>)</operator> <name>TypeSpecType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>TypeRep</name> <operator>=</operator> <name>Rep</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>UpdateExprRep</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Rep</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isExprRep</name><argument_list>(<argument><expr><operator>(</operator><name>TST</name><operator>)</operator> <name>TypeSpecType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ExprRep</name> <operator>=</operator> <name>Rep</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><name>bool</name></type> <name>SetTypeQual</name><parameter_list>(<parameter><decl><type><name>TQ</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>SetTypeQual</name><parameter_list>(<parameter><decl><type><name>TQ</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LangOptions</name> <modifier>&amp;</modifier></type><name>Lang</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>setFunctionSpecInline</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>setFunctionSpecForceInline</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>setFunctionSpecVirtual</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>setFunctionSpecExplicit</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>, <parameter><decl><type><name>ExplicitSpecifier</name></type> <name>ExplicitSpec</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CloseParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>setFunctionSpecNoreturn</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>SetFriendSpec</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>setModulePrivateSpec</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SetConstexprSpec</name><parameter_list>(<parameter><decl><type><name>ConstexprSpecKind</name></type> <name>ConstexprKind</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevSpec</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>bool</name> <macro><name>isFriendSpecified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Friend_specified</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getFriendSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FriendLoc</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isModulePrivateSpecified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>ModulePrivateLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getModulePrivateSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ModulePrivateLoc</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>ConstexprSpecKind</name> <macro><name>getConstexprSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>ConstexprSpecKind</name><argument_list>(<argument><expr><name>ConstexprSpecifier</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getConstexprSpecLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ConstexprLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>hasConstexprSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getConstexprSpecifier</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ConstexprSpecKind</name><operator>::</operator><name>Unspecified</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>ClearConstexprSpec</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ConstexprSpecifier</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ConstexprSpecKind</name><operator>::</operator><name>Unspecified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ConstexprLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>AttributePool</name> <operator>&amp;</operator><macro><name>getAttributePool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Attrs</name><operator>.</operator><name>getPool</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


















<function><type><name>void</name></type> <name>addAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AL</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Attrs</name><operator>.</operator><name>addAll</name></name><argument_list>(<argument><expr><call><name><name>AL</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>AL</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>hasAttributes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>Attrs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>getAttributes</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>Attrs</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>ParsedAttributes</name> <operator>&amp;</operator><macro><name>getAttributes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Attrs</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>takeAttributesFrom</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Attrs</name><operator>.</operator><name>takeAllFrom</name></name><argument_list>(<argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function_decl><type><name>void</name></type> <name>Finish</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>const</specifier> <name>WrittenBuiltinSpecs</name><operator>&amp;</operator> <macro><name>getWrittenBuiltinSpecs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>writtenBS</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>ObjCDeclSpec</name> <operator>*</operator><macro><name>getObjCQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ObjCQualifiers</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setObjCQualifiers</name><parameter_list>(<parameter><decl><type><name>ObjCDeclSpec</name> <modifier>*</modifier></type><name>quals</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>ObjCQualifiers</name> <operator>=</operator> <name>quals</name></expr>;</expr_stmt> </block_content>}</block></function>




<function_decl><type><name>bool</name></type> <name>isMissingDeclaratorOk</name><parameter_list>()</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>ObjCDeclSpec</name> <block>{<block_content>
<label><name>public</name>:</label>






<enum>enum <name>ObjCDeclQualifier</name> <block>{
<decl><name>DQ_None</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>,
<decl><name>DQ_In</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,
<decl><name>DQ_Inout</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,
<decl><name>DQ_Out</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>,
<decl><name>DQ_Bycopy</name> <init>= <expr><literal type="number">0x8</literal></expr></init></decl>,
<decl><name>DQ_Byref</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>,
<decl><name>DQ_Oneway</name> <init>= <expr><literal type="number">0x20</literal></expr></init></decl>,
<decl><name>DQ_CSNullability</name> <init>= <expr><literal type="number">0x40</literal></expr></init></decl>
}</block>;</enum>

<expr_stmt><expr><call><name>ObjCDeclSpec</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>objcDeclQualifier</name><argument_list>(<argument><expr><name>DQ_None</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>PropertyAttributes</name><argument_list>(<argument><expr><name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_noattr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Nullability</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>GetterName</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>SetterName</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>

<name>ObjCDeclQualifier</name> <macro><name>getObjCDeclQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>ObjCDeclQualifier</name><operator>)</operator><name>objcDeclQualifier</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setObjCDeclQualifier</name><parameter_list>(<parameter><decl><type><name>ObjCDeclQualifier</name></type> <name>DQVal</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>objcDeclQualifier</name> <operator>=</operator> <operator>(</operator><name>ObjCDeclQualifier</name><operator>)</operator> <operator>(</operator><name>objcDeclQualifier</name> <operator>|</operator> <name>DQVal</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>clearObjCDeclQualifier</name><parameter_list>(<parameter><decl><type><name>ObjCDeclQualifier</name></type> <name>DQVal</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>objcDeclQualifier</name> <operator>=</operator> <operator>(</operator><name>ObjCDeclQualifier</name><operator>)</operator> <operator>(</operator><name>objcDeclQualifier</name> <operator>&amp;</operator> <operator>~</operator><name>DQVal</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>ObjCPropertyAttribute</name><operator>::</operator><name>Kind</name> <macro><name>getPropertyAttributes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ObjCPropertyAttribute</name><operator>::</operator><call><name>Kind</name><argument_list>(<argument><expr><name>PropertyAttributes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>setPropertyAttributes</name><argument_list>(<argument><expr><name>ObjCPropertyAttribute</name><operator>::</operator><name>Kind</name> <name>PRVal</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name>PropertyAttributes</name> <operator>=</operator>
<operator>(</operator><name>ObjCPropertyAttribute</name><operator>::</operator><name>Kind</name><operator>)</operator><operator>(</operator><name>PropertyAttributes</name> <operator>|</operator> <name>PRVal</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><name>NullabilityKind</name> <macro><name>getNullability</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(
<argument><expr><operator>(</operator><operator>(</operator><call><name>getObjCDeclQualifier</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>DQ_CSNullability</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>getPropertyAttributes</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_nullability</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Objective-C declspec doesn't have nullability"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>NullabilityKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Nullability</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getNullabilityLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(
<argument><expr><operator>(</operator><operator>(</operator><call><name>getObjCDeclQualifier</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>DQ_CSNullability</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>getPropertyAttributes</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_nullability</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Objective-C declspec doesn't have nullability"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>NullabilityLoc</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setNullability</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>loc</name></decl></parameter>, <parameter><decl><type><name>NullabilityKind</name></type> <name>kind</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(
<argument><expr><operator>(</operator><operator>(</operator><call><name>getObjCDeclQualifier</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>DQ_CSNullability</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><call><name>getPropertyAttributes</name><argument_list>()</argument_list></call> <operator>&amp;</operator> <name>ObjCPropertyAttribute</name><operator>::</operator><name>kind_nullability</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Set the nullability declspec or property attribute first"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Nullability</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>NullabilityLoc</name> <operator>=</operator> <name>loc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><macro><name>getGetterName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>GetterName</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>getGetterName</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>GetterName</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getGetterNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>GetterNameLoc</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setGetterName</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>GetterName</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name>GetterNameLoc</name> <operator>=</operator> <name>loc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><macro><name>getSetterName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SetterName</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>getSetterName</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>SetterName</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getSetterNameLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SetterNameLoc</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setSetterName</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>SetterName</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name>SetterNameLoc</name> <operator>=</operator> <name>loc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>private</name>:</label>



<decl_stmt><decl><type><name>unsigned</name></type> <name>objcDeclQualifier</name> <range>: <expr><literal type="number">7</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>PropertyAttributes</name> <range>: <expr><name>NumObjCPropertyAttrsBits</name></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>Nullability</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>NullabilityLoc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>GetterName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>SetterName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>GetterNameLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>SetterNameLoc</name></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>UnqualifiedIdKind</name> <block>{<block_content>

<expr_stmt><expr><name>IK_Identifier</name></expr><operator>,</operator>

<expr><name>IK_OperatorFunctionId</name></expr><operator>,</operator>

<expr><name>IK_ConversionFunctionId</name></expr><operator>,</operator>

<expr><name>IK_LiteralOperatorId</name></expr><operator>,</operator>

<expr><name>IK_ConstructorName</name></expr><operator>,</operator>

<expr><name>IK_ConstructorTemplateId</name></expr><operator>,</operator>

<expr><name>IK_DestructorName</name></expr><operator>,</operator>

<expr><name>IK_TemplateId</name></expr><operator>,</operator>

<expr><name>IK_ImplicitSelfParam</name></expr><operator>,</operator>

<expr><name>IK_DeductionGuideName</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>UnqualifiedId</name> <block>{<block_content>
<label><name>private</name>:</label>
<expr_stmt><expr><call><name>UnqualifiedId</name><argument_list>(<argument><expr><specifier>const</specifier> <name>UnqualifiedId</name> <operator>&amp;</operator><name>Other</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>UnqualifiedId</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>

<decl_stmt><decl><type><name>UnqualifiedIdKind</name></type> <name>Kind</name></decl>;</decl_stmt>

<struct>struct <name>OFI</name> <block>{

<decl_stmt><decl><type><name>OverloadedOperatorKind</name></type> <name>Operator</name></decl>;</decl_stmt>








<decl_stmt><decl><type><name>SourceLocation</name></type> <name><name>SymbolLocations</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>



<union>union <block>{


<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Identifier</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>struct</name> <name>OFI</name></name></type> <name>OperatorFunctionId</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>UnionParsedType</name></type> <name>ConversionFunctionId</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>UnionParsedType</name></type> <name>ConstructorName</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>UnionParsedType</name></type> <name>DestructorName</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>UnionParsedTemplateTy</name></type> <name>TemplateName</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>TemplateIdAnnotation</name> <modifier>*</modifier></type><name>TemplateId</name></decl>;</decl_stmt>
}</block>;</union>




<decl_stmt><decl><type><name>SourceLocation</name></type> <name>StartLocation</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>EndLocation</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>UnqualifiedId</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>UnqualifiedIdKind</name><operator>::</operator><name>IK_Identifier</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Identifier</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>



<name>void</name> <macro><name>clear</name><argument_list>()</argument_list></macro> <block>{
<expr><name>Kind</name> <operator>=</operator> <name>UnqualifiedIdKind</name><operator>::</operator><name>IK_Identifier</name></expr>;
<expr><name>Identifier</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>StartLocation</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;
<expr><name>EndLocation</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;
}</block>


<name>bool</name> <macro><name>isValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>StartLocation</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isInvalid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>UnqualifiedIdKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>





<function><type><name>void</name></type> <name>setIdentifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>UnqualifiedIdKind</name><operator>::</operator><name>IK_Identifier</name></expr>;</expr_stmt>
<expr_stmt><expr><name>Identifier</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>StartLocation</name> <operator>=</operator> <name>EndLocation</name> <operator>=</operator> <name>IdLoc</name></expr>;</expr_stmt>
</block_content>}</block></function>










<function_decl><type><name>void</name></type> <name>setOperatorFunctionId</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OperatorLoc</name></decl></parameter>,
<parameter><decl><type><name>OverloadedOperatorKind</name></type> <name>Op</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name><name>SymbolLocations</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl></parameter>)</parameter_list>;</function_decl>









<function><type><name>void</name></type> <name>setConversionFunctionId</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OperatorLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>Ty</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>UnqualifiedIdKind</name><operator>::</operator><name>IK_ConversionFunctionId</name></expr>;</expr_stmt>
<expr_stmt><expr><name>StartLocation</name> <operator>=</operator> <name>OperatorLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>EndLocation</name> <operator>=</operator> <name>EndLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ConversionFunctionId</name> <operator>=</operator> <name>Ty</name></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><name>void</name></type> <name>setLiteralOperatorId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>UnqualifiedIdKind</name><operator>::</operator><name>IK_LiteralOperatorId</name></expr>;</expr_stmt>
<expr_stmt><expr><name>Identifier</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>StartLocation</name> <operator>=</operator> <name>OpLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>EndLocation</name> <operator>=</operator> <name>IdLoc</name></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><name>void</name></type> <name>setConstructorName</name><parameter_list>(<parameter><decl><type><name>ParsedType</name></type> <name>ClassType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ClassNameLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>UnqualifiedIdKind</name><operator>::</operator><name>IK_ConstructorName</name></expr>;</expr_stmt>
<expr_stmt><expr><name>StartLocation</name> <operator>=</operator> <name>ClassNameLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>EndLocation</name> <operator>=</operator> <name>EndLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ConstructorName</name> <operator>=</operator> <name>ClassType</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function_decl><type><name>void</name></type> <name>setConstructorTemplateId</name><parameter_list>(<parameter><decl><type><name>TemplateIdAnnotation</name> <modifier>*</modifier></type><name>TemplateId</name></decl></parameter>)</parameter_list>;</function_decl>







<function><type><name>void</name></type> <name>setDestructorName</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>TildeLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ClassType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>UnqualifiedIdKind</name><operator>::</operator><name>IK_DestructorName</name></expr>;</expr_stmt>
<expr_stmt><expr><name>StartLocation</name> <operator>=</operator> <name>TildeLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>EndLocation</name> <operator>=</operator> <name>EndLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>DestructorName</name> <operator>=</operator> <name>ClassType</name></expr>;</expr_stmt>
</block_content>}</block></function>






<function_decl><type><name>void</name></type> <name>setTemplateId</name><parameter_list>(<parameter><decl><type><name>TemplateIdAnnotation</name> <modifier>*</modifier></type><name>TemplateId</name></decl></parameter>)</parameter_list>;</function_decl>






<function><type><name>void</name></type> <name>setDeductionGuideName</name><parameter_list>(<parameter><decl><type><name>ParsedTemplateTy</name></type> <name>Template</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>UnqualifiedIdKind</name><operator>::</operator><name>IK_DeductionGuideName</name></expr>;</expr_stmt>
<expr_stmt><expr><name>TemplateName</name> <operator>=</operator> <name>Template</name></expr>;</expr_stmt>
<expr_stmt><expr><name>StartLocation</name> <operator>=</operator> <name>EndLocation</name> <operator>=</operator> <name>TemplateLoc</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>setImplicitSelfParam</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>UnqualifiedIdKind</name><operator>::</operator><name>IK_ImplicitSelfParam</name></expr>;</expr_stmt>
<expr_stmt><expr><name>Identifier</name> <operator>=</operator> <call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>StartLocation</name> <operator>=</operator> <name>EndLocation</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>StartLocation</name></expr></argument>, <argument><expr><name>EndLocation</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>StartLocation</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>EndLocation</name></expr>;</return> }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<typedef>typedef <type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Token</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>CachedTokens</name>;</typedef>





<struct>struct <name>DeclaratorChunk</name> <block>{
<macro><name>DeclaratorChunk</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block><empty_stmt>;</empty_stmt>

<enum>enum <block>{
<decl><name>Pointer</name></decl>, <decl><name>Reference</name></decl>, <decl><name>Array</name></decl>, <decl><name>Function</name></decl>, <decl><name>BlockPointer</name></decl>, <decl><name>MemberPointer</name></decl>, <decl><name>Paren</name></decl>, <decl><name>Pipe</name></decl>
}</block> <decl><name>Kind</name></decl>;</enum>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>EndLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<decl><name>ParsedAttributesView</name> <name>AttrList</name></decl>;</struct>

<struct>struct <name>PointerTypeInfo</name> <block>{

<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeQuals</name> <range>: <expr><literal type="number">5</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ConstQualLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>VolatileQualLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>RestrictQualLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>AtomicQualLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>UnalignedQualLoc</name></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>destroy</name><parameter_list>()</parameter_list> <block>{<block_content>
</block_content>}</block></function>
}</block>;</struct>

<struct>struct <name>ReferenceTypeInfo</name> <block>{

<decl_stmt><decl><type><name>bool</name></type> <name>HasRestrict</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>LValueRef</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<function><type><name>void</name></type> <name>destroy</name><parameter_list>()</parameter_list> <block>{<block_content>
</block_content>}</block></function>
}</block>;</struct>

<struct>struct <name>ArrayTypeInfo</name> <block>{


<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeQuals</name> <range>: <expr><literal type="number">5</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>hasStatic</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>isStar</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NumElts</name></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>destroy</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>
}</block>;</struct>








<struct>struct <name>ParamInfo</name> <block>{
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>IdentLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Param</name></decl>;</decl_stmt>






<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CachedTokens</name></expr></argument>&gt;</argument_list></name> <name>DefaultArgTokens</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ParamInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<macro><name>ParamInfo</name><argument_list>(<argument>IdentifierInfo *ident</argument>, <argument>SourceLocation iloc</argument>,
<argument>Decl *param</argument>,
<argument>std::unique_ptr&lt;CachedTokens&gt; DefArgTokens = nullptr</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Ident</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IdentLoc</name><argument_list>(<argument><expr><name>iloc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Param</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>DefaultArgTokens</name><argument_list>(<argument>std::move(DefArgTokens)</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>

<struct>struct <name>TypeAndRange</name> <block>{
<decl_stmt><decl><type><name>ParsedType</name></type> <name>Ty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceRange</name></type> <name>Range</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>FunctionTypeInfo</name> <block>{



<decl_stmt><decl><type><name>unsigned</name></type> <name>hasPrototype</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>isVariadic</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>isAmbiguous</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>RefQualifierIsLValueRef</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ExceptionSpecType</name> <range>: <expr><literal type="number">4</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>DeleteParams</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>HasTrailingReturnType</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumParams</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>unsigned</name></type> <name>NumExceptionsOrDecls</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>SourceLocation</name></type> <name>RefQualifierLoc</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>MutableLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ExceptionSpecLocBeg</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ExceptionSpecLocEnd</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>ParamInfo</name> <modifier>*</modifier></type><name>Params</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>DeclSpec</name> <modifier>*</modifier></type><name>MethodQualifiers</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>AttributeFactory</name> <modifier>*</modifier></type><name>QualAttrFactory</name></decl>;</decl_stmt>

<union>union <block>{



<decl_stmt><decl><type><name>TypeAndRange</name> <modifier>*</modifier></type><name>Exceptions</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NoexceptExpr</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>CachedTokens</name> <modifier>*</modifier></type><name>ExceptionSpecTokens</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier><modifier>*</modifier></type><name>DeclsInPrototype</name></decl>;</decl_stmt>
}</block>;</union>



<decl_stmt><decl><type><name>UnionParsedType</name></type> <name>TrailingReturnType</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TrailingReturnTypeLoc</name></decl>;</decl_stmt>




<function><type><name>void</name></type> <name>freeParams</name><parameter_list>()</parameter_list> <block>{<block_content>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>&lt;</operator> <name>NumParams</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>Params</name><index>[<expr><name>I</name></expr>]</index></name><operator>.</operator><call><name><name>DefaultArgTokens</name><operator>.</operator><name>reset</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>DeleteParams</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>delete</name><index>[]</index></name></type> <name>Params</name></decl>;</decl_stmt>
<expr_stmt><expr><name>DeleteParams</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>NumParams</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>destroy</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>freeParams</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>delete</name></type> <name>QualAttrFactory</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>delete</name></type> <name>MethodQualifiers</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><call><name>getExceptionSpecType</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<default>default:</default>
<break>break;</break>
<case>case <expr><name>EST_Dynamic</name></expr>:</case>
<decl_stmt><decl><type><name><name>delete</name><index>[]</index></name></type> <name>Exceptions</name></decl>;</decl_stmt>
<break>break;</break>
<case>case <expr><name>EST_Unparsed</name></expr>:</case>
<decl_stmt><decl><type><name>delete</name></type> <name>ExceptionSpecTokens</name></decl>;</decl_stmt>
<break>break;</break>
<case>case <expr><name>EST_None</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name>NumExceptionsOrDecls</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<decl_stmt><decl><type><name><name>delete</name><index>[]</index></name></type> <name>DeclsInPrototype</name></decl>;</decl_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>getOrCreateMethodQualifiers</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MethodQualifiers</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>QualAttrFactory</name> <operator>=</operator> <name>new</name> <call><name>AttributeFactory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>MethodQualifiers</name> <operator>=</operator> <name>new</name> <call><name>DeclSpec</name><argument_list>(<argument><expr><operator>*</operator><name>QualAttrFactory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><operator>*</operator><name>MethodQualifiers</name></expr>;</return>
</block_content>}</block></function>




<expr_stmt><expr><name>bool</name> <macro><name>isKNRPrototype</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><name>hasPrototype</name> <operator>&amp;&amp;</operator> <name>NumParams</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LParenLoc</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EllipsisLoc</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getRParenLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RParenLoc</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getExceptionSpecLocBeg</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ExceptionSpecLocBeg</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getExceptionSpecLocEnd</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ExceptionSpecLocEnd</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getExceptionSpecRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getExceptionSpecLocBeg</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>getExceptionSpecLocEnd</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getRefQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RefQualifierLoc</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getConstQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>MethodQualifiers</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>MethodQualifiers</name><operator>-&gt;</operator><name>getConstSpecLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getVolatileQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>MethodQualifiers</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>MethodQualifiers</name><operator>-&gt;</operator><name>getVolatileSpecLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getRestrictQualifierLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>MethodQualifiers</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>MethodQualifiers</name><operator>-&gt;</operator><name>getRestrictSpecLoc</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getMutableLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>MutableLoc</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasRefQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getRefQualifierLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasMutableQualifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getMutableLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasMethodTypeQualifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>MethodQualifiers</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>MethodQualifiers</name><operator>-&gt;</operator><name>getTypeQualifiers</name></name><argument_list>()</argument_list></call> <operator>||</operator>
<call><name><name>MethodQualifiers</name><operator>-&gt;</operator><name>getAttributes</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>size</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>ExceptionSpecificationType</name> <macro><name>getExceptionSpecType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExceptionSpecificationType</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ExceptionSpecType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getNumExceptions</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ExceptionSpecType</name> <operator>!=</operator> <name>EST_None</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>NumExceptionsOrDecls</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getDeclsInPrototype</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ExceptionSpecType</name> <operator>==</operator> <name>EST_None</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>DeclsInPrototype</name></expr></argument>, <argument><expr><name>NumExceptionsOrDecls</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasTrailingReturnType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasTrailingReturnType</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>ParsedType</name> <macro><name>getTrailingReturnType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>HasTrailingReturnType</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>TrailingReturnType</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceLocation</name> <macro><name>getTrailingReturnTypeLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>HasTrailingReturnType</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>TrailingReturnTypeLoc</name></expr>;</return>
}</block></expr></expr_stmt>
}</block>;</struct>

<struct>struct <name>BlockPointerTypeInfo</name> <block>{


<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeQuals</name> <range>: <expr><literal type="number">5</literal></expr></range></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>destroy</name><parameter_list>()</parameter_list> <block>{<block_content>
</block_content>}</block></function>
}</block>;</struct>

<struct>struct <name>MemberPointerTypeInfo</name> <block>{

<decl_stmt><decl><type><name>unsigned</name></type> <name>TypeQuals</name> <range>: <expr><literal type="number">5</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>StarLoc</name></decl>;</decl_stmt>


<macro><name>alignas</name><argument_list>(<argument>CXXScopeSpec</argument>)</argument_list></macro> <decl_stmt><decl><type><name>char</name></type> <name><name>ScopeMem</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>CXXScopeSpec</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
<function><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>Scope</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><operator>*</operator><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXScopeSpec</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ScopeMem</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>CXXScopeSpec</name> <operator>&amp;</operator><macro><name>Scope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXScopeSpec</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ScopeMem</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>destroy</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>Scope</name><argument_list>()</argument_list></call><operator>.</operator><operator>~</operator><call><name>CXXScopeSpec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
}</block>;</struct>

<struct>struct <name>PipeTypeInfo</name> <block>{

<decl_stmt><decl><type><name>unsigned</name></type> <name>AccessWrites</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>destroy</name><parameter_list>()</parameter_list> <block>{<block_content/>}</block></function>
}</block>;</struct>

<union>union <block>{
<decl_stmt><decl><type><name>PointerTypeInfo</name></type> <name>Ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ReferenceTypeInfo</name></type> <name>Ref</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ArrayTypeInfo</name></type> <name>Arr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FunctionTypeInfo</name></type> <name>Fun</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BlockPointerTypeInfo</name></type> <name>Cls</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MemberPointerTypeInfo</name></type> <name>Mem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PipeTypeInfo</name></type> <name>PipeInfo</name></decl>;</decl_stmt>
}</block>;</union>

<function><type><name>void</name></type> <name>destroy</name><parameter_list>()</parameter_list> <block>{<block_content>
<switch>switch <condition>(<expr><name>Kind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>Function</name></expr>:</case> <return>return <expr><call><name><name>Fun</name><operator>.</operator><name>destroy</name></name><argument_list>()</argument_list></call></expr>;</return>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>Pointer</name></expr>:</case> <return>return <expr><call><name><name>Ptr</name><operator>.</operator><name>destroy</name></name><argument_list>()</argument_list></call></expr>;</return>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>BlockPointer</name></expr>:</case> <return>return <expr><call><name><name>Cls</name><operator>.</operator><name>destroy</name></name><argument_list>()</argument_list></call></expr>;</return>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>Reference</name></expr>:</case> <return>return <expr><call><name><name>Ref</name><operator>.</operator><name>destroy</name></name><argument_list>()</argument_list></call></expr>;</return>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>Array</name></expr>:</case> <return>return <expr><call><name><name>Arr</name><operator>.</operator><name>destroy</name></name><argument_list>()</argument_list></call></expr>;</return>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>MemberPointer</name></expr>:</case> <return>return <expr><call><name><name>Mem</name><operator>.</operator><name>destroy</name></name><argument_list>()</argument_list></call></expr>;</return>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>Paren</name></expr>:</case> <return>return;</return>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>Pipe</name></expr>:</case> <return>return <expr><call><name><name>PipeInfo</name><operator>.</operator><name>destroy</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></switch>
</block_content>}</block></function>



<expr_stmt><expr><specifier>const</specifier> <name>ParsedAttributesView</name> <operator>&amp;</operator><macro><name>getAttrs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AttrList</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>getAttrs</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>AttrList</name></expr>;</return> </block_content>}</block></function>


<function><type><specifier>static</specifier> <name>DeclaratorChunk</name></type> <name>getPointer</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>TypeQuals</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ConstQualLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>VolatileQualLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RestrictQualLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AtomicQualLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>UnalignedQualLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclaratorChunk</name></type> <name>I</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>Pointer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>&amp;I.Ptr</argument>)</argument_list></macro> <expr_stmt><expr><name>PointerTypeInfo</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Ptr</name><operator>.</operator><name>TypeQuals</name></name> <operator>=</operator> <name>TypeQuals</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Ptr</name><operator>.</operator><name>ConstQualLoc</name></name> <operator>=</operator> <name>ConstQualLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Ptr</name><operator>.</operator><name>VolatileQualLoc</name></name> <operator>=</operator> <name>VolatileQualLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Ptr</name><operator>.</operator><name>RestrictQualLoc</name></name> <operator>=</operator> <name>RestrictQualLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Ptr</name><operator>.</operator><name>AtomicQualLoc</name></name> <operator>=</operator> <name>AtomicQualLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Ptr</name><operator>.</operator><name>UnalignedQualLoc</name></name> <operator>=</operator> <name>UnalignedQualLoc</name></expr>;</expr_stmt>
<return>return <expr><name>I</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>DeclaratorChunk</name></type> <name>getReference</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>TypeQuals</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>lvalue</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclaratorChunk</name></type> <name>I</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>Reference</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Ref</name><operator>.</operator><name>HasRestrict</name></name> <operator>=</operator> <operator>(</operator><name>TypeQuals</name> <operator>&amp;</operator> <name>DeclSpec</name><operator>::</operator><name>TQ_restrict</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Ref</name><operator>.</operator><name>LValueRef</name></name> <operator>=</operator> <name>lvalue</name></expr>;</expr_stmt>
<return>return <expr><name>I</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>DeclaratorChunk</name></type> <name>getArray</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>TypeQuals</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isStatic</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isStar</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NumElts</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RBLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclaratorChunk</name></type> <name>I</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>Array</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>LBLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>EndLoc</name></name> <operator>=</operator> <name>RBLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Arr</name><operator>.</operator><name>TypeQuals</name></name> <operator>=</operator> <name>TypeQuals</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Arr</name><operator>.</operator><name>hasStatic</name></name> <operator>=</operator> <name>isStatic</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Arr</name><operator>.</operator><name>isStar</name></name> <operator>=</operator> <name>isStar</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Arr</name><operator>.</operator><name>NumElts</name></name> <operator>=</operator> <name>NumElts</name></expr>;</expr_stmt>
<return>return <expr><name>I</name></expr>;</return>
</block_content>}</block></function>



<function_decl><type><specifier>static</specifier> <name>DeclaratorChunk</name></type> <name>getFunction</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>HasProto</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsAmbiguous</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>ParamInfo</name> <modifier>*</modifier></type><name>Params</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumParams</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RefQualifierIsLvalueRef</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RefQualifierLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>MutableLoc</name></decl></parameter>,
<parameter><decl><type><name>ExceptionSpecificationType</name></type> <name>ESpecType</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>ESpecRange</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name> <modifier>*</modifier></type><name>Exceptions</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name> <modifier>*</modifier></type><name>ExceptionRanges</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumExceptions</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NoexceptExpr</name></decl></parameter>,
<parameter><decl><type><name>CachedTokens</name> <modifier>*</modifier></type><name>ExceptionSpecTokens</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>DeclsInPrototype</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LocalRangeBegin</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LocalRangeEnd</name></decl></parameter>,
<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>TheDeclarator</name></decl></parameter>,
<parameter><decl><type><name>TypeResult</name></type> <name>TrailingReturnType</name> <init>=
<expr><call><name>TypeResult</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TrailingReturnTypeLoc</name> <init>=
<expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>DeclSpec</name> <modifier>*</modifier></type><name>MethodQualifiers</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>DeclaratorChunk</name></type> <name>getBlockPointer</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>TypeQuals</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclaratorChunk</name></type> <name>I</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>BlockPointer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Cls</name><operator>.</operator><name>TypeQuals</name></name> <operator>=</operator> <name>TypeQuals</name></expr>;</expr_stmt>
<return>return <expr><name>I</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>DeclaratorChunk</name></type> <name>getPipe</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>TypeQuals</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclaratorChunk</name></type> <name>I</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>Pipe</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>Loc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Cls</name><operator>.</operator><name>TypeQuals</name></name> <operator>=</operator> <name>TypeQuals</name></expr>;</expr_stmt>
<return>return <expr><name>I</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DeclaratorChunk</name></type> <name>getMemberPointer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>TypeQuals</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StarLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclaratorChunk</name></type> <name>I</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>MemberPointer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <call><name><name>SS</name><operator>.</operator><name>getBeginLoc</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>EndLoc</name></name> <operator>=</operator> <name>EndLoc</name></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>&amp;I.Mem</argument>)</argument_list></macro> <expr_stmt><expr><name>MemberPointerTypeInfo</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Mem</name><operator>.</operator><name>StarLoc</name></name> <operator>=</operator> <name>StarLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Mem</name><operator>.</operator><name>TypeQuals</name></name> <operator>=</operator> <name>TypeQuals</name></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>I.Mem.ScopeMem</argument>)</argument_list></macro> <expr_stmt><expr><call><name>CXXScopeSpec</name><argument_list>(<argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>I</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>DeclaratorChunk</name></type> <name>getParen</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DeclaratorChunk</name></type> <name>I</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>Paren</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>Loc</name></name> <operator>=</operator> <name>LParenLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>I</name><operator>.</operator><name>EndLoc</name></name> <operator>=</operator> <name>RParenLoc</name></expr>;</expr_stmt>
<return>return <expr><name>I</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isParen</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Kind</name> <operator>==</operator> <name>Paren</name></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>DecompositionDeclarator</name> <block>{<block_content>
<label><name>public</name>:</label>
<struct>struct <name>Binding</name> <block>{
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl>;</decl_stmt>
}</block>;</struct>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>LSquareLoc</name></decl>, <decl><type ref="prev"/><name>RSquareLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Binding</name> <modifier>*</modifier></type><name>Bindings</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumBindings</name> <range>: <expr><literal type="number">31</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>DeleteBindings</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>Declarator</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>DecompositionDeclarator</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>Bindings</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>NumBindings</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>DeleteBindings</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>
<call><name>DecompositionDeclarator</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DecompositionDeclarator</name> <operator>&amp;</operator><name>G</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>DecompositionDeclarator</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>DecompositionDeclarator</name> <operator>&amp;</operator><name>G</name><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>~</operator><macro><name>DecompositionDeclarator</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>DeleteBindings</name></expr>)</condition><block type="pseudo"><block_content>
<decl_stmt><decl><type><name><name>delete</name><index>[]</index></name></type> <name>Bindings</name></decl>;</decl_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>LSquareLoc</name> <operator>=</operator> <name>RSquareLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>DeleteBindings</name></expr>)</condition><block type="pseudo"><block_content>
<decl_stmt><decl><type><name><name>delete</name><index>[]</index></name></type> <name>Bindings</name></decl>;</decl_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Bindings</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>NumBindings</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>DeleteBindings</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Binding</name></expr></argument>&gt;</argument_list></name> <macro><name>bindings</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><name>Bindings</name></expr></argument>, <argument><expr><name>NumBindings</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isSet</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>LSquareLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLSquareLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LSquareLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getRSquareLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>RSquareLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>LSquareLoc</name></expr></argument>, <argument><expr><name>RSquareLoc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>FunctionDefinitionKind</name> <block>{<block_content>
<expr_stmt><expr><name>Declaration</name></expr><operator>,</operator>
<expr><name>Definition</name></expr><operator>,</operator>
<expr><name>Defaulted</name></expr><operator>,</operator>
<expr><name>Deleted</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>DeclaratorContext</name> <block>{<block_content>
<expr_stmt><expr><name>File</name></expr><operator>,</operator>
<expr><name>Prototype</name></expr><operator>,</operator>
<expr><name>ObjCResult</name></expr><operator>,</operator>
<expr><name>ObjCParameter</name></expr><operator>,</operator>
<expr><name>KNRTypeList</name></expr><operator>,</operator>
<expr><name>TypeName</name></expr><operator>,</operator>
<expr><name>FunctionalCast</name></expr><operator>,</operator>
<expr><name>Member</name></expr><operator>,</operator>
<expr><name>Block</name></expr><operator>,</operator>
<expr><name>ForInit</name></expr><operator>,</operator>
<expr><name>SelectionInit</name></expr><operator>,</operator>
<expr><name>Condition</name></expr><operator>,</operator>
<expr><name>TemplateParam</name></expr><operator>,</operator>
<expr><name>CXXNew</name></expr><operator>,</operator>
<expr><name>CXXCatch</name></expr><operator>,</operator>
<expr><name>ObjCCatch</name></expr><operator>,</operator>
<expr><name>BlockLiteral</name></expr><operator>,</operator>
<expr><name>LambdaExpr</name></expr><operator>,</operator>
<expr><name>LambdaExprParameter</name></expr><operator>,</operator>
<expr><name>ConversionId</name></expr><operator>,</operator>
<expr><name>TrailingReturn</name></expr><operator>,</operator>
<expr><name>TrailingReturnVar</name></expr><operator>,</operator>
<expr><name>TemplateArg</name></expr><operator>,</operator>
<expr><name>TemplateTypeArg</name></expr><operator>,</operator>
<expr><name>AliasDecl</name></expr><operator>,</operator>
<expr><name>AliasTemplate</name></expr><operator>,</operator>
<expr><name>RequiresExpr</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>













<decl_stmt><decl><type><name>class</name></type> <name>Declarator</name> <block>{<block_content>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UnqualifiedId</name></type> <name>Name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceRange</name></type> <name>Range</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>DeclaratorContext</name></type> <name>Context</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>DecompositionDeclarator</name></type> <name>BindingGroup</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>DeclaratorChunk</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>DeclTypeInfo</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>InvalidType</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>GroupingParens</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>unsigned</name></type> <name>FunctionDefinition</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>Redeclaration</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>Extension</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ObjCIvar</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ObjCWeakProperty</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>InlineStorageUsed</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>HasInitializer</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ParsedAttributes</name></type> <name>Attrs</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>AsmLabel</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>TrailingRequiresClause</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateParameterList</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>TemplateParameterLists</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>InventedTemplateParameterList</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<union>union <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<expr_stmt><expr><name>DeclaratorChunk</name><operator>::</operator><name>ParamInfo</name> <name><name>InlineParams</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>DecompositionDeclarator</name><operator>::</operator><name>Binding</name> <name><name>InlineBindings</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block>;</union>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>CommaLoc</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl>;</decl_stmt>

<macro><name>friend</name></macro> <struct_decl>struct <name>DeclaratorChunk</name>;</struct_decl>

<label><name>public</name>:</label>
<macro><name>Declarator</name><argument_list>(<argument>const DeclSpec &amp;ds</argument>, <argument>DeclaratorContext C</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>DS</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Range</name><argument_list>(<argument><expr><call><name><name>ds</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Context</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>InvalidType</name><argument_list>(<argument><expr><call><name><name>DS</name><operator>.</operator><name>getTypeSpecType</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclSpec</name><operator>::</operator><name>TST_error</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>GroupingParens</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>FunctionDefinition</name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name>FunctionDefinitionKind</name><operator>::</operator><name>Declaration</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Redeclaration</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Extension</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ObjCIvar</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>ObjCWeakProperty</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>InlineStorageUsed</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>HasInitializer</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Attrs</name><argument_list>(<argument><expr><call><name><name>ds</name><operator>.</operator><name>getAttributePool</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getFactory</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>AsmLabel</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>TrailingRequiresClause</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>InventedTemplateParameterList</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>

<operator>~</operator><macro><name>Declarator</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>clear</name><argument_list>()</argument_list></call></expr>;
}</block>


<specifier>const</specifier> <name>DeclSpec</name> <operator>&amp;</operator><macro><name>getDeclSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>DS</name></expr>;</return> }</block></expr></expr_stmt>






<function><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>getMutableDeclSpec</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclSpec</name> <operator>&amp;</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DS</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name>AttributePool</name> <operator>&amp;</operator><macro><name>getAttributePool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Attrs</name><operator>.</operator><name>getPool</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>CXXScopeSpec</name> <operator>&amp;</operator><macro><name>getCXXScopeSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SS</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>getCXXScopeSpec</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>SS</name></expr>;</return> </block_content>}</block></function>


<function><type><name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>getName</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>Name</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>DecompositionDeclarator</name> <operator>&amp;</operator><macro><name>getDecompositionDeclarator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>BindingGroup</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>DeclaratorContext</name> <macro><name>getContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Context</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isPrototypeContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>Context</name> <operator>==</operator> <name>DeclaratorContext</name><operator>::</operator><name>Prototype</name> <operator>||</operator>
<name>Context</name> <operator>==</operator> <name>DeclaratorContext</name><operator>::</operator><name>ObjCParameter</name> <operator>||</operator>
<name>Context</name> <operator>==</operator> <name>DeclaratorContext</name><operator>::</operator><name>ObjCResult</name> <operator>||</operator>
<name>Context</name> <operator>==</operator> <name>DeclaratorContext</name><operator>::</operator><name>LambdaExprParameter</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>SetSourceRange</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Range</name> <operator>=</operator> <name>R</name></expr>;</expr_stmt> </block_content>}</block></function>


<function><type><name>void</name></type> <name>SetRangeBegin</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Loc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Range</name><operator>.</operator><name>setBegin</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>SetRangeEnd</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Loc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Range</name><operator>.</operator><name>setEnd</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>



<function><type><name>void</name></type> <name>ExtendWithDeclSpec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>SourceRange</name></type> <name>SR</name> <init>= <expr><call><name><name>DS</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isInvalid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Range</name><operator>.</operator><name>setBegin</name></name><argument_list>(<argument><expr><call><name><name>SR</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>SR</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isInvalid</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Range</name><operator>.</operator><name>setEnd</name></name><argument_list>(<argument><expr><call><name><name>SR</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>SS</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Name</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Range</name> <operator>=</operator> <call><name><name>DS</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>BindingGroup</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>DeclTypeInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>destroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Attrs</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>AsmLabel</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>InlineStorageUsed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>HasInitializer</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ObjCIvar</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ObjCWeakProperty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<expr_stmt><expr><name>CommaLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>EllipsisLoc</name> <operator>=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<expr_stmt><expr><name>bool</name> <macro><name>mayOmitIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><name>Context</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>File</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>KNRTypeList</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Member</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Block</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ForInit</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>SelectionInit</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Condition</name></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>

<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TypeName</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>FunctionalCast</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>AliasDecl</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>AliasTemplate</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Prototype</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>LambdaExprParameter</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCParameter</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCResult</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateParam</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>CXXNew</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>CXXCatch</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCCatch</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>BlockLiteral</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>LambdaExpr</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ConversionId</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateArg</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateTypeArg</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TrailingReturn</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TrailingReturnVar</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>RequiresExpr</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/>}</block_content>
llvm_unreachable("unknown context kind!"</block></switch>)</block></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>mayHaveIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><name>Context</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>File</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>KNRTypeList</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Member</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Block</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ForInit</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>SelectionInit</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Condition</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Prototype</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>LambdaExprParameter</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateParam</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>CXXCatch</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCCatch</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>RequiresExpr</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TypeName</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>FunctionalCast</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>CXXNew</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>AliasDecl</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>AliasTemplate</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCParameter</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCResult</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>BlockLiteral</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>LambdaExpr</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ConversionId</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateArg</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateTypeArg</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TrailingReturn</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TrailingReturnVar</name></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/></block_content></block></switch>}</block>
<call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"unknown context kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}


bool <macro><name>mayHaveDecompositionDeclarator</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><name>Context</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>File</name></expr>:</case>


<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Block</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ForInit</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>SelectionInit</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Condition</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Member</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Prototype</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateParam</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>RequiresExpr</name></expr>:</case>

<return>return <expr><name>false</name></expr>;</return>


<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>KNRTypeList</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TypeName</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>FunctionalCast</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>AliasDecl</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>AliasTemplate</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>LambdaExprParameter</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCParameter</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCResult</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>CXXNew</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>CXXCatch</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCCatch</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>BlockLiteral</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>LambdaExpr</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ConversionId</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateArg</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateTypeArg</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TrailingReturn</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TrailingReturnVar</name></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>
<expr_stmt/></block_content></block></switch>}</block>
<call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"unknown context kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}



bool <macro><name>mayBeFollowedByCXXDirectInit</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>hasGroupingParens</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getDeclSpec</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getStorageClassSpec</name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclSpec</name><operator>::</operator><name>SCS_typedef</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getDeclSpec</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getStorageClassSpec</name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclSpec</name><operator>::</operator><name>SCS_extern</name> <operator>&amp;&amp;</operator>
<name>Context</name> <operator>!=</operator> <name>DeclaratorContext</name><operator>::</operator><name>File</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>Name</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>UnqualifiedIdKind</name><operator>::</operator><name>IK_Identifier</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name>Context</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>File</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Block</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ForInit</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>SelectionInit</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TrailingReturnVar</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Condition</name></expr>:</case>



<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>KNRTypeList</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Member</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Prototype</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>LambdaExprParameter</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCParameter</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCResult</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateParam</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>CXXCatch</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCCatch</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TypeName</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>FunctionalCast</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>CXXNew</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>AliasDecl</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>AliasTemplate</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>BlockLiteral</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>LambdaExpr</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ConversionId</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateArg</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateTypeArg</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TrailingReturn</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>RequiresExpr</name></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"unknown context kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}




bool <macro><name>isPastIdentifier</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Name</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>





<expr_stmt><expr><name>bool</name> <macro><name>hasName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Name</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>UnqualifiedIdKind</name><operator>::</operator><name>IK_Identifier</name> <operator>||</operator>
<name><name>Name</name><operator>.</operator><name>Identifier</name></name> <operator>||</operator> <call><name>isDecompositionDeclarator</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>isDecompositionDeclarator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>BindingGroup</name><operator>.</operator><name>isSet</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>IdentifierInfo</name> <operator>*</operator><macro><name>getIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Name</name><operator>.</operator><name>getKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>UnqualifiedIdKind</name><operator>::</operator><name>IK_Identifier</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>Name</name><operator>.</operator><name>Identifier</name></name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<return>return <expr><name>nullptr</name></expr>;</return>
}
SourceLocation <macro><name>getIdentifierLoc</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{ <return>return <expr><name><name>Name</name><operator>.</operator><name>StartLocation</name></name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>SetIdentifier</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Name</name><operator>.</operator><name>setIdentifier</name></name><argument_list>(<argument><expr><name>Id</name></expr></argument>, <argument><expr><name>IdLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><name>void</name></type>
<name>setDecompositionBindings</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LSquareLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>DecompositionDeclarator</name><operator>::</operator><name>Binding</name></expr></argument>&gt;</argument_list></name></type> <name>Bindings</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RSquareLoc</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>void</name></type> <name>AddTypeInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclaratorChunk</name> <operator>&amp;</operator><name>TI</name></expr></argument>, <argument><expr><name>ParsedAttributes</name> <operator>&amp;&amp;</operator><name>attrs</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>EndLoc</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>TI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>getAttrs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>addAll</name><argument_list>(<argument><expr><call><name><name>attrs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>attrs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>getAttributePool</name><argument_list>()</argument_list></call><operator>.</operator><call><name>takeAllFrom</name><argument_list>(<argument><expr><call><name><name>attrs</name><operator>.</operator><name>getPool</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>EndLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SetRangeEnd</name><argument_list>(<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>



<function><type><name>void</name></type> <name>AddTypeInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclaratorChunk</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>TI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>EndLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SetRangeEnd</name><argument_list>(<argument><expr><name>EndLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>AddInnermostTypeInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclaratorChunk</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>TI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>unsigned</name> <macro><name>getNumTypeObjects</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>DeclaratorChunk</name> <modifier>&amp;</modifier></type><name>getTypeObject</name><argument_list>(<argument><expr><name>unsigned</name> <name>i</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name><name>DeclTypeInfo</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid type chunk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>DeclTypeInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<function><type><name>DeclaratorChunk</name> <modifier>&amp;</modifier></type><name>getTypeObject</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name><name>DeclTypeInfo</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid type chunk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>DeclTypeInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <expr_stmt><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>DeclaratorChunk</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>const_iterator</name> <name>type_object_iterator</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>type_object_iterator</name></expr></argument>&gt;</argument_list></name> <name>type_object_range</name></expr>;</expr_stmt></typedef>


<expr_stmt><expr><name>type_object_range</name> <macro><name>type_objects</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>type_object_range</name><argument_list>(<argument><expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>DropFirstTypeObject</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>DeclTypeInfo</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"No type chunks to drop."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>destroy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<expr_stmt><expr><specifier>const</specifier> <name>DeclaratorChunk</name> <operator>*</operator><macro><name>getInnermostNonParenChunk</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i_end</name> <init>= <expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>i_end</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>DeclTypeInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><call><name>isParen</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>&amp;</operator><name><name>DeclTypeInfo</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><name>nullptr</name></expr>;</return>
}




const <expr_stmt><expr><name>DeclaratorChunk</name> <operator>*</operator><macro><name>getOutermostNonParenChunk</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>i_end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>i_end</name></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>DeclTypeInfo</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><call><name>isParen</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>&amp;</operator><name><name>DeclTypeInfo</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt/></block_content></block></for>}</block></expr></expr_stmt>
<return>return <expr><name>nullptr</name></expr>;</return>
}




bool <macro><name>isArrayOfUnknownBound</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>DeclaratorChunk</name> <operator>*</operator><name>chunk</name> <operator>=</operator> <call><name>getInnermostNonParenChunk</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><operator>(</operator><name>chunk</name> <operator>&amp;&amp;</operator> <name><name>chunk</name><operator>-&gt;</operator><name>Kind</name></name> <operator>==</operator> <name>DeclaratorChunk</name><operator>::</operator><name>Array</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>chunk</name><operator>-&gt;</operator><name>Arr</name><operator>.</operator><name>NumElts</name></name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>isFunctionDeclarator</name><argument_list>(<argument><expr><name>unsigned</name><operator>&amp;</operator> <name>idx</name></expr></argument>)</argument_list> const <block>{<block_content>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i_end</name> <init>= <expr><call><name><name>DeclTypeInfo</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>i_end</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
<switch>switch <condition>(<expr><name><name>DeclTypeInfo</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>Kind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>Function</name></expr>:</case>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>Paren</name></expr>:</case>
<continue>continue;</continue>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>Pointer</name></expr>:</case>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>Reference</name></expr>:</case>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>Array</name></expr>:</case>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>BlockPointer</name></expr>:</case>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>MemberPointer</name></expr>:</case>
<case>case <expr><name>DeclaratorChunk</name><operator>::</operator><name>Pipe</name></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"Invalid type chunk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>isFunctionDeclarator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>index</name></expr>;
<return>return <expr><call><name>isFunctionDeclarator</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>DeclaratorChunk</name><operator>::</operator><name>FunctionTypeInfo</name> <operator>&amp;</operator><macro><name>getFunctionTypeInfo</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isFunctionDeclarator</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Not a function declarator!"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name>unsigned</name> <name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<expr><call><name>isFunctionDeclarator</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>DeclTypeInfo</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>Fun</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>DeclaratorChunk</name><operator>::</operator><name>FunctionTypeInfo</name> <operator>&amp;</operator><macro><name>getFunctionTypeInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Declarator</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getFunctionTypeInfo</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>







<expr_stmt><expr><name>bool</name> <macro><name>isDeclarationOfFunction</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isFunctionDeclarationContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name>getDeclSpec</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getStorageClassSpec</name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclSpec</name><operator>::</operator><name>SCS_typedef</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<switch>switch <condition>(<expr><name>Context</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>File</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Member</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Block</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ForInit</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>SelectionInit</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>

<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Condition</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>KNRTypeList</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TypeName</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>FunctionalCast</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>AliasDecl</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>AliasTemplate</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Prototype</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>LambdaExprParameter</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCParameter</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCResult</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateParam</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>CXXNew</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>CXXCatch</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCCatch</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>BlockLiteral</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>LambdaExpr</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ConversionId</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateArg</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateTypeArg</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TrailingReturn</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TrailingReturnVar</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>RequiresExpr</name></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"unknown context kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}



bool <macro><name>isExpressionContext</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><name>Context</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>File</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>KNRTypeList</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Member</name></expr>:</case>


<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TypeName</name></expr>:</case>

<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>FunctionalCast</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>AliasDecl</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>AliasTemplate</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Prototype</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>LambdaExprParameter</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCParameter</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCResult</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateParam</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>CXXNew</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>CXXCatch</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ObjCCatch</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>BlockLiteral</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>LambdaExpr</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ConversionId</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TrailingReturn</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TrailingReturnVar</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateTypeArg</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>RequiresExpr</name></expr>:</case>
<return>return <expr><name>false</name></expr>;</return>

<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Block</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>ForInit</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>SelectionInit</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>Condition</name></expr>:</case>
<case>case <expr><name>DeclaratorContext</name><operator>::</operator><name>TemplateArg</name></expr>:</case>
<return>return <expr><name>true</name></expr>;</return>
<expr_stmt/></block_content></block></switch>}</block>

<call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"unknown context kind!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}



bool <macro><name>isFunctionDeclaratorAFunctionDeclaration</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isFunctionDeclarationContext</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>

<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>I</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>N</name> <init>= <expr><call><name>getNumTypeObjects</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>I</name> <operator>!=</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>I</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>getTypeObject</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call><operator>.</operator><name>Kind</name> <operator>!=</operator> <name>DeclaratorChunk</name><operator>::</operator><name>Paren</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>true</name></expr>;</return>
}



bool <macro><name>hasTrailingReturnType</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>Chunk</name> <range>: <expr><call><name>type_objects</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>Chunk</name><operator>.</operator><name>Kind</name></name> <operator>==</operator> <name>DeclaratorChunk</name><operator>::</operator><name>Function</name> <operator>&amp;&amp;</operator>
<call><name><name>Chunk</name><operator>.</operator><name>Fun</name><operator>.</operator><name>hasTrailingReturnType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block></expr></expr_stmt>
<return>return <expr><name>false</name></expr>;</return>
}


ParsedType <macro><name>getTrailingReturnType</name><argument_list>()</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>Chunk</name> <range>: <expr><call><name>type_objects</name><argument_list>()</argument_list></call></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>Chunk</name><operator>.</operator><name>Kind</name></name> <operator>==</operator> <name>DeclaratorChunk</name><operator>::</operator><name>Function</name> <operator>&amp;&amp;</operator>
<call><name><name>Chunk</name><operator>.</operator><name>Fun</name><operator>.</operator><name>hasTrailingReturnType</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>Chunk</name><operator>.</operator><name>Fun</name><operator>.</operator><name>getTrailingReturnType</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block></expr></expr_stmt>
<return>return <expr><call><name>ParsedType</name><argument_list>()</argument_list></call></expr>;</return>
}


void <macro><name>setTrailingRequiresClause</name><argument_list>(<argument>Expr *TRC</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><name>TrailingRequiresClause</name> <operator>=</operator> <name>TRC</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SetRangeEnd</name><argument_list>(<argument><expr><call><name><name>TRC</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>


<function><type><name>Expr</name> <modifier>*</modifier></type><name>getTrailingRequiresClause</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>TrailingRequiresClause</name></expr>;</return>
</block_content>}</block></function>



<expr_stmt><expr><name>bool</name> <macro><name>hasTrailingRequiresClause</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TrailingRequiresClause</name> <operator>!=</operator> <name>nullptr</name></expr>;</return>
}</block></expr></expr_stmt>


<function><type><name>void</name></type> <name>setTemplateParameterLists</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateParameterList</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>TPLs</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>TemplateParameterLists</name> <operator>=</operator> <name>TPLs</name></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateParameterList</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getTemplateParameterLists</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TemplateParameterLists</name></expr>;</return>
}</block></expr></expr_stmt>




<function><type><name>void</name></type> <name>setInventedTemplateParameterList</name><parameter_list>(<parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>Invented</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>InventedTemplateParameterList</name> <operator>=</operator> <name>Invented</name></expr>;</expr_stmt>
</block_content>}</block></function>




<expr_stmt><expr><name>TemplateParameterList</name> <operator>*</operator> <macro><name>getInventedTemplateParameterList</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>InventedTemplateParameterList</name></expr>;</return>
}</block></expr></expr_stmt>










<function><type><name>void</name></type> <name>takeAttributes</name><parameter_list>(<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>attrs</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>lastLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>Attrs</name><operator>.</operator><name>takeAllFrom</name></name><argument_list>(<argument><expr><name>attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>lastLoc</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>SetRangeEnd</name><argument_list>(<argument><expr><name>lastLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><specifier>const</specifier> <name>ParsedAttributes</name> <operator>&amp;</operator><macro><name>getAttributes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Attrs</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>getAttributes</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>Attrs</name></expr>;</return> </block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>hasAttributes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getAttributes</name><argument_list>()</argument_list></call><operator>.</operator><call><name>empty</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>getDeclSpec</name><argument_list>()</argument_list></call><operator>.</operator><call><name>hasAttributes</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>e</name> <init>= <expr><call><name>getNumTypeObjects</name><argument_list>()</argument_list></call></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>e</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getTypeObject</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>getAttrs</name><argument_list>()</argument_list></call><operator>.</operator><call><name>empty</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
<return>return <expr><name>false</name></expr>;</return>
}



void <macro><name>getCXX11AttributeRanges</name><argument_list>(<argument>SmallVectorImpl&lt;SourceRange&gt; &amp;Ranges</argument>)</argument_list></macro> <block>{<block_content>
<for>for <control>(<init><decl><type><specifier>const</specifier> <name>ParsedAttr</name> <modifier>&amp;</modifier></type><name>AL</name> <range>: <expr><name>Attrs</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name><name>AL</name><operator>.</operator><name>isCXX11Attribute</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Ranges</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name><name>AL</name><operator>.</operator><name>getRange</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block>

<function><type><name>void</name></type> <name>setAsmLabel</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>AsmLabel</name> <operator>=</operator> <name>E</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>getAsmLabel</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AsmLabel</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setExtension</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Val</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Extension</name> <operator>=</operator> <name>Val</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>bool</name> <macro><name>getExtension</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Extension</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setObjCIvar</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Val</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>ObjCIvar</name> <operator>=</operator> <name>Val</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>bool</name> <macro><name>isObjCIvar</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ObjCIvar</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setObjCWeakProperty</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Val</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>ObjCWeakProperty</name> <operator>=</operator> <name>Val</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>bool</name> <macro><name>isObjCWeakProperty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ObjCWeakProperty</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setInvalidType</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Val</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>InvalidType</name> <operator>=</operator> <name>Val</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>bool</name> <macro><name>isInvalidType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>InvalidType</name> <operator>||</operator> <call><name><name>DS</name><operator>.</operator><name>getTypeSpecType</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclSpec</name><operator>::</operator><name>TST_error</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setGroupingParens</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>flag</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>GroupingParens</name> <operator>=</operator> <name>flag</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>bool</name> <macro><name>hasGroupingParens</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>GroupingParens</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isFirstDeclarator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>CommaLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getCommaLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CommaLoc</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setCommaLoc</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CL</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>CommaLoc</name> <operator>=</operator> <name>CL</name></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>hasEllipsis</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>EllipsisLoc</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEllipsisLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>EllipsisLoc</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setEllipsisLoc</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>EL</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>EllipsisLoc</name> <operator>=</operator> <name>EL</name></expr>;</expr_stmt> </block_content>}</block></function>

<function><type><name>void</name></type> <name>setFunctionDefinitionKind</name><parameter_list>(<parameter><decl><type><name>FunctionDefinitionKind</name></type> <name>Val</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>FunctionDefinition</name> <operator>=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>isFunctionDefinition</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getFunctionDefinitionKind</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>FunctionDefinitionKind</name><operator>::</operator><name>Declaration</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>FunctionDefinitionKind</name> <macro><name>getFunctionDefinitionKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>FunctionDefinitionKind</name><operator>)</operator><name>FunctionDefinition</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setHasInitializer</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Val</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>HasInitializer</name> <operator>=</operator> <name>Val</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>bool</name> <macro><name>hasInitializer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>HasInitializer</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>bool</name></type> <name>isFirstDeclarationOfMember</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getContext</name><argument_list>()</argument_list></call> <operator>==</operator> <name>DeclaratorContext</name><operator>::</operator><name>Member</name> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name>getDeclSpec</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isFriendSpecified</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function_decl><type><name>bool</name></type> <name>isStaticMember</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>isCtorOrDtor</name><parameter_list>()</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>setRedeclaration</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Val</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Redeclaration</name> <operator>=</operator> <name>Val</name></expr>;</expr_stmt> </block_content>}</block></function>
<expr_stmt><expr><name>bool</name> <macro><name>isRedeclaration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Redeclaration</name></expr>;</return> }</block></expr></expr_stmt>
};



<struct>struct <name>FieldDeclarator</name> <block>{
<decl_stmt><decl><type><name>Declarator</name></type> <name>D</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BitfieldSize</name></decl>;</decl_stmt>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>FieldDeclarator</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclSpec</name> <operator>&amp;</operator><name>DS</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>D</name><argument_list>(<argument><expr><name>DS</name></expr></argument>, <argument><expr><name>DeclaratorContext</name><operator>::</operator><name>Member</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>BitfieldSize</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>


<decl_stmt><decl><type><name>class</name></type> <name>VirtSpecifiers</name> <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>Specifier</name> <block>{
<decl><name>VS_None</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>VS_Override</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>VS_Final</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>VS_Sealed</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,

<decl><name>VS_GNU_Final</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>,
<decl><name>VS_Abstract</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>
}</block>;</enum>

<expr_stmt><expr><call><name>VirtSpecifiers</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>Specifiers</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>LastSpecifier</name><argument_list>(<argument>VS_None</argument>)</argument_list></macro> <expr><block>{ }</block>

<name>bool</name> <macro><name>SetSpecifier</name><argument_list>(<argument>Specifier VS</argument>, <argument>SourceLocation Loc</argument>,
<argument>const char *&amp;PrevSpec</argument>)</argument_list></macro></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isUnset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Specifiers</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isOverrideSpecified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Specifiers</name> <operator>&amp;</operator> <name>VS_Override</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getOverrideLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VS_overrideLoc</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isFinalSpecified</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Specifiers</name> <operator>&amp;</operator> <operator>(</operator><name>VS_Final</name> <operator>|</operator> <name>VS_Sealed</name> <operator>|</operator> <name>VS_GNU_Final</name><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isFinalSpelledSealed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Specifiers</name> <operator>&amp;</operator> <name>VS_Sealed</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getFinalLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VS_finalLoc</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getAbstractLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>VS_abstractLoc</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>clear</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Specifiers</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> </block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getSpecifierName</name><parameter_list>(<parameter><decl><type><name>Specifier</name></type> <name>VS</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getFirstLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FirstLocation</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLastLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LastLocation</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>Specifier</name> <macro><name>getLastSpecifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LastSpecifier</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Specifiers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Specifier</name></type> <name>LastSpecifier</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>VS_overrideLoc</name></decl>, <decl><type ref="prev"/><name>VS_finalLoc</name></decl>, <decl><type ref="prev"/><name>VS_abstractLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FirstLocation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>LastLocation</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>LambdaCaptureInitKind</name> <block>{<block_content>
<expr_stmt><expr><name>NoInit</name></expr><operator>,</operator>
<expr><name>CopyInit</name></expr><operator>,</operator>
<expr><name>DirectInit</name></expr><operator>,</operator>
<expr><name>ListInit</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<struct>struct <name>LambdaIntroducer</name> <block>{

<struct>struct <name>LambdaCapture</name> <block>{
<decl_stmt><decl><type><name>LambdaCaptureKind</name></type> <name>Kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LambdaCaptureInitKind</name></type> <name>InitKind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Init</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParsedType</name></type> <name>InitCaptureType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceRange</name></type> <name>ExplicitRange</name></decl>;</decl_stmt>

<macro><name>LambdaCapture</name><argument_list>(<argument>LambdaCaptureKind Kind</argument>, <argument>SourceLocation Loc</argument>,
<argument>IdentifierInfo *Id</argument>, <argument>SourceLocation EllipsisLoc</argument>,
<argument>LambdaCaptureInitKind InitKind</argument>, <argument>ExprResult Init</argument>,
<argument>ParsedType InitCaptureType</argument>,
<argument>SourceRange ExplicitRange</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Loc</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Id</name><argument_list>(<argument><expr><name>Id</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>EllipsisLoc</name><argument_list>(<argument><expr><name>EllipsisLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>InitKind</name><argument_list>(<argument><expr><name>InitKind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Init</name><argument_list>(<argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>InitCaptureType</name><argument_list>(<argument><expr><name>InitCaptureType</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>ExplicitRange</name><argument_list>(<argument>ExplicitRange</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>SourceRange</name></type> <name>Range</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>DefaultLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LambdaCaptureDefault</name></type> <name>Default</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>LambdaCapture</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>Captures</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>LambdaIntroducer</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>Default</name><argument_list>(<argument>LCD_None</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <macro><name>addCapture</name><argument_list>(<argument>LambdaCaptureKind Kind</argument>,
<argument>SourceLocation Loc</argument>,
<argument>IdentifierInfo* Id</argument>,
<argument>SourceLocation EllipsisLoc</argument>,
<argument>LambdaCaptureInitKind InitKind</argument>,
<argument>ExprResult Init</argument>,
<argument>ParsedType InitCaptureType</argument>,
<argument>SourceRange ExplicitRange</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Captures</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><call><name>LambdaCapture</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>, <argument><expr><name>EllipsisLoc</name></expr></argument>, <argument><expr><name>InitKind</name></expr></argument>, <argument><expr><name>Init</name></expr></argument>,
<argument><expr><name>InitCaptureType</name></expr></argument>, <argument><expr><name>ExplicitRange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block></expr></expr_stmt>
}</block>;</struct>

<struct>struct <name>InventedTemplateParameterInfo</name> <block>{



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumExplicitTemplateParams</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>AutoTemplateParameterDepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>








<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>TemplateParams</name></decl>;</decl_stmt>
}</block>;</struct>

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
