<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Tooling/Syntax/Nodes.h">



















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_TOOLING_SYNTAX_NODES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_TOOLING_SYNTAX_NODES_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TokenKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/Token.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Tooling/Syntax/Tokens.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Tooling/Syntax/Tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/raw_ostream.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>syntax</name> <block>{<block_content>




<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>NodeKind</name> <range>: <expr><name>uint16_t</name> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONCRETE_NODE</name><parameter_list>(<parameter><type><name>Kind</name></type></parameter>, <parameter><type><name>Base</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Kind,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Tooling/Syntax/Nodes.inc"</cpp:file></cpp:include>
}</block></expr></range></decl>;</decl_stmt>

<expr_stmt><expr><name>raw_ostream</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name><operator>,</operator> <name>NodeKind</name> <name>K</name><operator>)</operator></expr>;</expr_stmt>
















<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>NodeRole</name> <range>: <expr><name>uint8_t</name> <block>{


<expr><name>Detached</name></expr>,

<expr><name>Unknown</name></expr>,

<expr><name>OpenParen</name></expr>,

<expr><name>CloseParen</name></expr>,

<expr><name>IntroducerKeyword</name></expr>,

<expr><name>LiteralToken</name></expr>,

<expr><name>ArrowToken</name></expr>,
<expr><name>ExternKeyword</name></expr>,
<expr><name>TemplateKeyword</name></expr>,



<expr><name>BodyStatement</name></expr>,

<expr><name>ListElement</name></expr>,
<expr><name>ListDelimiter</name></expr>,


<expr><name>OperatorToken</name></expr>,
<expr><name>Operand</name></expr>,
<expr><name>LeftHandSide</name></expr>,
<expr><name>RightHandSide</name></expr>,
<expr><name>ReturnValue</name></expr>,
<expr><name>CaseValue</name></expr>,
<expr><name>ThenStatement</name></expr>,
<expr><name>ElseKeyword</name></expr>,
<expr><name>ElseStatement</name></expr>,
<expr><name>Expression</name></expr>,
<expr><name>Statement</name></expr>,
<expr><name>Condition</name></expr>,
<expr><name>Message</name></expr>,
<expr><name>Declarator</name></expr>,
<expr><name>Declaration</name></expr>,
<expr><name>Size</name></expr>,
<expr><name>Parameters</name></expr>,
<expr><name>TrailingReturn</name></expr>,
<expr><name>UnqualifiedId</name></expr>,
<expr><name>Qualifier</name></expr>,
<expr><name>SubExpression</name></expr>,
<expr><name>Object</name></expr>,
<expr><name>AccessToken</name></expr>,
<expr><name>Member</name></expr>,
<expr><name>Callee</name></expr>,
<expr><name>Arguments</name></expr>,
<expr><name>Declarators</name></expr>
}</block></expr></range></decl>;</decl_stmt>

<expr_stmt><expr><name>raw_ostream</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name><operator>,</operator> <name>NodeRole</name> <name>R</name><operator>)</operator></expr>;</expr_stmt>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Tooling/Syntax/NodeClasses.inc"</cpp:file></cpp:include>



<decl_stmt><decl><type><name>class</name> <name>NestedNameSpecifier</name></type> <name>final</name> <range>: <expr><name>public</name> <name>List</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>NestedNameSpecifier</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>List</name><argument_list>(<argument>NodeKind::NestedNameSpecifier</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>NameSpecifier</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <call><name>getSpecifiers</name><argument_list>()</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>List</name><operator>::</operator><name><name>ElementAndDelimiter</name><argument_list type="generic">&lt;<argument><expr><name>syntax</name><operator>::</operator><name>NameSpecifier</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<call><name>getSpecifiersAndDoubleColons</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name> <name>UnqualifiedId</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Tree</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>UnqualifiedId</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Tree</name><argument_list>(<argument>NodeKind::UnqualifiedId</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name> <name>UnknownExpression</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Expression</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>UnknownExpression</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Expression</name><argument_list>(<argument>NodeKind::UnknownExpression</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>






<decl_stmt><decl><type><name>class</name> <name>CallArguments</name></type> <name>final</name> <range>: <expr><name>public</name> <name>List</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>CallArguments</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>List</name><argument_list>(<argument>NodeKind::CallArguments</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Expression</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <call><name>getArguments</name><argument_list>()</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>List</name><operator>::</operator><name><name>ElementAndDelimiter</name><argument_list type="generic">&lt;<argument><expr><name>Expression</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <call><name>getArgumentsAndCommas</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>UnaryOperatorExpression</name> <range>: <expr><name>public</name> <name>Expression</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>UnaryOperatorExpression</name><argument_list>(<argument>NodeKind K</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Expression</name><argument_list>(<argument>K</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getOperatorToken</name><argument_list>()</argument_list></call></expr>;
<expr><name>Expression</name> <operator>*</operator><call><name>getOperand</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>










<decl_stmt><decl><type><name>class</name> <name>PrefixUnaryOperatorExpression</name></type> <name>final</name> <range>: <expr><name>public</name> <name>UnaryOperatorExpression</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PrefixUnaryOperatorExpression</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>UnaryOperatorExpression</name><argument_list>(<argument>NodeKind::PrefixUnaryOperatorExpression</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>






<decl_stmt><decl><type><name>class</name> <name>PostfixUnaryOperatorExpression</name></type> <name>final</name> <range>: <expr><name>public</name> <name>UnaryOperatorExpression</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>PostfixUnaryOperatorExpression</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>UnaryOperatorExpression</name><argument_list>(<argument>NodeKind::PostfixUnaryOperatorExpression</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>








<decl_stmt><decl><type><name>class</name> <name>BinaryOperatorExpression</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Expression</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>BinaryOperatorExpression</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Expression</name><argument_list>(<argument>NodeKind::BinaryOperatorExpression</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Expression</name> <operator>*</operator><call><name>getLhs</name><argument_list>()</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getOperatorToken</name><argument_list>()</argument_list></call></expr>;
<expr><name>Expression</name> <operator>*</operator><call><name>getRhs</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>Statement</name> <range>: <expr><name>public</name> <name>Tree</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Statement</name><argument_list>(<argument>NodeKind K</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Tree</name><argument_list>(<argument>K</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name> <name>UnknownStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>UnknownStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::UnknownStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>DeclarationStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>DeclarationStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::DeclarationStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>EmptyStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>EmptyStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::EmptyStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>SwitchStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>SwitchStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::SwitchStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getSwitchKeyword</name><argument_list>()</argument_list></call></expr>;
<expr><name>Statement</name> <operator>*</operator><call><name>getBody</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>CaseStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>CaseStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::CaseStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getCaseKeyword</name><argument_list>()</argument_list></call></expr>;
<expr><name>Expression</name> <operator>*</operator><call><name>getCaseValue</name><argument_list>()</argument_list></call></expr>;
<expr><name>Statement</name> <operator>*</operator><call><name>getBody</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>DefaultStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>DefaultStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::DefaultStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getDefaultKeyword</name><argument_list>()</argument_list></call></expr>;
<expr><name>Statement</name> <operator>*</operator><call><name>getBody</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name> <name>IfStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>IfStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::IfStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getIfKeyword</name><argument_list>()</argument_list></call></expr>;
<expr><name>Statement</name> <operator>*</operator><call><name>getThenStatement</name><argument_list>()</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getElseKeyword</name><argument_list>()</argument_list></call></expr>;
<expr><name>Statement</name> <operator>*</operator><call><name>getElseStatement</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>ForStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ForStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::ForStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getForKeyword</name><argument_list>()</argument_list></call></expr>;
<expr><name>Statement</name> <operator>*</operator><call><name>getBody</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>WhileStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>WhileStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::WhileStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getWhileKeyword</name><argument_list>()</argument_list></call></expr>;
<expr><name>Statement</name> <operator>*</operator><call><name>getBody</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>ContinueStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ContinueStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::ContinueStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getContinueKeyword</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>BreakStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>BreakStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::BreakStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getBreakKeyword</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name> <name>ReturnStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ReturnStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::ReturnStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getReturnKeyword</name><argument_list>()</argument_list></call></expr>;
<expr><name>Expression</name> <operator>*</operator><call><name>getReturnValue</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>RangeBasedForStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>RangeBasedForStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::RangeBasedForStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getForKeyword</name><argument_list>()</argument_list></call></expr>;
<expr><name>Statement</name> <operator>*</operator><call><name>getBody</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name> <name>ExpressionStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ExpressionStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::ExpressionStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Expression</name> <operator>*</operator><call><name>getExpression</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>CompoundStatement</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Statement</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>CompoundStatement</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Statement</name><argument_list>(<argument>NodeKind::CompoundStatement</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getLbrace</name><argument_list>()</argument_list></call></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Statement</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <call><name>getStatements</name><argument_list>()</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getRbrace</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>Declaration</name> <range>: <expr><name>public</name> <name>Tree</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Declaration</name><argument_list>(<argument>NodeKind K</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Tree</name><argument_list>(<argument>K</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>UnknownDeclaration</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declaration</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>UnknownDeclaration</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Declaration</name><argument_list>(<argument>NodeKind::UnknownDeclaration</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>EmptyDeclaration</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declaration</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>EmptyDeclaration</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Declaration</name><argument_list>(<argument>NodeKind::EmptyDeclaration</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name> <name>StaticAssertDeclaration</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declaration</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>StaticAssertDeclaration</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Declaration</name><argument_list>(<argument>NodeKind::StaticAssertDeclaration</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Expression</name> <operator>*</operator><call><name>getCondition</name><argument_list>()</argument_list></call></expr>;
<expr><name>Expression</name> <operator>*</operator><call><name>getMessage</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name> <name>LinkageSpecificationDeclaration</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declaration</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>LinkageSpecificationDeclaration</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>Declaration</name><argument_list>(<argument>NodeKind::LinkageSpecificationDeclaration</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name> <name>DeclaratorList</name></type> <name>final</name> <range>: <expr><name>public</name> <name>List</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>DeclaratorList</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>List</name><argument_list>(<argument>NodeKind::DeclaratorList</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>SimpleDeclarator</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <call><name>getDeclarators</name><argument_list>()</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>List</name><operator>::</operator><name><name>ElementAndDelimiter</name><argument_list type="generic">&lt;<argument><expr><name>syntax</name><operator>::</operator><name>SimpleDeclarator</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<call><name>getDeclaratorsAndCommas</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name> <name>SimpleDeclaration</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declaration</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>SimpleDeclaration</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Declaration</name><argument_list>(<argument>NodeKind::SimpleDeclaration</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;

<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>SimpleDeclarator</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <call><name>getDeclarators</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>TemplateDeclaration</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declaration</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>TemplateDeclaration</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Declaration</name><argument_list>(<argument>NodeKind::TemplateDeclaration</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getTemplateKeyword</name><argument_list>()</argument_list></call></expr>;
<expr><name>Declaration</name> <operator>*</operator><call><name>getDeclaration</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>






<decl_stmt><decl><type><name>class</name> <name>ExplicitTemplateInstantiation</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declaration</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ExplicitTemplateInstantiation</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>Declaration</name><argument_list>(<argument>NodeKind::ExplicitTemplateInstantiation</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getTemplateKeyword</name><argument_list>()</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getExternKeyword</name><argument_list>()</argument_list></call></expr>;
<expr><name>Declaration</name> <operator>*</operator><call><name>getDeclaration</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>NamespaceDefinition</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declaration</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>NamespaceDefinition</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Declaration</name><argument_list>(<argument>NodeKind::NamespaceDefinition</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>NamespaceAliasDefinition</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declaration</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>NamespaceAliasDefinition</name><argument_list>()</argument_list></call>
<operator>:</operator> <macro><name>Declaration</name><argument_list>(<argument>NodeKind::NamespaceAliasDefinition</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>UsingNamespaceDirective</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declaration</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>UsingNamespaceDirective</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Declaration</name><argument_list>(<argument>NodeKind::UsingNamespaceDirective</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name> <name>UsingDeclaration</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declaration</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>UsingDeclaration</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Declaration</name><argument_list>(<argument>NodeKind::UsingDeclaration</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name> <name>TypeAliasDeclaration</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declaration</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>TypeAliasDeclaration</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Declaration</name><argument_list>(<argument>NodeKind::TypeAliasDeclaration</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>













<decl_stmt><decl><type><name>class</name></type> <name>Declarator</name> <range>: <expr><name>public</name> <name>Tree</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>Declarator</name><argument_list>(<argument>NodeKind K</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Tree</name><argument_list>(<argument>K</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name> <name>SimpleDeclarator</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declarator</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>SimpleDeclarator</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Declarator</name><argument_list>(<argument>NodeKind::SimpleDeclarator</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>class</name> <name>ParenDeclarator</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Declarator</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ParenDeclarator</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Declarator</name><argument_list>(<argument>NodeKind::ParenDeclarator</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getLparen</name><argument_list>()</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getRparen</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>class</name> <name>ArraySubscript</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Tree</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ArraySubscript</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Tree</name><argument_list>(<argument>NodeKind::ArraySubscript</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;

<expr><name>Leaf</name> <operator>*</operator><call><name>getLbracket</name><argument_list>()</argument_list></call></expr>;
<expr><name>Expression</name> <operator>*</operator><call><name>getSize</name><argument_list>()</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getRbracket</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name> <name>TrailingReturnType</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Tree</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>TrailingReturnType</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Tree</name><argument_list>(<argument>NodeKind::TrailingReturnType</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;

<expr><name>Leaf</name> <operator>*</operator><call><name>getArrowToken</name><argument_list>()</argument_list></call></expr>;


<expr><name>SimpleDeclarator</name> <operator>*</operator><call><name>getDeclarator</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name> <name>ParameterDeclarationList</name></type> <name>final</name> <range>: <expr><name>public</name> <name>List</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ParameterDeclarationList</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>List</name><argument_list>(<argument>NodeKind::ParameterDeclarationList</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>SimpleDeclaration</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <call><name>getParameterDeclarations</name><argument_list>()</argument_list></call></expr>;
<expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>List</name><operator>::</operator><name><name>ElementAndDelimiter</name><argument_list type="generic">&lt;<argument><expr><name>syntax</name><operator>::</operator><name>SimpleDeclaration</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<call><name>getParametersAndCommas</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>












<decl_stmt><decl><type><name>class</name> <name>ParametersAndQualifiers</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Tree</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>ParametersAndQualifiers</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Tree</name><argument_list>(<argument>NodeKind::ParametersAndQualifiers</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getLparen</name><argument_list>()</argument_list></call></expr>;
<expr><name>ParameterDeclarationList</name> <operator>*</operator><call><name>getParameters</name><argument_list>()</argument_list></call></expr>;
<expr><name>Leaf</name> <operator>*</operator><call><name>getRparen</name><argument_list>()</argument_list></call></expr>;
<expr><name>TrailingReturnType</name> <operator>*</operator><call><name>getTrailingReturn</name><argument_list>()</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name> <name>MemberPointer</name></type> <name>final</name> <range>: <expr><name>public</name> <name>Tree</name> <block>{
<expr><name>public</name><operator>:</operator>
<call><name>MemberPointer</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Tree</name><argument_list>(<argument>NodeKind::MemberPointer</argument>)</argument_list></macro> <block>{}</block>
<specifier>static</specifier> <name>bool</name> <call><name>classof</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Node</name> <operator>*</operator><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONCRETE_NODE</name><parameter_list>(<parameter><type><name>Kind</name></type></parameter>, <parameter><type><name>Base</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>inline bool Kind::classof(const Node *N) { return N-&gt;getKind() == NodeKind::Kind; }</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_NODE</name><parameter_list>(<parameter><type><name>Kind</name></type></parameter>, <parameter><type><name>Base</name></type></parameter>, <parameter><type><name>First</name></type></parameter>, <parameter><type><name>Last</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>inline bool Kind::classof(const Node *N) { return N-&gt;getKind() &gt;= NodeKind::First &amp;&amp; N-&gt;getKind() &lt;= NodeKind::Last; }</cpp:value></cpp:define>



<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Tooling/Syntax/Nodes.inc"</cpp:file></cpp:include>

</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
