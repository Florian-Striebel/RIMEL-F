<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Sema/CodeCompleteConsumer.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_SEMA_CODECOMPLETECONSUMER_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang-c/Index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/MacroInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/CodeCompleteOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/DeclSpec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/None.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallPtrSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/type_traits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionTemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LangOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NamedDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NestedNameSpecifier</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Preprocessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>RawComment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Sema</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UsingShadowDecl</name></decl>;</decl_stmt>



<enum>enum <block>{


<decl><name>CCP_NextInitializer</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>,



<decl><name>CCP_EnumInCase</name> <init>= <expr><literal type="number">7</literal></expr></init></decl>,


<decl><name>CCP_SuperCompletion</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>,


<decl><name>CCP_LocalDeclaration</name> <init>= <expr><literal type="number">34</literal></expr></init></decl>,



<decl><name>CCP_MemberDeclaration</name> <init>= <expr><literal type="number">35</literal></expr></init></decl>,



<decl><name>CCP_Keyword</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>,


<decl><name>CCP_CodePattern</name> <init>= <expr><literal type="number">40</literal></expr></init></decl>,


<decl><name>CCP_Declaration</name> <init>= <expr><literal type="number">50</literal></expr></init></decl>,


<decl><name>CCP_Type</name> <init>= <expr><name>CCP_Declaration</name></expr></init></decl>,


<decl><name>CCP_Constant</name> <init>= <expr><literal type="number">65</literal></expr></init></decl>,


<decl><name>CCP_Macro</name> <init>= <expr><literal type="number">70</literal></expr></init></decl>,


<decl><name>CCP_NestedNameSpecifier</name> <init>= <expr><literal type="number">75</literal></expr></init></decl>,



<decl><name>CCP_Unlikely</name> <init>= <expr><literal type="number">80</literal></expr></init></decl>,


<decl><name>CCP_ObjC_cmd</name> <init>= <expr><name>CCP_Unlikely</name></expr></init></decl>
}</block>;</enum>



<enum>enum <block>{

<decl><name>CCD_InBaseClass</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,



<decl><name>CCD_ObjectQualifierMatch</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,




<decl><name>CCD_SelectorMatch</name> <init>= <expr><operator>-</operator><literal type="number">3</literal></expr></init></decl>,



<decl><name>CCD_bool_in_ObjC</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,



<decl><name>CCD_ProbablyNotObjCCollection</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>,


<decl><name>CCD_MethodAsProperty</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,



<decl><name>CCD_BlockPropertySetter</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>
}</block>;</enum>



<enum>enum <block>{


<decl><name>CCF_ExactTypeMatch</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,




<decl><name>CCF_SimilarTypeMatch</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>
}</block>;</enum>



<enum>enum <name>SimplifiedTypeClass</name> <block>{
<decl><name>STC_Arithmetic</name></decl>,
<decl><name>STC_Array</name></decl>,
<decl><name>STC_Block</name></decl>,
<decl><name>STC_Function</name></decl>,
<decl><name>STC_ObjectiveC</name></decl>,
<decl><name>STC_Other</name></decl>,
<decl><name>STC_Pointer</name></decl>,
<decl><name>STC_Record</name></decl>,
<decl><name>STC_Void</name></decl>
}</block>;</enum>


<function_decl><type><name>SimplifiedTypeClass</name></type> <name>getSimplifiedTypeClass</name><parameter_list>(<parameter><decl><type><name>CanQualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>QualType</name></type> <name>getDeclUsageType</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>C</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>)</parameter_list>;</function_decl>










<function_decl><type><name>unsigned</name></type> <name>getMacroUsagePriority</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>MacroName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LangOptions</name> <modifier>&amp;</modifier></type><name>LangOpts</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>PreferredTypeIsPointer</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>CXCursorKind</name></type> <name>getCursorKindForDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>class</name></type> <name>CodeCompletionContext</name> <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>Kind</name> <block>{

<decl><name>CCC_Other</name></decl>,



<decl><name>CCC_OtherWithMacros</name></decl>,



<decl><name>CCC_TopLevel</name></decl>,



<decl><name>CCC_ObjCInterface</name></decl>,



<decl><name>CCC_ObjCImplementation</name></decl>,



<decl><name>CCC_ObjCIvarList</name></decl>,


<decl><name>CCC_ClassStructUnion</name></decl>,



<decl><name>CCC_Statement</name></decl>,


<decl><name>CCC_Expression</name></decl>,



<decl><name>CCC_ObjCMessageReceiver</name></decl>,







<decl><name>CCC_DotMemberAccess</name></decl>,







<decl><name>CCC_ArrowMemberAccess</name></decl>,







<decl><name>CCC_ObjCPropertyAccess</name></decl>,



<decl><name>CCC_EnumTag</name></decl>,



<decl><name>CCC_UnionTag</name></decl>,



<decl><name>CCC_ClassOrStructTag</name></decl>,


<decl><name>CCC_ObjCProtocolName</name></decl>,



<decl><name>CCC_Namespace</name></decl>,


<decl><name>CCC_Type</name></decl>,


<decl><name>CCC_NewName</name></decl>,



<decl><name>CCC_SymbolOrNewName</name></decl>,



<decl><name>CCC_Symbol</name></decl>,


<decl><name>CCC_MacroName</name></decl>,



<decl><name>CCC_MacroNameUse</name></decl>,


<decl><name>CCC_PreprocessorExpression</name></decl>,



<decl><name>CCC_PreprocessorDirective</name></decl>,






<decl><name>CCC_NaturalLanguage</name></decl>,


<decl><name>CCC_SelectorName</name></decl>,


<decl><name>CCC_TypeQualifiers</name></decl>,



<decl><name>CCC_ParenthesizedExpression</name></decl>,



<decl><name>CCC_ObjCInstanceMessage</name></decl>,


<decl><name>CCC_ObjCClassMessage</name></decl>,



<decl><name>CCC_ObjCInterfaceName</name></decl>,


<decl><name>CCC_ObjCCategoryName</name></decl>,


<decl><name>CCC_IncludedFile</name></decl>,



<decl><name>CCC_Recovery</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><name>using</name></type> <name>VisitedContextSet</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>Kind</name></type> <name>CCKind</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>IsUsingDeclaration</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>PreferredType</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>BaseType</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>SelIdents</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>CXXScopeSpec</name></expr></argument>&gt;</argument_list></name> <name>ScopeSpecifier</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>VisitedContextSet</name></type> <name>VisitedContexts</name></decl>;</decl_stmt>

<label><name>public</name>:</label>

<macro><name>CodeCompletionContext</name><argument_list>(<argument>Kind CCKind</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>CCKind</name><argument_list>(<argument><expr><name>CCKind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IsUsingDeclaration</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>SelIdents</name><argument_list>(<argument>None</argument>)</argument_list></macro> <expr><block>{}</block>


<macro><name>CodeCompletionContext</name><argument_list>(<argument>Kind CCKind</argument>, <argument>QualType T</argument>,
<argument>ArrayRef&lt;IdentifierInfo *&gt; SelIdents = None</argument>)</argument_list></macro>
<operator>:</operator> <call><name>CCKind</name><argument_list>(<argument><expr><name>CCKind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IsUsingDeclaration</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>SelIdents</name><argument_list>(<argument>SelIdents</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><name>CCKind</name> <operator>==</operator> <name>CCC_DotMemberAccess</name> <operator>||</operator> <name>CCKind</name> <operator>==</operator> <name>CCC_ArrowMemberAccess</name> <operator>||</operator>
<name>CCKind</name> <operator>==</operator> <name>CCC_ObjCPropertyAccess</name> <operator>||</operator> <name>CCKind</name> <operator>==</operator> <name>CCC_ObjCClassMessage</name> <operator>||</operator>
<name>CCKind</name> <operator>==</operator> <name>CCC_ObjCInstanceMessage</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>BaseType</name> <operator>=</operator> <name>T</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>PreferredType</name> <operator>=</operator> <name>T</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isUsingDeclaration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>IsUsingDeclaration</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setIsUsingDeclaration</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>V</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>IsUsingDeclaration</name> <operator>=</operator> <name>V</name></expr>;</expr_stmt> </block_content>}</block></function>


<expr_stmt><expr><name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CCKind</name></expr>;</return> }</block></expr></expr_stmt>




<expr_stmt><expr><name>QualType</name> <macro><name>getPreferredType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PreferredType</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setPreferredType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><name>PreferredType</name> <operator>=</operator> <name>T</name></expr>;</expr_stmt> </block_content>}</block></function>



<expr_stmt><expr><name>QualType</name> <macro><name>getBaseType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BaseType</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getSelIdents</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SelIdents</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>wantConstructorResults</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<function><type><name>void</name></type> <name>setCXXScopeSpecifier</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>ScopeSpecifier</name></name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>SS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>addVisitedContext</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>Ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>VisitedContexts</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><specifier>const</specifier> <name>VisitedContextSet</name> <operator>&amp;</operator><macro><name>getVisitedContexts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>VisitedContexts</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXScopeSpec</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getCXXScopeSpecifier</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>ScopeSpecifier</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>ScopeSpecifier</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>llvm</name><operator>::</operator><name>None</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <macro><name>getCompletionKindString</name><argument_list>(<argument>CodeCompletionContext::Kind Kind</argument>)</argument_list></macro></expr>;</expr_stmt>








<decl_stmt><decl><type><name>class</name></type> <name>CodeCompletionString</name> <block>{<block_content>
<label><name>public</name>:</label>


<enum>enum <name>ChunkKind</name> <block>{



<decl><name>CK_TypedText</name></decl>,



<decl><name>CK_Text</name></decl>,




<decl><name>CK_Optional</name></decl>,



<decl><name>CK_Placeholder</name></decl>,



<decl><name>CK_Informative</name></decl>,


<decl><name>CK_ResultType</name></decl>,




<decl><name>CK_CurrentParameter</name></decl>,


<decl><name>CK_LeftParen</name></decl>,


<decl><name>CK_RightParen</name></decl>,


<decl><name>CK_LeftBracket</name></decl>,


<decl><name>CK_RightBracket</name></decl>,


<decl><name>CK_LeftBrace</name></decl>,


<decl><name>CK_RightBrace</name></decl>,


<decl><name>CK_LeftAngle</name></decl>,


<decl><name>CK_RightAngle</name></decl>,


<decl><name>CK_Comma</name></decl>,


<decl><name>CK_Colon</name></decl>,


<decl><name>CK_SemiColon</name></decl>,


<decl><name>CK_Equal</name></decl>,


<decl><name>CK_HorizontalSpace</name></decl>,



<decl><name>CK_VerticalSpace</name></decl>
}</block>;</enum>


<struct>struct <name>Chunk</name> <block>{


<decl_stmt><decl><type><name>ChunkKind</name></type> <name>Kind</name> <init>= <expr><name>CK_Text</name></expr></init></decl>;</decl_stmt>

<union>union <block>{




<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Text</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>CodeCompletionString</name> <modifier>*</modifier></type><name>Optional</name></decl>;</decl_stmt>
}</block>;</union>

<expr_stmt><expr><call><name>Chunk</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Text</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <block>{}</block>

<name>explicit</name> <macro><name>Chunk</name><argument_list>(<argument>ChunkKind Kind</argument>, <argument>const char *Text = <literal type="string">""</literal></argument>)</argument_list></macro></expr>;</expr_stmt>


<function_decl><type><specifier>static</specifier> <name>Chunk</name></type> <name>CreateText</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Text</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>Chunk</name></type> <name>CreateOptional</name><parameter_list>(<parameter><decl><type><name>CodeCompletionString</name> <modifier>*</modifier></type><name>Optional</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>Chunk</name></type> <name>CreatePlaceholder</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Placeholder</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>Chunk</name></type> <name>CreateInformative</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Informative</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>Chunk</name></type> <name>CreateResultType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ResultType</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>Chunk</name></type> <name>CreateCurrentParameter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>CurrentParameter</name></decl></parameter>)</parameter_list>;</function_decl>
}</block>;</struct>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CodeCompletionBuilder</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>CodeCompletionResult</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumChunks</name> <range>: <expr><literal type="number">16</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumAnnotations</name> <range>: <expr><literal type="number">16</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>Priority</name> <range>: <expr><literal type="number">16</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>Availability</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>StringRef</name></type> <name>ParentName</name></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>BriefComment</name></decl>;</decl_stmt>

<macro><name>CodeCompletionString</name><argument_list>(<argument>const Chunk *Chunks</argument>, <argument>unsigned NumChunks</argument>,
<argument>unsigned Priority</argument>, <argument>CXAvailabilityKind Availability</argument>,
<argument>const char **Annotations</argument>, <argument>unsigned NumAnnotations</argument>,
<argument>StringRef ParentName</argument>,
<argument>const char *BriefComment</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><operator>~</operator><call><name>CodeCompletionString</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>CodeCompletionString</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CodeCompletionString</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>CodeCompletionString</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>CodeCompletionString</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>iterator</name> <init>= <expr><specifier>const</specifier> <name>Chunk</name> <operator>*</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Chunk</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>begin</name><argument_list>()</argument_list></call> <operator>+</operator> <name>NumChunks</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumChunks</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumChunks</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>Chunk</name> <modifier>&amp;</modifier></type><name><name>operator</name><index>[]</index></name><argument_list>(<argument><expr><name>unsigned</name> <name>I</name></expr></argument>)</argument_list> const <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>size</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Chunk index out-of-range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>begin</name><argument_list>()</argument_list></call><index>[<expr><name>I</name></expr>]</index></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getTypedText</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getPriority</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Priority</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getAvailability</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Availability</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getAnnotationCount</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getAnnotation</name><argument_list>(<argument><expr><name>unsigned</name> <name>AnnotationNr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<expr_stmt><expr><name>StringRef</name> <macro><name>getParentContextName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>ParentName</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getBriefComment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>BriefComment</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getAsString</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>CodeCompletionAllocator</name> <range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <block>{
<expr><name>public</name><operator>:</operator>

<specifier>const</specifier> <name>char</name> <operator>*</operator><call><name>CopyString</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Twine</name> <operator>&amp;</operator><name>String</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>GlobalCodeCompletionAllocator</name> <range>: <expr><name>public</name> <name>CodeCompletionAllocator</name> <block>{}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CodeCompletionTUInfo</name> <block>{<block_content>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator></expr></argument>, <argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <name>ParentNames</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>GlobalCodeCompletionAllocator</name></expr></argument>&gt;</argument_list></name> <name>AllocatorRef</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>explicit</name></type> <name>CodeCompletionTUInfo</name><argument_list>(
<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>GlobalCodeCompletionAllocator</name></expr></argument>&gt;</argument_list></name> <name>Allocator</name></expr></argument>)</argument_list>
<range>: <macro><name>AllocatorRef</name><argument_list>(<argument>std::move(Allocator)</argument>)</argument_list></macro> <expr><block>{}</block>

<name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>GlobalCodeCompletionAllocator</name></expr></argument>&gt;</argument_list></name> <macro><name>getAllocatorRef</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>AllocatorRef</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<expr_stmt><expr><name>CodeCompletionAllocator</name> <operator>&amp;</operator><macro><name>getAllocator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>AllocatorRef</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>AllocatorRef</name></expr>;</return>
}</block></expr></expr_stmt>

<function_decl><type><name>StringRef</name></type> <name>getParentName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

}

namespace <macro><name>clang</name></macro> <block>{<block_content>


<decl_stmt><decl><type><name>class</name></type> <name>CodeCompletionBuilder</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>using</name></type> <name>Chunk</name> <init>= <expr><name>CodeCompletionString</name><operator>::</operator><name>Chunk</name></expr></init></decl>;</decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>CodeCompletionAllocator</name> <modifier>&amp;</modifier></type><name>Allocator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CodeCompletionTUInfo</name> <modifier>&amp;</modifier></type><name>CCTUInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Priority</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CXAvailabilityKind</name></type> <name>Availability</name> <init>= <expr><name>CXAvailability_Available</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StringRef</name></type> <name>ParentName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>BriefComment</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Chunk</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>Chunks</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>char</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Annotations</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>CodeCompletionBuilder</name><argument_list>(<argument><expr><name>CodeCompletionAllocator</name> <operator>&amp;</operator><name>Allocator</name></expr></argument>,
<argument><expr><name>CodeCompletionTUInfo</name> <operator>&amp;</operator><name>CCTUInfo</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Allocator</name><argument_list>(<argument><expr><name>Allocator</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>CCTUInfo</name><argument_list>(<argument>CCTUInfo</argument>)</argument_list></macro> <expr><block>{}</block>

<macro><name>CodeCompletionBuilder</name><argument_list>(<argument>CodeCompletionAllocator &amp;Allocator</argument>,
<argument>CodeCompletionTUInfo &amp;CCTUInfo</argument>,
<argument>unsigned Priority</argument>, <argument>CXAvailabilityKind Availability</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Allocator</name><argument_list>(<argument><expr><name>Allocator</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>CCTUInfo</name><argument_list>(<argument><expr><name>CCTUInfo</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Priority</name><argument_list>(<argument><expr><name>Priority</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>Availability</name><argument_list>(<argument>Availability</argument>)</argument_list></macro> <expr><block>{}</block>



<name>CodeCompletionAllocator</name> <operator>&amp;</operator><macro><name>getAllocator</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Allocator</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>CodeCompletionTUInfo</name> <operator>&amp;</operator><macro><name>getCodeCompletionTUInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CCTUInfo</name></expr>;</return> }</block></expr></expr_stmt>




<function_decl><type><name>CodeCompletionString</name> <modifier>*</modifier></type><name>TakeString</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddTypedTextChunk</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Text</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddTextChunk</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Text</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddOptionalChunk</name><parameter_list>(<parameter><decl><type><name>CodeCompletionString</name> <modifier>*</modifier></type><name>Optional</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddPlaceholderChunk</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Placeholder</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddInformativeChunk</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Text</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddResultTypeChunk</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ResultType</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddCurrentParameterChunk</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>CurrentParameter</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>AddChunk</name><argument_list>(<argument><expr><name>CodeCompletionString</name><operator>::</operator><name>ChunkKind</name> <name>CK</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>Text</name> <operator>=</operator> <literal type="string">""</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>AddAnnotation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>A</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Annotations</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>addParentContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getBriefComment</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>BriefComment</name></expr>;</return> }</block></expr></expr_stmt>
<function_decl><type><name>void</name></type> <name>addBriefComment</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Comment</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>StringRef</name> <macro><name>getParentName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ParentName</name></expr>;</return> }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>CodeCompletionResult</name> <block>{<block_content>
<label><name>public</name>:</label>

<enum>enum <name>ResultKind</name> <block>{

<decl><name>RK_Declaration</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,


<decl><name>RK_Keyword</name></decl>,


<decl><name>RK_Macro</name></decl>,


<decl><name>RK_Pattern</name></decl>
}</block>;</enum>



<decl_stmt><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>Declaration</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<union>union <block>{


<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Keyword</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>CodeCompletionString</name> <modifier>*</modifier></type><name>Pattern</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Macro</name></decl>;</decl_stmt>
}</block>;</union>


<decl_stmt><decl><type><name>unsigned</name></type> <name>Priority</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>StartParameter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ResultKind</name></type> <name>Kind</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CXCursorKind</name></type> <name>CursorKind</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CXAvailabilityKind</name></type> <name>Availability</name> <init>= <expr><name>CXAvailability_Available</name></expr></init></decl>;</decl_stmt>





























<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>FixItHint</name></expr></argument>&gt;</argument_list></name> <name>FixIts</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>Hidden</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>InBaseClass</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>QualifierIsInformative</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>StartsNestedNameSpecifier</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>AllParametersAreInformative</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>DeclaringEntity</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>




<decl_stmt><decl><type><name>NestedNameSpecifier</name> <modifier>*</modifier></type><name>Qualifier</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><specifier>const</specifier> <name>UsingShadowDecl</name> <modifier>*</modifier></type><name>ShadowDecl</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><specifier>const</specifier> <name>MacroInfo</name> <modifier>*</modifier></type><name>MacroDefInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<macro><name>CodeCompletionResult</name><argument_list>(<argument>const NamedDecl *Declaration</argument>, <argument>unsigned Priority</argument>,
<argument>NestedNameSpecifier *Qualifier = nullptr</argument>,
<argument>bool QualifierIsInformative = false</argument>,
<argument>bool Accessible = true</argument>,
<argument>std::vector&lt;FixItHint&gt; FixIts = std::vector&lt;FixItHint&gt;()</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Declaration</name><argument_list>(<argument><expr><name>Declaration</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Priority</name><argument_list>(<argument><expr><name>Priority</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Kind</name><argument_list>(<argument><expr><name>RK_Declaration</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>FixIts</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>FixIts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Hidden</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>InBaseClass</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>QualifierIsInformative</name><argument_list>(<argument><expr><name>QualifierIsInformative</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>StartsNestedNameSpecifier</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>AllParametersAreInformative</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>DeclaringEntity</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Qualifier</name><argument_list>(<argument>Qualifier</argument>)</argument_list></macro> <expr><block>{

<expr><call><name>computeCursorKindAndAvailability</name><argument_list>(<argument><expr><name>Accessible</name></expr></argument>)</argument_list></call></expr>;
}</block>


<macro><name>CodeCompletionResult</name><argument_list>(<argument>const char *Keyword</argument>, <argument>unsigned Priority = CCP_Keyword</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Keyword</name><argument_list>(<argument><expr><name>Keyword</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Priority</name><argument_list>(<argument><expr><name>Priority</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Kind</name><argument_list>(<argument><expr><name>RK_Keyword</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>CursorKind</name><argument_list>(<argument><expr><name>CXCursor_NotImplemented</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Hidden</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>InBaseClass</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>QualifierIsInformative</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>StartsNestedNameSpecifier</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>AllParametersAreInformative</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>DeclaringEntity</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>


<macro><name>CodeCompletionResult</name><argument_list>(<argument>const IdentifierInfo *Macro</argument>,
<argument>const MacroInfo *MI = nullptr</argument>,
<argument>unsigned Priority = CCP_Macro</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Macro</name><argument_list>(<argument><expr><name>Macro</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Priority</name><argument_list>(<argument><expr><name>Priority</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Kind</name><argument_list>(<argument><expr><name>RK_Macro</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>CursorKind</name><argument_list>(<argument><expr><name>CXCursor_MacroDefinition</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Hidden</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>InBaseClass</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>QualifierIsInformative</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>StartsNestedNameSpecifier</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>AllParametersAreInformative</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>DeclaringEntity</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>MacroDefInfo</name><argument_list>(<argument>MI</argument>)</argument_list></macro> <expr><block>{}</block>


<macro><name>CodeCompletionResult</name><argument_list>(
<argument>CodeCompletionString *Pattern</argument>, <argument>unsigned Priority = CCP_CodePattern</argument>,
<argument>CXCursorKind CursorKind = CXCursor_NotImplemented</argument>,
<argument>CXAvailabilityKind Availability = CXAvailability_Available</argument>,
<argument>const NamedDecl *D = nullptr</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Declaration</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Pattern</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Priority</name><argument_list>(<argument><expr><name>Priority</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Kind</name><argument_list>(<argument><expr><name>RK_Pattern</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>CursorKind</name><argument_list>(<argument><expr><name>CursorKind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Availability</name><argument_list>(<argument><expr><name>Availability</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Hidden</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>InBaseClass</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>QualifierIsInformative</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>StartsNestedNameSpecifier</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>AllParametersAreInformative</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>DeclaringEntity</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>



<macro><name>CodeCompletionResult</name><argument_list>(<argument>CodeCompletionString *Pattern</argument>, <argument>const NamedDecl *D</argument>,
<argument>unsigned Priority</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Declaration</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Pattern</name><argument_list>(<argument><expr><name>Pattern</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Priority</name><argument_list>(<argument><expr><name>Priority</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Kind</name><argument_list>(<argument><expr><name>RK_Pattern</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Hidden</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>InBaseClass</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>QualifierIsInformative</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>StartsNestedNameSpecifier</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>AllParametersAreInformative</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>DeclaringEntity</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>computeCursorKindAndAvailability</name><argument_list>()</argument_list></call></expr>;
}</block>



<specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><macro><name>getDeclaration</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Kind</name> <operator>==</operator> <name>RK_Declaration</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>Kind</name> <operator>==</operator> <name>RK_Pattern</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Not a declaration or pattern result"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Declaration</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getKeyword</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>==</operator> <name>RK_Keyword</name> <operator>&amp;&amp;</operator> <literal type="string">"Not a keyword result"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Keyword</name></expr>;</return>
}</block></expr></expr_stmt>








<function_decl><type><name>CodeCompletionString</name> <modifier>*</modifier></type><name>CreateCodeCompletionString</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CodeCompletionContext</name> <modifier>&amp;</modifier></type><name>CCContext</name></decl></parameter>,
<parameter><decl><type><name>CodeCompletionAllocator</name> <modifier>&amp;</modifier></type><name>Allocator</name></decl></parameter>,
<parameter><decl><type><name>CodeCompletionTUInfo</name> <modifier>&amp;</modifier></type><name>CCTUInfo</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IncludeBriefComments</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CodeCompletionString</name> <modifier>*</modifier></type><name>CreateCodeCompletionString</name><parameter_list>(<parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl></parameter>,
<parameter><decl><type><name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CodeCompletionContext</name> <modifier>&amp;</modifier></type><name>CCContext</name></decl></parameter>,
<parameter><decl><type><name>CodeCompletionAllocator</name> <modifier>&amp;</modifier></type><name>Allocator</name></decl></parameter>,
<parameter><decl><type><name>CodeCompletionTUInfo</name> <modifier>&amp;</modifier></type><name>CCTUInfo</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IncludeBriefComments</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>CodeCompletionString</name> <modifier>*</modifier></type>
<name>CreateCodeCompletionStringForMacro</name><parameter_list>(<parameter><decl><type><name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>,
<parameter><decl><type><name>CodeCompletionAllocator</name> <modifier>&amp;</modifier></type><name>Allocator</name></decl></parameter>,
<parameter><decl><type><name>CodeCompletionTUInfo</name> <modifier>&amp;</modifier></type><name>CCTUInfo</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>CodeCompletionString</name> <modifier>*</modifier></type><name>createCodeCompletionStringForDecl</name><parameter_list>(
<parameter><decl><type><name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>, <parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl></parameter>, <parameter><decl><type><name>CodeCompletionBuilder</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IncludeBriefComments</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CodeCompletionContext</name> <modifier>&amp;</modifier></type><name>CCContext</name></decl></parameter>,
<parameter><decl><type><name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>CodeCompletionString</name> <modifier>*</modifier></type><name>createCodeCompletionStringForOverride</name><parameter_list>(
<parameter><decl><type><name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>, <parameter><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl></parameter>, <parameter><decl><type><name>CodeCompletionBuilder</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IncludeBriefComments</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CodeCompletionContext</name> <modifier>&amp;</modifier></type><name>CCContext</name></decl></parameter>,
<parameter><decl><type><name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>StringRef</name></type> <name>getOrderedName</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>Saved</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>private</name>:</label>
<function_decl><type><name>void</name></type> <name>computeCursorKindAndAvailability</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>Accessible</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>&lt;</operator><operator>(</operator><specifier>const</specifier> <name>CodeCompletionResult</name> <operator>&amp;</operator><name>X</name><operator>,</operator> <specifier>const</specifier> <name>CodeCompletionResult</name> <operator>&amp;</operator><name>Y</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>bool</name> <name>operator</name><operator>&gt;</operator><operator>(</operator><specifier>const</specifier> <name>CodeCompletionResult</name> <operator>&amp;</operator><name>X</name><operator>,</operator>
<specifier>const</specifier> <name>CodeCompletionResult</name> <operator>&amp;</operator><name>Y</name><operator>)</operator> <block>{
<return>return <expr><name>Y</name> <operator>&lt;</operator> <name>X</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>bool</name> <name>operator</name><operator>&lt;=</operator><operator>(</operator><specifier>const</specifier> <name>CodeCompletionResult</name> <operator>&amp;</operator><name>X</name><operator>,</operator>
<specifier>const</specifier> <name>CodeCompletionResult</name> <operator>&amp;</operator><name>Y</name><operator>)</operator> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><name>Y</name> <operator>&lt;</operator> <name>X</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>inline</specifier> <name>bool</name> <name>operator</name><operator>&gt;=</operator><operator>(</operator><specifier>const</specifier> <name>CodeCompletionResult</name> <operator>&amp;</operator><name>X</name><operator>,</operator>
<specifier>const</specifier> <name>CodeCompletionResult</name> <operator>&amp;</operator><name>Y</name><operator>)</operator> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><name>X</name> <operator>&lt;</operator> <name>Y</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>CodeCompleteConsumer</name> <block>{<block_content>
<label><name>protected</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>CodeCompleteOptions</name></type> <name>CodeCompleteOpts</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>class</name></type> <name>OverloadCandidate</name> <block>{<block_content>
<label><name>public</name>:</label>

<enum>enum <name>CandidateKind</name> <block>{

<decl><name>CK_Function</name></decl>,


<decl><name>CK_FunctionTemplate</name></decl>,



<decl><name>CK_FunctionType</name></decl>
}</block>;</enum>

<label><name>private</name>:</label>

<decl_stmt><decl><type><name>CandidateKind</name></type> <name>Kind</name></decl>;</decl_stmt>

<union>union <block>{


<decl_stmt><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Function</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>FunctionTemplateDecl</name> <modifier>*</modifier></type><name>FunctionTemplate</name></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>FunctionType</name> <modifier>*</modifier></type><name>Type</name></decl>;</decl_stmt>
}</block>;</union>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>OverloadCandidate</name><argument_list>(<argument><expr><name>FunctionDecl</name> <operator>*</operator><name>Function</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>CK_Function</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Function</name><argument_list>(<argument>Function</argument>)</argument_list></macro> <expr><block>{}</block>

<call><name>OverloadCandidate</name><argument_list>(<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator><name>FunctionTemplateDecl</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>CK_FunctionTemplate</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>FunctionTemplate</name><argument_list>(<argument>FunctionTemplateDecl</argument>)</argument_list></macro> <expr><block>{}</block>

<call><name>OverloadCandidate</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionType</name> <operator>*</operator><name>Type</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>CK_FunctionType</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Type</name><argument_list>(<argument>Type</argument>)</argument_list></macro> <expr><block>{}</block>


<name>CandidateKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>FunctionDecl</name> <operator>*</operator><macro><name>getFunction</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>FunctionTemplateDecl</name> <operator>*</operator><macro><name>getFunctionTemplate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getKind</name><argument_list>()</argument_list></call> <operator>==</operator> <name>CK_FunctionTemplate</name> <operator>&amp;&amp;</operator> <literal type="string">"Not a function template"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>FunctionTemplate</name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>FunctionType</name> <operator>*</operator><macro><name>getFunctionType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<decl_stmt><decl><type><name>CodeCompletionString</name> <modifier>*</modifier></type><name>CreateSignatureString</name><argument_list>(<argument><expr><name>unsigned</name> <name>CurrentArg</name></expr></argument>,
<argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>,
<argument><expr><name>CodeCompletionAllocator</name> <operator>&amp;</operator><name>Allocator</name></expr></argument>,
<argument><expr><name>CodeCompletionTUInfo</name> <operator>&amp;</operator><name>CCTUInfo</name></expr></argument>,
<argument><expr><name>bool</name> <name>IncludeBriefComments</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>CodeCompleteConsumer</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CodeCompleteOptions</name> <operator>&amp;</operator><name>CodeCompleteOpts</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>CodeCompleteOpts</name><argument_list>(<argument>CodeCompleteOpts</argument>)</argument_list></macro> <block>{}</block>


<name>bool</name> <macro><name>includeMacros</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CodeCompleteOpts</name><operator>.</operator><name>IncludeMacros</name></name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>includeCodePatterns</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CodeCompleteOpts</name><operator>.</operator><name>IncludeCodePatterns</name></name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>includeGlobals</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CodeCompleteOpts</name><operator>.</operator><name>IncludeGlobals</name></name></expr>;</return> }</block></expr></expr_stmt>




<expr_stmt><expr><name>bool</name> <macro><name>includeNamespaceLevelDecls</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CodeCompleteOpts</name><operator>.</operator><name>IncludeNamespaceLevelDecls</name></name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>includeBriefComments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CodeCompleteOpts</name><operator>.</operator><name>IncludeBriefComments</name></name></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>includeFixIts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>CodeCompleteOpts</name><operator>.</operator><name>IncludeFixIts</name></name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>loadExternal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>CodeCompleteOpts</name><operator>.</operator><name>LoadExternal</name></name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>CodeCompleteConsumer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<function><type><name>virtual</name> <name>bool</name></type> <name>isResultFilteredOut</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Filter</name></decl></parameter>,
<parameter><decl><type><name>CodeCompletionResult</name></type> <name>Results</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>




<function><type><name>virtual</name> <name>void</name></type> <name>ProcessCodeCompleteResults</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>CodeCompletionContext</name></type> <name>Context</name></decl></parameter>,
<parameter><decl><type><name>CodeCompletionResult</name> <modifier>*</modifier></type><name>Results</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumResults</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>












<function><type><name>virtual</name> <name>void</name></type> <name>ProcessOverloadCandidates</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>CurrentArg</name></decl></parameter>,
<parameter><decl><type><name>OverloadCandidate</name> <modifier>*</modifier></type><name>Candidates</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumCandidates</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpenParLoc</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>




<function_decl><type><name>virtual</name> <name>CodeCompletionAllocator</name> <modifier>&amp;</modifier></type><name>getAllocator</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<function_decl><type><name>virtual</name> <name>CodeCompletionTUInfo</name> <modifier>&amp;</modifier></type><name>getCodeCompletionTUInfo</name><parameter_list>()</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<function_decl><type><specifier>const</specifier> <name>RawComment</name> <modifier>*</modifier></type><name>getCompletionComment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><specifier>const</specifier> <name>RawComment</name> <modifier>*</modifier></type><name>getPatternCompletionComment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><specifier>const</specifier> <name>RawComment</name> <modifier>*</modifier></type>
<name>getParameterComment</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CodeCompleteConsumer</name><operator>::</operator><name>OverloadCandidate</name> <operator>&amp;</operator><name>Result</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>ArgIndex</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>PrintingCodeCompleteConsumer</name> <range>: <expr><name>public</name> <name>CodeCompleteConsumer</name> <block>{

<expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr>;

<expr><name>CodeCompletionTUInfo</name> <name>CCTUInfo</name></expr>;

<expr><name>public</name><operator>:</operator>


<call><name>PrintingCodeCompleteConsumer</name><argument_list>(<argument><expr><specifier>const</specifier> <name>CodeCompleteOptions</name> <operator>&amp;</operator><name>CodeCompleteOpts</name></expr></argument>,
<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>CodeCompleteConsumer</name><argument_list>(<argument><expr><name>CodeCompleteOpts</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>OS</name><argument_list>(<argument><expr><name>OS</name></expr></argument>)</argument_list></call></expr>,
<macro><name>CCTUInfo</name><argument_list>(<argument>std::make_shared&lt;GlobalCodeCompletionAllocator&gt;()</argument>)</argument_list></macro> <expr><block>{}</block>


<name>void</name> <macro><name>ProcessCodeCompleteResults</name><argument_list>(<argument>Sema &amp;S</argument>, <argument>CodeCompletionContext Context</argument>,
<argument>CodeCompletionResult *Results</argument>,
<argument>unsigned NumResults</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>ProcessOverloadCandidates</name><argument_list>(<argument>Sema &amp;S</argument>, <argument>unsigned CurrentArg</argument>,
<argument>OverloadCandidate *Candidates</argument>,
<argument>unsigned NumCandidates</argument>,
<argument>SourceLocation OpenParLoc</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>isResultFilteredOut</name><argument_list>(<argument>StringRef Filter</argument>, <argument>CodeCompletionResult Results</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>CodeCompletionAllocator</name> <operator>&amp;</operator><macro><name>getAllocator</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name><name>CCTUInfo</name><operator>.</operator><name>getAllocator</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>CodeCompletionTUInfo</name> <operator>&amp;</operator><macro><name>getCodeCompletionTUInfo</name><argument_list>()</argument_list></macro> <name>override</name> <block>{ <return>return <expr><name>CCTUInfo</name></expr>;</return> }</block>
}</expr>;

}</block></expr></range></decl></decl_stmt></block_content></block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
