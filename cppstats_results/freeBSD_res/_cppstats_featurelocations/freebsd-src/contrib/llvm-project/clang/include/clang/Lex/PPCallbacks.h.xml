<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Lex/PPCallbacks.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_LEX_PPCALLBACKS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_LEX_PPCALLBACKS_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/DiagnosticIDs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/ModuleLoader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/Pragma.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>Token</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IdentifierInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MacroDefinition</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MacroDirective</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MacroArgs</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>PPCallbacks</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>PPCallbacks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<enum>enum <name>FileChangeReason</name> <block>{
<decl><name>EnterFile</name></decl>, <decl><name>ExitFile</name></decl>, <decl><name>SystemHeaderPragma</name></decl>, <decl><name>RenameFile</name></decl>
}</block>;</enum>





<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>FileChanged</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>FileChangeReason</name> <name>Reason</name></expr></argument>,
<argument><expr><name>SrcMgr</name><operator>::</operator><name>CharacteristicKind</name> <name>FileType</name></expr></argument>,
<argument><expr><name>FileID</name> <name>PrevFID</name> <operator>=</operator> <call><name>FileID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> <block>{<block_content>
</block_content>}</block></decl></decl_stmt>









<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>FileSkipped</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FileEntryRef</name> <operator>&amp;</operator><name>SkippedFile</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>FilenameTok</name></expr></argument>,
<argument><expr><name>SrcMgr</name><operator>::</operator><name>CharacteristicKind</name> <name>FileType</name></expr></argument>)</argument_list> <block>{<block_content/>}</block></decl></decl_stmt>













<function><type><name>virtual</name> <name>bool</name></type> <name>FileNotFound</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>FileName</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>char</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>RecoveryPath</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>










































<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>InclusionDirective</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>HashLoc</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Token</name> <operator>&amp;</operator><name>IncludeTok</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>FileName</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsAngled</name></expr></argument>,
<argument><expr><name>CharSourceRange</name> <name>FilenameRange</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>File</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>SearchPath</name></expr></argument>,
<argument><expr><name>StringRef</name> <name>RelativePath</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Module</name> <operator>*</operator><name>Imported</name></expr></argument>,
<argument><expr><name>SrcMgr</name><operator>::</operator><name>CharacteristicKind</name> <name>FileType</name></expr></argument>)</argument_list> <block>{<block_content>
</block_content>}</block></decl></decl_stmt>









<function><type><name>virtual</name> <name>void</name></type> <name>EnteredSubmodule</name><parameter_list>(<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ImportLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForPragma</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>









<function><type><name>virtual</name> <name>void</name></type> <name>LeftSubmodule</name><parameter_list>(<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ImportLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForPragma</name></decl></parameter>)</parameter_list> <block>{<block_content> </block_content>}</block></function>











<function><type><name>virtual</name> <name>void</name></type> <name>moduleImport</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ImportLoc</name></decl></parameter>,
<parameter><decl><type><name>ModuleIdPath</name></type> <name>Path</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Module</name> <modifier>*</modifier></type><name>Imported</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>




<function><type><name>virtual</name> <name>void</name></type> <name>EndOfMainFile</name><parameter_list>()</parameter_list> <block>{<block_content>
</block_content>}</block></function>





<function><type><name>virtual</name> <name>void</name></type> <name>Ident</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>


<function><type><name>virtual</name> <name>void</name></type> <name>PragmaDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>PragmaIntroducerKind</name></type> <name>Introducer</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>


<function><type><name>virtual</name> <name>void</name></type> <name>PragmaComment</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Kind</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Str</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>


<function><type><name>virtual</name> <name>void</name></type> <name>PragmaMark</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Trivia</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>



<function><type><name>virtual</name> <name>void</name></type> <name>PragmaDetectMismatch</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Name</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Value</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>




<function><type><name>virtual</name> <name>void</name></type> <name>PragmaDebug</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>DebugType</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>


<enum>enum <name>PragmaMessageKind</name> <block>{

<decl><name>PMK_Message</name></decl>,


<decl><name>PMK_Warning</name></decl>,


<decl><name>PMK_Error</name></decl>
}</block>;</enum>






<function><type><name>virtual</name> <name>void</name></type> <name>PragmaMessage</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Namespace</name></decl></parameter>,
<parameter><decl><type><name>PragmaMessageKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Str</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>



<function><type><name>virtual</name> <name>void</name></type> <name>PragmaDiagnosticPush</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Namespace</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>



<function><type><name>virtual</name> <name>void</name></type> <name>PragmaDiagnosticPop</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Namespace</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>


<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>PragmaDiagnostic</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>StringRef</name> <name>Namespace</name></expr></argument>,
<argument><expr><name>diag</name><operator>::</operator><name>Severity</name> <name>mapping</name></expr></argument>, <argument><expr><name>StringRef</name> <name>Str</name></expr></argument>)</argument_list> <block>{<block_content/>}</block></decl></decl_stmt>



<function><type><name>virtual</name> <name>void</name></type> <name>PragmaOpenCLExtension</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StateLoc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>State</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>


<function><type><name>virtual</name> <name>void</name></type> <name>PragmaWarning</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>WarningSpec</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>Ids</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>


<function><type><name>virtual</name> <name>void</name></type> <name>PragmaWarningPush</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>Level</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>


<function><type><name>virtual</name> <name>void</name></type> <name>PragmaWarningPop</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>



<function><type><name>virtual</name> <name>void</name></type> <name>PragmaExecCharsetPush</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Str</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>



<function><type><name>virtual</name> <name>void</name></type> <name>PragmaExecCharsetPop</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>



<function><type><name>virtual</name> <name>void</name></type> <name>PragmaAssumeNonNullBegin</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>



<function><type><name>virtual</name> <name>void</name></type> <name>PragmaAssumeNonNullEnd</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>



<function><type><name>virtual</name> <name>void</name></type> <name>MacroExpands</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>MacroNameTok</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MacroDefinition</name> <modifier>&amp;</modifier></type><name>MD</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MacroArgs</name> <modifier>*</modifier></type><name>Args</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function><type><name>virtual</name> <name>void</name></type> <name>MacroDefined</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>MacroNameTok</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MacroDirective</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>







<function><type><name>virtual</name> <name>void</name></type> <name>MacroUndefined</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>MacroNameTok</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MacroDefinition</name> <modifier>&amp;</modifier></type><name>MD</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MacroDirective</name> <modifier>*</modifier></type><name>Undef</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>



<function><type><name>virtual</name> <name>void</name></type> <name>Defined</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>MacroNameTok</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MacroDefinition</name> <modifier>&amp;</modifier></type><name>MD</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>



<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>HasInclude</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>StringRef</name> <name>FileName</name></expr></argument>, <argument><expr><name>bool</name> <name>IsAngled</name></expr></argument>,
<argument><expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>FileEntryRef</name></expr></argument>&gt;</argument_list></name> <name>File</name></expr></argument>,
<argument><expr><name>SrcMgr</name><operator>::</operator><name>CharacteristicKind</name> <name>FileType</name></expr></argument>)</argument_list></decl>;</decl_stmt>







<function><type><name>virtual</name> <name>void</name></type> <name>SourceRangeSkipped</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndifLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>

<enum>enum <name>ConditionValueKind</name> <block>{
<decl><name>CVK_NotEvaluated</name></decl>, <decl><name>CVK_False</name></decl>, <decl><name>CVK_True</name></decl>
}</block>;</enum>







<function><type><name>virtual</name> <name>void</name></type> <name>If</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>ConditionRange</name></decl></parameter>,
<parameter><decl><type><name>ConditionValueKind</name></type> <name>ConditionValue</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>







<function><type><name>virtual</name> <name>void</name></type> <name>Elif</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>ConditionRange</name></decl></parameter>,
<parameter><decl><type><name>ConditionValueKind</name></type> <name>ConditionValue</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>IfLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>





<function><type><name>virtual</name> <name>void</name></type> <name>Ifdef</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>MacroNameTok</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MacroDefinition</name> <modifier>&amp;</modifier></type><name>MD</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>





<function><type><name>virtual</name> <name>void</name></type> <name>Elifdef</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>MacroNameTok</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MacroDefinition</name> <modifier>&amp;</modifier></type><name>MD</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>





<function><type><name>virtual</name> <name>void</name></type> <name>Elifdef</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>ConditionRange</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IfLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>





<function><type><name>virtual</name> <name>void</name></type> <name>Ifndef</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>MacroNameTok</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MacroDefinition</name> <modifier>&amp;</modifier></type><name>MD</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>





<function><type><name>virtual</name> <name>void</name></type> <name>Elifndef</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>MacroNameTok</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MacroDefinition</name> <modifier>&amp;</modifier></type><name>MD</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>





<function><type><name>virtual</name> <name>void</name></type> <name>Elifndef</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>ConditionRange</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IfLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>




<function><type><name>virtual</name> <name>void</name></type> <name>Else</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>IfLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>




<function><type><name>virtual</name> <name>void</name></type> <name>Endif</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>IfLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>PPChainedCallbacks</name> <range>: <expr><name>public</name> <name>PPCallbacks</name> <block>{
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PPCallbacks</name></expr></argument>&gt;</argument_list></name> <name>First</name></expr>, <expr><name>Second</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>PPChainedCallbacks</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PPCallbacks</name></expr></argument>&gt;</argument_list></name> <name>_First</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>PPCallbacks</name></expr></argument>&gt;</argument_list></name> <name>_Second</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>First</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>_First</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>, <macro><name>Second</name><argument_list>(<argument>std::move(_Second)</argument>)</argument_list></macro> <expr><block>{}</block>

<operator>~</operator><macro><name>PPChainedCallbacks</name><argument_list>()</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>FileChanged</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>FileChangeReason Reason</argument>,
<argument>SrcMgr::CharacteristicKind FileType</argument>,
<argument>FileID PrevFID</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>FileChanged</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Reason</name></expr></argument>, <argument><expr><name>FileType</name></expr></argument>, <argument><expr><name>PrevFID</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>FileChanged</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Reason</name></expr></argument>, <argument><expr><name>FileType</name></expr></argument>, <argument><expr><name>PrevFID</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>FileSkipped</name><argument_list>(<argument>const FileEntryRef &amp;SkippedFile</argument>, <argument>const Token &amp;FilenameTok</argument>,
<argument>SrcMgr::CharacteristicKind FileType</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>FileSkipped</name></name><argument_list>(<argument><expr><name>SkippedFile</name></expr></argument>, <argument><expr><name>FilenameTok</name></expr></argument>, <argument><expr><name>FileType</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>FileSkipped</name></name><argument_list>(<argument><expr><name>SkippedFile</name></expr></argument>, <argument><expr><name>FilenameTok</name></expr></argument>, <argument><expr><name>FileType</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>bool</name> <macro><name>FileNotFound</name><argument_list>(<argument>StringRef FileName</argument>,
<argument>SmallVectorImpl&lt;char&gt; &amp;RecoveryPath</argument>)</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name><name>First</name><operator>-&gt;</operator><name>FileNotFound</name></name><argument_list>(<argument><expr><name>FileName</name></expr></argument>, <argument><expr><name>RecoveryPath</name></expr></argument>)</argument_list></call> <operator>||</operator>
<call><name><name>Second</name><operator>-&gt;</operator><name>FileNotFound</name></name><argument_list>(<argument><expr><name>FileName</name></expr></argument>, <argument><expr><name>RecoveryPath</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>InclusionDirective</name><argument_list>(<argument>SourceLocation HashLoc</argument>, <argument>const Token &amp;IncludeTok</argument>,
<argument>StringRef FileName</argument>, <argument>bool IsAngled</argument>,
<argument>CharSourceRange FilenameRange</argument>, <argument>const FileEntry *File</argument>,
<argument>StringRef SearchPath</argument>, <argument>StringRef RelativePath</argument>,
<argument>const Module *Imported</argument>,
<argument>SrcMgr::CharacteristicKind FileType</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>InclusionDirective</name></name><argument_list>(<argument><expr><name>HashLoc</name></expr></argument>, <argument><expr><name>IncludeTok</name></expr></argument>, <argument><expr><name>FileName</name></expr></argument>, <argument><expr><name>IsAngled</name></expr></argument>,
<argument><expr><name>FilenameRange</name></expr></argument>, <argument><expr><name>File</name></expr></argument>, <argument><expr><name>SearchPath</name></expr></argument>, <argument><expr><name>RelativePath</name></expr></argument>,
<argument><expr><name>Imported</name></expr></argument>, <argument><expr><name>FileType</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>InclusionDirective</name></name><argument_list>(<argument><expr><name>HashLoc</name></expr></argument>, <argument><expr><name>IncludeTok</name></expr></argument>, <argument><expr><name>FileName</name></expr></argument>, <argument><expr><name>IsAngled</name></expr></argument>,
<argument><expr><name>FilenameRange</name></expr></argument>, <argument><expr><name>File</name></expr></argument>, <argument><expr><name>SearchPath</name></expr></argument>, <argument><expr><name>RelativePath</name></expr></argument>,
<argument><expr><name>Imported</name></expr></argument>, <argument><expr><name>FileType</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>EnteredSubmodule</name><argument_list>(<argument>Module *M</argument>, <argument>SourceLocation ImportLoc</argument>,
<argument>bool ForPragma</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>EnteredSubmodule</name></name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>ImportLoc</name></expr></argument>, <argument><expr><name>ForPragma</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>EnteredSubmodule</name></name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>ImportLoc</name></expr></argument>, <argument><expr><name>ForPragma</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>LeftSubmodule</name><argument_list>(<argument>Module *M</argument>, <argument>SourceLocation ImportLoc</argument>,
<argument>bool ForPragma</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>LeftSubmodule</name></name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>ImportLoc</name></expr></argument>, <argument><expr><name>ForPragma</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>LeftSubmodule</name></name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>ImportLoc</name></expr></argument>, <argument><expr><name>ForPragma</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>moduleImport</name><argument_list>(<argument>SourceLocation ImportLoc</argument>, <argument>ModuleIdPath Path</argument>,
<argument>const Module *Imported</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>moduleImport</name></name><argument_list>(<argument><expr><name>ImportLoc</name></expr></argument>, <argument><expr><name>Path</name></expr></argument>, <argument><expr><name>Imported</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>moduleImport</name></name><argument_list>(<argument><expr><name>ImportLoc</name></expr></argument>, <argument><expr><name>Path</name></expr></argument>, <argument><expr><name>Imported</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>EndOfMainFile</name><argument_list>()</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>EndOfMainFile</name></name><argument_list>()</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>EndOfMainFile</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>Ident</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>StringRef str</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>Ident</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>Ident</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaDirective</name><argument_list>(<argument>SourceLocation Loc</argument>,
<argument>PragmaIntroducerKind Introducer</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaDirective</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Introducer</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaDirective</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Introducer</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaComment</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>const IdentifierInfo *Kind</argument>,
<argument>StringRef Str</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaComment</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>Str</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaComment</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>Str</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaDetectMismatch</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>StringRef Name</argument>,
<argument>StringRef Value</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaDetectMismatch</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Name</name></expr></argument>, <argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaDetectMismatch</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Name</name></expr></argument>, <argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaDebug</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>StringRef DebugType</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaDebug</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>DebugType</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaDebug</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>DebugType</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaMessage</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>StringRef Namespace</argument>,
<argument>PragmaMessageKind Kind</argument>, <argument>StringRef Str</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaMessage</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Namespace</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>Str</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaMessage</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Namespace</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>Str</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaDiagnosticPush</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>StringRef Namespace</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaDiagnosticPush</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Namespace</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaDiagnosticPush</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Namespace</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaDiagnosticPop</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>StringRef Namespace</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaDiagnosticPop</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Namespace</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaDiagnosticPop</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Namespace</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaDiagnostic</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>StringRef Namespace</argument>,
<argument>diag::Severity mapping</argument>, <argument>StringRef Str</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaDiagnostic</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Namespace</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>Str</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaDiagnostic</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Namespace</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>Str</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>HasInclude</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>StringRef FileName</argument>, <argument>bool IsAngled</argument>,
<argument>Optional&lt;FileEntryRef&gt; File</argument>,
<argument>SrcMgr::CharacteristicKind FileType</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>PragmaOpenCLExtension</name><argument_list>(<argument>SourceLocation NameLoc</argument>, <argument>const IdentifierInfo *Name</argument>,
<argument>SourceLocation StateLoc</argument>, <argument>unsigned State</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaOpenCLExtension</name></name><argument_list>(<argument><expr><name>NameLoc</name></expr></argument>, <argument><expr><name>Name</name></expr></argument>, <argument><expr><name>StateLoc</name></expr></argument>, <argument><expr><name>State</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaOpenCLExtension</name></name><argument_list>(<argument><expr><name>NameLoc</name></expr></argument>, <argument><expr><name>Name</name></expr></argument>, <argument><expr><name>StateLoc</name></expr></argument>, <argument><expr><name>State</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaWarning</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>StringRef WarningSpec</argument>,
<argument>ArrayRef&lt;int&gt; Ids</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaWarning</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>WarningSpec</name></expr></argument>, <argument><expr><name>Ids</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaWarning</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>WarningSpec</name></expr></argument>, <argument><expr><name>Ids</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaWarningPush</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>int Level</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaWarningPush</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Level</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaWarningPush</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Level</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaWarningPop</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaWarningPop</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaWarningPop</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaExecCharsetPush</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>StringRef Str</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaExecCharsetPush</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Str</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaExecCharsetPush</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>Str</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaExecCharsetPop</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaExecCharsetPop</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaExecCharsetPop</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaAssumeNonNullBegin</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaAssumeNonNullBegin</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaAssumeNonNullBegin</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>PragmaAssumeNonNullEnd</name><argument_list>(<argument>SourceLocation Loc</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>PragmaAssumeNonNullEnd</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>PragmaAssumeNonNullEnd</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>MacroExpands</name><argument_list>(<argument>const Token &amp;MacroNameTok</argument>, <argument>const MacroDefinition &amp;MD</argument>,
<argument>SourceRange Range</argument>, <argument>const MacroArgs *Args</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>MacroExpands</name></name><argument_list>(<argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>, <argument><expr><name>Range</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>MacroExpands</name></name><argument_list>(<argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>, <argument><expr><name>Range</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>MacroDefined</name><argument_list>(<argument>const Token &amp;MacroNameTok</argument>,
<argument>const MacroDirective *MD</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>MacroDefined</name></name><argument_list>(<argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>MacroDefined</name></name><argument_list>(<argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>MacroUndefined</name><argument_list>(<argument>const Token &amp;MacroNameTok</argument>,
<argument>const MacroDefinition &amp;MD</argument>,
<argument>const MacroDirective *Undef</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>MacroUndefined</name></name><argument_list>(<argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>, <argument><expr><name>Undef</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>MacroUndefined</name></name><argument_list>(<argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>, <argument><expr><name>Undef</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>Defined</name><argument_list>(<argument>const Token &amp;MacroNameTok</argument>, <argument>const MacroDefinition &amp;MD</argument>,
<argument>SourceRange Range</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>Defined</name></name><argument_list>(<argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>, <argument><expr><name>Range</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>Defined</name></name><argument_list>(<argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>, <argument><expr><name>Range</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>SourceRangeSkipped</name><argument_list>(<argument>SourceRange Range</argument>, <argument>SourceLocation EndifLoc</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>SourceRangeSkipped</name></name><argument_list>(<argument><expr><name>Range</name></expr></argument>, <argument><expr><name>EndifLoc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>SourceRangeSkipped</name></name><argument_list>(<argument><expr><name>Range</name></expr></argument>, <argument><expr><name>EndifLoc</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>If</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>SourceRange ConditionRange</argument>,
<argument>ConditionValueKind ConditionValue</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>If</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>ConditionRange</name></expr></argument>, <argument><expr><name>ConditionValue</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>If</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>ConditionRange</name></expr></argument>, <argument><expr><name>ConditionValue</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>Elif</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>SourceRange ConditionRange</argument>,
<argument>ConditionValueKind ConditionValue</argument>, <argument>SourceLocation IfLoc</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>Elif</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>ConditionRange</name></expr></argument>, <argument><expr><name>ConditionValue</name></expr></argument>, <argument><expr><name>IfLoc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>Elif</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>ConditionRange</name></expr></argument>, <argument><expr><name>ConditionValue</name></expr></argument>, <argument><expr><name>IfLoc</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>Ifdef</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>const Token &amp;MacroNameTok</argument>,
<argument>const MacroDefinition &amp;MD</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>Ifdef</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>Ifdef</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>Elifdef</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>const Token &amp;MacroNameTok</argument>,
<argument>const MacroDefinition &amp;MD</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>Elifdef</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>Elifdef</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>Elifdef</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>SourceRange ConditionRange</argument>,
<argument>SourceLocation IfLoc</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>Elifdef</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>ConditionRange</name></expr></argument>, <argument><expr><name>IfLoc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>Elifdef</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>ConditionRange</name></expr></argument>, <argument><expr><name>IfLoc</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>Ifndef</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>const Token &amp;MacroNameTok</argument>,
<argument>const MacroDefinition &amp;MD</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>Ifndef</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>Ifndef</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>Elifndef</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>const Token &amp;MacroNameTok</argument>,
<argument>const MacroDefinition &amp;MD</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>Elifndef</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>Elifndef</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>MacroNameTok</name></expr></argument>, <argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>Elifndef</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>SourceRange ConditionRange</argument>,
<argument>SourceLocation IfLoc</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>Elifndef</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>ConditionRange</name></expr></argument>, <argument><expr><name>IfLoc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>Elifndef</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>ConditionRange</name></expr></argument>, <argument><expr><name>IfLoc</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>Else</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>SourceLocation IfLoc</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>Else</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>IfLoc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>Else</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>IfLoc</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>void</name> <macro><name>Endif</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>SourceLocation IfLoc</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><call><name><name>First</name><operator>-&gt;</operator><name>Endif</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>IfLoc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Second</name><operator>-&gt;</operator><name>Endif</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>IfLoc</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>
}</block></expr></range></decl>;</decl_stmt>

</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
