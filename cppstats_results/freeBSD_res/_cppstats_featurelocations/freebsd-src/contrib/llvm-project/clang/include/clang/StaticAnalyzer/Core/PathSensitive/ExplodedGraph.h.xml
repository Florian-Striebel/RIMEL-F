<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/ExplodedGraph.h">
















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPLODEDGRAPH_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_EXPLODEDGRAPH_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/AnalysisDeclContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/ProgramPoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Analysis/Support/BumpVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/ProgramState.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/StaticAnalyzer/Core/PathSensitive/SVals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DepthFirstIterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/GraphTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SetVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Allocator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Compiler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>CFG</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParentMap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>ento</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ExplodedGraph</name></decl>;</decl_stmt>










<decl_stmt><decl><type><name>class</name></type> <name>ExplodedNode</name> <range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FoldingSetNode</name> <block>{
<expr><name>friend</name> <name>class</name> <name>BranchNodeBuilder</name></expr>;
<expr><name>friend</name> <name>class</name> <name>CoreEngine</name></expr>;
<expr><name>friend</name> <name>class</name> <name>EndOfFunctionNodeBuilder</name></expr>;
<expr><name>friend</name> <name>class</name> <name>ExplodedGraph</name></expr>;
<expr><name>friend</name> <name>class</name> <name>IndirectGotoNodeBuilder</name></expr>;
<expr><name>friend</name> <name>class</name> <name>NodeBuilder</name></expr>;
<expr><name>friend</name> <name>class</name> <name>SwitchNodeBuilder</name></expr>;










<expr><name>class</name> <name>NodeGroup</name> <block>{




<expr><name>uintptr_t</name> <name>P</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>NodeGroup</name><argument_list>(<argument>bool Flag = false</argument>)</argument_list></macro> <operator>:</operator> <macro><name>P</name><argument_list>(<argument>Flag</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>getFlag</name><argument_list>()</argument_list></call> <operator>==</operator> <name>Flag</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>ExplodedNode</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>ExplodedNode</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator><macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>P</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>getFlag</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> }</block>




<name>void</name> <call><name>addNode</name><argument_list>(<argument><expr><name>ExplodedNode</name> <operator>*</operator><name>N</name></expr></argument>, <argument><expr><name>ExplodedGraph</name> <operator>&amp;</operator><name>G</name></expr></argument>)</argument_list></call></expr>;






<expr><name>void</name> <call><name>replaceNode</name><argument_list>(<argument><expr><name>ExplodedNode</name> <operator>*</operator><name>node</name></expr></argument>)</argument_list></call></expr>;


<expr><name>bool</name> <macro><name>getFlag</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><name>P</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
}</block>
}</expr>;



<expr><specifier>const</specifier> <name>ProgramPoint</name> <name>Location</name></expr>;


<expr><name>ProgramStateRef</name> <name>State</name></expr>;


<expr><name>NodeGroup</name> <name>Preds</name></expr>;


<expr><name>NodeGroup</name> <name>Succs</name></expr>;

<expr><name>int64_t</name> <name>Id</name></expr>;

<expr><name>public</name><operator>:</operator>
<name>explicit</name> <macro><name>ExplodedNode</name><argument_list>(<argument>const ProgramPoint &amp;loc</argument>, <argument>ProgramStateRef state</argument>,
<argument>int64_t Id</argument>, <argument>bool IsSink</argument>)</argument_list></macro>
<operator>:</operator> <call><name>Location</name><argument_list>(<argument><expr><name>loc</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>State</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>, <expr><call><name>Succs</name><argument_list>(<argument><expr><name>IsSink</name></expr></argument>)</argument_list></call></expr>, <macro><name>Id</name><argument_list>(<argument>Id</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isSink</name><argument_list>()</argument_list></call> <operator>==</operator> <name>IsSink</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>ProgramPoint</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Location</name></expr>;</return> }</block>

<specifier>const</specifier> <name>LocationContext</name> <operator>*</operator><macro><name>getLocationContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLocationContext</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>StackFrameContext</name> <operator>*</operator><macro><name>getStackFrame</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocation</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getStackFrame</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Decl</name> <operator>&amp;</operator><macro><name>getCodeDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><call><name>getLocationContext</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getDecl</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>CFG</name> <operator>&amp;</operator><macro><name>getCFG</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><call><name>getLocationContext</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getCFG</name><argument_list>()</argument_list></call></expr>;</return> }</block>

<specifier>const</specifier> <name>CFGBlock</name> <operator>*</operator><macro><name>getCFGBlock</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><specifier>const</specifier> <name>ParentMap</name> <operator>&amp;</operator><macro><name>getParentMap</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getLocationContext</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getParentMap</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <operator>&amp;</operator><macro><name>getAnalysis</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>*</operator><call><name>getLocationContext</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name><name>getAnalysis</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>ProgramStateRef</name> <operator>&amp;</operator><macro><name>getState</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>State</name></expr>;</return> }</block>

<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name> <macro><name>getLocationAs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_LVALUE_FUNCTION</name> <block>{
<return>return <expr><name><name>Location</name><operator>.</operator><name>getAs</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return>
}</block>


<name>SVal</name> <macro><name>getSVal</name><argument_list>(<argument>const Stmt *S</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getState</name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getSVal</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><call><name>getLocationContext</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID &amp;ID</argument>,
<argument>const ProgramPoint &amp;Loc</argument>,
<argument>const ProgramStateRef &amp;state</argument>,
<argument>bool IsSink</argument>)</argument_list></macro> <block>{
<expr><call><name><name>ID</name><operator>.</operator><name>Add</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddPointer</name></name><argument_list>(<argument><expr><call><name><name>state</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>ID</name><operator>.</operator><name>AddBoolean</name></name><argument_list>(<argument><expr><name>IsSink</name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>Profile</name><argument_list>(<argument>llvm::FoldingSetNodeID&amp; ID</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<expr><call><name>Profile</name><argument_list>(<argument><expr><name>ID</name></expr></argument>, <argument><expr><name>Location</name></expr></argument>, <argument><expr><name>State</name></expr></argument>, <argument><expr><call><name>isSink</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>



<name>void</name> <call><name>addPredecessor</name><argument_list>(<argument><expr><name>ExplodedNode</name> <operator>*</operator><name>V</name></expr></argument>, <argument><expr><name>ExplodedGraph</name> <operator>&amp;</operator><name>G</name></expr></argument>)</argument_list></call></expr>;

<expr><name>unsigned</name> <macro><name>succ_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>unsigned</name> <macro><name>pred_size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>succ_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>pred_empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>isSink</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>getFlag</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>hasSinglePred</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>(</operator><call><name>pred_size</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
}</block>

<name>ExplodedNode</name> <operator>*</operator><macro><name>getFirstPred</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>pred_empty</name><argument_list>()</argument_list></call> <operator>?</operator> <name>nullptr</name> <operator>:</operator> <operator>*</operator><operator>(</operator><call><name>pred_begin</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</return>
}</block>

<specifier>const</specifier> <name>ExplodedNode</name> <operator>*</operator><macro><name>getFirstPred</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedNode</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getFirstPred</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>ExplodedNode</name> <operator>*</operator><macro><name>getFirstSucc</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><ternary><condition><expr><call><name>succ_empty</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>nullptr</name></expr> </then><else>: <expr><operator>*</operator><operator>(</operator><call><name>succ_begin</name><argument_list>()</argument_list></call><operator>)</operator></expr></else></ternary></expr>;</return>
}</block>

<specifier>const</specifier> <name>ExplodedNode</name> <operator>*</operator><macro><name>getFirstSucc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedNode</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getFirstSucc</name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>using</name> <name>succ_iterator</name> <operator>=</operator> <name>ExplodedNode</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator></expr>;
<expr><name>using</name> <name>succ_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>succ_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>using</name> <name>const_succ_iterator</name> <operator>=</operator> <specifier>const</specifier> <name>ExplodedNode</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator></expr>;
<expr><name>using</name> <name>const_succ_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_succ_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>using</name> <name>pred_iterator</name> <operator>=</operator> <name>ExplodedNode</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator></expr>;
<expr><name>using</name> <name>pred_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>pred_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>using</name> <name>const_pred_iterator</name> <operator>=</operator> <specifier>const</specifier> <name>ExplodedNode</name> <operator>*</operator> <specifier>const</specifier> <operator>*</operator></expr>;
<expr><name>using</name> <name>const_pred_range</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>const_pred_iterator</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>pred_iterator</name> <macro><name>pred_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>pred_iterator</name> <macro><name>pred_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Preds</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>pred_range</name> <macro><name>preds</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><block>{<expr><call><name><name>Preds</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>, <macro><name>Preds</name></macro><expr><operator>.</operator><macro><name>end</name><argument_list>()</argument_list></macro></expr>}</block></expr>;</return> }</block>

<name>const_pred_iterator</name> <macro><name>pred_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedNode</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>pred_begin</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>const_pred_iterator</name> <macro><name>pred_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedNode</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>pred_end</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>const_pred_range</name> <macro><name>preds</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><block>{<expr><call><name><name>Preds</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>, <macro><name>Preds</name></macro><expr><operator>.</operator><macro><name>end</name><argument_list>()</argument_list></macro></expr>}</block></expr>;</return> }</block>

<name>succ_iterator</name> <macro><name>succ_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>succ_iterator</name> <macro><name>succ_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Succs</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>succ_range</name> <macro><name>succs</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><block>{<expr><call><name><name>Succs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>, <macro><name>Succs</name></macro><expr><operator>.</operator><macro><name>end</name><argument_list>()</argument_list></macro></expr>}</block></expr>;</return> }</block>

<name>const_succ_iterator</name> <macro><name>succ_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedNode</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>succ_begin</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>const_succ_iterator</name> <macro><name>succ_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedNode</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>succ_end</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<name>const_succ_range</name> <macro><name>succs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><block>{<expr><call><name><name>Succs</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>, <macro><name>Succs</name></macro><expr><operator>.</operator><macro><name>end</name><argument_list>()</argument_list></macro></expr>}</block></expr>;</return> }</block>

<name>int64_t</name> <macro><name>getID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Id</name></expr>;</return> }</block>






<name>bool</name> <macro><name>isTrivial</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getStmtForDiagnostics</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getNextStmtForDiagnostics</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getPreviousStmtForDiagnostics</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;





<expr><specifier>const</specifier> <name>Stmt</name> <operator>*</operator><macro><name>getCurrentOrPreviousStmtForDiagnostics</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>private</name><operator>:</operator>
<name>void</name> <macro><name>replaceSuccessor</name><argument_list>(<argument>ExplodedNode *node</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Succs</name><operator>.</operator><name>replaceNode</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>; }</block>
<name>void</name> <macro><name>replacePredecessor</name><argument_list>(<argument>ExplodedNode *node</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Preds</name><operator>.</operator><name>replaceNode</name></name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>; }</block></expr>
}</block></expr>;

<expr><name>using</name> <name>InterExplodedGraphMap</name> <operator>=</operator>
<name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ExplodedNode</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>ExplodedNode</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;

<expr><name>class</name> <name>ExplodedGraph</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>friend</name> <name>class</name> <name>CoreEngine</name></expr>;


<expr><name>using</name> <name>NodeVector</name> <operator>=</operator> <name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedNode</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;





<expr><name>NodeVector</name> <name>Roots</name></expr>;



<expr><name>NodeVector</name> <name>EndNodes</name></expr>;


<expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedNode</name></expr></argument>&gt;</argument_list></name> <name>Nodes</name></expr>;



<expr><name>BumpVectorContext</name> <name>BVC</name></expr>;


<expr><name>int64_t</name> <name>NumNodes</name> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>NodeVector</name> <name>ChangedNodes</name></expr>;


<expr><name>NodeVector</name> <name>FreeNodes</name></expr>;




<expr><name>unsigned</name> <name>ReclaimNodeInterval</name> <operator>=</operator> <literal type="number">0</literal></expr>;


<expr><name>unsigned</name> <name>ReclaimCounter</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>ExplodedGraph</name><argument_list>()</argument_list></call></expr>;
<expr><operator>~</operator><call><name>ExplodedGraph</name><argument_list>()</argument_list></call></expr>;





<expr><name>ExplodedNode</name> <operator>*</operator><macro><name>getNode</name><argument_list>(<argument>const ProgramPoint &amp;L</argument>, <argument>ProgramStateRef State</argument>,
<argument>bool IsSink = false</argument>,
<argument>bool* IsNew = nullptr</argument>)</argument_list></macro></expr>;





<expr><name>ExplodedNode</name> <operator>*</operator><macro><name>createUncachedNode</name><argument_list>(<argument>const ProgramPoint &amp;L</argument>,
<argument>ProgramStateRef State</argument>,
<argument>int64_t Id</argument>,
<argument>bool IsSink = false</argument>)</argument_list></macro></expr>;

<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedGraph</name></expr></argument>&gt;</argument_list></name> <macro><name>MakeEmptyGraph</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedGraph</name></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr>;</return>
}</block>


<name>ExplodedNode</name> <operator>*</operator><macro><name>addRoot</name><argument_list>(<argument>ExplodedNode *V</argument>)</argument_list></macro> <block>{
<expr><call><name><name>Roots</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>V</name></expr>;</return>
}</block>


<name>ExplodedNode</name> <operator>*</operator><macro><name>addEndOfPath</name><argument_list>(<argument>ExplodedNode *V</argument>)</argument_list></macro> <block>{
<expr><call><name><name>EndNodes</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>V</name></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>num_roots</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Roots</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>unsigned</name> <macro><name>num_eops</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>EndNodes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumNodes</name> <operator>==</operator> <literal type="number">0</literal></expr>;</return> }</block>
<name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>NumNodes</name></expr>;</return> }</block>

<name>void</name> <macro><name>reserve</name><argument_list>(<argument>unsigned NodeCount</argument>)</argument_list></macro> <block>{ <expr><call><name><name>Nodes</name><operator>.</operator><name>reserve</name></name><argument_list>(<argument><expr><name>NodeCount</name></expr></argument>)</argument_list></call></expr>; }</block>


<name>using</name> <name>NodeTy</name> <operator>=</operator> <name>ExplodedNode</name></expr>;
<expr><name>using</name> <name>AllNodesTy</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedNode</name></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>using</name> <name>roots_iterator</name> <operator>=</operator> <name>NodeVector</name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_roots_iterator</name> <operator>=</operator> <name>NodeVector</name><operator>::</operator><name>const_iterator</name></expr>;
<expr><name>using</name> <name>eop_iterator</name> <operator>=</operator> <name>NodeVector</name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_eop_iterator</name> <operator>=</operator> <name>NodeVector</name><operator>::</operator><name>const_iterator</name></expr>;
<expr><name>using</name> <name>node_iterator</name> <operator>=</operator> <name>AllNodesTy</name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_node_iterator</name> <operator>=</operator> <name>AllNodesTy</name><operator>::</operator><name>const_iterator</name></expr>;

<expr><name>node_iterator</name> <macro><name>nodes_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Nodes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>node_iterator</name> <macro><name>nodes_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Nodes</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>const_node_iterator</name> <macro><name>nodes_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Nodes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>const_node_iterator</name> <macro><name>nodes_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Nodes</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>roots_iterator</name> <macro><name>roots_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Roots</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>roots_iterator</name> <macro><name>roots_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Roots</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>const_roots_iterator</name> <macro><name>roots_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Roots</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>const_roots_iterator</name> <macro><name>roots_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Roots</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>eop_iterator</name> <macro><name>eop_begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>EndNodes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>eop_iterator</name> <macro><name>eop_end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>EndNodes</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>const_eop_iterator</name> <macro><name>eop_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>EndNodes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>const_eop_iterator</name> <macro><name>eop_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>EndNodes</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <operator>&amp;</operator> <macro><name>getAllocator</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>BVC</name><operator>.</operator><name>getAllocator</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>BumpVectorContext</name> <operator>&amp;</operator><macro><name>getNodeAllocator</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>BVC</name></expr>;</return> }</block>

<name>using</name> <name>NodeMap</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ExplodedNode</name> <operator>*</operator></expr></argument>, <argument><expr><name>ExplodedNode</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr>;











<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedGraph</name></expr></argument>&gt;</argument_list></name>
<macro><name>trim</name><argument_list>(<argument>ArrayRef&lt;const NodeTy *&gt; Nodes</argument>,
<argument>InterExplodedGraphMap *ForwardMap = nullptr</argument>,
<argument>InterExplodedGraphMap *InverseMap = nullptr</argument>)</argument_list></macro> <specifier>const</specifier></expr>;



<expr><name>void</name> <macro><name>enableNodeReclamation</name><argument_list>(<argument>unsigned Interval</argument>)</argument_list></macro> <block>{
<expr><name>ReclaimCounter</name> <operator>=</operator> <name>ReclaimNodeInterval</name> <operator>=</operator> <name>Interval</name></expr>;
}</block>



<name>void</name> <call><name>reclaimRecentlyAllocatedNodes</name><argument_list>()</argument_list></call></expr>;



<expr><specifier>static</specifier> <name>bool</name> <call><name>isInterestingLValueExpr</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>Ex</name></expr></argument>)</argument_list></call></expr>;

<expr><name>private</name><operator>:</operator>
<name>bool</name> <call><name>shouldCollect</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ExplodedNode</name> <operator>*</operator><name>node</name></expr></argument>)</argument_list></call></expr>;
<expr><name>void</name> <call><name>collectNode</name><argument_list>(<argument><expr><name>ExplodedNode</name> <operator>*</operator><name>node</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;

<expr><name>class</name> <name>ExplodedNodeSet</name> <block>{
<expr><name>using</name> <name>ImplTy</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>SmallSetVector</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedNode</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr>;
<expr><name>ImplTy</name> <name>Impl</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ExplodedNodeSet</name><argument_list>(<argument>ExplodedNode *N</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>N</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedNode</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>isSink</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>Impl</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block>

<call><name>ExplodedNodeSet</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;

<expr><name>void</name> <macro><name>Add</name><argument_list>(<argument>ExplodedNode *N</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>N</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ExplodedNode</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>isSink</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><call><name><name>Impl</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>using</name> <name>iterator</name> <operator>=</operator> <name>ImplTy</name><operator>::</operator><name>iterator</name></expr>;
<expr><name>using</name> <name>const_iterator</name> <operator>=</operator> <name>ImplTy</name><operator>::</operator><name>const_iterator</name></expr>;

<expr><name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>empty</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>bool</name> <macro><name>erase</name><argument_list>(<argument>ExplodedNode *N</argument>)</argument_list></macro> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>remove</name></name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>void</name> <macro><name>clear</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name><name>Impl</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>; }</block>

<name>void</name> <macro><name>insert</name><argument_list>(<argument>const ExplodedNodeSet &amp;S</argument>)</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>&amp;</operator><name>S</name> <operator>!=</operator> <name>this</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name>empty</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Impl</name> <operator>=</operator> <name><name>S</name><operator>.</operator><name>Impl</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Impl</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>S</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
}</block>

<name>iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>

<name>const_iterator</name> <macro><name>begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
<name>const_iterator</name> <macro><name>end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Impl</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>;</return> }</block>
}</expr>;

}</block></expr>

}</block>



<name>namespace</name> <name>llvm</name> <block>{
<expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name> struct <name><name>GraphTraits</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>ento</name><operator>::</operator><name>ExplodedGraph</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>GraphTy</name> <operator>=</operator> <name>clang</name><operator>::</operator><name>ento</name><operator>::</operator><name>ExplodedGraph</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>NodeRef</name> <operator>=</operator> <name>clang</name><operator>::</operator><name>ento</name><operator>::</operator><name>ExplodedNode</name> <operator>*</operator></expr>;
<expr><name>using</name> <name>ChildIteratorType</name> <operator>=</operator> <name>clang</name><operator>::</operator><name>ento</name><operator>::</operator><name>ExplodedNode</name><operator>::</operator><name>succ_iterator</name></expr>;
<expr><name>using</name> <name>nodes_iterator</name> <operator>=</operator> <name>llvm</name><operator>::</operator><name><name>df_iterator</name><argument_list type="generic">&lt;<argument><expr><name>GraphTy</name></expr></argument>&gt;</argument_list></name></expr>;

<expr><specifier>static</specifier> <name>NodeRef</name> <macro><name>getEntryNode</name><argument_list>(<argument>const GraphTy G</argument>)</argument_list></macro> <block>{
<return>return <expr><operator>*</operator><call><name><name>G</name><operator>-&gt;</operator><name>roots_begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>predecessorOfTrivial</name><argument_list>(<argument>NodeRef N</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>N</name><operator>-&gt;</operator><name>succ_size</name></name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name><name>N</name><operator>-&gt;</operator><name>getFirstSucc</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isTrivial</name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ChildIteratorType</name> <macro><name>child_begin</name><argument_list>(<argument>NodeRef N</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>predecessorOfTrivial</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>child_begin</name><argument_list>(<argument><expr><operator>*</operator><call><name><name>N</name><operator>-&gt;</operator><name>succ_begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>N</name><operator>-&gt;</operator><name>succ_begin</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>ChildIteratorType</name> <macro><name>child_end</name><argument_list>(<argument>NodeRef N</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><call><name>predecessorOfTrivial</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>child_end</name><argument_list>(<argument><expr><call><name><name>N</name><operator>-&gt;</operator><name>getFirstSucc</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr>
<return>return <expr><call><name><name>N</name><operator>-&gt;</operator><name>succ_end</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></range></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>nodes_iterator</name></type> <name>nodes_begin</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GraphTy</name></type> <name>G</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>df_begin</name><argument_list>(<argument><expr><name>G</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>nodes_iterator</name></type> <name>nodes_end</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GraphTy</name></type> <name>G</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>df_end</name><argument_list>(<argument><expr><name>G</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
