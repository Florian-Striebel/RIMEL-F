<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Serialization/ASTReader.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_SERIALIZATION_ASTREADER_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_SERIALIZATION_ASTREADER_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Diagnostic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/DiagnosticOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/IdentifierTable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/ExternalPreprocessorSource.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/HeaderSearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/PreprocessingRecord.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Lex/PreprocessorOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/ExternalSemaSource.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/IdentifierResolver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/Sema.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Serialization/ASTBitCodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Serialization/ContinuousRangeMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Serialization/ModuleFile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Serialization/ModuleFileExtension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Serialization/ModuleManager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/DenseSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/IntrusiveRefCntPtr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/MapVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/STLExtras.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SetVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallPtrSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringMap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/iterator_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Bitstream/BitstreamReader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/MemoryBuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/Timer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/VersionTuple.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cassert&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstddef&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;cstdint&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctime&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;deque&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;set&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utility&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTConsumer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTDeserializationListener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTRecordReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXTemporary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclarationName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclaratorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>EnumDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FieldDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FileEntry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FileManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FileSystemOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>GlobalModuleIndex</name></decl>;</decl_stmt>
<struct_decl>struct <name>HeaderFileInfo</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>HeaderSearchOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LangOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LazyASTUnresolvedSet</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MacroInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>InMemoryModuleCache</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NamedDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NamespaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCCategoryDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCInterfaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PCHContainerReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Preprocessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PreprocessorOptions</name></decl>;</decl_stmt>
<struct_decl>struct <name>QualifierInfo</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>Sema</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SourceManager</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SwitchCase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TargetOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Token</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypedefNameDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ValueDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarDecl</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>class</name></type> <name>ASTReaderListener</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><call><name>ASTReaderListener</name><argument_list>()</argument_list></call></expr>;</expr_stmt>





<function><type><name>virtual</name> <name>bool</name></type> <name>ReadFullVersionInformation</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>FullVersion</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>FullVersion</name> <operator>!=</operator> <call><name>getClangFullRepositoryVersion</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>virtual</name> <name>void</name></type> <name>ReadModuleName</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>ModuleName</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
<function><type><name>virtual</name> <name>void</name></type> <name>ReadModuleMapFile</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>ModuleMapPath</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>




<function><type><name>virtual</name> <name>bool</name></type> <name>ReadLanguageOptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LangOptions</name> <modifier>&amp;</modifier></type><name>LangOpts</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Complain</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowCompatibleDifferences</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>virtual</name> <name>bool</name></type> <name>ReadTargetOptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetOptions</name> <modifier>&amp;</modifier></type><name>TargetOpts</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Complain</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowCompatibleDifferences</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>virtual</name> <name>bool</name></type>
<name>ReadDiagnosticOptions</name><parameter_list>(<parameter><decl><type><name><name>IntrusiveRefCntPtr</name><argument_list type="generic">&lt;<argument><expr><name>DiagnosticOptions</name></expr></argument>&gt;</argument_list></name></type> <name>DiagOpts</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Complain</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>virtual</name> <name>bool</name></type> <name>ReadFileSystemOptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileSystemOptions</name> <modifier>&amp;</modifier></type><name>FSOpts</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Complain</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>





<function><type><name>virtual</name> <name>bool</name></type> <name>ReadHeaderSearchOptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HeaderSearchOptions</name> <modifier>&amp;</modifier></type><name>HSOpts</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>SpecificModuleCachePath</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Complain</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>









<decl_stmt><decl><type><name>virtual</name> <name>bool</name></type> <name>ReadPreprocessorOptions</name><argument_list>(<argument><expr><specifier>const</specifier> <name>PreprocessorOptions</name> <operator>&amp;</operator><name>PPOpts</name></expr></argument>,
<argument><expr><name>bool</name> <name>Complain</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>SuggestedPredefines</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>ReadCounter</name><argument_list>(<argument><expr><specifier>const</specifier> <name>serialization</name><operator>::</operator><name>ModuleFile</name> <operator>&amp;</operator><name>M</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>Value</name></expr></argument>)</argument_list> <block>{<block_content/>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>virtual</name> <name>void</name></type> <name>visitModuleFile</name><argument_list>(<argument><expr><name>StringRef</name> <name>Filename</name></expr></argument>,
<argument><expr><name>serialization</name><operator>::</operator><name>ModuleKind</name> <name>Kind</name></expr></argument>)</argument_list> <block>{<block_content/>}</block></decl></decl_stmt>



<function><type><name>virtual</name> <name>bool</name></type> <name>needsInputFileVisitation</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></function>



<function><type><name>virtual</name> <name>bool</name></type> <name>needsSystemInputFileVisitation</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>false</name></expr>;</return> </block_content>}</block></function>







<function><type><name>virtual</name> <name>bool</name></type> <name>visitInputFile</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isSystem</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isOverridden</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isExplicitModule</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<expr_stmt><expr><name>virtual</name> <name>bool</name> <macro><name>needsImportVisitation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></expr_stmt>



<function><type><name>virtual</name> <name>void</name></type> <name>visitImport</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>ModuleName</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Filename</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>


<function><type><name>virtual</name> <name>void</name></type> <name>readModuleFileExtension</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>ModuleFileExtensionMetadata</name> <modifier>&amp;</modifier></type><name>Metadata</name></decl></parameter>)</parameter_list> <block>{<block_content/>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ChainedASTReaderListener</name> <range>: <expr><name>public</name> <name>ASTReaderListener</name> <block>{
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReaderListener</name></expr></argument>&gt;</argument_list></name> <name>First</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReaderListener</name></expr></argument>&gt;</argument_list></name> <name>Second</name></expr>;

<expr><name>public</name><operator>:</operator>

<call><name>ChainedASTReaderListener</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReaderListener</name></expr></argument>&gt;</argument_list></name> <name>First</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReaderListener</name></expr></argument>&gt;</argument_list></name> <name>Second</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>First</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>First</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>, <macro><name>Second</name><argument_list>(<argument>std::move(Second)</argument>)</argument_list></macro> <expr><block>{}</block>

<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReaderListener</name></expr></argument>&gt;</argument_list></name> <macro><name>takeFirst</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>First</name></expr></argument>)</argument_list></call></expr>;</return> }</block>
<name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReaderListener</name></expr></argument>&gt;</argument_list></name> <macro><name>takeSecond</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Second</name></expr></argument>)</argument_list></call></expr>;</return> }</block>

<name>bool</name> <macro><name>ReadFullVersionInformation</name><argument_list>(<argument>StringRef FullVersion</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>ReadModuleName</name><argument_list>(<argument>StringRef ModuleName</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>ReadModuleMapFile</name><argument_list>(<argument>StringRef ModuleMapPath</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>ReadLanguageOptions</name><argument_list>(<argument>const LangOptions &amp;LangOpts</argument>, <argument>bool Complain</argument>,
<argument>bool AllowCompatibleDifferences</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>ReadTargetOptions</name><argument_list>(<argument>const TargetOptions &amp;TargetOpts</argument>, <argument>bool Complain</argument>,
<argument>bool AllowCompatibleDifferences</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>ReadDiagnosticOptions</name><argument_list>(<argument>IntrusiveRefCntPtr&lt;DiagnosticOptions&gt; DiagOpts</argument>,
<argument>bool Complain</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>ReadFileSystemOptions</name><argument_list>(<argument>const FileSystemOptions &amp;FSOpts</argument>,
<argument>bool Complain</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>bool</name> <macro><name>ReadHeaderSearchOptions</name><argument_list>(<argument>const HeaderSearchOptions &amp;HSOpts</argument>,
<argument>StringRef SpecificModuleCachePath</argument>,
<argument>bool Complain</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>ReadPreprocessorOptions</name><argument_list>(<argument>const PreprocessorOptions &amp;PPOpts</argument>,
<argument>bool Complain</argument>,
<argument>std::string &amp;SuggestedPredefines</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>void</name> <macro><name>ReadCounter</name><argument_list>(<argument>const serialization::ModuleFile &amp;M</argument>, <argument>unsigned Value</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>needsInputFileVisitation</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>needsSystemInputFileVisitation</name><argument_list>()</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>visitModuleFile</name><argument_list>(<argument>StringRef Filename</argument>,
<argument>serialization::ModuleKind Kind</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>visitInputFile</name><argument_list>(<argument>StringRef Filename</argument>, <argument>bool isSystem</argument>,
<argument>bool isOverridden</argument>, <argument>bool isExplicitModule</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>readModuleFileExtension</name><argument_list>(
<argument>const ModuleFileExtensionMetadata &amp;Metadata</argument>)</argument_list></macro> <name>override</name></expr>;
}</block></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>PCHValidator</name> <range>: <expr><name>public</name> <name>ASTReaderListener</name> <block>{
<expr><name>Preprocessor</name> <operator>&amp;</operator><name>PP</name></expr>;
<expr><name>ASTReader</name> <operator>&amp;</operator><name>Reader</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>PCHValidator</name><argument_list>(<argument><expr><name>Preprocessor</name> <operator>&amp;</operator><name>PP</name></expr></argument>, <argument><expr><name>ASTReader</name> <operator>&amp;</operator><name>Reader</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>PP</name><argument_list>(<argument><expr><name>PP</name></expr></argument>)</argument_list></call></expr>, <macro><name>Reader</name><argument_list>(<argument>Reader</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>ReadLanguageOptions</name><argument_list>(<argument>const LangOptions &amp;LangOpts</argument>, <argument>bool Complain</argument>,
<argument>bool AllowCompatibleDifferences</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>ReadTargetOptions</name><argument_list>(<argument>const TargetOptions &amp;TargetOpts</argument>, <argument>bool Complain</argument>,
<argument>bool AllowCompatibleDifferences</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>ReadDiagnosticOptions</name><argument_list>(<argument>IntrusiveRefCntPtr&lt;DiagnosticOptions&gt; DiagOpts</argument>,
<argument>bool Complain</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>ReadPreprocessorOptions</name><argument_list>(<argument>const PreprocessorOptions &amp;PPOpts</argument>, <argument>bool Complain</argument>,
<argument>std::string &amp;SuggestedPredefines</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>bool</name> <macro><name>ReadHeaderSearchOptions</name><argument_list>(<argument>const HeaderSearchOptions &amp;HSOpts</argument>,
<argument>StringRef SpecificModuleCachePath</argument>,
<argument>bool Complain</argument>)</argument_list></macro> <name>override</name></expr>;
<expr><name>void</name> <macro><name>ReadCounter</name><argument_list>(<argument>const serialization::ModuleFile &amp;M</argument>, <argument>unsigned Value</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>private</name><operator>:</operator>
<name>void</name> <call><name>Error</name><argument_list>(<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>Msg</name></expr></argument>)</argument_list></call></expr>;
}</block></expr></range></decl>;</decl_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>SimpleASTReaderListener</name> <range>: <expr><name>public</name> <name>ASTReaderListener</name> <block>{
<expr><name>Preprocessor</name> <operator>&amp;</operator><name>PP</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>SimpleASTReaderListener</name><argument_list>(<argument><expr><name>Preprocessor</name> <operator>&amp;</operator><name>PP</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>PP</name><argument_list>(<argument>PP</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <macro><name>ReadPreprocessorOptions</name><argument_list>(<argument>const PreprocessorOptions &amp;PPOpts</argument>, <argument>bool Complain</argument>,
<argument>std::string &amp;SuggestedPredefines</argument>)</argument_list></macro> <name>override</name></expr>;
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>serialization</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ReadMethodPoolVisitor</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>reader</name> <block>{<block_content>

<decl_stmt><decl><type><name>class</name></type> <name>ASTIdentifierLookupTrait</name></decl>;</decl_stmt>


<struct_decl>struct <name>DeclContextLookupTable</name>;</struct_decl>

</block_content>}</block></decl></decl_stmt>

</block_content>}</block></decl></decl_stmt>













<decl_stmt><decl><type><name>class</name></type> <name>ASTReader</name>
<range>: <expr><name>public</name> <name>ExternalPreprocessorSource</name></expr></range></decl>,
<decl><type ref="prev"/><name>public</name> <name>ExternalPreprocessingRecordSource</name></decl>,
<decl><type ref="prev"/><name>public</name> <name>ExternalHeaderFileInfoSource</name></decl>,
<decl><type ref="prev"/><name>public</name> <name>ExternalSemaSource</name></decl>,
<decl><type ref="prev"/><name>public</name> <name>IdentifierInfoLookup</name></decl>,
<decl><type ref="prev"/><name>public</name> <name>ExternalSLocEntrySource</name>
<block>{<block_content>
<label><name>public</name>:</label>

<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTIdentifierIterator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTRecordReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTUnit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>PCHValidator</name></decl>;</decl_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>serialization</name><operator>::</operator><name>reader</name><operator>::</operator><name>ASTIdentifierLookupTrait</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>serialization</name><operator>::</operator><name>ReadMethodPoolVisitor</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>TypeLocReader</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>RecordData</name> <init>= <expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>RecordDataImpl</name> <init>= <expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<enum>enum <name>ASTReadResult</name> <block>{


<decl><name>Success</name></decl>,


<decl><name>Failure</name></decl>,


<decl><name>Missing</name></decl>,



<decl><name>OutOfDate</name></decl>,


<decl><name>VersionMismatch</name></decl>,



<decl><name>ConfigurationMismatch</name></decl>,


<decl><name>HadErrors</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><name>using</name></type> <name>ModuleFile</name> <init>= <expr><name>serialization</name><operator>::</operator><name>ModuleFile</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>ModuleKind</name> <init>= <expr><name>serialization</name><operator>::</operator><name>ModuleKind</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>ModuleManager</name> <init>= <expr><name>serialization</name><operator>::</operator><name>ModuleManager</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>ModuleIterator</name> <init>= <expr><name>ModuleManager</name><operator>::</operator><name>ModuleIterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>ModuleConstIterator</name> <init>= <expr><name>ModuleManager</name><operator>::</operator><name>ModuleConstIterator</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>ModuleReverseIterator</name> <init>= <expr><name>ModuleManager</name><operator>::</operator><name>ModuleReverseIterator</name></expr></init></decl>;</decl_stmt>

<label><name>private</name>:</label>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReaderListener</name></expr></argument>&gt;</argument_list></name> <name>Listener</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>ASTDeserializationListener</name> <modifier>*</modifier></type><name>DeserializationListener</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>OwnsDeserializationListener</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceManager</name> <modifier>&amp;</modifier></type><name>SourceMgr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FileManager</name> <modifier>&amp;</modifier></type><name>FileMgr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PCHContainerReader</name> <modifier>&amp;</modifier></type><name>PCHContainerRdr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiagnosticsEngine</name> <modifier>&amp;</modifier></type><name>Diags</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>Sema</name> <modifier>*</modifier></type><name>SemaObj</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ASTContext</name> <modifier>*</modifier></type><name>ContextObj</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ASTConsumer</name> <modifier>*</modifier></type><name>Consumer</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ModuleManager</name></type> <name>ModuleMgr</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>IdentifierResolver</name></type> <name>DummyIdResolver</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>StringMap</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>shared_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ModuleFileExtension</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>ModuleFileExtensions</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>Timer</name></expr></argument>&gt;</argument_list></name> <name>ReadTimer</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>CurrentImportLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>ModuleKind</name></expr></argument>&gt;</argument_list></name></type> <name>CurrentDeserializingModuleKind</name></decl>;</decl_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>GlobalModuleIndex</name></expr></argument>&gt;</argument_list></name> <name>GlobalIndex</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name><name>ContinuousRangeMap</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><name>ModuleFile</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>GlobalBitOffsetsMap</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>ContinuousRangeMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>ModuleFile</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>&gt;</argument_list></name></type> <name>GlobalSLocEntryMap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>GlobalSLocOffsetMapType</name> <init>=
<expr><name><name>ContinuousRangeMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>ModuleFile</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>GlobalSLocOffsetMapType</name></type> <name>GlobalSLocOffsetMap</name></decl>;</decl_stmt>





<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <name>TypesLoaded</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>GlobalTypeMapType</name> <init>=
<expr><name><name>ContinuousRangeMap</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>TypeID</name></expr></argument>, <argument><expr><name>ModuleFile</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>GlobalTypeMapType</name></type> <name>GlobalTypeMap</name></decl>;</decl_stmt>





<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>DeclsLoaded</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>GlobalDeclMapType</name> <init>=
<expr><name><name>ContinuousRangeMap</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><name>ModuleFile</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>GlobalDeclMapType</name></type> <name>GlobalDeclMap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>FileOffset</name> <init>= <expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ModuleFile</name> <operator>*</operator></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>FileOffsetsTy</name> <init>= <expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>FileOffset</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>DeclUpdateOffsetsMap</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><name>FileOffsetsTy</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>DeclUpdateOffsetsMap</name></type> <name>DeclUpdateOffsets</name></decl>;</decl_stmt>

<struct>struct <name>PendingUpdateRecord</name> <block>{
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl>;</decl_stmt>
<expr_stmt><expr><name>serialization</name><operator>::</operator><name>GlobalDeclID</name> <name>ID</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>JustLoaded</name></decl>;</decl_stmt>

<macro><name>PendingUpdateRecord</name><argument_list>(<argument>serialization::GlobalDeclID ID</argument>, <argument>Decl *D</argument>,
<argument>bool JustLoaded</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ID</name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>JustLoaded</name><argument_list>(<argument>JustLoaded</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>PendingUpdateRecord</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>PendingUpdateRecords</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>PendingFakeDefinitionKind</name> <block>{<block_content> <expr_stmt><expr><name>NotFake</name></expr><operator>,</operator> <expr><name>Fake</name></expr><operator>,</operator> <expr><name>FakeLoaded</name></expr></expr_stmt> </block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>PendingFakeDefinitionKind</name></expr></argument>&gt;</argument_list></name> <name>PendingFakeDefinitionData</name></expr>;</expr_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallMapVector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>PendingExceptionSpecUpdates</name></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallMapVector</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>QualType</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>PendingDeducedTypeUpdates</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>, <argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>ImportedTypedefNamesForLinkage</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>AnonymousDeclarationsForMerging</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>using</name></type> <name>LETemporaryKey</name> <init>= <expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>LETemporaryKey</name></expr></argument>, <argument><expr><name>LifetimeExtendedTemporaryDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>LETemporaryForMerging</name></expr>;</expr_stmt>

<struct>struct <name>FileDeclsInfo</name> <block>{
<decl_stmt><decl><type><name>ModuleFile</name> <modifier>*</modifier></type><name>Mod</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>LocalDeclID</name></expr></argument>&gt;</argument_list></name></type> <name>Decls</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FileDeclsInfo</name><argument_list>()</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<expr_stmt><expr><call><name>FileDeclsInfo</name><argument_list>(<argument><expr><name>ModuleFile</name> <operator>*</operator><name>Mod</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>LocalDeclID</name></expr></argument>&gt;</argument_list></name> <name>Decls</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Mod</name><argument_list>(<argument><expr><name>Mod</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Decls</name><argument_list>(<argument>Decls</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>FileID</name></expr></argument>, <argument><expr><name>FileDeclsInfo</name></expr></argument>&gt;</argument_list></name> <name>FileDeclIDs</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>using</name></type> <name>LexicalContents</name> <init>= <expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>support</name><operator>::</operator><name>unaligned_uint32_t</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>DeclContext</name><operator>*</operator></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ModuleFile</name><operator>*</operator></expr></argument>, <argument><expr><name>LexicalContents</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>LexicalDecls</name></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ModuleFile</name><operator>*</operator></expr></argument>, <argument><expr><name>LexicalContents</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>TULexicalDecls</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator></expr></argument>,
<argument><expr><name>serialization</name><operator>::</operator><name>reader</name><operator>::</operator><name>DeclContextLookupTable</name></expr></argument>&gt;</argument_list></name> <name>Lookups</name></expr>;</expr_stmt>





<struct>struct <name>PendingVisibleUpdate</name> <block>{
<decl_stmt><decl><type><name>ModuleFile</name> <modifier>*</modifier></type><name>Mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>Data</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name>using</name></type> <name>DeclContextVisibleUpdates</name> <init>= <expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>PendingVisibleUpdate</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><name>DeclContextVisibleUpdates</name></expr></argument>&gt;</argument_list></name>
<name>PendingVisibleUpdates</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>PendingDefinitions</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>PendingBodiesMap</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallDenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>PendingBodiesMap</name></type> <name>PendingBodies</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SetVector</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>PendingMergedDefinitionsToDeduplicate</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ReadLexicalDeclContextStorage</name><argument_list>(<argument><expr><name>ModuleFile</name> <operator>&amp;</operator><name>M</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BitstreamCursor</name> <operator>&amp;</operator><name>Cursor</name></expr></argument>,
<argument><expr><name>uint64_t</name> <name>Offset</name></expr></argument>, <argument><expr><name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ReadVisibleDeclContextStorage</name><argument_list>(<argument><expr><name>ModuleFile</name> <operator>&amp;</operator><name>M</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>BitstreamCursor</name> <operator>&amp;</operator><name>Cursor</name></expr></argument>,
<argument><expr><name>uint64_t</name> <name>Offset</name></expr></argument>, <argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name> <name>ID</name></expr></argument>)</argument_list></decl>;</decl_stmt>







<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>IdentifiersLoaded</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>GlobalIdentifierMapType</name> <init>=
<expr><name><name>ContinuousRangeMap</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>IdentID</name></expr></argument>, <argument><expr><name>ModuleFile</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>GlobalIdentifierMapType</name></type> <name>GlobalIdentifierMap</name></decl>;</decl_stmt>







<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>MacroInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>MacrosLoaded</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>LoadedMacroInfo</name> <init>=
<expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>serialization</name><operator>::</operator><name>SubmoduleID</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><name>LoadedMacroInfo</name></expr></argument>&gt;</argument_list></name> <name>LoadedUndefs</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>GlobalMacroMapType</name> <init>=
<expr><name><name>ContinuousRangeMap</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>MacroID</name></expr></argument>, <argument><expr><name>ModuleFile</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>GlobalMacroMapType</name></type> <name>GlobalMacroMap</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Module</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>SubmodulesLoaded</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>GlobalSubmoduleMapType</name> <init>=
<expr><name><name>ContinuousRangeMap</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>SubmoduleID</name></expr></argument>, <argument><expr><name>ModuleFile</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>GlobalSubmoduleMapType</name></type> <name>GlobalSubmoduleMap</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>using</name></type> <name>HiddenNames</name> <init>= <expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>using</name></type> <name>HiddenNamesMapType</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Module</name> <operator>*</operator></expr></argument>, <argument><expr><name>HiddenNames</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>HiddenNamesMapType</name></type> <name>HiddenNamesMap</name></decl>;</decl_stmt>


<struct>struct <name>UnresolvedModuleRef</name> <block>{

<decl_stmt><decl><type><name>ModuleFile</name> <modifier>*</modifier></type><name>File</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>Mod</name></decl>;</decl_stmt>


<enum>enum <block>{ <decl><name>Import</name></decl>, <decl><name>Export</name></decl>, <decl><name>Conflict</name></decl> }</block> <decl><name>Kind</name></decl>;</enum>


<decl_stmt><decl><type><name>unsigned</name></type> <name>ID</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsWildcard</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>StringRef</name></type> <name>String</name></decl>;</decl_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>UnresolvedModuleRef</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>UnresolvedModuleRefs</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Selector</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>SelectorsLoaded</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>GlobalSelectorMapType</name> <init>=
<expr><name><name>ContinuousRangeMap</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>SelectorID</name></expr></argument>, <argument><expr><name>ModuleFile</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>GlobalSelectorMapType</name></type> <name>GlobalSelectorMap</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Selector</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>SelectorGeneration</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Selector</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>SelectorOutOfDate</name></expr>;</expr_stmt>

<struct>struct <name>PendingMacroInfo</name> <block>{
<decl_stmt><decl><type><name>ModuleFile</name> <modifier>*</modifier></type><name>M</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint32_t</name></type> <name>MacroDirectivesOffset</name></decl>;</decl_stmt>

<macro><name>PendingMacroInfo</name><argument_list>(<argument>ModuleFile *M</argument>, <argument>uint32_t MacroDirectivesOffset</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>M</name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>MacroDirectivesOffset</name><argument_list>(<argument>MacroDirectivesOffset</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>using</name></type> <name>PendingMacroIDsMap</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>PendingMacroInfo</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>PendingMacroIDsMap</name></type> <name>PendingMacroIDs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>GlobalPreprocessedEntityMapType</name> <init>=
<expr><name><name>ContinuousRangeMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>ModuleFile</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name>GlobalPreprocessedEntityMapType</name></type> <name>GlobalPreprocessedEntityMap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>GlobalSkippedRangeMapType</name> <init>=
<expr><name><name>ContinuousRangeMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>ModuleFile</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>GlobalSkippedRangeMapType</name></type> <name>GlobalSkippedRangeMap</name></decl>;</decl_stmt>











<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>EagerlyDeserializedDecls</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>TentativeDefinitions</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>&gt;</argument_list></name></type> <name>VTableUses</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>&gt;</argument_list></name></type> <name>PendingInstantiations</name></decl>;</decl_stmt>









<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>UnusedFileScopedDecls</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>DelegatingCtorDecls</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>SelectorID</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>&gt;</argument_list></name></type> <name>ReferencedSelectorsData</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>IdentifierID</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>&gt;</argument_list></name></type> <name>WeakUndeclaredIdentifiers</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>ExtVectorDecls</name></decl>;</decl_stmt>










<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>UnusedLocalTypedefNameCandidates</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>ForceCUDAHostDeviceDepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>SemaDeclRefs</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>TypeID</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>SpecialTypes</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>CUDASpecialDeclRefs</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></type> <name>FPPragmaOptions</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>OptimizeOffPragmaLocation</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>PragmaMSStructState</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type> <name>PragmaMSPointersToMembersState</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>PointersToMembersPragmaLocation</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>FPOptionsOverride</name></expr></argument>&gt;</argument_list></name></type> <name>FpPragmaCurrentValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>FpPragmaCurrentLocation</name></decl>;</decl_stmt>
<struct>struct <name>FpPragmaStackEntry</name> <block>{
<decl_stmt><decl><type><name>FPOptionsOverride</name></type> <name>Value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Location</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>PushLocation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StringRef</name></type> <name>SlotLabel</name></decl>;</decl_stmt>
}</block>;</struct>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>FpPragmaStackEntry</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>FpPragmaStack</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>FpPragmaStrings</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>Sema</name><operator>::</operator><name>AlignPackInfo</name></expr></argument>&gt;</argument_list></name></type> <name>PragmaAlignPackCurrentValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>PragmaAlignPackCurrentLocation</name></decl>;</decl_stmt>
<struct>struct <name>PragmaAlignPackStackEntry</name> <block>{
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>AlignPackInfo</name> <name>Value</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Location</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>PushLocation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StringRef</name></type> <name>SlotLabel</name></decl>;</decl_stmt>
}</block>;</struct>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>PragmaAlignPackStackEntry</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>PragmaAlignPackStack</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>PragmaAlignPackStrings</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>OpenCLOptions</name></type> <name>OpenCLExtensions</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>OpenCLTypeExtMap</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>set</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>OpenCLDeclExtMap</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>KnownNamespaces</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>UndefinedButUsed</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>DelayedDeleteExprs</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ModuleFile</name> <modifier>*</modifier></expr></argument>, <argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type>
<name>LateParsedTemplates</name></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallSetVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>DeclsToCheckForDeferredDiags</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<struct>struct <name>ImportedSubmodule</name> <block>{
<expr_stmt><expr><name>serialization</name><operator>::</operator><name>SubmoduleID</name> <name>ID</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ImportLoc</name></decl>;</decl_stmt>

<macro><name>ImportedSubmodule</name><argument_list>(<argument>serialization::SubmoduleID ID</argument>, <argument>SourceLocation ImportLoc</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>ID</name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>ImportLoc</name><argument_list>(<argument>ImportLoc</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>

<label><name>private</name>:</label>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ImportedSubmodule</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>ImportedModules</name></decl>;</decl_stmt>




<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>isysroot</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>DisableValidationForModuleKind</name></type> <name>DisableValidationKind</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>AllowASTWithCompilerErrors</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>AllowConfigurationMismatch</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ValidateSystemInputs</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ValidateASTInputFilesContent</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>UseGlobalIndex</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>TriedLoadingGlobalIndex</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ProcessingUpdateRecords</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>SwitchCaseMapTy</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>SwitchCase</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><name>SwitchCaseMapTy</name></type> <name>SwitchCaseStmts</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SwitchCaseMapTy</name> <modifier>*</modifier></type><name>CurrSwitchCaseStmts</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumSLocEntriesRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>TotalNumSLocEntries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumStatementsRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>TotalNumStatements</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumMacrosRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>TotalNumMacros</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumIdentifierLookups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumIdentifierLookupHits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumSelectorsRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumMethodPoolEntriesRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumMethodPoolLookups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumMethodPoolHits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumMethodPoolTableLookups</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumMethodPoolTableHits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>TotalNumMethodPoolEntries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumLexicalDeclContextsRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>TotalLexicalDeclContexts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumVisibleDeclContextsRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>TotalVisibleDeclContexts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint64_t</name></type> <name>TotalModulesSizeInBits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumCurrentElementsDeserializing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>PassingDeclsToConsumer</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>






<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>PendingIdentifierInfos</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallMapVector</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name>
<name>PendingFakeLookupResults</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>IdentifierGeneration</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>InterestingDecl</name> <block>{<block_content>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>DeclHasPendingBody</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>InterestingDecl</name><argument_list>(<argument>Decl *D</argument>, <argument>bool HasBody</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>D</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>DeclHasPendingBody</name><argument_list>(<argument>HasBody</argument>)</argument_list></macro> <expr><block>{}</block>

<name>Decl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>D</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>bool</name></type> <name>hasPendingBody</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>DeclHasPendingBody</name></expr>;</return> </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>







<expr_stmt><expr><name>std</name><operator>::</operator><name><name>deque</name><argument_list type="generic">&lt;<argument><expr><name>InterestingDecl</name></expr></argument>&gt;</argument_list></name> <name>PotentiallyInterestingDecls</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>serialization</name><operator>::</operator><name>TypeID</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type>
<name>PendingFunctionTypes</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>PendingDeclChains</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>PendingIncompleteDeclChains</name></decl>;</decl_stmt>



<struct>struct <name>PendingDeclContextInfo</name> <block>{
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl>;</decl_stmt>
<expr_stmt><expr><name>serialization</name><operator>::</operator><name>GlobalDeclID</name> <name>SemaDC</name></expr>;</expr_stmt>
<expr_stmt><expr><name>serialization</name><operator>::</operator><name>GlobalDeclID</name> <name>LexicalDC</name></expr>;</expr_stmt>
}</block>;</struct>






<expr_stmt><expr><name>std</name><operator>::</operator><name><name>deque</name><argument_list type="generic">&lt;<argument><expr><name>PendingDeclContextInfo</name></expr></argument>&gt;</argument_list></name> <name>PendingDeclContextInfos</name></expr>;</expr_stmt>







<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>PendingOdrMergeChecks</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>DataPointers</name> <init>=
<expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name> <operator>*</operator></expr></argument>, <argument><expr>struct <name>CXXRecordDecl</name><operator>::</operator><name>DefinitionData</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallDenseMap</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>DataPointers</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name>
<name>PendingOdrMergeFailures</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallDenseMap</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name>
<name>PendingFunctionOdrMergeFailures</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallDenseMap</name><argument_list type="generic">&lt;<argument><expr><name>EnumDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>EnumDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name>
<name>PendingEnumOdrMergeFailures</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>DiagnosedOdrMergeFailures</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>ObjCCategoryDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>CategoriesDeserialized</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ObjCInterfaceDecl</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>ObjCClassesLoaded</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>KeyDeclsMap</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>






<decl_stmt><decl><type><name>KeyDeclsMap</name></type> <name>KeyDecls</name></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>, <argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>MergedDeclContexts</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>EnumDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>EnumDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>EnumDefinitions</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>StmtStack</name></decl>;</decl_stmt>


<enum>enum <name>ReadingKind</name> <block>{
<decl><name>Read_None</name></decl>, <decl><name>Read_Decl</name></decl>, <decl><name>Read_Type</name></decl>, <decl><name>Read_Stmt</name></decl>
}</block>;</enum>


<decl_stmt><decl><type><name>ReadingKind</name></type> <name>ReadingKind</name> <init>= <expr><name>Read_None</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ReadingKindTracker</name> <block>{<block_content>
<decl_stmt><decl><type><name>ASTReader</name> <modifier>&amp;</modifier></type><name>Reader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>ReadingKind</name></name></type> <name>PrevKind</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>ReadingKindTracker</name><argument_list>(<argument>enum ReadingKind newKind</argument>, <argument>ASTReader &amp;reader</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Reader</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>PrevKind</name><argument_list>(<argument>Reader.ReadingKind</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>Reader</name><operator>.</operator><name>ReadingKind</name></name> <operator>=</operator> <name>newKind</name></expr>;
}</block>

<call><name>ReadingKindTracker</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ReadingKindTracker</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ReadingKindTracker</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>ReadingKindTracker</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>~</operator><macro><name>ReadingKindTracker</name><argument_list>()</argument_list></macro> <block>{ <expr><name><name>Reader</name><operator>.</operator><name>ReadingKind</name></name> <operator>=</operator> <name>PrevKind</name></expr>; }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ProcessingUpdatesRAIIObj</name> <block>{<block_content>
<decl_stmt><decl><type><name>ASTReader</name> <modifier>&amp;</modifier></type><name>Reader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>PrevState</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>ProcessingUpdatesRAIIObj</name><argument_list>(<argument><expr><name>ASTReader</name> <operator>&amp;</operator><name>reader</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Reader</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>PrevState</name><argument_list>(<argument>Reader.ProcessingUpdateRecords</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>Reader</name><operator>.</operator><name>ProcessingUpdateRecords</name></name> <operator>=</operator> <name>true</name></expr>;
}</block>

<call><name>ProcessingUpdatesRAIIObj</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ProcessingUpdatesRAIIObj</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ProcessingUpdatesRAIIObj</name> <modifier>&amp;</modifier></type>
<name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>ProcessingUpdatesRAIIObj</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>~</operator><macro><name>ProcessingUpdatesRAIIObj</name><argument_list>()</argument_list></macro> <block>{ <expr><name><name>Reader</name><operator>.</operator><name>ProcessingUpdateRecords</name></name> <operator>=</operator> <name>PrevState</name></expr>; }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>









<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>SuggestedPredefines</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>DefinitionSource</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>shouldDisableValidationForFile</name><argument_list>(<argument><expr><specifier>const</specifier> <name>serialization</name><operator>::</operator><name>ModuleFile</name> <operator>&amp;</operator><name>M</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<function_decl><type><name>Stmt</name> <modifier>*</modifier></type><name>ReadStmtFromStream</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>InputFileInfo</name> <block>{
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>Filename</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>ContentHash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>off_t</name></type> <name>StoredSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>StoredTime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Overridden</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Transient</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>TopLevelModuleMap</name></decl>;</decl_stmt>
}</block>;</struct>


<function_decl><type><name>InputFileInfo</name></type> <name>readInputFileInfo</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>serialization</name><operator>::</operator><name>InputFile</name> <macro><name>getInputFile</name><argument_list>(<argument>ModuleFile &amp;F</argument>, <argument>unsigned ID</argument>,
<argument>bool Complain = true</argument>)</argument_list></macro></expr>;</expr_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>void</name></type> <name>ResolveImportedPath</name><argument_list>(<argument><expr><name>ModuleFile</name> <operator>&amp;</operator><name>M</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>Filename</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>ResolveImportedPath</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>Filename</name></expr></argument>, <argument><expr><name>StringRef</name> <name>Prefix</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function><type><name>Decl</name> <modifier>*</modifier></type><name>getKeyDeclaration</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>D</name> <operator>=</operator> <call><name><name>D</name><operator>-&gt;</operator><name>getCanonicalDecl</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>isFromASTFile</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>D</name></expr>;</return></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>auto</name></type> <name>I</name> <init>= <expr><call><name><name>KeyDecls</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>I</name> <operator>==</operator> <call><name><name>KeyDecls</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name><name>I</name><operator>-&gt;</operator><name>second</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>D</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>GetExistingDecl</name><argument_list>(<argument><expr><name><name>I</name><operator>-&gt;</operator><name>second</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>getKeyDeclaration</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getKeyDeclaration</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Fn</name></expr></argument>&gt;</argument_list></name>
<name>void</name></type> <name>forEachImportedKeyDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>Fn</name></type> <name>Visit</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>D</name> <operator>=</operator> <call><name><name>D</name><operator>-&gt;</operator><name>getCanonicalDecl</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>D</name><operator>-&gt;</operator><name>isFromASTFile</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<decl_stmt><decl><type><name>auto</name></type> <name>It</name> <init>= <expr><call><name><name>KeyDecls</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>It</name> <operator>!=</operator> <call><name><name>KeyDecls</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><decl><type><name>auto</name></type> <name>ID</name> <range>: <expr><name><name>It</name><operator>-&gt;</operator><name>second</name></name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Visit</name><argument_list>(<argument><expr><call><name>GetExistingDecl</name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
</block_content>}</block></function>


<expr_stmt><expr><specifier>const</specifier> <name>serialization</name><operator>::</operator><name>reader</name><operator>::</operator><name>DeclContextLookupTable</name> <operator>*</operator>
<macro><name>getLoadedLookupTables</name><argument_list>(<argument>DeclContext *Primary</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>private</name>:</label>
<struct>struct <name>ImportedModule</name> <block>{
<decl_stmt><decl><type><name>ModuleFile</name> <modifier>*</modifier></type><name>Mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ModuleFile</name> <modifier>*</modifier></type><name>ImportedBy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ImportLoc</name></decl>;</decl_stmt>

<macro><name>ImportedModule</name><argument_list>(<argument>ModuleFile *Mod</argument>,
<argument>ModuleFile *ImportedBy</argument>,
<argument>SourceLocation ImportLoc</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Mod</name><argument_list>(<argument><expr><name>Mod</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ImportedBy</name><argument_list>(<argument><expr><name>ImportedBy</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>ImportLoc</name><argument_list>(<argument>ImportLoc</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>

<function_decl><type><name>ASTReadResult</name></type> <name>ReadASTCore</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>FileName</name></decl></parameter>, <parameter><decl><type><name>ModuleKind</name></type> <name>Type</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ImportLoc</name></decl></parameter>, <parameter><decl><type><name>ModuleFile</name> <modifier>*</modifier></type><name>ImportedBy</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ImportedModule</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Loaded</name></decl></parameter>,
<parameter><decl><type><name>off_t</name></type> <name>ExpectedSize</name></decl></parameter>, <parameter><decl><type><name>time_t</name></type> <name>ExpectedModTime</name></decl></parameter>,
<parameter><decl><type><name>ASTFileSignature</name></type> <name>ExpectedSignature</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>ClientLoadCapabilities</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ASTReadResult</name></type> <name>ReadControlBlock</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ImportedModule</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Loaded</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ModuleFile</name> <modifier>*</modifier></type><name>ImportedBy</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>ClientLoadCapabilities</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>ASTReadResult</name></type> <name>ReadOptionsBlock</name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator><name>BitstreamCursor</name> <operator>&amp;</operator><name>Stream</name></expr></argument>, <argument><expr><name>unsigned</name> <name>ClientLoadCapabilities</name></expr></argument>,
<argument><expr><name>bool</name> <name>AllowCompatibleConfigurationMismatch</name></expr></argument>, <argument><expr><name>ASTReaderListener</name> <operator>&amp;</operator><name>Listener</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>SuggestedPredefines</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<function_decl><type><name>ASTReadResult</name></type> <name>readUnhashedControlBlock</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>WasImportedBy</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>ClientLoadCapabilities</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>ASTReadResult</name></type>
<name>readUnhashedControlBlockImpl</name><argument_list>(<argument><expr><name>ModuleFile</name> <operator>*</operator><name>F</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>StreamData</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>ClientLoadCapabilities</name></expr></argument>,
<argument><expr><name>bool</name> <name>AllowCompatibleConfigurationMismatch</name></expr></argument>,
<argument><expr><name>ASTReaderListener</name> <operator>*</operator><name>Listener</name></expr></argument>,
<argument><expr><name>bool</name> <name>ValidateDiagnosticOptions</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>ASTReadResult</name></type> <name>ReadASTBlock</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ClientLoadCapabilities</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ASTReadResult</name></type> <name>ReadExtensionBlock</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>ReadModuleOffsetMap</name><argument_list>(<argument><expr><name>ModuleFile</name> <operator>&amp;</operator><name>F</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<function_decl><type><name>bool</name></type> <name>ParseLineTable</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ReadSourceManagerBlock</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BitstreamCursor</name> <operator>&amp;</operator><macro><name>SLocCursorForID</name><argument_list>(<argument>int ID</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>SourceLocation</name></type> <name>getImportLocation</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>*</modifier></type><name>F</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ASTReadResult</name></type> <name>ReadModuleMapFileBlock</name><parameter_list>(<parameter><decl><type><name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ModuleFile</name> <modifier>*</modifier></type><name>ImportedBy</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>ClientLoadCapabilities</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ASTReadResult</name></type> <name>ReadSubmoduleBlock</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>ClientLoadCapabilities</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ParseLanguageOptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Complain</name></decl></parameter>,
<parameter><decl><type><name>ASTReaderListener</name> <modifier>&amp;</modifier></type><name>Listener</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowCompatibleDifferences</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ParseTargetOptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Complain</name></decl></parameter>,
<parameter><decl><type><name>ASTReaderListener</name> <modifier>&amp;</modifier></type><name>Listener</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowCompatibleDifferences</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ParseDiagnosticOptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Complain</name></decl></parameter>,
<parameter><decl><type><name>ASTReaderListener</name> <modifier>&amp;</modifier></type><name>Listener</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ParseFileSystemOptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Complain</name></decl></parameter>,
<parameter><decl><type><name>ASTReaderListener</name> <modifier>&amp;</modifier></type><name>Listener</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ParseHeaderSearchOptions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Complain</name></decl></parameter>,
<parameter><decl><type><name>ASTReaderListener</name> <modifier>&amp;</modifier></type><name>Listener</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ParsePreprocessorOptions</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordData</name> <operator>&amp;</operator><name>Record</name></expr></argument>, <argument><expr><name>bool</name> <name>Complain</name></expr></argument>,
<argument><expr><name>ASTReaderListener</name> <operator>&amp;</operator><name>Listener</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>SuggestedPredefines</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<struct>struct <name>RecordLocation</name> <block>{
<decl_stmt><decl><type><name>ModuleFile</name> <modifier>*</modifier></type><name>F</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>Offset</name></decl>;</decl_stmt>

<macro><name>RecordLocation</name><argument_list>(<argument>ModuleFile *M</argument>, <argument>uint64_t O</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>F</name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Offset</name><argument_list>(<argument>O</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>

<function_decl><type><name>QualType</name></type> <name>readTypeRecord</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>RecordLocation</name></type> <name>TypeCursorForIndex</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>LoadedDecl</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Index</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ReadDeclRecord</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name> <name>ID</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>markIncompleteDeclChain</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Canon</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>getMostRecentExistingDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>RecordLocation</name></type> <name>DeclCursorForID</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name> <name>ID</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>&amp;</operator><name>Location</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>loadDeclUpdateRecords</name><parameter_list>(<parameter><decl><type><name>PendingUpdateRecord</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>loadPendingDeclChain</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>LocalOffset</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>loadObjCCategories</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>GlobalDeclID</name> <name>ID</name></expr></argument>, <argument><expr><name>ObjCInterfaceDecl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>PreviousGeneration</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>RecordLocation</name></type> <name>getLocalBitOffset</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>GlobalOffset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>uint64_t</name></type> <name>getGlobalBitOffset</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>LocalOffset</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>serialization</name><operator>::</operator><name>PreprocessedEntityID</name>
<macro><name>findPreprocessedEntity</name><argument_list>(<argument>SourceLocation Loc</argument>, <argument>bool EndsAfter</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<expr_stmt><expr><name>serialization</name><operator>::</operator><name>PreprocessedEntityID</name>
<macro><name>findNextPreprocessedEntity</name><argument_list>(
<argument>GlobalSLocOffsetMapType::const_iterator SLocMapI</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ModuleFile</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name>
<macro><name>getModulePreprocessedEntity</name><argument_list>(<argument>unsigned GlobalIndex</argument>)</argument_list></macro></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>PreprocessingRecord</name><operator>::</operator><name>iterator</name></expr></argument>&gt;</argument_list></name>
<macro><name>getModulePreprocessedEntities</name><argument_list>(<argument>ModuleFile &amp;Mod</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><name>bool</name></type> <name>canRecoverFromOutOfDate</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>ModuleFileName</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>ClientLoadCapabilities</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>class</name></type> <name>ModuleDeclIterator</name>
<range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name><name>iterator_adaptor_base</name><argument_list type="generic">&lt;
<argument><expr><name>ModuleDeclIterator</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>serialization</name><operator>::</operator><name>LocalDeclID</name> <operator>*</operator></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name>random_access_iterator_tag</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>ptrdiff_t</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>ASTReader</name> <operator>*</operator><name>Reader</name> <operator>=</operator> <name>nullptr</name></expr>;
<expr><name>ModuleFile</name> <operator>*</operator><name>Mod</name> <operator>=</operator> <name>nullptr</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>ModuleDeclIterator</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>iterator_adaptor_base</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <block>{}</block>

<call><name>ModuleDeclIterator</name><argument_list>(<argument><expr><name>ASTReader</name> <operator>*</operator><name>Reader</name></expr></argument>, <argument><expr><name>ModuleFile</name> <operator>*</operator><name>Mod</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>serialization</name><operator>::</operator><name>LocalDeclID</name> <operator>*</operator><name>Pos</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>iterator_adaptor_base</name><argument_list>(<argument><expr><name>Pos</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Reader</name><argument_list>(<argument><expr><name>Reader</name></expr></argument>)</argument_list></call></expr>, <macro><name>Mod</name><argument_list>(<argument>Mod</argument>)</argument_list></macro> <expr><block>{}</block>

<name>value_type</name> <name>operator</name><operator>*</operator><operator>(</operator><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Reader</name><operator>-&gt;</operator><name>GetDecl</name></name><argument_list>(<argument><expr><call><name><name>Reader</name><operator>-&gt;</operator><name>getGlobalDeclID</name></name><argument_list>(<argument><expr><operator>*</operator><name>Mod</name></expr></argument>, <argument><expr><operator>*</operator><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>value_type</name> <name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr>) <specifier>const</specifier> <block>{ <return>return <expr><operator>*</operator><operator>*</operator><name>this</name></expr>;</return> }</block>

<name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>ModuleDeclIterator</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Reader</name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>Reader</name></name> <operator>&amp;&amp;</operator> <name>Mod</name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>Mod</name></name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>I</name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>I</name></name></expr>;</return>
}</block>
}</block></expr></range></decl></decl_stmt><empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>iterator_range</name><argument_list type="generic">&lt;<argument><expr><name>ModuleDeclIterator</name></expr></argument>&gt;</argument_list></name>
<call><name>getModuleFileLevelDecls</name><argument_list>(<argument><expr><name>ModuleFile</name> <operator>&amp;</operator><name>Mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>private</name>:</label>
<function_decl><type><name>void</name></type> <name>PassInterestingDeclsToConsumer</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>PassInterestingDeclToConsumer</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>finishPendingActions</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>diagnoseOdrViolations</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>pushExternalDeclIntoScope</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>addPendingDeclContextInfo</name><argument_list>(<argument><expr><name>Decl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><name>serialization</name><operator>::</operator><name>GlobalDeclID</name> <name>SemaDC</name></expr></argument>,
<argument><expr><name>serialization</name><operator>::</operator><name>GlobalDeclID</name> <name>LexicalDC</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PendingDeclContextInfo</name></type> <name>Info</name> <init>= <expr><block>{ <expr><name>D</name></expr>, <expr><name>SemaDC</name></expr>, <expr><name>LexicalDC</name></expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>PendingDeclContextInfos</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>Info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>





<decl_stmt><decl><type><name>void</name></type> <name>Error</name><argument_list>(<argument><expr><name>StringRef</name> <name>Msg</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>Error</name><argument_list>(<argument><expr><name>unsigned</name> <name>DiagID</name></expr></argument>, <argument><expr><name>StringRef</name> <name>Arg1</name> <operator>=</operator> <call><name>StringRef</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>StringRef</name> <name>Arg2</name> <operator>=</operator> <call><name>StringRef</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>StringRef</name> <name>Arg3</name> <operator>=</operator> <call><name>StringRef</name><argument_list>()</argument_list></call></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>Error</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>Error</name> <operator>&amp;&amp;</operator><name>Err</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>public</name>:</label>







































<macro><name>ASTReader</name><argument_list>(<argument>Preprocessor &amp;PP</argument>, <argument>InMemoryModuleCache &amp;ModuleCache</argument>,
<argument>ASTContext *Context</argument>, <argument>const PCHContainerReader &amp;PCHContainerRdr</argument>,
<argument>ArrayRef&lt;std::shared_ptr&lt;ModuleFileExtension&gt;&gt; Extensions</argument>,
<argument>StringRef isysroot = <literal type="string">""</literal></argument>,
<argument>DisableValidationForModuleKind DisableValidationKind =
DisableValidationForModuleKind::None</argument>,
<argument>bool AllowASTWithCompilerErrors = false</argument>,
<argument>bool AllowConfigurationMismatch = false</argument>,
<argument>bool ValidateSystemInputs = false</argument>,
<argument>bool ValidateASTInputFilesContent = false</argument>,
<argument>bool UseGlobalIndex = true</argument>,
<argument>std::unique_ptr&lt;llvm::Timer&gt; ReadTimer = {}</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>ASTReader</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ASTReader</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ASTReader</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>ASTReader</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>~</operator><macro><name>ASTReader</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>

<expr_stmt><expr><name>SourceManager</name> <operator>&amp;</operator><macro><name>getSourceManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SourceMgr</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>FileManager</name> <operator>&amp;</operator><macro><name>getFileManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>FileMgr</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><macro><name>getDiags</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Diags</name></expr>;</return> }</block></expr></expr_stmt>






<enum>enum <name>LoadFailureCapabilities</name> <block>{

<decl><name>ARR_None</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,



<decl><name>ARR_Missing</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,



<decl><name>ARR_OutOfDate</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,



<decl><name>ARR_VersionMismatch</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>,




<decl><name>ARR_ConfigurationMismatch</name> <init>= <expr><literal type="number">0x8</literal></expr></init></decl>,



<decl><name>ARR_TreatModuleWithErrorsAsOutOfDate</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>
}</block>;</enum>

















<function_decl><type><name>ASTReadResult</name></type> <name>ReadAST</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>FileName</name></decl></parameter>, <parameter><decl><type><name>ModuleKind</name></type> <name>Type</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ImportLoc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>ClientLoadCapabilities</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ImportedSubmodule</name></expr></argument>&gt;</argument_list></name> <modifier>*</modifier></type><name>Imported</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>










<decl_stmt><decl><type><name>void</name></type> <name>makeModuleVisible</name><argument_list>(<argument><expr><name>Module</name> <operator>*</operator><name>Mod</name></expr></argument>,
<argument><expr><name>Module</name><operator>::</operator><name>NameVisibilityKind</name> <name>NameVisibility</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>ImportLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>makeNamesVisible</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>HiddenNames</name> <modifier>&amp;</modifier></type><name>Names</name></decl></parameter>, <parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>Owner</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>mergeDefinitionVisibility</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Def</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>MergedDef</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReaderListener</name></expr></argument>&gt;</argument_list></name> <macro><name>takeListener</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Listener</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>setListener</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReaderListener</name></expr></argument>&gt;</argument_list></name> <name>Listener</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><name><name>this</name><operator>-&gt;</operator><name>Listener</name></name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Listener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>




<decl_stmt><decl><type><name>void</name></type> <name>addListener</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReaderListener</name></expr></argument>&gt;</argument_list></name> <name>L</name></expr></argument>)</argument_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Listener</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>L</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>ChainedASTReaderListener</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Listener</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Listener</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ListenerScope</name> <block>{<block_content>
<decl_stmt><decl><type><name>ASTReader</name> <modifier>&amp;</modifier></type><name>Reader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Chained</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>ListenerScope</name><argument_list>(<argument><expr><name>ASTReader</name> <operator>&amp;</operator><name>Reader</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>ASTReaderListener</name></expr></argument>&gt;</argument_list></name> <name>L</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Reader</name><argument_list>(<argument>Reader</argument>)</argument_list></macro> <block>{
<expr><name>auto</name> <name>Old</name> <operator>=</operator> <call><name><name>Reader</name><operator>.</operator><name>takeListener</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>Old</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>Chained</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name>L</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name><name>make_unique</name><argument_list type="generic">&lt;<argument><expr><name>ChainedASTReaderListener</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Old</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
Reader.setListener(std::move(L</block></if></if_stmt>))</block></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><operator>~</operator><macro><name>ListenerScope</name><argument_list>()</argument_list></macro> <block>{
<expr><name>auto</name> <name>New</name> <operator>=</operator> <call><name><name>Reader</name><operator>.</operator><name>takeListener</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>Chained</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Reader</name><operator>.</operator><name>setListener</name></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>ChainedASTReaderListener</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>New</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>takeSecond</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<function_decl><type><name>void</name></type> <name>setDeserializationListener</name><parameter_list>(<parameter><decl><type><name>ASTDeserializationListener</name> <modifier>*</modifier></type><name>Listener</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>TakeOwnership</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>ASTDeserializationListener</name> <modifier>*</modifier></type><name>getDeserializationListener</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><name>DeserializationListener</name></expr>;</return>
</block_content>}</block></function>


<expr_stmt><expr><name>bool</name> <macro><name>hasGlobalIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>(</operator><name>bool</name><operator>)</operator><name>GlobalIndex</name></expr>;</return> }</block></expr></expr_stmt>


<function><type><name>GlobalModuleIndex</name> <modifier>*</modifier></type><name>getGlobalIndex</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>GlobalIndex</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>


<function><type><name>void</name></type> <name>resetForReload</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>TriedLoadingGlobalIndex</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> </block_content>}</block></function>




<function_decl><type><name>bool</name></type> <name>loadGlobalIndex</name><parameter_list>()</parameter_list>;</function_decl>



<expr_stmt><expr><name>bool</name> <macro><name>isGlobalIndexUnavailable</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>InitializeContext</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>UpdateSema</name><parameter_list>()</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>addInMemoryBuffer</name><argument_list>(<argument><expr><name>StringRef</name> <operator>&amp;</operator><name>FileName</name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>MemoryBuffer</name></expr></argument>&gt;</argument_list></name> <name>Buffer</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>ModuleMgr</name><operator>.</operator><name>addInMemoryBuffer</name></name><argument_list>(<argument><expr><name>FileName</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>Buffer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>






<function_decl><type><name>void</name></type> <name>finalizeForWriting</name><parameter_list>()</parameter_list>;</function_decl>


<function><type><name>ModuleManager</name> <modifier>&amp;</modifier></type><name>getModuleManager</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>ModuleMgr</name></expr>;</return> </block_content>}</block></function>


<expr_stmt><expr><name>Preprocessor</name> <operator>&amp;</operator><macro><name>getPreprocessor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PP</name></expr>;</return> }</block></expr></expr_stmt>



<function><type><name>StringRef</name></type> <name>getOriginalSourceFile</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>ModuleMgr</name><operator>.</operator><name>getPrimaryModule</name></name><argument_list>()</argument_list></call><operator>.</operator><name>OriginalSourceFileName</name></expr>;</return>
</block_content>}</block></function>



<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name>
<call><name>getOriginalSourceFile</name><argument_list>(<argument><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><name>ASTFileName</name></expr></argument>, <argument><expr><name>FileManager</name> <operator>&amp;</operator><name>FileMgr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>PCHContainerReader</name> <operator>&amp;</operator><name>PCHContainerRdr</name></expr></argument>,
<argument><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><name>Diags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<function_decl><type><specifier>static</specifier> <name>bool</name></type>
<name>readASTFileControlBlock</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Filename</name></decl></parameter>, <parameter><decl><type><name>FileManager</name> <modifier>&amp;</modifier></type><name>FileMgr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PCHContainerReader</name> <modifier>&amp;</modifier></type><name>PCHContainerRdr</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>FindModuleFileExtensions</name></decl></parameter>,
<parameter><decl><type><name>ASTReaderListener</name> <modifier>&amp;</modifier></type><name>Listener</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ValidateDiagnosticOptions</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isAcceptableASTFile</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Filename</name></decl></parameter>, <parameter><decl><type><name>FileManager</name> <modifier>&amp;</modifier></type><name>FileMgr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PCHContainerReader</name> <modifier>&amp;</modifier></type><name>PCHContainerRdr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LangOptions</name> <modifier>&amp;</modifier></type><name>LangOpts</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TargetOptions</name> <modifier>&amp;</modifier></type><name>TargetOpts</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PreprocessorOptions</name> <modifier>&amp;</modifier></type><name>PPOpts</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>ExistingModuleCachePath</name></decl></parameter>)</parameter_list>;</function_decl>




<expr_stmt><expr><specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><macro><name>getSuggestedPredefines</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>SuggestedPredefines</name></expr>;</return> }</block></expr></expr_stmt>





<decl_stmt><decl><type><name>PreprocessedEntity</name> <modifier>*</modifier></type><name>ReadPreprocessedEntity</name><argument_list>(<argument><expr><name>unsigned</name> <name>Index</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name>
<macro><name>findPreprocessedEntitiesInRange</name><argument_list>(<argument>SourceRange Range</argument>)</argument_list></macro> <name>override</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></type> <name>isPreprocessedEntityInFileID</name><argument_list>(<argument><expr><name>unsigned</name> <name>Index</name></expr></argument>,
<argument><expr><name>FileID</name> <name>FID</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceRange</name></type> <name>ReadSkippedRange</name><argument_list>(<argument><expr><name>unsigned</name> <name>Index</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>HeaderFileInfo</name></type> <name>GetHeaderFileInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><name>FE</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>ReadPragmaDiagnosticMappings</name><parameter_list>(<parameter><decl><type><name>DiagnosticsEngine</name> <modifier>&amp;</modifier></type><name>Diag</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>unsigned</name> <macro><name>getTotalNumSLocs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>TotalNumSLocEntries</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getTotalNumIdentifiers</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>IdentifiersLoaded</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getTotalNumMacros</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>MacrosLoaded</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getTotalNumTypes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>TypesLoaded</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getTotalNumDecls</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>DeclsLoaded</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getTotalNumSubmodules</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>SubmodulesLoaded</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getTotalNumSelectors</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>SelectorsLoaded</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>getTotalNumPreprocessedEntities</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>unsigned</name> <name>Result</name> <operator>=</operator> <literal type="number">0</literal></expr>;
<for>for <control>(<init><decl><type><specifier>const</specifier> <specifier>auto</specifier> <modifier>&amp;</modifier></type><name>M</name> <range>: <expr><name>ModuleMgr</name></expr></range></decl></init>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>Result</name> <operator>+=</operator> <name><name>M</name><operator>.</operator><name>NumPreprocessedEntities</name></name></expr>;</expr_stmt></block_content></block></for></block></expr></expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>QualType</name></type> <name>GetType</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>TypeID</name> <name>ID</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>QualType</name></type> <name>getLocalType</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>LocalID</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>serialization</name><operator>::</operator><name>TypeID</name> <macro><name>getGlobalTypeID</name><argument_list>(<argument>ModuleFile &amp;F</argument>, <argument>unsigned LocalID</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<function><type><name>QualType</name></type> <name>readType</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>Idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Idx</name> <operator>&gt;=</operator> <call><name><name>Record</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><block>{}</block></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>getLocalType</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name><name>Record</name><index>[<expr><name>Idx</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<expr_stmt><expr><name>serialization</name><operator>::</operator><name>DeclID</name> <macro><name>getGlobalDeclID</name><argument_list>(<argument>ModuleFile &amp;F</argument>,
<argument>serialization::LocalDeclID LocalID</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>isDeclIDFromModule</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>GlobalDeclID</name> <name>ID</name></expr></argument>, <argument><expr><name>ModuleFile</name> <operator>&amp;</operator><name>M</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function_decl><type><name>ModuleFile</name> <modifier>*</modifier></type><name>getOwningModuleFile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <call><name>getOwningModuleNameForDiagnostic</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>getSourceLocationForDeclID</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>GlobalDeclID</name> <name>ID</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>GetDecl</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name> <name>ID</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>GetExternalDecl</name><argument_list>(<argument><expr><name>uint32_t</name> <name>ID</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>GetExistingDecl</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>DeclID</name> <name>ID</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function><type><name>Decl</name> <modifier>*</modifier></type><name>GetLocalDecl</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>LocalID</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>GetDecl</name><argument_list>(<argument><expr><call><name>getGlobalDeclID</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>LocalID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <modifier>*</modifier></type><name>GetLocalDeclAs</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>LocalID</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>GetLocalDecl</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>LocalID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<expr_stmt><expr><name>serialization</name><operator>::</operator><name>DeclID</name>
<macro><name>mapGlobalIDToModuleFileGlobalID</name><argument_list>(<argument>ModuleFile &amp;M</argument>,
<argument>serialization::DeclID GlobalID</argument>)</argument_list></macro></expr>;</expr_stmt>





<expr_stmt><expr><name>serialization</name><operator>::</operator><name>DeclID</name> <call><name>ReadDeclID</name><argument_list>(<argument><expr><name>ModuleFile</name> <operator>&amp;</operator><name>F</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>RecordData</name> <operator>&amp;</operator><name>Record</name></expr></argument>,
<argument><expr><name>unsigned</name> <operator>&amp;</operator><name>Idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<function><type><name>Decl</name> <modifier>*</modifier></type><name>ReadDecl</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>GetDecl</name><argument_list>(<argument><expr><call><name>ReadDeclID</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>






<function><type><name><name>template</name><argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <modifier>*</modifier></type><name>ReadDeclAs</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name>GetDecl</name><argument_list>(<argument><expr><call><name>ReadDeclID</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<decl_stmt><decl><type><name>void</name></type> <name>CompleteRedeclChain</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CXXBaseSpecifier</name> <modifier>*</modifier></type><name>GetExternalCXXBaseSpecifiers</name><argument_list>(<argument><expr><name>uint64_t</name> <name>Offset</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>GetExternalDeclStmt</name><argument_list>(<argument><expr><name>uint64_t</name> <name>Offset</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>




<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ReadBlockAbbrevs</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>BitstreamCursor</name> <operator>&amp;</operator><name>Cursor</name></expr></argument>, <argument><expr><name>unsigned</name> <name>BlockID</name></expr></argument>,
<argument><expr><name>uint64_t</name> <operator>*</operator><name>StartOfBlockOffset</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>FindExternalVisibleDeclsByName</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>,
<argument><expr><name>DeclarationName</name> <name>Name</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>














<decl_stmt><decl><type><name>void</name></type>
<name>FindExternalLexicalDecls</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><name>Decl</name><operator>::</operator><name>Kind</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>IsKindWeWant</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Decls</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>void</name></type> <name>FindFileRegionDecls</name><argument_list>(<argument><expr><name>FileID</name> <name>File</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Offset</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Length</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Decls</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>




<expr_stmt><expr><name>void</name> <macro><name>StartedDeserializing</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>



<expr_stmt><expr><name>void</name> <macro><name>FinishedDeserializing</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>






<decl_stmt><decl><type><name>void</name></type> <name>StartTranslationUnit</name><argument_list>(<argument><expr><name>ASTConsumer</name> <operator>*</operator><name>Consumer</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>


<expr_stmt><expr><name>void</name> <macro><name>PrintStats</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>dump</name><parameter_list>()</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>getMemoryBufferSizes</name><argument_list>(<argument><expr><name>MemoryBufferSizes</name> <operator>&amp;</operator><name>sizes</name></expr></argument>)</argument_list> const <name>override</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>void</name></type> <name>InitializeSema</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>


<function><type><name>void</name></type> <name>ForgetSema</name><parameter_list>()</parameter_list> override <block>{<block_content> <expr_stmt><expr><name>SemaObj</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt> </block_content>}</block></function>







<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>get</name><argument_list>(<argument><expr><name>StringRef</name> <name>Name</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>



<expr_stmt><expr><name>IdentifierIterator</name> <operator>*</operator><macro><name>getIdentifiers</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>ReadMethodPool</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>updateOutOfDateSelector</name><argument_list>(<argument><expr><name>Selector</name> <name>Sel</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>ReadKnownNamespaces</name><argument_list>(
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Namespaces</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ReadUndefinedButUsed</name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Undefined</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ReadMismatchingDeleteExpressions</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;
<argument><expr><name>FieldDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator>
<name>Exprs</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ReadTentativeDefinitions</name><argument_list>(
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>TentativeDefs</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ReadUnusedFileScopedDecls</name><argument_list>(
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>DeclaratorDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Decls</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ReadDelegatingConstructors</name><argument_list>(
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Decls</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ReadExtVectorDecls</name><argument_list>(<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>TypedefNameDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Decls</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ReadUnusedLocalTypedefNameCandidates</name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallSetVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>TypedefNameDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Decls</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ReadDeclsToCheckForDeferredDiags</name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallSetVector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Decls</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ReadReferencedSelectors</name><argument_list>(
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>Selector</name></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Sels</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ReadWeakUndeclaredIdentifiers</name><argument_list>(
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>WeakInfo</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>WI</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ReadUsedVTables</name><argument_list>(<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ExternalVTableUse</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>VTables</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ReadPendingInstantiations</name><argument_list>(
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>,
<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Pending</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>ReadLateParsedTemplates</name><argument_list>(
<argument><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>LateParsedTemplate</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<operator>&amp;</operator><name>LPTMap</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>LoadSelector</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>SetIdentifierInfo</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>SetGloballyVisibleDecls</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>DeclIDs</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>*</modifier></type><name>Decls</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>DiagnosticBuilder</name></type> <name>Diag</name><argument_list>(<argument><expr><name>unsigned</name> <name>DiagID</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<decl_stmt><decl><type><name>DiagnosticBuilder</name></type> <name>Diag</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>unsigned</name> <name>DiagID</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>DecodeIdentifierInfo</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>IdentifierID</name> <name>ID</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>readIdentifier</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>Idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>DecodeIdentifierInfo</name><argument_list>(<argument><expr><call><name>getGlobalIdentifierID</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name><name>Record</name><index>[<expr><name>Idx</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>GetIdentifier</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>IdentifierID</name> <name>ID</name></expr></argument>)</argument_list> <name>override</name> <block>{<block_content>

<function_decl><type><name>Deserializing</name></type> <name>AnIdentifier</name><parameter_list>(<parameter><decl><type><name>this</name></type></decl></parameter>)</parameter_list>;</function_decl>

<return>return <expr><call><name>DecodeIdentifierInfo</name><argument_list>(<argument><expr><name>ID</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function_decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>getLocalIdentifier</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>LocalID</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>serialization</name><operator>::</operator><name>IdentifierID</name> <macro><name>getGlobalIdentifierID</name><argument_list>(<argument>ModuleFile &amp;M</argument>,
<argument>unsigned LocalID</argument>)</argument_list></macro></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>resolvePendingMacro</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PendingMacroInfo</name> <modifier>&amp;</modifier></type><name>PMInfo</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>getMacro</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>MacroID</name> <name>ID</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<expr_stmt><expr><name>serialization</name><operator>::</operator><name>MacroID</name> <macro><name>getGlobalMacroID</name><argument_list>(<argument>ModuleFile &amp;M</argument>, <argument>unsigned LocalID</argument>)</argument_list></macro></expr>;</expr_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>ReadSLocEntry</name><argument_list>(<argument><expr><name>int</name> <name>ID</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>, <argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name> <macro><name>getModuleImportLoc</name><argument_list>(<argument>int ID</argument>)</argument_list></macro> <name>override</name></expr>;</expr_stmt>



<expr_stmt><expr><name>serialization</name><operator>::</operator><name>SubmoduleID</name>
<macro><name>getGlobalSubmoduleID</name><argument_list>(<argument>ModuleFile &amp;M</argument>, <argument>unsigned LocalID</argument>)</argument_list></macro></expr>;</expr_stmt>



<decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>getSubmodule</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>SubmoduleID</name> <name>GlobalID</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<decl_stmt><decl><type><name>Module</name> <modifier>*</modifier></type><name>getModule</name><argument_list>(<argument><expr><name>unsigned</name> <name>ID</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>



<function_decl><type><name>ModuleFile</name> <modifier>*</modifier></type><name>getLocalModuleFile</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>unsigned</name></type> <name>getModuleFileID</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>*</modifier></type><name>M</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>ASTSourceDescriptor</name></expr></argument>&gt;</argument_list></name> <macro><name>getSourceDescriptor</name><argument_list>(<argument>unsigned ID</argument>)</argument_list></macro> <name>override</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ExtKind</name></type> <name>hasExternalDefinitions</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>



<function_decl><type><name>Selector</name></type> <name>getLocalSelector</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>LocalID</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>Selector</name></type> <name>DecodeSelector</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>SelectorID</name> <name>Idx</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Selector</name></type> <name>GetExternalSelector</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>SelectorID</name> <name>ID</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>
<expr_stmt><expr><name>uint32_t</name> <macro><name>GetNumExternalSelectors</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>

<function><type><name>Selector</name></type> <name>ReadSelector</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>Idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getLocalSelector</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name><name>Record</name><index>[<expr><name>Idx</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<expr_stmt><expr><name>serialization</name><operator>::</operator><name>SelectorID</name> <macro><name>getGlobalSelectorID</name><argument_list>(<argument>ModuleFile &amp;F</argument>,
<argument>unsigned LocalID</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>CXXCtorInitializer</name> <modifier>*</modifier><modifier>*</modifier></type><name>GetExternalCXXCtorInitializers</name><argument_list>(<argument><expr><name>uint64_t</name> <name>Offset</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>


<expr_stmt><expr><name>Sema</name><operator>::</operator><name>AlignPackInfo</name> <macro><name>ReadAlignPackInfo</name><argument_list>(<argument>uint32_t Raw</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Sema</name><operator>::</operator><name>AlignPackInfo</name><operator>::</operator><call><name>getFromRawEncoding</name><argument_list>(<argument><expr><name>Raw</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type>
<name>ReadUntranslatedSourceLocation</name><argument_list>(<argument><expr><name>SourceLocation</name><operator>::</operator><name>UIntTy</name> <name>Raw</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><name>SourceLocation</name><operator>::</operator><call><name>getFromRawEncoding</name><argument_list>(<argument><expr><operator>(</operator><name>Raw</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>|</operator>
<operator>(</operator><name>Raw</name> <operator>&lt;&lt;</operator> <operator>(</operator><literal type="number">8</literal> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Raw</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ReadSourceLocation</name><argument_list>(<argument><expr><name>ModuleFile</name> <operator>&amp;</operator><name>ModuleFile</name></expr></argument>,
<argument><expr><name>SourceLocation</name><operator>::</operator><name>UIntTy</name> <name>Raw</name></expr></argument>)</argument_list> const <block>{<block_content>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name> <init>= <expr><call><name>ReadUntranslatedSourceLocation</name><argument_list>(<argument><expr><name>Raw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>TranslateSourceLocation</name><argument_list>(<argument><expr><name>ModuleFile</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>TranslateSourceLocation</name><argument_list>(<argument><expr><name>ModuleFile</name> <operator>&amp;</operator><name>ModuleFile</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>ModuleFile</name><operator>.</operator><name>ModuleOffsetMap</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ReadModuleOffsetMap</name><argument_list>(<argument><expr><name>ModuleFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>ModuleFile</name><operator>.</operator><name>SLocRemap</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><call><name><name>Loc</name><operator>.</operator><name>getOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator>
<call><name><name>ModuleFile</name><operator>.</operator><name>SLocRemap</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Cannot find offset to remap."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>SourceLocation</name><operator>::</operator><name>IntTy</name> <name>Remap</name> <operator>=</operator>
<call><name><name>ModuleFile</name><operator>.</operator><name>SLocRemap</name><operator>.</operator><name>find</name></name><argument_list>(<argument><expr><call><name><name>Loc</name><operator>.</operator><name>getOffset</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>second</name></expr>;</expr_stmt>
<return>return <expr><call><name><name>Loc</name><operator>.</operator><name>getLocWithOffset</name></name><argument_list>(<argument><expr><name>Remap</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>


<function><type><name>SourceLocation</name></type> <name>ReadSourceLocation</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>ModuleFile</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RecordDataImpl</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>Idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>ReadSourceLocation</name><argument_list>(<argument><expr><name>ModuleFile</name></expr></argument>, <argument><expr><name><name>Record</name><index>[<expr><name>Idx</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>SourceRange</name></type> <name>ReadSourceRange</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>Idx</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><specifier>static</specifier> <name>std</name><operator>::</operator><name>string</name> <call><name>ReadString</name><argument_list>(<argument><expr><specifier>const</specifier> <name>RecordData</name> <operator>&amp;</operator><name>Record</name></expr></argument>, <argument><expr><name>unsigned</name> <operator>&amp;</operator><name>Idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>void</name></type> <name>SkipString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>Idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Idx</name> <operator>+=</operator> <name><name>Record</name><index>[<expr><name>Idx</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <call><name>ReadPath</name><argument_list>(<argument><expr><name>ModuleFile</name> <operator>&amp;</operator><name>F</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>RecordData</name> <operator>&amp;</operator><name>Record</name></expr></argument>, <argument><expr><name>unsigned</name> <operator>&amp;</operator><name>Idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>ReadPath</name><argument_list>(<argument>StringRef BaseDirectory</argument>, <argument>const RecordData &amp;Record</argument>,
<argument>unsigned &amp;Idx</argument>)</argument_list></macro></expr>;</expr_stmt>


<function><type><specifier>static</specifier> <name>void</name></type> <name>SkipPath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>Idx</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>SkipString</name><argument_list>(<argument><expr><name>Record</name></expr></argument>, <argument><expr><name>Idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>VersionTuple</name></type> <name>ReadVersionTuple</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>Idx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>CXXTemporary</name> <modifier>*</modifier></type><name>ReadCXXTemporary</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecordData</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>Idx</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>Stmt</name> <modifier>*</modifier></type><name>ReadStmt</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>Expr</name> <modifier>*</modifier></type><name>ReadExpr</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>Stmt</name> <modifier>*</modifier></type><name>ReadSubStmt</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ReadingKind</name> <operator>==</operator> <name>Read_Stmt</name> <operator>&amp;&amp;</operator>
<literal type="string">"Should be called only during statement reading!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>StmtStack</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Read too many sub-statements!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>StmtStack</name><operator>.</operator><name>pop_back_val</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>Expr</name> <modifier>*</modifier></type><name>ReadSubExpr</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>Token</name></type> <name>ReadToken</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecordDataImpl</name> <modifier>&amp;</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>Idx</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>ReadMacroRecord</name><parameter_list>(<parameter><decl><type><name>ModuleFile</name> <modifier>&amp;</modifier></type><name>F</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>Offset</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>serialization</name><operator>::</operator><name>PreprocessedEntityID</name>
<macro><name>getGlobalPreprocessedEntityID</name><argument_list>(<argument>ModuleFile &amp;M</argument>, <argument>unsigned LocalID</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>







<function_decl><type><name>void</name></type> <name>addPendingMacro</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>ModuleFile</name> <modifier>*</modifier></type><name>M</name></decl></parameter>,
<parameter><decl><type><name>uint32_t</name></type> <name>MacroDirectivesOffset</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>void</name> <macro><name>ReadDefinedMacros</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>updateOutOfDateIdentifier</name><argument_list>(<argument><expr><name>IdentifierInfo</name> <operator>&amp;</operator><name>II</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>markIdentifierUpToDate</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>completeVisibleDeclsMap</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>)</argument_list> <name>override</name></decl>;</decl_stmt>


<function><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>getContext</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ContextObj</name> <operator>&amp;&amp;</operator> <literal type="string">"requested AST context when not loading AST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><name>ContextObj</name></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>uint64_t</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>PreloadedDeclIDs</name></decl>;</decl_stmt>




<function><type><name>Sema</name> <modifier>*</modifier></type><name>getSema</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>SemaObj</name></expr>;</return> </block_content>}</block></function>




<function_decl><type><name>IdentifierResolver</name> <modifier>&amp;</modifier></type><name>getIdResolver</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>IdentifierTable</name> <modifier>&amp;</modifier></type><name>getIdentifierTable</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>RecordSwitchCaseID</name><parameter_list>(<parameter><decl><type><name>SwitchCase</name> <modifier>*</modifier></type><name>SC</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>SwitchCase</name> <modifier>*</modifier></type><name>getSwitchCaseWithID</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ClearSwitchCaseIDs</name><parameter_list>()</parameter_list>;</function_decl>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name>BitstreamCursor</name></expr></argument>,
<argument><expr><name>serialization</name><operator>::</operator><name>ModuleFile</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>CommentsCursors</name></decl>;</decl_stmt>


<expr_stmt><expr><name>void</name> <macro><name>ReadComments</name><argument_list>()</argument_list></macro> <name>override</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>visitInputFiles</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>ModuleFile</name> <operator>&amp;</operator><name>MF</name></expr></argument>,
<argument><expr><name>bool</name> <name>IncludeSystem</name></expr></argument>, <argument><expr><name>bool</name> <name>Complain</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><specifier>const</specifier> <name>serialization</name><operator>::</operator><name>InputFile</name> <operator>&amp;</operator><name>IF</name>,
<name>bool</name> <name>isSystem</name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>Visitor</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>visitTopLevelModuleMaps</name><argument_list>(<argument><expr><name>serialization</name><operator>::</operator><name>ModuleFile</name> <operator>&amp;</operator><name>MF</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;
<argument><expr><name>void</name><operator>(</operator><specifier>const</specifier> <name>FileEntry</name> <operator>*</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>Visitor</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function><type><name>bool</name></type> <name>isProcessingUpdateRecords</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>ProcessingUpdateRecords</name></expr>;</return> </block_content>}</block></function>
};

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
