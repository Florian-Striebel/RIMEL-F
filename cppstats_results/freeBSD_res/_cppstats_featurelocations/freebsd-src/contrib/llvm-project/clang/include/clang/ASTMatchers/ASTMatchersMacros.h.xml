<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/ASTMatchers/ASTMatchersMacros.h">















































<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_ASTMATCHERS_ASTMATCHERSMACROS_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_ASTMATCHERS_ASTMATCHERSMACROS_H</name></cpp:macro></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_MATCHER_FUNCTION</name><parameter_list>(<parameter><type><name>ReturnType</name></type></parameter>, <parameter><type><name>DefineMatcher</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>inline ReturnType DefineMatcher##_getInstance(); inline ReturnType DefineMatcher() { return ::clang::ast_matchers::internal::MemoizedMatcher&lt; ReturnType, DefineMatcher##_getInstance&gt;::getInstance(); } inline ReturnType DefineMatcher##_getInstance()</cpp:value></cpp:define>


















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_MATCHER_FUNCTION_P</name><parameter_list>(<parameter><type><name>ReturnType</name></type></parameter>, <parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>ParamType</name></type></parameter>, <parameter><type><name>Param</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>AST_MATCHER_FUNCTION_P_OVERLOAD(ReturnType, DefineMatcher, ParamType, Param, 0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_MATCHER_FUNCTION_P_OVERLOAD</name><parameter_list>(<parameter><type><name>ReturnType</name></type></parameter>, <parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>ParamType</name></type></parameter>, <parameter><type><name>Param</name></type></parameter>, <parameter><type><name>OverloadId</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>inline ReturnType DefineMatcher(ParamType const &amp;Param); typedef ReturnType (&amp;DefineMatcher##_Type##OverloadId)(ParamType const &amp;); inline ReturnType DefineMatcher(ParamType const &amp;Param)</cpp:value></cpp:define>
















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_MATCHER</name><parameter_list>(<parameter><type><name>Type</name></type></parameter>, <parameter><type><name>DefineMatcher</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>namespace internal { class matcher_##DefineMatcher##Matcher : public ::clang::ast_matchers::internal::MatcherInterface&lt;Type&gt; { public: explicit matcher_##DefineMatcher##Matcher() = default; bool matches(const Type &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const override; }; } inline ::clang::ast_matchers::internal::Matcher&lt;Type&gt; DefineMatcher() { return ::clang::ast_matchers::internal::makeMatcher( new internal::matcher_##DefineMatcher##Matcher()); } inline bool internal::matcher_##DefineMatcher##Matcher::matches( const Type &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const</cpp:value></cpp:define>

































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_MATCHER_P</name><parameter_list>(<parameter><type><name>Type</name></type></parameter>, <parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>ParamType</name></type></parameter>, <parameter><type><name>Param</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>AST_MATCHER_P_OVERLOAD(Type, DefineMatcher, ParamType, Param, 0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_MATCHER_P_OVERLOAD</name><parameter_list>(<parameter><type><name>Type</name></type></parameter>, <parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>ParamType</name></type></parameter>, <parameter><type><name>Param</name></type></parameter>, <parameter><type><name>OverloadId</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>namespace internal { class matcher_##DefineMatcher##OverloadId##Matcher : public ::clang::ast_matchers::internal::MatcherInterface&lt;Type&gt; { public: explicit matcher_##DefineMatcher##OverloadId##Matcher( ParamType const &amp;A##Param) : Param(A##Param) {} bool matches(const Type &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const override; private: ParamType Param; }; } inline ::clang::ast_matchers::internal::Matcher&lt;Type&gt; DefineMatcher( ParamType const &amp;Param) { return ::clang::ast_matchers::internal::makeMatcher( new internal::matcher_##DefineMatcher##OverloadId##Matcher(Param)); } typedef ::clang::ast_matchers::internal::Matcher&lt;Type&gt; ( &amp;DefineMatcher##_Type##OverloadId)(ParamType const &amp;Param); inline bool internal::matcher_##DefineMatcher##OverloadId##Matcher::matches( const Type &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const</cpp:value></cpp:define>











































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_MATCHER_P2</name><parameter_list>(<parameter><type><name>Type</name></type></parameter>, <parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>ParamType1</name></type></parameter>, <parameter><type><name>Param1</name></type></parameter>, <parameter><type><name>ParamType2</name></type></parameter>, <parameter><type><name>Param2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>AST_MATCHER_P2_OVERLOAD(Type, DefineMatcher, ParamType1, Param1, ParamType2, Param2, 0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_MATCHER_P2_OVERLOAD</name><parameter_list>(<parameter><type><name>Type</name></type></parameter>, <parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>ParamType1</name></type></parameter>, <parameter><type><name>Param1</name></type></parameter>, <parameter><type><name>ParamType2</name></type></parameter>, <parameter><type><name>Param2</name></type></parameter>, <parameter><type><name>OverloadId</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>namespace internal { class matcher_##DefineMatcher##OverloadId##Matcher : public ::clang::ast_matchers::internal::MatcherInterface&lt;Type&gt; { public: matcher_##DefineMatcher##OverloadId##Matcher(ParamType1 const &amp;A##Param1, ParamType2 const &amp;A##Param2) : Param1(A##Param1), Param2(A##Param2) {} bool matches(const Type &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const override; private: ParamType1 Param1; ParamType2 Param2; }; } inline ::clang::ast_matchers::internal::Matcher&lt;Type&gt; DefineMatcher( ParamType1 const &amp;Param1, ParamType2 const &amp;Param2) { return ::clang::ast_matchers::internal::makeMatcher( new internal::matcher_##DefineMatcher##OverloadId##Matcher(Param1, Param2)); } typedef ::clang::ast_matchers::internal::Matcher&lt;Type&gt; ( &amp;DefineMatcher##_Type##OverloadId)(ParamType1 const &amp;Param1, ParamType2 const &amp;Param2); inline bool internal::matcher_##DefineMatcher##OverloadId##Matcher::matches( const Type &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const</cpp:value></cpp:define>








































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_POLYMORPHIC_SUPPORTED_TYPES</name><parameter_list>(<parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>void(::clang::ast_matchers::internal::TypeList&lt;__VA_ARGS__&gt;)</cpp:value></cpp:define>








<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_POLYMORPHIC_MATCHER</name><parameter_list>(<parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>ReturnTypesF</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>namespace internal { template &lt;typename NodeType&gt; class matcher_##DefineMatcher##Matcher : public ::clang::ast_matchers::internal::MatcherInterface&lt;NodeType&gt; { public: bool matches(const NodeType &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const override; }; } inline ::clang::ast_matchers::internal::PolymorphicMatcher&lt; internal::matcher_##DefineMatcher##Matcher, ReturnTypesF&gt; DefineMatcher() { return ::clang::ast_matchers::internal::PolymorphicMatcher&lt; internal::matcher_##DefineMatcher##Matcher, ReturnTypesF&gt;(); } template &lt;typename NodeType&gt; bool internal::matcher_##DefineMatcher##Matcher&lt;NodeType&gt;::matches( const NodeType &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const</cpp:value></cpp:define>
































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_POLYMORPHIC_MATCHER_P</name><parameter_list>(<parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>ReturnTypesF</name></type></parameter>, <parameter><type><name>ParamType</name></type></parameter>, <parameter><type><name>Param</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>AST_POLYMORPHIC_MATCHER_P_OVERLOAD(DefineMatcher, ReturnTypesF, ParamType, Param, 0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_POLYMORPHIC_MATCHER_P_OVERLOAD</name><parameter_list>(<parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>ReturnTypesF</name></type></parameter>, <parameter><type><name>ParamType</name></type></parameter>, <parameter><type><name>Param</name></type></parameter>, <parameter><type><name>OverloadId</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>namespace internal { template &lt;typename NodeType, typename ParamT&gt; class matcher_##DefineMatcher##OverloadId##Matcher : public ::clang::ast_matchers::internal::MatcherInterface&lt;NodeType&gt; { public: explicit matcher_##DefineMatcher##OverloadId##Matcher( ParamType const &amp;A##Param) : Param(A##Param) {} bool matches(const NodeType &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const override; private: ParamType Param; }; } inline ::clang::ast_matchers::internal::PolymorphicMatcher&lt; internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF, ParamType&gt; DefineMatcher(ParamType const &amp;Param) { return ::clang::ast_matchers::internal::PolymorphicMatcher&lt; internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF, ParamType&gt;(Param); } typedef ::clang::ast_matchers::internal::PolymorphicMatcher&lt; internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF, ParamType&gt; (&amp;DefineMatcher##_Type##OverloadId)(ParamType const &amp;Param); template &lt;typename NodeType, typename ParamT&gt; bool internal:: matcher_##DefineMatcher##OverloadId##Matcher&lt;NodeType, ParamT&gt;::matches( const NodeType &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const</cpp:value></cpp:define>













































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_POLYMORPHIC_MATCHER_P2</name><parameter_list>(<parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>ReturnTypesF</name></type></parameter>, <parameter><type><name>ParamType1</name></type></parameter>, <parameter><type><name>Param1</name></type></parameter>, <parameter><type><name>ParamType2</name></type></parameter>, <parameter><type><name>Param2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>AST_POLYMORPHIC_MATCHER_P2_OVERLOAD(DefineMatcher, ReturnTypesF, ParamType1, Param1, ParamType2, Param2, 0)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_POLYMORPHIC_MATCHER_P2_OVERLOAD</name><parameter_list>(<parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>ReturnTypesF</name></type></parameter>, <parameter><type><name>ParamType1</name></type></parameter>, <parameter><type><name>Param1</name></type></parameter>, <parameter><type><name>ParamType2</name></type></parameter>, <parameter><type><name>Param2</name></type></parameter>, <parameter><type><name>OverloadId</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>namespace internal { template &lt;typename NodeType, typename ParamT1, typename ParamT2&gt; class matcher_##DefineMatcher##OverloadId##Matcher : public ::clang::ast_matchers::internal::MatcherInterface&lt;NodeType&gt; { public: matcher_##DefineMatcher##OverloadId##Matcher(ParamType1 const &amp;A##Param1, ParamType2 const &amp;A##Param2) : Param1(A##Param1), Param2(A##Param2) {} bool matches(const NodeType &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const override; private: ParamType1 Param1; ParamType2 Param2; }; } inline ::clang::ast_matchers::internal::PolymorphicMatcher&lt; internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF, ParamType1, ParamType2&gt; DefineMatcher(ParamType1 const &amp;Param1, ParamType2 const &amp;Param2) { return ::clang::ast_matchers::internal::PolymorphicMatcher&lt; internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF, ParamType1, ParamType2&gt;(Param1, Param2); } typedef ::clang::ast_matchers::internal::PolymorphicMatcher&lt; internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF, ParamType1, ParamType2&gt; (&amp;DefineMatcher##_Type##OverloadId)( ParamType1 const &amp;Param1, ParamType2 const &amp;Param2); template &lt;typename NodeType, typename ParamT1, typename ParamT2&gt; bool internal::matcher_##DefineMatcher##OverloadId##Matcher&lt; NodeType, ParamT1, ParamT2&gt;:: matches(const NodeType &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const</cpp:value></cpp:define>











































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_TYPE_TRAVERSE_MATCHER_DECL</name><parameter_list>(<parameter><type><name>MatcherName</name></type></parameter>, <parameter><type><name>FunctionName</name></type></parameter>, <parameter><type><name>ReturnTypesF</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>namespace internal { template &lt;typename T&gt; struct TypeMatcher##MatcherName##Getter { static QualType (T::*value())() const { return &amp;T::FunctionName; } }; } extern const ::clang::ast_matchers::internal:: TypeTraversePolymorphicMatcher&lt; QualType, ::clang::ast_matchers::internal::TypeMatcher##MatcherName##Getter, ::clang::ast_matchers::internal::TypeTraverseMatcher, ReturnTypesF&gt;::Func MatcherName</cpp:value></cpp:define>













<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_TYPE_TRAVERSE_MATCHER_DEF</name><parameter_list>(<parameter><type><name>MatcherName</name></type></parameter>, <parameter><type><name>ReturnTypesF</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>const ::clang::ast_matchers::internal::TypeTraversePolymorphicMatcher&lt; QualType, ::clang::ast_matchers::internal::TypeMatcher##MatcherName##Getter, ::clang::ast_matchers::internal::TypeTraverseMatcher, ReturnTypesF&gt;::Func MatcherName</cpp:value></cpp:define>













<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_TYPE_TRAVERSE_MATCHER</name><parameter_list>(<parameter><type><name>MatcherName</name></type></parameter>, <parameter><type><name>FunctionName</name></type></parameter>, <parameter><type><name>ReturnTypesF</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>namespace internal { template &lt;typename T&gt; struct TypeMatcher##MatcherName##Getter { static QualType (T::*value())() const { return &amp;T::FunctionName; } }; } const ::clang::ast_matchers::internal::TypeTraversePolymorphicMatcher&lt; QualType, ::clang::ast_matchers::internal::TypeMatcher##MatcherName##Getter, ::clang::ast_matchers::internal::TypeTraverseMatcher, ReturnTypesF&gt;::Func MatcherName</cpp:value></cpp:define>











<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_TYPELOC_TRAVERSE_MATCHER_DECL</name><parameter_list>(<parameter><type><name>MatcherName</name></type></parameter>, <parameter><type><name>FunctionName</name></type></parameter>, <parameter><type><name>ReturnTypesF</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>namespace internal { template &lt;typename T&gt; struct TypeLocMatcher##MatcherName##Getter { static TypeLoc (T::*value())() const { return &amp;T::FunctionName##Loc; } }; } extern const ::clang::ast_matchers::internal:: TypeTraversePolymorphicMatcher&lt; TypeLoc, ::clang::ast_matchers::internal:: TypeLocMatcher##MatcherName##Getter, ::clang::ast_matchers::internal::TypeLocTraverseMatcher, ReturnTypesF&gt;::Func MatcherName##Loc; AST_TYPE_TRAVERSE_MATCHER_DECL(MatcherName, FunctionName##Type, ReturnTypesF)</cpp:value></cpp:define>















<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_TYPELOC_TRAVERSE_MATCHER_DEF</name><parameter_list>(<parameter><type><name>MatcherName</name></type></parameter>, <parameter><type><name>ReturnTypesF</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>const ::clang::ast_matchers::internal::TypeTraversePolymorphicMatcher&lt; TypeLoc, ::clang::ast_matchers::internal::TypeLocMatcher##MatcherName##Getter, ::clang::ast_matchers::internal::TypeLocTraverseMatcher, ReturnTypesF&gt;::Func MatcherName##Loc; AST_TYPE_TRAVERSE_MATCHER_DEF(MatcherName, ReturnTypesF)</cpp:value></cpp:define>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_TYPELOC_TRAVERSE_MATCHER</name><parameter_list>(<parameter><type><name>MatcherName</name></type></parameter>, <parameter><type><name>FunctionName</name></type></parameter>, <parameter><type><name>ReturnTypesF</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>namespace internal { template &lt;typename T&gt; struct TypeLocMatcher##MatcherName##Getter { static TypeLoc (T::*value())() const { return &amp;T::FunctionName##Loc; } }; } const ::clang::ast_matchers::internal::TypeTraversePolymorphicMatcher&lt; TypeLoc, ::clang::ast_matchers::internal::TypeLocMatcher##MatcherName##Getter, ::clang::ast_matchers::internal::TypeLocTraverseMatcher, ReturnTypesF&gt;::Func MatcherName##Loc; AST_TYPE_TRAVERSE_MATCHER(MatcherName, FunctionName##Type, ReturnTypesF)</cpp:value></cpp:define>

























<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_MATCHER_REGEX</name><parameter_list>(<parameter><type><name>Type</name></type></parameter>, <parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>Param</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>AST_MATCHER_REGEX_OVERLOAD(Type, DefineMatcher, Param, 0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_MATCHER_REGEX_OVERLOAD</name><parameter_list>(<parameter><type><name>Type</name></type></parameter>, <parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>Param</name></type></parameter>, <parameter><type><name>OverloadId</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>namespace internal { class matcher_##DefineMatcher##OverloadId##Matcher : public ::clang::ast_matchers::internal::MatcherInterface&lt;Type&gt; { public: explicit matcher_##DefineMatcher##OverloadId##Matcher( std::shared_ptr&lt;llvm::Regex&gt; RE) : Param(std::move(RE)) {} bool matches(const Type &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const override; private: std::shared_ptr&lt;llvm::Regex&gt; Param; }; } inline ::clang::ast_matchers::internal::Matcher&lt;Type&gt; DefineMatcher( llvm::StringRef Param, llvm::Regex::RegexFlags RegexFlags) { return ::clang::ast_matchers::internal::makeMatcher( new internal::matcher_##DefineMatcher##OverloadId##Matcher( ::clang::ast_matchers::internal::createAndVerifyRegex( Param, RegexFlags, #DefineMatcher))); } inline ::clang::ast_matchers::internal::Matcher&lt;Type&gt; DefineMatcher( llvm::StringRef Param) { return DefineMatcher(Param, llvm::Regex::NoFlags); } typedef ::clang::ast_matchers::internal::Matcher&lt;Type&gt; ( &amp;DefineMatcher##_Type##OverloadId##Flags)(llvm::StringRef, llvm::Regex::RegexFlags); typedef ::clang::ast_matchers::internal::Matcher&lt;Type&gt; ( &amp;DefineMatcher##_Type##OverloadId)(llvm::StringRef); inline bool internal::matcher_##DefineMatcher##OverloadId##Matcher::matches( const Type &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const</cpp:value></cpp:define>














































<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_POLYMORPHIC_MATCHER_REGEX</name><parameter_list>(<parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>ReturnTypesF</name></type></parameter>, <parameter><type><name>Param</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>AST_POLYMORPHIC_MATCHER_REGEX_OVERLOAD(DefineMatcher, ReturnTypesF, Param, 0)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AST_POLYMORPHIC_MATCHER_REGEX_OVERLOAD</name><parameter_list>(<parameter><type><name>DefineMatcher</name></type></parameter>, <parameter><type><name>ReturnTypesF</name></type></parameter>, <parameter><type><name>Param</name></type></parameter>, <parameter><type><name>OverloadId</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>namespace internal { template &lt;typename NodeType, typename ParamT&gt; class matcher_##DefineMatcher##OverloadId##Matcher : public ::clang::ast_matchers::internal::MatcherInterface&lt;NodeType&gt; { public: explicit matcher_##DefineMatcher##OverloadId##Matcher( std::shared_ptr&lt;llvm::Regex&gt; RE) : Param(std::move(RE)) {} bool matches(const NodeType &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const override; private: std::shared_ptr&lt;llvm::Regex&gt; Param; }; } inline ::clang::ast_matchers::internal::PolymorphicMatcher&lt; internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF, std::shared_ptr&lt;llvm::Regex&gt;&gt; DefineMatcher(llvm::StringRef Param, llvm::Regex::RegexFlags RegexFlags) { return ::clang::ast_matchers::internal::PolymorphicMatcher&lt; internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF, std::shared_ptr&lt;llvm::Regex&gt;&gt;( ::clang::ast_matchers::internal::createAndVerifyRegex( Param, RegexFlags, #DefineMatcher)); } inline ::clang::ast_matchers::internal::PolymorphicMatcher&lt; internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF, std::shared_ptr&lt;llvm::Regex&gt;&gt; DefineMatcher(llvm::StringRef Param) { return DefineMatcher(Param, llvm::Regex::NoFlags); } typedef ::clang::ast_matchers::internal::PolymorphicMatcher&lt; internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF, std::shared_ptr&lt;llvm::Regex&gt;&gt; ( &amp;DefineMatcher##_Type##OverloadId##Flags)( llvm::StringRef Param, llvm::Regex::RegexFlags RegexFlags); typedef ::clang::ast_matchers::internal::PolymorphicMatcher&lt; internal::matcher_##DefineMatcher##OverloadId##Matcher, ReturnTypesF, std::shared_ptr&lt;llvm::Regex&gt;&gt; (&amp;DefineMatcher##_Type##OverloadId)( llvm::StringRef Param); template &lt;typename NodeType, typename ParamT&gt; bool internal:: matcher_##DefineMatcher##OverloadId##Matcher&lt;NodeType, ParamT&gt;::matches( const NodeType &amp;Node, ::clang::ast_matchers::internal::ASTMatchFinder *Finder, ::clang::ast_matchers::internal::BoundNodesTreeBuilder *Builder) const</cpp:value></cpp:define>



















































<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
