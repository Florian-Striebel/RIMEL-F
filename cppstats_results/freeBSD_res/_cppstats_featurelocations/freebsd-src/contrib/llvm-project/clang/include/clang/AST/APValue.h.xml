<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/APValue.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_APVALUE_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_APVALUE_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/LLVM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APFixedPoint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APFloat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/APSInt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/FoldingSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerIntPair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/PointerUnion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Support/AlignOf.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>namespace</name></type> <name>serialization</name> <block>{<block_content>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>BasicReaderBase</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>AddrLabelExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CharUnits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXRecordDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DiagnosticBuilder</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FieldDecl</name></decl>;</decl_stmt>
<struct_decl>struct <name>PrintingPolicy</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>Type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ValueDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>QualType</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>TypeInfoLValue</name> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Type</name> <modifier>*</modifier></type><name>T</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>TypeInfoLValue</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>T</name><argument_list>()</argument_list></macro> <block>{}</block>
<name>explicit</name> <call><name>TypeInfoLValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>Type</name> <operator>*</operator><macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>T</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>T</name></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name> <modifier>*</modifier></type><name>getOpaqueValue</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>Type</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>TypeInfoLValue</name></type> <name>getFromOpaqueValue</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>Value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>TypeInfoLValue</name></type> <name>V</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>V</name><operator>.</operator><name>T</name></name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Type</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>V</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name></type> <name>print</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>raw_ostream</name> <operator>&amp;</operator><name>Out</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>DynamicAllocLValue</name> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>Index</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>DynamicAllocLValue</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Index</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <block>{}</block>
<name>explicit</name> <macro><name>DynamicAllocLValue</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Index</name><argument_list>(<argument>Index + <literal type="number">1</literal></argument>)</argument_list></macro> <block>{}</block>
<name>unsigned</name> <macro><name>getIndex</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>Index</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Index</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return> }</block></expr></expr_stmt>

<function><type><name>void</name> <modifier>*</modifier></type><name>getOpaqueValue</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Index</name></expr></argument>)</argument_list></call>
<operator>&lt;&lt;</operator> <name>NumLowBitsAvailable</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>DynamicAllocLValue</name></type> <name>getFromOpaqueValue</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>Value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DynamicAllocLValue</name></type> <name>V</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>V</name><operator>.</operator><name>Index</name></name> <operator>=</operator> <call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>uintptr_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <name>NumLowBitsAvailable</name></expr>;</expr_stmt>
<return>return <expr><name>V</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>getMaxIndex</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><operator>(</operator><name>std</name><operator>::</operator><name><name>numeric_limits</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name><operator>::</operator><call><name>max</name><argument_list>()</argument_list></call> <operator>&gt;&gt;</operator> <name>NumLowBitsAvailable</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>constexpr</name> <name>int</name></type> <name>NumLowBitsAvailable</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>
<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>PointerLikeTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>TypeInfoLValue</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>void</name> <operator>*</operator><macro><name>getAsVoidPointer</name><argument_list>(<argument>clang::TypeInfoLValue V</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>V</name><operator>.</operator><name>getOpaqueValue</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>clang</name><operator>::</operator><name>TypeInfoLValue</name> <macro><name>getFromVoidPointer</name><argument_list>(<argument>void *P</argument>)</argument_list></macro> <block>{
<return>return <expr><name>clang</name><operator>::</operator><name>TypeInfoLValue</name><operator>::</operator><call><name>getFromOpaqueValue</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<specifier>static</specifier> <name>constexpr</name> <name>int</name> <name>NumLowBitsAvailable</name> <operator>=</operator> <literal type="number">3</literal></expr>;
}</block></expr>;</expr_stmt>

<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>PointerLikeTypeTraits</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>DynamicAllocLValue</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>void</name> <operator>*</operator><macro><name>getAsVoidPointer</name><argument_list>(<argument>clang::DynamicAllocLValue V</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>V</name><operator>.</operator><name>getOpaqueValue</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>clang</name><operator>::</operator><name>DynamicAllocLValue</name> <macro><name>getFromVoidPointer</name><argument_list>(<argument>void *P</argument>)</argument_list></macro> <block>{
<return>return <expr><name>clang</name><operator>::</operator><name>DynamicAllocLValue</name><operator>::</operator><call><name>getFromOpaqueValue</name><argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<specifier>static</specifier> <name>constexpr</name> <name>int</name> <name>NumLowBitsAvailable</name> <operator>=</operator>
<name>clang</name><operator>::</operator><name>DynamicAllocLValue</name><operator>::</operator><name>NumLowBitsAvailable</name></expr>;
}</block></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>



<decl_stmt><decl><type><name>class</name></type> <name>APValue</name> <block>{<block_content>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name>APFixedPoint</name> <name>APFixedPoint</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <name>APSInt</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name>APFloat</name> <name>APFloat</name></expr>;</expr_stmt></typedef>
<label><name>public</name>:</label>
<enum>enum <name>ValueKind</name> <block>{

<decl><name>None</name></decl>,

<decl><name>Indeterminate</name></decl>,
<decl><name>Int</name></decl>,
<decl><name>Float</name></decl>,
<decl><name>FixedPoint</name></decl>,
<decl><name>ComplexInt</name></decl>,
<decl><name>ComplexFloat</name></decl>,
<decl><name>LValue</name></decl>,
<decl><name>Vector</name></decl>,
<decl><name>Array</name></decl>,
<decl><name>Struct</name></decl>,
<decl><name>Union</name></decl>,
<decl><name>MemberPointer</name></decl>,
<decl><name>AddrLabelDiff</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>LValueBase</name> <block>{<block_content>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><name>TypeInfoLValue</name></expr></argument>,
<argument><expr><name>DynamicAllocLValue</name></expr></argument>&gt;</argument_list></name>
<name>PtrTy</name></expr>;</expr_stmt></typedef>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>LValueBase</name><argument_list>()</argument_list></call> <operator>:</operator> <name>Local</name><block>{}</block> <block>{}</block>
<macro><name>LValueBase</name><argument_list>(<argument>const ValueDecl *P</argument>, <argument>unsigned I = <literal type="number">0</literal></argument>, <argument>unsigned V = <literal type="number">0</literal></argument>)</argument_list></macro></expr>;</expr_stmt>
<macro><name>LValueBase</name><argument_list>(<argument>const Expr *P</argument>, <argument>unsigned I = <literal type="number">0</literal></argument>, <argument>unsigned V = <literal type="number">0</literal></argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>LValueBase</name></type> <name>getDynamicAlloc</name><parameter_list>(<parameter><decl><type><name>DynamicAllocLValue</name></type> <name>LV</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>LValueBase</name></type> <name>getTypeInfo</name><parameter_list>(<parameter><decl><type><name>TypeInfoLValue</name></type> <name>LV</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>TypeInfo</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>bool</name> <macro><name>is</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Ptr</name><operator>.</operator><name>is</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <macro><name>get</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Ptr</name><operator>.</operator><name>get</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>T</name> <macro><name>dyn_cast</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name><name>Ptr</name><operator>.</operator><name>dyn_cast</name></name><operator>&lt;</operator><name>T</name><operator>&gt;</operator><operator>(</operator><operator>)</operator></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>void</name> <operator>*</operator><macro><name>getOpaqueValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isNull</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getCallIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>QualType</name> <macro><name>getTypeInfoType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>QualType</name> <macro><name>getDynamicAllocType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>QualType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>LValueBase</name> <operator>&amp;</operator><name>LHS</name><operator>,</operator> <specifier>const</specifier> <name>LValueBase</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>LValueBase</name> <operator>&amp;</operator><name>LHS</name><operator>,</operator> <specifier>const</specifier> <name>LValueBase</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><name>LHS</name> <operator>==</operator> <name>RHS</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>friend</name> <name>llvm</name><operator>::</operator><name>hash_code</name> <call><name>hash_value</name><argument_list>(<argument><expr><specifier>const</specifier> <name>LValueBase</name> <operator>&amp;</operator><name>Base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>friend</name></macro> struct <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMapInfo</name><argument_list type="generic">&lt;<argument><expr><name>LValueBase</name></expr></argument>&gt;</argument_list></name></expr>;</expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>PtrTy</name></type> <name>Ptr</name></decl>;</decl_stmt>
<struct>struct <name>LocalState</name> <block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>CallIndex</name></decl>, <decl><type ref="prev"/><name>Version</name></decl>;</decl_stmt>
}</block>;</struct>
<union>union <block>{
<decl_stmt><decl><type><name>LocalState</name></type> <name>Local</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>TypeInfoType</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>DynamicAllocType</name></decl>;</decl_stmt>
}</block>;</union>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>BaseOrMemberType</name></expr>;</expr_stmt></typedef>


<decl_stmt><decl><type><name>class</name></type> <name>LValuePathEntry</name> <block>{<block_content>
<expr_stmt><expr><call><name>static_assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uintptr_t</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"pointer doesn't fit in 64 bits?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>uint64_t</name></type> <name>Value</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>LValuePathEntry</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Value</name><argument_list>()</argument_list></macro> <block>{}</block>
<macro><name>LValuePathEntry</name><argument_list>(<argument>BaseOrMemberType BaseOrMember</argument>)</argument_list></macro></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>LValuePathEntry</name></type> <name>ArrayIndex</name><parameter_list>(<parameter><decl><type><name>uint64_t</name></type> <name>Index</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>LValuePathEntry</name></type> <name>Result</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>Value</name></name> <operator>=</operator> <name>Index</name></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>BaseOrMemberType</name> <macro><name>getAsBaseOrMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>BaseOrMemberType</name><operator>::</operator><call><name>getFromOpaqueValue</name><argument_list>(
<argument><expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>uint64_t</name> <macro><name>getAsArrayIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Value</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><name>LValuePathEntry</name> <name>A</name><operator>,</operator> <name>LValuePathEntry</name> <name>B</name><operator>)</operator> <block>{
<return>return <expr><name><name>A</name><operator>.</operator><name>Value</name></name> <operator>==</operator> <name><name>B</name><operator>.</operator><name>Value</name></name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>friend</name> <name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><name>LValuePathEntry</name> <name>A</name><operator>,</operator> <name>LValuePathEntry</name> <name>B</name><operator>)</operator> <block>{
<return>return <expr><name><name>A</name><operator>.</operator><name>Value</name></name> <operator>!=</operator> <name><name>B</name><operator>.</operator><name>Value</name></name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>friend</name> <name>llvm</name><operator>::</operator><name>hash_code</name> <macro><name>hash_value</name><argument_list>(<argument>LValuePathEntry A</argument>)</argument_list></macro> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>hash_value</name><argument_list>(<argument><expr><name><name>A</name><operator>.</operator><name>Value</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LValuePathSerializationHelper</name> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ElemTy</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>LValuePathEntry</name></expr></argument>&gt;</argument_list></name></type> <name>Path</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>LValuePathSerializationHelper</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>LValuePathEntry</name></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>QualType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><name>QualType</name></type> <name>getType</name><parameter_list>()</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<struct>struct <name>NoLValuePath</name> <block>{}</block>;</struct>
<struct>struct <name>UninitArray</name> <block>{}</block>;</struct>
<struct>struct <name>UninitStruct</name> <block>{}</block>;</struct>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>Impl</name></expr></argument>&gt;</argument_list></name> <name>friend</name> <name>class</name> <name>clang</name><operator>::</operator><name>serialization</name><operator>::</operator><name>BasicReaderBase</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTImporter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTNodeImporter</name></decl>;</decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>ValueKind</name></type> <name>Kind</name></decl>;</decl_stmt>

<struct>struct <name>ComplexAPSInt</name> <block>{
<decl_stmt><decl><type><name>APSInt</name></type> <name>Real</name></decl>, <decl><type ref="prev"/><name>Imag</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ComplexAPSInt</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>Real</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Imag</name><argument_list>(<argument><literal type="number">1</literal></argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>
<struct>struct <name>ComplexAPFloat</name> <block>{
<decl_stmt><decl><type><name>APFloat</name></type> <name>Real</name></decl>, <decl><type ref="prev"/><name>Imag</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ComplexAPFloat</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>Real</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Imag</name><argument_list>(<argument><literal type="number">0.0</literal></argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>
<struct_decl>struct <name>LV</name>;</struct_decl>
<struct>struct <name>Vec</name> <block>{
<decl_stmt><decl><type><name>APValue</name> <modifier>*</modifier></type><name>Elts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumElts</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Vec</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>Elts</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>NumElts</name><argument_list>(<argument><literal type="number">0</literal></argument>)</argument_list></macro> <expr><block>{}</block>
<operator>~</operator><macro><name>Vec</name><argument_list>()</argument_list></macro> <block>{ <expr><name><name>delete</name><index>[]</index></name> <name>Elts</name></expr>; }</block></expr></expr_stmt>
}</block>;</struct>
<struct>struct <name>Arr</name> <block>{
<decl_stmt><decl><type><name>APValue</name> <modifier>*</modifier></type><name>Elts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumElts</name></decl>, <decl><type ref="prev"/><name>ArrSize</name></decl>;</decl_stmt>
<macro><name>Arr</name><argument_list>(<argument>unsigned NumElts</argument>, <argument>unsigned ArrSize</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><operator>~</operator><call><name>Arr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block>;</struct>
<struct>struct <name>StructData</name> <block>{
<decl_stmt><decl><type><name>APValue</name> <modifier>*</modifier></type><name>Elts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumBases</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>NumFields</name></decl>;</decl_stmt>
<macro><name>StructData</name><argument_list>(<argument>unsigned NumBases</argument>, <argument>unsigned NumFields</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><operator>~</operator><call><name>StructData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block>;</struct>
<struct>struct <name>UnionData</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>FieldDecl</name> <modifier>*</modifier></type><name>Field</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>APValue</name> <modifier>*</modifier></type><name>Value</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>UnionData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>~</operator><call><name>UnionData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block>;</struct>
<struct>struct <name>AddrLabelDiffData</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>AddrLabelExpr</name><modifier>*</modifier></type> <name>LHSExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>AddrLabelExpr</name><modifier>*</modifier></type> <name>RHSExpr</name></decl>;</decl_stmt>
}</block>;</struct>
<struct_decl>struct <name>MemberPointerData</name>;</struct_decl>


<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>AlignedCharArrayUnion</name><argument_list type="generic">&lt;<argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>APSInt</name></expr></argument>, <argument><expr><name>APFloat</name></expr></argument>, <argument><expr><name>ComplexAPSInt</name></expr></argument>,
<argument><expr><name>ComplexAPFloat</name></expr></argument>, <argument><expr><name>Vec</name></expr></argument>, <argument><expr><name>Arr</name></expr></argument>, <argument><expr><name>StructData</name></expr></argument>,
<argument><expr><name>UnionData</name></expr></argument>, <argument><expr><name>AddrLabelDiffData</name></expr></argument>&gt;</argument_list></name> <name>DataType</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>size_t</name></type> <name>DataSize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>DataType</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DataType</name></type> <name>Data</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>APValue</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{}</block>
<name>explicit</name> <macro><name>APValue</name><argument_list>(<argument>APSInt I</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{
<expr><call><name>MakeInt</name><argument_list>()</argument_list></call></expr>; <expr><call><name>setInt</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
<name>explicit</name> <macro><name>APValue</name><argument_list>(<argument>APFloat F</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{
<expr><call><name>MakeFloat</name><argument_list>()</argument_list></call></expr>; <expr><call><name>setFloat</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
<name>explicit</name> <macro><name>APValue</name><argument_list>(<argument>APFixedPoint FX</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{
<expr><call><name>MakeFixedPoint</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>FX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
<name>explicit</name> <macro><name>APValue</name><argument_list>(<argument>const APValue *E</argument>, <argument>unsigned N</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{
<expr><call><name>MakeVector</name><argument_list>()</argument_list></call></expr>; <expr><call><name>setVector</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;
}</block>
<macro><name>APValue</name><argument_list>(<argument>APSInt R</argument>, <argument>APSInt I</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{
<expr><call><name>MakeComplexInt</name><argument_list>()</argument_list></call></expr>; <expr><call><name>setComplexInt</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
<macro><name>APValue</name><argument_list>(<argument>APFloat R</argument>, <argument>APFloat I</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{
<expr><call><name>MakeComplexFloat</name><argument_list>()</argument_list></call></expr>; <expr><call><name>setComplexFloat</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
<call><name>APValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>APValue</name> <operator>&amp;</operator><name>RHS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APValue</name><argument_list>(<argument><expr><name>APValue</name> <operator>&amp;&amp;</operator><name>RHS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>APValue</name><argument_list>(<argument>LValueBase B</argument>, <argument>const CharUnits &amp;O</argument>, <argument>NoLValuePath N</argument>,
<argument>bool IsNullPtr = false</argument>)</argument_list></macro>
: <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>MakeLValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>setLValue</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>O</name></expr></argument>, <argument><expr><name>N</name></expr></argument>, <argument><expr><name>IsNullPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>APValue</name><argument_list>(<argument>LValueBase B</argument>, <argument>const CharUnits &amp;O</argument>, <argument>ArrayRef&lt;LValuePathEntry&gt; Path</argument>,
<argument>bool OnePastTheEnd</argument>, <argument>bool IsNullPtr = false</argument>)</argument_list></macro>
: <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>MakeLValue</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>setLValue</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>O</name></expr></argument>, <argument><expr><name>Path</name></expr></argument>, <argument><expr><name>OnePastTheEnd</name></expr></argument>, <argument><expr><name>IsNullPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>APValue</name><argument_list>(<argument>UninitArray</argument>, <argument>unsigned InitElts</argument>, <argument>unsigned Size</argument>)</argument_list></macro> : <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>MakeArray</name><argument_list>(<argument><expr><name>InitElts</name></expr></argument>, <argument><expr><name>Size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>APValue</name><argument_list>(<argument>UninitStruct</argument>, <argument>unsigned B</argument>, <argument>unsigned M</argument>)</argument_list></macro> : <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name>MakeStruct</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>M</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>APValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>APValue</name> <operator>&amp;</operator><name>V</name> <operator>=</operator> <call><name>APValue</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{
<expr><call><name>MakeUnion</name><argument_list>()</argument_list></call></expr>; <expr><call><name>setUnion</name><argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>;
}</block>
<macro><name>APValue</name><argument_list>(<argument>const ValueDecl *Member</argument>, <argument>bool IsDerivedMember</argument>,
<argument>ArrayRef&lt;const CXXRecordDecl*&gt; Path</argument>)</argument_list></macro> <operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{
<expr><call><name>MakeMemberPointer</name><argument_list>(<argument><expr><name>Member</name></expr></argument>, <argument><expr><name>IsDerivedMember</name></expr></argument>, <argument><expr><name>Path</name></expr></argument>)</argument_list></call></expr>;
}</block>
<call><name>APValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>AddrLabelExpr</name><operator>*</operator> <name>LHSExpr</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>AddrLabelExpr</name><operator>*</operator> <name>RHSExpr</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>None</argument>)</argument_list></macro> <block>{
<expr><call><name>MakeAddrLabelDiff</name><argument_list>()</argument_list></call></expr>; <expr><call><name>setAddrLabelDiff</name><argument_list>(<argument><expr><name>LHSExpr</name></expr></argument>, <argument><expr><name>RHSExpr</name></expr></argument>)</argument_list></call></expr>;
}</block>
<specifier>static</specifier> <name>APValue</name> <macro><name>IndeterminateValue</name><argument_list>()</argument_list></macro> <block>{
<expr><name>APValue</name> <name>Result</name></expr>;
<expr><name><name>Result</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>Indeterminate</name></expr>;
<return>return <expr><name>Result</name></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>APValue</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>APValue</name> <operator>&amp;</operator><name>RHS</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>APValue</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><name>APValue</name> <operator>&amp;&amp;</operator><name>RHS</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>~</operator><macro><name>APValue</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>Kind</name> <operator>!=</operator> <name>None</name> <operator>&amp;&amp;</operator> <name>Kind</name> <operator>!=</operator> <name>Indeterminate</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>DestroyDataAndMakeUninit</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>






<expr_stmt><expr><name>bool</name> <macro><name>needsCleanup</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>swap</name><parameter_list>(<parameter><decl><type><name>APValue</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>void</name></type> <name>Profile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>ValueKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isAbsent</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>None</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isIndeterminate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>Indeterminate</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>hasValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>!=</operator> <name>None</name> <operator>&amp;&amp;</operator> <name>Kind</name> <operator>!=</operator> <name>Indeterminate</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isInt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>Int</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isFloat</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>Float</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isFixedPoint</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>FixedPoint</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isComplexInt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>ComplexInt</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isComplexFloat</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>ComplexFloat</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isLValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>LValue</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isVector</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>Vector</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isArray</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>Array</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isStruct</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>Struct</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isUnion</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>Union</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isMemberPointer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>MemberPointer</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isAddrLabelDiff</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name> <operator>==</operator> <name>AddrLabelDiff</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>dump</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>printPretty</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>, <argument><expr><name>QualType</name> <name>Ty</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>printPretty</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>PrintingPolicy</name> <operator>&amp;</operator><name>Policy</name></expr></argument>, <argument><expr><name>QualType</name> <name>Ty</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>*</operator><name>Ctx</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getAsString</name><argument_list>(<argument>const ASTContext &amp;Ctx</argument>, <argument>QualType Ty</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function><type><name>APSInt</name> <modifier>&amp;</modifier></type><name>getInt</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isInt</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><operator>(</operator><name>APSInt</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>APSInt</name> <operator>&amp;</operator><macro><name>getInt</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getInt</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>toIntegralConstant</name><argument_list>(<argument><expr><name>APSInt</name> <operator>&amp;</operator><name>Result</name></expr></argument>, <argument><expr><name>QualType</name> <name>SrcTy</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function><type><name>APFloat</name> <modifier>&amp;</modifier></type><name>getFloat</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isFloat</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><operator>(</operator><name>APFloat</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>APFloat</name> <operator>&amp;</operator><macro><name>getFloat</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getFloat</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>APFixedPoint</name> <modifier>&amp;</modifier></type><name>getFixedPoint</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isFixedPoint</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><operator>(</operator><name>APFixedPoint</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>APFixedPoint</name> <operator>&amp;</operator><macro><name>getFixedPoint</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name> <operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getFixedPoint</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>APSInt</name> <modifier>&amp;</modifier></type><name>getComplexIntReal</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isComplexInt</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>(</operator><name>ComplexAPSInt</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>Real</name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>APSInt</name> <operator>&amp;</operator><macro><name>getComplexIntReal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getComplexIntReal</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>APSInt</name> <modifier>&amp;</modifier></type><name>getComplexIntImag</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isComplexInt</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>(</operator><name>ComplexAPSInt</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>Imag</name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>APSInt</name> <operator>&amp;</operator><macro><name>getComplexIntImag</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getComplexIntImag</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>APFloat</name> <modifier>&amp;</modifier></type><name>getComplexFloatReal</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isComplexFloat</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>(</operator><name>ComplexAPFloat</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>Real</name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>APFloat</name> <operator>&amp;</operator><macro><name>getComplexFloatReal</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getComplexFloatReal</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>APFloat</name> <modifier>&amp;</modifier></type><name>getComplexFloatImag</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isComplexFloat</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>(</operator><name>ComplexAPFloat</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>Imag</name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>APFloat</name> <operator>&amp;</operator><macro><name>getComplexFloatImag</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getComplexFloatImag</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>LValueBase</name> <macro><name>getLValueBase</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<function_decl><type><name>CharUnits</name> <modifier>&amp;</modifier></type><name>getLValueOffset</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><specifier>const</specifier> <name>CharUnits</name> <operator>&amp;</operator><macro><name>getLValueOffset</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getLValueOffset</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isLValueOnePastTheEnd</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>hasLValuePath</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>LValuePathEntry</name></expr></argument>&gt;</argument_list></name> <macro><name>getLValuePath</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getLValueCallIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getLValueVersion</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isNullPointer</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function><type><name>APValue</name> <modifier>&amp;</modifier></type><name>getVectorElt</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isVector</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getVectorLength</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Index out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>(</operator><name>Vec</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name><name>Elts</name><index>[<expr><name>I</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>const</specifier> <name>APValue</name> <modifier>&amp;</modifier></type><name>getVectorElt</name><argument_list>(<argument><expr><name>unsigned</name> <name>I</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getVectorElt</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getVectorLength</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isVector</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Vec</name> <operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>NumElts</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>APValue</name> <modifier>&amp;</modifier></type><name>getArrayInitializedElt</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isArray</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>I</name> <operator>&lt;</operator> <call><name>getArrayInitializedElts</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Index out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>(</operator><name>Arr</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name><name>Elts</name><index>[<expr><name>I</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>const</specifier> <name>APValue</name> <modifier>&amp;</modifier></type><name>getArrayInitializedElt</name><argument_list>(<argument><expr><name>unsigned</name> <name>I</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getArrayInitializedElt</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>hasArrayFiller</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getArrayInitializedElts</name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name>getArraySize</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>APValue</name> <modifier>&amp;</modifier></type><name>getArrayFiller</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isArray</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>hasArrayFiller</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"No array filler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>(</operator><name>Arr</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name><name>Elts</name><index>[<expr><call><name>getArrayInitializedElts</name><argument_list>()</argument_list></call></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>APValue</name> <operator>&amp;</operator><macro><name>getArrayFiller</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getArrayFiller</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getArrayInitializedElts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isArray</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Arr</name> <operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>NumElts</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getArraySize</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isArray</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>Arr</name> <operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>ArrSize</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getStructNumBases</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isStruct</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>StructData</name> <operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>NumBases</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>unsigned</name> <macro><name>getStructNumFields</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isStruct</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>StructData</name> <operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>NumFields</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>APValue</name> <modifier>&amp;</modifier></type><name>getStructBase</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isStruct</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getStructNumBases</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"base class index OOB"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>(</operator><name>StructData</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name><name>Elts</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<function><type><name>APValue</name> <modifier>&amp;</modifier></type><name>getStructField</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isStruct</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <call><name>getStructNumFields</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"field index OOB"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>(</operator><operator>(</operator><name>StructData</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name><name>Elts</name><index>[<expr><call><name>getStructNumBases</name><argument_list>()</argument_list></call> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>
<decl_stmt><decl><type><specifier>const</specifier> <name>APValue</name> <modifier>&amp;</modifier></type><name>getStructBase</name><argument_list>(<argument><expr><name>unsigned</name> <name>i</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getStructBase</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>APValue</name> <modifier>&amp;</modifier></type><name>getStructField</name><argument_list>(<argument><expr><name>unsigned</name> <name>i</name></expr></argument>)</argument_list> const <block>{<block_content>
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getStructField</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>FieldDecl</name> <operator>*</operator><macro><name>getUnionField</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isUnion</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>UnionData</name> <operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>Field</name></expr>;</return>
}</block></expr></expr_stmt>
<function><type><name>APValue</name> <modifier>&amp;</modifier></type><name>getUnionValue</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isUnion</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>UnionData</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>Value</name></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><specifier>const</specifier> <name>APValue</name> <operator>&amp;</operator><macro><name>getUnionValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><call><name>getUnionValue</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><macro><name>getMemberPointerDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isMemberPointerToDerivedMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getMemberPointerPath</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>AddrLabelExpr</name><operator>*</operator> <macro><name>getAddrLabelDiffLHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isAddrLabelDiff</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>AddrLabelDiffData</name> <operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>LHSExpr</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>AddrLabelExpr</name><operator>*</operator> <macro><name>getAddrLabelDiffRHS</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isAddrLabelDiff</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>AddrLabelDiffData</name> <operator>*</operator><operator>)</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>RHSExpr</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>setInt</name><parameter_list>(<parameter><decl><type><name>APSInt</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isInt</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>APSInt</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setFloat</name><parameter_list>(<parameter><decl><type><name>APFloat</name></type> <name>F</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isFloat</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>APFloat</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setFixedPoint</name><parameter_list>(<parameter><decl><type><name>APFixedPoint</name></type> <name>FX</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isFixedPoint</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>APFixedPoint</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>FX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setVector</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>APValue</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name></expr></argument>&gt;</argument_list></name></type> <name>InternalElts</name> <init>= <expr><call><name>setVectorUninit</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>N</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>InternalElts</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>E</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setComplexInt</name><parameter_list>(<parameter><decl><type><name>APSInt</name></type> <name>R</name></decl></parameter>, <parameter><decl><type><name>APSInt</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>R</name><operator>.</operator><name>getBitWidth</name></name><argument_list>()</argument_list></call> <operator>==</operator> <call><name><name>I</name><operator>.</operator><name>getBitWidth</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Invalid complex int (type mismatch)."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isComplexInt</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ComplexAPSInt</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>Real</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ComplexAPSInt</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>Imag</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>setComplexFloat</name><parameter_list>(<parameter><decl><type><name>APFloat</name></type> <name>R</name></decl></parameter>, <parameter><decl><type><name>APFloat</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>&amp;</operator><call><name><name>R</name><operator>.</operator><name>getSemantics</name></name><argument_list>()</argument_list></call> <operator>==</operator> <operator>&amp;</operator><call><name><name>I</name><operator>.</operator><name>getSemantics</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Invalid complex float (type mismatch)."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isComplexFloat</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ComplexAPFloat</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>Real</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>ComplexAPFloat</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>Imag</name> <operator>=</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>setLValue</name><parameter_list>(<parameter><decl><type><name>LValueBase</name></type> <name>B</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CharUnits</name> <modifier>&amp;</modifier></type><name>O</name></decl></parameter>, <parameter><decl><type><name>NoLValuePath</name></type></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsNullPtr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setLValue</name><parameter_list>(<parameter><decl><type><name>LValueBase</name></type> <name>B</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CharUnits</name> <modifier>&amp;</modifier></type><name>O</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>LValuePathEntry</name></expr></argument>&gt;</argument_list></name></type> <name>Path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>OnePastTheEnd</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsNullPtr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setUnion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FieldDecl</name> <modifier>*</modifier></type><name>Field</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>APValue</name> <modifier>&amp;</modifier></type><name>Value</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>setAddrLabelDiff</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AddrLabelExpr</name><modifier>*</modifier></type> <name>LHSExpr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>AddrLabelExpr</name><modifier>*</modifier></type> <name>RHSExpr</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>AddrLabelDiffData</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>LHSExpr</name> <operator>=</operator> <name>LHSExpr</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>AddrLabelDiffData</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator><operator>-&gt;</operator><name>RHSExpr</name> <operator>=</operator> <name>RHSExpr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>private</name>:</label>
<function_decl><type><name>void</name></type> <name>DestroyDataAndMakeUninit</name><parameter_list>()</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>MakeInt</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isAbsent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Bad state change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>(void *)&amp;Data</argument>)</argument_list></macro> <expr_stmt><expr><call><name>APSInt</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>Int</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>MakeFloat</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isAbsent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Bad state change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>(void *)(char *)&amp;Data</argument>)</argument_list></macro> <expr_stmt><expr><call><name>APFloat</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>Float</name></expr>;</expr_stmt>
</block_content>}</block></function>
<decl_stmt><decl><type><name>void</name></type> <name>MakeFixedPoint</name><argument_list>(<argument><expr><name>APFixedPoint</name> <operator>&amp;&amp;</operator><name>FX</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isAbsent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Bad state change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>(void *)(char *)&amp;Data</argument>)</argument_list></macro> <expr_stmt><expr><call><name>APFixedPoint</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>FX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>FixedPoint</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>
<function><type><name>void</name></type> <name>MakeVector</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isAbsent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Bad state change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>(void *)(char *)&amp;Data</argument>)</argument_list></macro> <expr_stmt><expr><call><name>Vec</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>Vector</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>MakeComplexInt</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isAbsent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Bad state change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>(void *)(char *)&amp;Data</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ComplexAPSInt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>ComplexInt</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>MakeComplexFloat</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isAbsent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Bad state change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>(void *)(char *)&amp;Data</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ComplexAPFloat</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>ComplexFloat</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>MakeLValue</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MakeArray</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>InitElts</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Size</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>MakeStruct</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>B</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>M</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isAbsent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Bad state change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>(void *)(char *)&amp;Data</argument>)</argument_list></macro> <expr_stmt><expr><call><name>StructData</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>M</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>Struct</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>MakeUnion</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isAbsent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Bad state change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>(void *)(char *)&amp;Data</argument>)</argument_list></macro> <expr_stmt><expr><call><name>UnionData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>Union</name></expr>;</expr_stmt>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>MakeMemberPointer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ValueDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsDerivedMember</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Path</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>void</name></type> <name>MakeAddrLabelDiff</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isAbsent</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Bad state change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>new</name> <argument_list>(<argument>(void *)(char *)&amp;Data</argument>)</argument_list></macro> <expr_stmt><expr><call><name>AddrLabelDiffData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Kind</name> <operator>=</operator> <name>AddrLabelDiff</name></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>private</name>:</label>



<function><type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>APValue</name></expr></argument>&gt;</argument_list></name></type> <name>setVectorUninit</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>N</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isVector</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <literal type="string">"Invalid accessor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Vec</name> <modifier>*</modifier></type><name>V</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Vec</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>Data</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>V</name><operator>-&gt;</operator><name>Elts</name></name> <operator>=</operator> <name>new</name> <name><name>APValue</name><index>[<expr><name>N</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>V</name><operator>-&gt;</operator><name>NumElts</name></name> <operator>=</operator> <name>N</name></expr>;</expr_stmt>
<return>return <expr><block>{<expr><name><name>V</name><operator>-&gt;</operator><name>Elts</name></name></expr>, <expr><name><name>V</name><operator>-&gt;</operator><name>NumElts</name></name></expr>}</block></expr>;</return>
</block_content>}</block></function>
<function_decl><type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>LValuePathEntry</name></expr></argument>&gt;</argument_list></name></type>
<name>setLValueUninit</name><parameter_list>(<parameter><decl><type><name>LValueBase</name></type> <name>B</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CharUnits</name> <modifier>&amp;</modifier></type><name>O</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Size</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>OnePastTheEnd</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsNullPtr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type>
<name>setMemberPointerUninit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ValueDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsDerivedMember</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Size</name></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>
<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>DenseMapInfo</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>APValue</name><operator>::</operator><name>LValueBase</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><specifier>static</specifier> <name>clang</name><operator>::</operator><name>APValue</name><operator>::</operator><name>LValueBase</name> <call><name>getEmptyKey</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>clang</name><operator>::</operator><name>APValue</name><operator>::</operator><name>LValueBase</name> <call><name>getTombstoneKey</name><argument_list>()</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>unsigned</name> <call><name>getHashValue</name><argument_list>(<argument><expr><specifier>const</specifier> <name>clang</name><operator>::</operator><name>APValue</name><operator>::</operator><name>LValueBase</name> <operator>&amp;</operator><name>Base</name></expr></argument>)</argument_list></call></expr>;
<expr><specifier>static</specifier> <name>bool</name> <call><name>isEqual</name><argument_list>(<argument><expr><specifier>const</specifier> <name>clang</name><operator>::</operator><name>APValue</name><operator>::</operator><name>LValueBase</name> <operator>&amp;</operator><name>LHS</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>clang</name><operator>::</operator><name>APValue</name><operator>::</operator><name>LValueBase</name> <operator>&amp;</operator><name>RHS</name></expr></argument>)</argument_list></call></expr>;
}</block></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
