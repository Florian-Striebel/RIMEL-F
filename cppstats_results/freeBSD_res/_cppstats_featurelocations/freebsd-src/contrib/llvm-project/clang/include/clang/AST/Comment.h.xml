<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/AST/Comment.h">











<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_AST_COMMENT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_AST_COMMENT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/CommentCommandTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/SourceLocation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/StringRef.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParmVarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateParameterList</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>comments</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>FullComment</name></decl>;</decl_stmt>






<enum>enum <name>CommandMarkerKind</name> <block>{




<decl><name>CMK_Backslash</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,





<decl><name>CMK_At</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>
}</block>;</enum>



<decl_stmt><decl><type><name>class</name></type> <name>Comment</name> <block>{<block_content>
<label><name>protected</name>:</label>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceRange</name></type> <name>Range</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>CommentBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>Comment</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>Kind</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <block>{ <decl><name>NumCommentBits</name> <init>= <expr><literal type="number">8</literal></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>InlineContentCommentBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>InlineContentComment</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumCommentBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>HasTrailingNewline</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <block>{ <decl><name>NumInlineContentCommentBits</name> <init>= <expr><name>NumCommentBits</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>TextCommentBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>TextComment</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumInlineContentCommentBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>mutable</name> <name>unsigned</name></type> <name>IsWhitespaceValid</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>mutable</name> <name>unsigned</name></type> <name>IsWhitespace</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <block>{ <decl><name>NumTextCommentBits</name> <init>= <expr><name>NumInlineContentCommentBits</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>InlineCommandCommentBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>InlineCommandComment</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumInlineContentCommentBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>RenderKind</name> <range>: <expr><literal type="number">3</literal></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>CommandID</name> <range>: <expr><name>CommandInfo</name><operator>::</operator><name>NumCommandIDBits</name></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <block>{ <decl><name>NumInlineCommandCommentBits</name> <init>= <expr><name>NumInlineContentCommentBits</name> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator>
<name>CommandInfo</name><operator>::</operator><name>NumCommandIDBits</name></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>HTMLTagCommentBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>HTMLTagComment</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumInlineContentCommentBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsMalformed</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <block>{ <decl><name>NumHTMLTagCommentBits</name> <init>= <expr><name>NumInlineContentCommentBits</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>HTMLStartTagCommentBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>HTMLStartTagComment</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumHTMLTagCommentBits</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>IsSelfClosing</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <block>{ <decl><name>NumHTMLStartTagCommentBits</name> <init>= <expr><name>NumHTMLTagCommentBits</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>ParagraphCommentBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ParagraphComment</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumCommentBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>mutable</name> <name>unsigned</name></type> <name>IsWhitespaceValid</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>mutable</name> <name>unsigned</name></type> <name>IsWhitespace</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <block>{ <decl><name>NumParagraphCommentBits</name> <init>= <expr><name>NumCommentBits</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>BlockCommandCommentBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>BlockCommandComment</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumCommentBits</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>CommandID</name> <range>: <expr><name>CommandInfo</name><operator>::</operator><name>NumCommandIDBits</name></expr></range></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>CommandMarker</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <block>{ <decl><name>NumBlockCommandCommentBits</name> <init>= <expr><name>NumCommentBits</name> <operator>+</operator>
<name>CommandInfo</name><operator>::</operator><name>NumCommandIDBits</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl> }</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>ParamCommandCommentBitfields</name> <block>{<block_content>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ParamCommandComment</name></decl>;</decl_stmt>

<label><name>unsigned</name> :</label> <expr_stmt><expr><name>NumBlockCommandCommentBits</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>Direction</name> <range>: <expr><literal type="number">2</literal></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>IsDirectionExplicit</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<enum>enum <block>{ <decl><name>NumParamCommandCommentBits</name> <init>= <expr><name>NumBlockCommandCommentBits</name> <operator>+</operator> <literal type="number">3</literal></expr></init></decl> }</block>;</enum>

<union>union <block>{
<decl_stmt><decl><type><name>CommentBitfields</name></type> <name>CommentBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>InlineContentCommentBitfields</name></type> <name>InlineContentCommentBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TextCommentBitfields</name></type> <name>TextCommentBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>InlineCommandCommentBitfields</name></type> <name>InlineCommandCommentBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HTMLTagCommentBitfields</name></type> <name>HTMLTagCommentBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HTMLStartTagCommentBitfields</name></type> <name>HTMLStartTagCommentBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParagraphCommentBitfields</name></type> <name>ParagraphCommentBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BlockCommandCommentBitfields</name></type> <name>BlockCommandCommentBits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParamCommandCommentBitfields</name></type> <name>ParamCommandCommentBits</name></decl>;</decl_stmt>
}</block>;</union>

<function><type><name>void</name></type> <name>setSourceRange</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>SR</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Range</name> <operator>=</operator> <name>SR</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>setLocation</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>Loc</name> <operator>=</operator> <name>L</name></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>public</name>:</label>
<enum>enum <name>CommentKind</name> <block>{
<decl><name>NoCommentKind</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMENT</name><parameter_list>(<parameter><type><name>CLASS</name></type></parameter>, <parameter><type><name>PARENT</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>CLASS##Kind,</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMENT_RANGE</name><parameter_list>(<parameter><type><name>BASE</name></type></parameter>, <parameter><type><name>FIRST</name></type></parameter>, <parameter><type><name>LAST</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>First##BASE##Constant=FIRST##Kind, Last##BASE##Constant=LAST##Kind,</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LAST_COMMENT_RANGE</name><parameter_list>(<parameter><type><name>BASE</name></type></parameter>, <parameter><type><name>FIRST</name></type></parameter>, <parameter><type><name>LAST</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>First##BASE##Constant=FIRST##Kind, Last##BASE##Constant=LAST##Kind</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABSTRACT_COMMENT</name><parameter_list>(<parameter><type><name>COMMENT</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/CommentNodes.inc"</cpp:file></cpp:include>
}</block>;</enum>

<macro><name>Comment</name><argument_list>(<argument>CommentKind K</argument>,
<argument>SourceLocation LocBegin</argument>,
<argument>SourceLocation LocEnd</argument>)</argument_list></macro> :
<expr_stmt><expr><call><name>Loc</name><argument_list>(<argument><expr><name>LocBegin</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Range</name><argument_list>(<argument>SourceRange(LocBegin, LocEnd)</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>CommentBits</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>K</name></expr>;
}</block>

<name>CommentKind</name> <macro><name>getCommentKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>CommentKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>CommentBits</name><operator>.</operator><name>Kind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getCommentKindName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>void</name> <macro><name>dump</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>void</name> <macro><name>dumpColor</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>dump</name><argument_list>(<argument><expr><name>raw_ostream</name> <operator>&amp;</operator><name>OS</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<expr_stmt><expr><name>SourceRange</name> <macro><name>getSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Range</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getBegin</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getEndLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>SourceLocation</name> <macro><name>getLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Loc</name></expr>;</return> }</block></expr></expr_stmt>

<typedef>typedef <type><name>Comment</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>child_iterator</name>;</typedef>

<expr_stmt><expr><name>child_iterator</name> <macro><name>child_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>child_iterator</name> <macro><name>child_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>unsigned</name> <macro><name>child_count</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>child_end</name><argument_list>()</argument_list></call> <operator>-</operator> <call><name>child_begin</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>InlineContentComment</name> <range>: <expr><name>public</name> <name>Comment</name> <block>{
<expr><name>protected</name><operator>:</operator>
<macro><name>InlineContentComment</name><argument_list>(<argument>CommentKind K</argument>,
<argument>SourceLocation LocBegin</argument>,
<argument>SourceLocation LocEnd</argument>)</argument_list></macro> <operator>:</operator>
<macro><name>Comment</name><argument_list>(<argument>K</argument>, <argument>LocBegin</argument>, <argument>LocEnd</argument>)</argument_list></macro> <block>{
<expr><name><name>InlineContentCommentBits</name><operator>.</operator><name>HasTrailingNewline</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>FirstInlineContentCommentConstant</name> <operator>&amp;&amp;</operator>
<call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>LastInlineContentCommentConstant</name></expr>;</return>
}</block>

<name>void</name> <macro><name>addTrailingNewline</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>InlineContentCommentBits</name><operator>.</operator><name>HasTrailingNewline</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;
}</block>

<name>bool</name> <macro><name>hasTrailingNewline</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>InlineContentCommentBits</name><operator>.</operator><name>HasTrailingNewline</name></name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>TextComment</name> <operator>:</operator> <name>public</name> <name>InlineContentComment</name> <block>{
<expr><name>StringRef</name> <name>Text</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>TextComment</name><argument_list>(<argument>SourceLocation LocBegin</argument>,
<argument>SourceLocation LocEnd</argument>,
<argument>StringRef Text</argument>)</argument_list></macro> <operator>:</operator>
<call><name>InlineContentComment</name><argument_list>(<argument><expr><name>TextCommentKind</name></expr></argument>, <argument><expr><name>LocBegin</name></expr></argument>, <argument><expr><name>LocEnd</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Text</name><argument_list>(<argument>Text</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>TextCommentBits</name><operator>.</operator><name>IsWhitespaceValid</name></name> <operator>=</operator> <name>false</name></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TextCommentKind</name></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>

<name>child_iterator</name> <macro><name>child_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>

<name>StringRef</name> <macro><name>getText</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>Text</name></expr>;</return> }</block>

<name>bool</name> <macro><name>isWhitespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name><name>TextCommentBits</name><operator>.</operator><name>IsWhitespaceValid</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>TextCommentBits</name><operator>.</operator><name>IsWhitespace</name></name></expr>;</return></block_content></block></if></if_stmt>

<name><name>TextCommentBits</name><operator>.</operator><name>IsWhitespace</name></name> <operator>=</operator> <call><name>isWhitespaceNoCache</name><argument_list>()</argument_list></call></block></expr>;
<expr><name><name>TextCommentBits</name><operator>.</operator><name>IsWhitespaceValid</name></name> <operator>=</operator> <name>true</name></expr>;
<return>return <expr><name><name>TextCommentBits</name><operator>.</operator><name>IsWhitespace</name></name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>bool</name> <macro><name>isWhitespaceNoCache</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr></range></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>InlineCommandComment</name> <range>: <expr><name>public</name> <name>InlineContentComment</name> <block>{
<expr><name>public</name><operator>:</operator>
struct <name>Argument</name> <block>{
<expr><name>SourceRange</name> <name>Range</name></expr>;
<expr><name>StringRef</name> <name>Text</name></expr>;

<macro><name>Argument</name><argument_list>(<argument>SourceRange Range</argument>, <argument>StringRef Text</argument>)</argument_list></macro> <operator>:</operator> <expr><call><name>Range</name><argument_list>(<argument><expr><name>Range</name></expr></argument>)</argument_list></call></expr>, <macro><name>Text</name><argument_list>(<argument>Text</argument>)</argument_list></macro> <expr><block>{ }</block></expr>
}</block></expr>;



enum <expr><name>RenderKind</name> <block>{
<expr><name>RenderNormal</name></expr>,
<expr><name>RenderBold</name></expr>,
<expr><name>RenderMonospaced</name></expr>,
<expr><name>RenderEmphasized</name></expr>,
<expr><name>RenderAnchor</name></expr>
}</block></expr>;

<expr><name>protected</name><operator>:</operator>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Argument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>InlineCommandComment</name><argument_list>(<argument>SourceLocation LocBegin</argument>,
<argument>SourceLocation LocEnd</argument>,
<argument>unsigned CommandID</argument>,
<argument>RenderKind RK</argument>,
<argument>ArrayRef&lt;Argument&gt; Args</argument>)</argument_list></macro> <operator>:</operator>
<call><name>InlineContentComment</name><argument_list>(<argument><expr><name>InlineCommandCommentKind</name></expr></argument>, <argument><expr><name>LocBegin</name></expr></argument>, <argument><expr><name>LocEnd</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Args</name><argument_list>(<argument>Args</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>InlineCommandCommentBits</name><operator>.</operator><name>RenderKind</name></name> <operator>=</operator> <name>RK</name></expr>;
<expr><name><name>InlineCommandCommentBits</name><operator>.</operator><name>CommandID</name></name> <operator>=</operator> <name>CommandID</name></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>InlineCommandCommentKind</name></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>

<name>child_iterator</name> <macro><name>child_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>

<name>unsigned</name> <macro><name>getCommandID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>InlineCommandCommentBits</name><operator>.</operator><name>CommandID</name></name></expr>;</return>
}</block>

<name>StringRef</name> <macro><name>getCommandName</name><argument_list>(<argument>const CommandTraits &amp;Traits</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Traits</name><operator>.</operator><name>getCommandInfo</name></name><argument_list>(<argument><expr><call><name>getCommandID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>Name</name></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getCommandNameRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLocWithOffset</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>RenderKind</name> <macro><name>getRenderKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>RenderKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>InlineCommandCommentBits</name><operator>.</operator><name>RenderKind</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>StringRef</name> <macro><name>getArgText</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Args</name><index>[<expr><name>Idx</name></expr>]</index></name><operator>.</operator><name>Text</name></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getArgRange</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Args</name><index>[<expr><name>Idx</name></expr>]</index></name><operator>.</operator><name>Range</name></expr>;</return>
}</block>
}</expr>;



<expr><name>class</name> <name>HTMLTagComment</name> <operator>:</operator> <name>public</name> <name>InlineContentComment</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>StringRef</name> <name>TagName</name></expr>;
<expr><name>SourceRange</name> <name>TagNameRange</name></expr>;

<macro><name>HTMLTagComment</name><argument_list>(<argument>CommentKind K</argument>,
<argument>SourceLocation LocBegin</argument>,
<argument>SourceLocation LocEnd</argument>,
<argument>StringRef TagName</argument>,
<argument>SourceLocation TagNameBegin</argument>,
<argument>SourceLocation TagNameEnd</argument>)</argument_list></macro> <operator>:</operator>
<expr><call><name>InlineContentComment</name><argument_list>(<argument><expr><name>K</name></expr></argument>, <argument><expr><name>LocBegin</name></expr></argument>, <argument><expr><name>LocEnd</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>TagName</name><argument_list>(<argument><expr><name>TagName</name></expr></argument>)</argument_list></call></expr>,
<macro><name>TagNameRange</name><argument_list>(<argument>TagNameBegin</argument>, <argument>TagNameEnd</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setLocation</name><argument_list>(<argument><expr><name>TagNameBegin</name></expr></argument>)</argument_list></call></expr>;
<expr><name><name>HTMLTagCommentBits</name><operator>.</operator><name>IsMalformed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>FirstHTMLTagCommentConstant</name> <operator>&amp;&amp;</operator>
<call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>LastHTMLTagCommentConstant</name></expr>;</return>
}</block>

<name>StringRef</name> <macro><name>getTagName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{ <return>return <expr><name>TagName</name></expr>;</return> }</block>

<name>SourceRange</name> <macro><name>getTagNameSourceRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<expr><name>SourceLocation</name> <name>L</name> <operator>=</operator> <call><name>getLocation</name><argument_list>()</argument_list></call></expr>;
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name><name>L</name><operator>.</operator><name>getLocWithOffset</name></name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>L</name><operator>.</operator><name>getLocWithOffset</name></name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>+</operator> <call><name><name>TagName</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isMalformed</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>HTMLTagCommentBits</name><operator>.</operator><name>IsMalformed</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setIsMalformed</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>HTMLTagCommentBits</name><operator>.</operator><name>IsMalformed</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;
}</block>
}</expr>;


<expr><name>class</name> <name>HTMLStartTagComment</name> <operator>:</operator> <name>public</name> <name>HTMLTagComment</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>class</name> <name>Attribute</name> <block>{
<expr><name>public</name><operator>:</operator>
<name>SourceLocation</name> <name>NameLocBegin</name></expr>;
<expr><name>StringRef</name> <name>Name</name></expr>;

<expr><name>SourceLocation</name> <name>EqualsLoc</name></expr>;

<expr><name>SourceRange</name> <name>ValueRange</name></expr>;
<expr><name>StringRef</name> <name>Value</name></expr>;

<macro><name>Attribute</name><argument_list>()</argument_list></macro> <expr><block>{ }</block>

<macro><name>Attribute</name><argument_list>(<argument>SourceLocation NameLocBegin</argument>, <argument>StringRef Name</argument>)</argument_list></macro> <operator>:</operator>
<call><name>NameLocBegin</name><argument_list>(<argument><expr><name>NameLocBegin</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Name</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>EqualsLoc</name><argument_list>(<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ValueRange</name><argument_list>(<argument><expr><call><name>SourceRange</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>, <macro><name>Value</name><argument_list>(<argument>StringRef()</argument>)</argument_list></macro>
<expr><block>{ }</block>

<macro><name>Attribute</name><argument_list>(<argument>SourceLocation NameLocBegin</argument>, <argument>StringRef Name</argument>,
<argument>SourceLocation EqualsLoc</argument>,
<argument>SourceRange ValueRange</argument>, <argument>StringRef Value</argument>)</argument_list></macro> <operator>:</operator>
<call><name>NameLocBegin</name><argument_list>(<argument><expr><name>NameLocBegin</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Name</name><argument_list>(<argument><expr><name>Name</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>EqualsLoc</name><argument_list>(<argument><expr><name>EqualsLoc</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>ValueRange</name><argument_list>(<argument><expr><name>ValueRange</name></expr></argument>)</argument_list></call></expr>, <macro><name>Value</name><argument_list>(<argument>Value</argument>)</argument_list></macro>
<expr><block>{ }</block>

<name>SourceLocation</name> <macro><name>getNameLocEnd</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>NameLocBegin</name><operator>.</operator><name>getLocWithOffset</name></name><argument_list>(<argument><expr><call><name><name>Name</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getNameRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>NameLocBegin</name></expr></argument>, <argument><expr><call><name>getNameLocEnd</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;

<expr><name>private</name><operator>:</operator>
<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Attribute</name></expr></argument>&gt;</argument_list></name> <name>Attributes</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>HTMLStartTagComment</name><argument_list>(<argument>SourceLocation LocBegin</argument>,
<argument>StringRef TagName</argument>)</argument_list></macro> <operator>:</operator>
<macro><name>HTMLTagComment</name><argument_list>(<argument>HTMLStartTagCommentKind</argument>,
<argument>LocBegin</argument>, <argument>LocBegin.getLocWithOffset(<literal type="number">1</literal> + TagName.size())</argument>,
<argument>TagName</argument>,
<argument>LocBegin.getLocWithOffset(<literal type="number">1</literal>)</argument>,
<argument>LocBegin.getLocWithOffset(<literal type="number">1</literal> + TagName.size())</argument>)</argument_list></macro> <block>{
<expr><name><name>HTMLStartTagCommentBits</name><operator>.</operator><name>IsSelfClosing</name></name> <operator>=</operator> <name>false</name></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>HTMLStartTagCommentKind</name></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>

<name>child_iterator</name> <macro><name>child_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>

<name>unsigned</name> <macro><name>getNumAttrs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Attributes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Attribute</name> <operator>&amp;</operator><macro><name>getAttr</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Attributes</name><index>[<expr><name>Idx</name></expr>]</index></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setAttrs</name><argument_list>(<argument>ArrayRef&lt;Attribute&gt; Attrs</argument>)</argument_list></macro> <block>{
<expr><name>Attributes</name> <operator>=</operator> <name>Attrs</name></expr>;
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Attrs</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>const</specifier> <name>Attribute</name> <modifier>&amp;</modifier></type><name>Attr</name> <init>= <expr><call><name><name>Attrs</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>L</name> <init>= <expr><call><name><name>Attr</name><operator>.</operator><name>ValueRange</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>L</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Range</name><operator>.</operator><name>setEnd</name></name><argument_list>(<argument><expr><name>L</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name><name>Range</name><operator>.</operator><name>setEnd</name></name><argument_list>(<argument><expr><call><name><name>Attr</name><operator>.</operator><name>getNameLocEnd</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
}

void setGreaterLoc(SourceLocation GreaterLoc</block></else></if_stmt>)</block_content> <block>{<block_content>
<expr_stmt><expr><call><name><name>Range</name><operator>.</operator><name>setEnd</name></name><argument_list>(<argument><expr><name>GreaterLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>

bool isSelfClosing(</block></block></if></if_stmt>) <specifier>const</specifier> <block>{
<return>return <expr><name><name>HTMLStartTagCommentBits</name><operator>.</operator><name>IsSelfClosing</name></name></expr>;</return>
}</block></block>

<name>void</name> <macro><name>setSelfClosing</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>HTMLStartTagCommentBits</name><operator>.</operator><name>IsSelfClosing</name></name> <operator>=</operator> <name>true</name></expr>;
}</block>
}</expr>;


<expr><name>class</name> <name>HTMLEndTagComment</name> <operator>:</operator> <name>public</name> <name>HTMLTagComment</name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>HTMLEndTagComment</name><argument_list>(<argument>SourceLocation LocBegin</argument>,
<argument>SourceLocation LocEnd</argument>,
<argument>StringRef TagName</argument>)</argument_list></macro> <operator>:</operator>
<macro><name>HTMLTagComment</name><argument_list>(<argument>HTMLEndTagCommentKind</argument>,
<argument>LocBegin</argument>, <argument>LocEnd</argument>,
<argument>TagName</argument>,
<argument>LocBegin.getLocWithOffset(<literal type="number">2</literal>)</argument>,
<argument>LocBegin.getLocWithOffset(<literal type="number">2</literal> + TagName.size())</argument>)</argument_list></macro>
<block>{ }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>HTMLEndTagCommentKind</name></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>

<name>child_iterator</name> <macro><name>child_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>
}</expr>;



<expr><name>class</name> <name>BlockContentComment</name> <operator>:</operator> <name>public</name> <name>Comment</name> <block>{
<expr><name>protected</name><operator>:</operator>
<macro><name>BlockContentComment</name><argument_list>(<argument>CommentKind K</argument>,
<argument>SourceLocation LocBegin</argument>,
<argument>SourceLocation LocEnd</argument>)</argument_list></macro> <operator>:</operator>
<macro><name>Comment</name><argument_list>(<argument>K</argument>, <argument>LocBegin</argument>, <argument>LocEnd</argument>)</argument_list></macro>
<block>{ }</block>

<name>public</name><operator>:</operator>
<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>FirstBlockContentCommentConstant</name> <operator>&amp;&amp;</operator>
<call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>LastBlockContentCommentConstant</name></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>ParagraphComment</name> <operator>:</operator> <name>public</name> <name>BlockContentComment</name> <block>{
<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>InlineContentComment</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Content</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>ParagraphComment</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>InlineContentComment</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Content</name></expr></argument>)</argument_list></call> <operator>:</operator>
<call><name>BlockContentComment</name><argument_list>(<argument><expr><name>ParagraphCommentKind</name></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>Content</name><argument_list>(<argument>Content</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Content</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ParagraphCommentBits</name><operator>.</operator><name>IsWhitespace</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ParagraphCommentBits</name><operator>.</operator><name>IsWhitespaceValid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<return>return;</return>
<expr_stmt/>}</block_content>

ParagraphCommentBits.IsWhitespaceValid = false</block><empty_stmt>;</empty_stmt></if></if_stmt>

<call><name>setSourceRange</name><argument_list>(<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name><name>Content</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Content</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;
<expr><call><name>setLocation</name><argument_list>(<argument><expr><call><name><name>Content</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ParagraphCommentKind</name></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>child_iterator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Content</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>child_iterator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Content</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isWhitespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><name><name>ParagraphCommentBits</name><operator>.</operator><name>IsWhitespaceValid</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>ParagraphCommentBits</name><operator>.</operator><name>IsWhitespace</name></name></expr>;</return></block_content></block></if></if_stmt>

<name><name>ParagraphCommentBits</name><operator>.</operator><name>IsWhitespace</name></name> <operator>=</operator> <call><name>isWhitespaceNoCache</name><argument_list>()</argument_list></call></block></expr>;
<expr><name><name>ParagraphCommentBits</name><operator>.</operator><name>IsWhitespaceValid</name></name> <operator>=</operator> <name>true</name></expr>;
<return>return <expr><name><name>ParagraphCommentBits</name><operator>.</operator><name>IsWhitespace</name></name></expr>;</return>
}</block>

<name>private</name><operator>:</operator>
<name>bool</name> <macro><name>isWhitespaceNoCache</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;
}</block></expr>;




<expr><name>class</name> <name>BlockCommandComment</name> <operator>:</operator> <name>public</name> <name>BlockContentComment</name> <block>{
<expr><name>public</name><operator>:</operator>
struct <name>Argument</name> <block>{
<expr><name>SourceRange</name> <name>Range</name></expr>;
<expr><name>StringRef</name> <name>Text</name></expr>;

<macro><name>Argument</name><argument_list>()</argument_list></macro> <expr><block>{ }</block>
<macro><name>Argument</name><argument_list>(<argument>SourceRange Range</argument>, <argument>StringRef Text</argument>)</argument_list></macro> <operator>:</operator> <call><name>Range</name><argument_list>(<argument><expr><name>Range</name></expr></argument>)</argument_list></call></expr>, <macro><name>Text</name><argument_list>(<argument>Text</argument>)</argument_list></macro> <expr><block>{ }</block></expr>
}</block></expr>;

<expr><name>protected</name><operator>:</operator>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Argument</name></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;


<expr><name>ParagraphComment</name> <operator>*</operator><name>Paragraph</name></expr>;

<macro><name>BlockCommandComment</name><argument_list>(<argument>CommentKind K</argument>,
<argument>SourceLocation LocBegin</argument>,
<argument>SourceLocation LocEnd</argument>,
<argument>unsigned CommandID</argument>,
<argument>CommandMarkerKind CommandMarker</argument>)</argument_list></macro> <operator>:</operator>
<expr><call><name>BlockContentComment</name><argument_list>(<argument><expr><name>K</name></expr></argument>, <argument><expr><name>LocBegin</name></expr></argument>, <argument><expr><name>LocEnd</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Paragraph</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setLocation</name><argument_list>(<argument><expr><call><name>getCommandNameBeginLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name><name>BlockCommandCommentBits</name><operator>.</operator><name>CommandID</name></name> <operator>=</operator> <name>CommandID</name></expr>;
<expr><name><name>BlockCommandCommentBits</name><operator>.</operator><name>CommandMarker</name></name> <operator>=</operator> <name>CommandMarker</name></expr>;
}</block>

<name>public</name><operator>:</operator>
<macro><name>BlockCommandComment</name><argument_list>(<argument>SourceLocation LocBegin</argument>,
<argument>SourceLocation LocEnd</argument>,
<argument>unsigned CommandID</argument>,
<argument>CommandMarkerKind CommandMarker</argument>)</argument_list></macro> <operator>:</operator>
<call><name>BlockContentComment</name><argument_list>(<argument><expr><name>BlockCommandCommentKind</name></expr></argument>, <argument><expr><name>LocBegin</name></expr></argument>, <argument><expr><name>LocEnd</name></expr></argument>)</argument_list></call></expr>,
<macro><name>Paragraph</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>setLocation</name><argument_list>(<argument><expr><call><name>getCommandNameBeginLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name><name>BlockCommandCommentBits</name><operator>.</operator><name>CommandID</name></name> <operator>=</operator> <name>CommandID</name></expr>;
<expr><name><name>BlockCommandCommentBits</name><operator>.</operator><name>CommandMarker</name></name> <operator>=</operator> <name>CommandMarker</name></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <name>FirstBlockCommandCommentConstant</name> <operator>&amp;&amp;</operator>
<call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>LastBlockCommandCommentConstant</name></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>child_iterator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Paragraph</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>child_iterator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>&amp;</operator><name>Paragraph</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getCommandID</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>BlockCommandCommentBits</name><operator>.</operator><name>CommandID</name></name></expr>;</return>
}</block>

<name>StringRef</name> <macro><name>getCommandName</name><argument_list>(<argument>const CommandTraits &amp;Traits</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Traits</name><operator>.</operator><name>getCommandInfo</name></name><argument_list>(<argument><expr><call><name>getCommandID</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>Name</name></expr>;</return>
}</block>

<name>SourceLocation</name> <macro><name>getCommandNameBeginLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLocWithOffset</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getCommandNameRange</name><argument_list>(<argument>const CommandTraits &amp;Traits</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>StringRef</name> <name>Name</name> <operator>=</operator> <call><name>getCommandName</name><argument_list>(<argument><expr><name>Traits</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getCommandNameBeginLoc</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>getLocWithOffset</name><argument_list>(<argument><expr><literal type="number">1</literal> <operator>+</operator> <call><name><name>Name</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumArgs</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>StringRef</name> <macro><name>getArgText</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Args</name><index>[<expr><name>Idx</name></expr>]</index></name><operator>.</operator><name>Text</name></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getArgRange</name><argument_list>(<argument>unsigned Idx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Args</name><index>[<expr><name>Idx</name></expr>]</index></name><operator>.</operator><name>Range</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setArgs</name><argument_list>(<argument>ArrayRef&lt;Argument&gt; A</argument>)</argument_list></macro> <block>{
<expr><name>Args</name> <operator>=</operator> <name>A</name></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Args</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>NewLocEnd</name> <init>= <expr><call><name><name>Args</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name><name>Range</name><operator>.</operator><name>getEnd</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><call><name><name>NewLocEnd</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setSourceRange</name><argument_list>(<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewLocEnd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt/>}</block_content>
}

ParagraphComment *getParagraph(</block></if></if_stmt>) <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name>Paragraph</name></expr>;</return>
}</block></block>

<name>bool</name> <macro><name>hasNonWhitespaceParagraph</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Paragraph</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name><name>Paragraph</name><operator>-&gt;</operator><name>isWhitespace</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setParagraph</name><argument_list>(<argument>ParagraphComment *PC</argument>)</argument_list></macro> <block>{
<expr><name>Paragraph</name> <operator>=</operator> <name>PC</name></expr>;
<expr><name>SourceLocation</name> <name>NewLocEnd</name> <operator>=</operator> <call><name><name>PC</name><operator>-&gt;</operator><name>getEndLoc</name></name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>NewLocEnd</name><operator>.</operator><name>isValid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>setSourceRange</name><argument_list>(<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NewLocEnd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>

<name>CommandMarkerKind</name> <macro><name>getCommandMarker</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>CommandMarkerKind</name></expr></argument>&gt;</argument_list></name><argument_list>(
<argument><expr><name><name>BlockCommandCommentBits</name><operator>.</operator><name>CommandMarker</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>ParamCommandComment</name> <operator>:</operator> <name>public</name> <name>BlockCommandComment</name> <block>{
<expr><name>private</name><operator>:</operator>

<name>unsigned</name> <name>ParamIndex</name></expr>;

<expr><name>public</name><operator>:</operator>
enum <operator>:</operator> <name>unsigned</name> <block>{
<expr><name>InvalidParamIndex</name> <operator>=</operator> <operator>~</operator><literal type="number">0U</literal></expr>,
<expr><name>VarArgParamIndex</name> <operator>=</operator> <operator>~</operator><literal type="number">0U</literal> <operator>-</operator> <literal type="number">1U</literal></expr>
}</block></expr>;

<macro><name>ParamCommandComment</name><argument_list>(<argument>SourceLocation LocBegin</argument>,
<argument>SourceLocation LocEnd</argument>,
<argument>unsigned CommandID</argument>,
<argument>CommandMarkerKind CommandMarker</argument>)</argument_list></macro> <operator>:</operator>
<expr><call><name>BlockCommandComment</name><argument_list>(<argument><expr><name>ParamCommandCommentKind</name></expr></argument>, <argument><expr><name>LocBegin</name></expr></argument>, <argument><expr><name>LocEnd</name></expr></argument>,
<argument><expr><name>CommandID</name></expr></argument>, <argument><expr><name>CommandMarker</name></expr></argument>)</argument_list></call></expr>,
<macro><name>ParamIndex</name><argument_list>(<argument>InvalidParamIndex</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>ParamCommandCommentBits</name><operator>.</operator><name>Direction</name></name> <operator>=</operator> <name>In</name></expr>;
<expr><name><name>ParamCommandCommentBits</name><operator>.</operator><name>IsDirectionExplicit</name></name> <operator>=</operator> <name>false</name></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>ParamCommandCommentKind</name></expr>;</return>
}</block>

enum <name>PassDirection</name> <block>{
<expr><name>In</name></expr>,
<expr><name>Out</name></expr>,
<expr><name>InOut</name></expr>
}</block></expr>;

<expr><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <operator>*</operator><macro><name>getDirectionAsString</name><argument_list>(<argument>PassDirection D</argument>)</argument_list></macro></expr>;

<expr><name>PassDirection</name> <macro><name>getDirection</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>PassDirection</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>ParamCommandCommentBits</name><operator>.</operator><name>Direction</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>bool</name> <macro><name>isDirectionExplicit</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name><name>ParamCommandCommentBits</name><operator>.</operator><name>IsDirectionExplicit</name></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setDirection</name><argument_list>(<argument>PassDirection Direction</argument>, <argument>bool Explicit</argument>)</argument_list></macro> <block>{
<expr><name><name>ParamCommandCommentBits</name><operator>.</operator><name>Direction</name></name> <operator>=</operator> <name>Direction</name></expr>;
<expr><name><name>ParamCommandCommentBits</name><operator>.</operator><name>IsDirectionExplicit</name></name> <operator>=</operator> <name>Explicit</name></expr>;
}</block>

<name>bool</name> <macro><name>hasParamName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
}</block>

<name>StringRef</name> <macro><name>getParamName</name><argument_list>(<argument>const FullComment *FC</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>StringRef</name> <macro><name>getParamNameAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Text</name></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getParamNameRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Range</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isParamIndexValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name>ParamIndex</name> <operator>!=</operator> <name>InvalidParamIndex</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isVarArgParam</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name>ParamIndex</name> <operator>==</operator> <name>VarArgParamIndex</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setIsVarArgParam</name><argument_list>()</argument_list></macro> <block>{
<expr><name>ParamIndex</name> <operator>=</operator> <name>VarArgParamIndex</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isParamIndexValid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<name>unsigned</name> <macro><name>getParamIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isParamIndexValid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isVarArgParam</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>ParamIndex</name></expr>;</return>
}</block>

<name>void</name> <macro><name>setParamIndex</name><argument_list>(<argument>unsigned Index</argument>)</argument_list></macro> <block>{
<expr><name>ParamIndex</name> <operator>=</operator> <name>Index</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isParamIndexValid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isVarArgParam</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;


<expr><name>class</name> <name>TParamCommandComment</name> <operator>:</operator> <name>public</name> <name>BlockCommandComment</name> <block>{
<expr><name>private</name><operator>:</operator>












<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>Position</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>TParamCommandComment</name><argument_list>(<argument>SourceLocation LocBegin</argument>,
<argument>SourceLocation LocEnd</argument>,
<argument>unsigned CommandID</argument>,
<argument>CommandMarkerKind CommandMarker</argument>)</argument_list></macro> <operator>:</operator>
<macro><name>BlockCommandComment</name><argument_list>(<argument>TParamCommandCommentKind</argument>, <argument>LocBegin</argument>, <argument>LocEnd</argument>, <argument>CommandID</argument>,
<argument>CommandMarker</argument>)</argument_list></macro>
<block>{ }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>TParamCommandCommentKind</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>hasParamName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getNumArgs</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</return>
}</block>

<name>StringRef</name> <macro><name>getParamName</name><argument_list>(<argument>const FullComment *FC</argument>)</argument_list></macro> <specifier>const</specifier></expr>;

<expr><name>StringRef</name> <macro><name>getParamNameAsWritten</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Text</name></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getParamNameRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>Range</name></expr>;</return>
}</block>

<name>bool</name> <macro><name>isPositionValid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><operator>!</operator><call><name><name>Position</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getDepth</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isPositionValid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>Position</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getIndex</name><argument_list>(<argument>unsigned Depth</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isPositionValid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name><name>Position</name><index>[<expr><name>Depth</name></expr>]</index></name></expr>;</return>
}</block>

<name>void</name> <macro><name>setPosition</name><argument_list>(<argument>ArrayRef&lt;unsigned&gt; NewPosition</argument>)</argument_list></macro> <block>{
<expr><name>Position</name> <operator>=</operator> <name>NewPosition</name></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name>isPositionValid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>
}</expr>;


<expr><name>class</name> <name>VerbatimBlockLineComment</name> <operator>:</operator> <name>public</name> <name>Comment</name> <block>{
<expr><name>StringRef</name> <name>Text</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>VerbatimBlockLineComment</name><argument_list>(<argument>SourceLocation LocBegin</argument>,
<argument>StringRef Text</argument>)</argument_list></macro> <operator>:</operator>
<call><name>Comment</name><argument_list>(<argument><expr><name>VerbatimBlockLineCommentKind</name></expr></argument>,
<argument><expr><name>LocBegin</name></expr></argument>,
<argument><expr><call><name><name>LocBegin</name><operator>.</operator><name>getLocWithOffset</name></name><argument_list>(<argument><expr><call><name><name>Text</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>,
<macro><name>Text</name><argument_list>(<argument>Text</argument>)</argument_list></macro>
<expr><block>{ }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>VerbatimBlockLineCommentKind</name></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>

<name>child_iterator</name> <macro><name>child_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>

<name>StringRef</name> <macro><name>getText</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name>Text</name></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>VerbatimBlockComment</name> <operator>:</operator> <name>public</name> <name>BlockCommandComment</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>StringRef</name> <name>CloseName</name></expr>;
<expr><name>SourceLocation</name> <name>CloseNameLocBegin</name></expr>;
<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>VerbatimBlockLineComment</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Lines</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>VerbatimBlockComment</name><argument_list>(<argument>SourceLocation LocBegin</argument>,
<argument>SourceLocation LocEnd</argument>,
<argument>unsigned CommandID</argument>)</argument_list></macro> <operator>:</operator>
<macro><name>BlockCommandComment</name><argument_list>(<argument>VerbatimBlockCommentKind</argument>,
<argument>LocBegin</argument>, <argument>LocEnd</argument>, <argument>CommandID</argument>,
<argument>CMK_At</argument>)</argument_list></macro>
<block>{ }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>VerbatimBlockCommentKind</name></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>child_iterator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Lines</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>child_iterator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Lines</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>void</name> <macro><name>setCloseName</name><argument_list>(<argument>StringRef Name</argument>, <argument>SourceLocation LocBegin</argument>)</argument_list></macro> <block>{
<expr><name>CloseName</name> <operator>=</operator> <name>Name</name></expr>;
<expr><name>CloseNameLocBegin</name> <operator>=</operator> <name>LocBegin</name></expr>;
}</block>

<name>void</name> <macro><name>setLines</name><argument_list>(<argument>ArrayRef&lt;VerbatimBlockLineComment *&gt; L</argument>)</argument_list></macro> <block>{
<expr><name>Lines</name> <operator>=</operator> <name>L</name></expr>;
}</block>

<name>StringRef</name> <macro><name>getCloseName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CloseName</name></expr>;</return>
}</block>

<name>unsigned</name> <macro><name>getNumLines</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>Lines</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block>

<name>StringRef</name> <macro><name>getText</name><argument_list>(<argument>unsigned LineIdx</argument>)</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>Lines</name><index>[<expr><name>LineIdx</name></expr>]</index></name><operator>-&gt;</operator><call><name>getText</name><argument_list>()</argument_list></call></expr>;</return>
}</block>
}</expr>;




<expr><name>class</name> <name>VerbatimLineComment</name> <operator>:</operator> <name>public</name> <name>BlockCommandComment</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>StringRef</name> <name>Text</name></expr>;
<expr><name>SourceLocation</name> <name>TextBegin</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>VerbatimLineComment</name><argument_list>(<argument>SourceLocation LocBegin</argument>,
<argument>SourceLocation LocEnd</argument>,
<argument>unsigned CommandID</argument>,
<argument>SourceLocation TextBegin</argument>,
<argument>StringRef Text</argument>)</argument_list></macro> <operator>:</operator>
<call><name>BlockCommandComment</name><argument_list>(<argument><expr><name>VerbatimLineCommentKind</name></expr></argument>,
<argument><expr><name>LocBegin</name></expr></argument>, <argument><expr><name>LocEnd</name></expr></argument>,
<argument><expr><name>CommandID</name></expr></argument>,
<argument><expr><name>CMK_At</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Text</name><argument_list>(<argument><expr><name>Text</name></expr></argument>)</argument_list></call></expr>,
<macro><name>TextBegin</name><argument_list>(<argument>TextBegin</argument>)</argument_list></macro>
<expr><block>{ }</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>VerbatimLineCommentKind</name></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>

<name>child_iterator</name> <macro><name>child_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>nullptr</name></expr>;</return> }</block>

<name>StringRef</name> <macro><name>getText</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Text</name></expr>;</return>
}</block>

<name>SourceRange</name> <macro><name>getTextRange</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>SourceRange</name><argument_list>(<argument><expr><name>TextBegin</name></expr></argument>, <argument><expr><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


struct <expr><name>DeclInfo</name> <block>{


<expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>CommentDecl</name></expr>;









<expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>CurrentDecl</name></expr>;



<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ParamVars</name></expr>;



<expr><name>QualType</name> <name>ReturnType</name></expr>;




<expr><specifier>const</specifier> <name>TemplateParameterList</name> <operator>*</operator><name>TemplateParameters</name></expr>;



enum <expr><name>DeclKind</name> <block>{

<expr><name>OtherKind</name></expr>,











<expr><name>FunctionKind</name></expr>,





<expr><name>ClassKind</name></expr>,





<expr><name>VariableKind</name></expr>,


<expr><name>NamespaceKind</name></expr>,



<expr><name>TypedefKind</name></expr>,


<expr><name>EnumKind</name></expr>
}</block></expr>;


enum <expr><name>TemplateDeclKind</name> <block>{
<expr><name>NotTemplate</name></expr>,
<expr><name>Template</name></expr>,
<expr><name>TemplateSpecialization</name></expr>,
<expr><name>TemplatePartialSpecialization</name></expr>
}</block></expr>;


<expr><name>unsigned</name> <name>IsFilled</name> <operator>:</operator> <literal type="number">1</literal></expr>;


<expr><name>unsigned</name> <name>Kind</name> <operator>:</operator> <literal type="number">3</literal></expr>;


<expr><name>unsigned</name> <name>TemplateKind</name> <operator>:</operator> <literal type="number">2</literal></expr>;


<expr><name>unsigned</name> <name>IsObjCMethod</name> <operator>:</operator> <literal type="number">1</literal></expr>;




<expr><name>unsigned</name> <name>IsInstanceMethod</name> <operator>:</operator> <literal type="number">1</literal></expr>;




<expr><name>unsigned</name> <name>IsClassMethod</name> <operator>:</operator> <literal type="number">1</literal></expr>;

<expr><name>void</name> <call><name>fill</name><argument_list>()</argument_list></call></expr>;

<expr><name>DeclKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>TemplateDeclKind</name> <macro><name>getTemplateKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>TemplateDeclKind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>TemplateKind</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
}</expr>;


<expr><name>class</name> <name>FullComment</name> <operator>:</operator> <name>public</name> <name>Comment</name> <block>{
<expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BlockContentComment</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Blocks</name></expr>;
<expr><name>DeclInfo</name> <operator>*</operator><name>ThisDeclInfo</name></expr>;

<expr><name>public</name><operator>:</operator>
<call><name>FullComment</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BlockContentComment</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Blocks</name></expr></argument>, <argument><expr><name>DeclInfo</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call> <operator>:</operator>
<call><name>Comment</name><argument_list>(<argument><expr><name>FullCommentKind</name></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>,
<expr><call><name>Blocks</name><argument_list>(<argument><expr><name>Blocks</name></expr></argument>)</argument_list></call></expr>, <macro><name>ThisDeclInfo</name><argument_list>(<argument>D</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Blocks</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<call><name>setSourceRange</name><argument_list>(
<argument><expr><call><name>SourceRange</name><argument_list>(<argument><expr><call><name><name>Blocks</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name><name>Blocks</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getEndLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></block></expr>;
<expr><call><name>setLocation</name><argument_list>(<argument><expr><call><name><name>Blocks</name><operator>.</operator><name>front</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>getBeginLoc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>classof</name><argument_list>(<argument>const Comment *C</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name><name>C</name><operator>-&gt;</operator><name>getCommentKind</name></name><argument_list>()</argument_list></call> <operator>==</operator> <name>FullCommentKind</name></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_begin</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>child_iterator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Blocks</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<name>child_iterator</name> <macro><name>child_end</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>reinterpret_cast</name><argument_list type="generic">&lt;<argument><expr><name>child_iterator</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Blocks</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>const</specifier> <name>Decl</name> <operator>*</operator><macro><name>getDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<return>return <expr><name><name>ThisDeclInfo</name><operator>-&gt;</operator><name>CommentDecl</name></name></expr>;</return>
}</block>

<specifier>const</specifier> <name>DeclInfo</name> <operator>*</operator><macro><name>getDeclInfo</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <name>LLVM_READONLY</name> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ThisDeclInfo</name><operator>-&gt;</operator><name>IsFilled</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>ThisDeclInfo</name><operator>-&gt;</operator><name>fill</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr>
<return>return <expr><name>ThisDeclInfo</name></expr>;</return>
}</block>

<name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BlockContentComment</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getBlocks</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Blocks</name></expr>;</return> }</block>

}</expr>;
}</block></expr>
}</block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></block></expr></range></decl></decl_stmt></block_content></block></decl></decl_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
