<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/home/user/cppstats/test/freeBSD_res/_cppstats_featurelocations/freebsd-src/contrib/llvm-project/clang/include/clang/Sema/Sema.h">












<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LLVM_CLANG_SEMA_SEMA_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLVM_CLANG_SEMA_SEMA_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTConcept.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ASTFwd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Attr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Availability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ComparisonCategories.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclTemplate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/DeclarationName.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/Expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprConcepts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprObjC.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExprOpenMP.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/ExternalASTSource.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/LocInfoType.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/MangleNumberingContext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/NSAPI.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/PrettyPrinter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtCXX.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/StmtOpenMP.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeLoc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/AST/TypeOrdering.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/BitmaskEnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/DarwinSDKInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/ExpressionTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Module.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenCLOptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/OpenMPKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/PragmaKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/Specifiers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TemplateKinds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Basic/TypeTraits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/AnalysisBasedWarnings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/CleanupInfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/DeclSpec.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/ExternalSemaSource.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/IdentifierResolver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/ObjCMethodList.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/Ownership.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/Scope.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/SemaConcept.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/TypoCorrection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"clang/Sema/Weak.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/ArrayRef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/Optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SetVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallBitVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallPtrSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallSet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/SmallVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/ADT/TinyPtrVector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"llvm/Frontend/OpenMP/OMPConstants.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;deque&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;tuple&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;vector&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>APSInt</name></decl>;</decl_stmt>
<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>ValueT</name><operator>&gt;</operator> struct <name>DenseMapInfo</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>ValueT</name></expr></argument>, <argument><expr><name>typename</name> <name>ValueInfoT</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>DenseSet</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SmallBitVector</name></decl>;</decl_stmt>
<struct_decl>struct <name>InlineAsmIdentifierInfo</name>;</struct_decl>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>clang</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>ADLResult</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTConsumer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTMutationListener</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ASTWriter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ArrayType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParsedAttr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BindingDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CapturedDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXBasePath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXBasePaths</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXBindTemporaryExpr</name></decl>;</decl_stmt>
<typedef>typedef <type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CXXBaseSpecifier</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>CXXCastPath</name>;</typedef>
<decl_stmt><decl><type><name>class</name></type> <name>CXXConstructorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXConversionDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXDeleteExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXDestructorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXFieldCollector</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXMemberCallExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXMethodDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXScopeSpec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXTemporary</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CXXTryStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CallExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ClassTemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ClassTemplatePartialSpecializationDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ClassTemplateSpecializationDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarTemplatePartialSpecializationDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeCompleteConsumer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeCompletionAllocator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeCompletionTUInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CodeCompletionResult</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CoroutineBodyStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Decl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclAccessPair</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclRefExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeclaratorDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DeducedTemplateArgument</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DependentDiagnostic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DesignatedInitExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Designation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>EnableIfAttr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>EnumConstantDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ExtVectorType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FormatAttr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FriendDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionProtoType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionTemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ImplicitConversionSequence</name></decl>;</decl_stmt>
<typedef>typedef <type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ImplicitConversionSequence</name></expr></argument>&gt;</argument_list></name></type> <name>ConversionSequenceList</name>;</typedef>
<decl_stmt><decl><type><name>class</name></type> <name>InitListExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>InitializationKind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>InitializationSequence</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>InitializedEntity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IntegerLiteral</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LabelStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LambdaExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LangOptions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LocalInstantiationScope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LookupResult</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MacroInfo</name></decl>;</decl_stmt>
<typedef>typedef <type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>ModuleIdPath</name>;</typedef>
<decl_stmt><decl><type><name>class</name></type> <name>ModuleLoader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>MultiLevelTemplateArgumentList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>NamedDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCCategoryDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCCategoryImplDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCCompatibleAliasDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCContainerDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCImplDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCImplementationDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCInterfaceDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCIvarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>class</name> <name>T</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>ObjCList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCMessageExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCMethodDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCPropertyDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ObjCProtocolDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPThreadPrivateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPRequiresDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPDeclareReductionDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPDeclareSimdDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OMPClause</name></decl>;</decl_stmt>
<struct_decl>struct <name>OMPVarListLocTy</name>;</struct_decl>
<struct_decl>struct <name>OverloadCandidate</name>;</struct_decl>
<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>OverloadCandidateParamOrder</name> <range>: <expr><name>char</name></expr></range></decl>;</decl_stmt>
<enum_decl>enum <name>OverloadCandidateRewriteKind</name> : <type><name>unsigned</name></type>;</enum_decl>
<decl_stmt><decl><type><name>class</name></type> <name>OverloadCandidateSet</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>OverloadExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParenListExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ParmVarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Preprocessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PseudoDestructorTypeStorage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PseudoObjectExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>QualType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StandardConversionSequence</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Stmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>StringLiteral</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SwitchStmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateArgument</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateArgumentList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateArgumentLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateInstantiationCallback</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateParameterList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplatePartialOrderingContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateTemplateParmDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Token</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypeAliasDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypedefDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypedefNameDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypeLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TypoCorrectionConsumer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnqualifiedId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnresolvedLookupExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnresolvedMemberExpr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnresolvedSetImpl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UnresolvedSetIterator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UsingDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>UsingShadowDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>ValueDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VarTemplateSpecializationDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VisibilityAttr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>VisibleDeclConsumer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>IndirectFieldDecl</name></decl>;</decl_stmt>
<struct_decl>struct <name>DeductionFailureInfo</name>;</struct_decl>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateSpecCandidateSet</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>sema</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>AccessedEntity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>BlockScopeInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>Capture</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CapturedRegionScopeInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CapturingScopeInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>CompoundScopeInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DelayedDiagnostic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>DelayedDiagnosticPool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>FunctionScopeInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>LambdaScopeInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>PossiblyUnreachableDiag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>SemaPPCallbacks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>class</name></type> <name>TemplateDeductionInfo</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>threadSafety</name> <block>{<block_content>
<decl_stmt><decl><type><name>class</name></type> <name>BeforeSet</name></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>threadSafetyCleanup</name><parameter_list>(<parameter><decl><type><name>BeforeSet</name><modifier>*</modifier></type> <name>Cache</name></decl></parameter>)</parameter_list>;</function_decl>
</block_content>}</block></decl></decl_stmt>



<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>TemplateTypeParmType</name><operator>*</operator></expr></argument>, <argument><expr><name>NamedDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <name>UnexpandedParameterPack</name></expr>;</expr_stmt></typedef>



<struct>struct <name>FileNullability</name> <block>{


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>PointerLoc</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>SourceLocation</name></type> <name>PointerEndLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>uint8_t</name></type> <name>PointerKind</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>SawTypeNullability</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
}</block>;</struct>



<decl_stmt><decl><type><name>class</name></type> <name>FileNullabilityMap</name> <block>{<block_content>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>FileID</name></expr></argument>, <argument><expr><name>FileNullability</name></expr></argument>&gt;</argument_list></name> <name>Map</name></expr>;</expr_stmt>


<struct>struct <block>{
<decl_stmt><decl><type><name>FileID</name></type> <name>File</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FileNullability</name></type> <name>Nullability</name></decl>;</decl_stmt>
}</block> <decl><name>Cache</name></decl>;</struct>

<label><name>public</name>:</label>
<function><type><name>FileNullability</name> <modifier>&amp;</modifier></type><name>operator</name>[]<parameter_list>(<parameter><decl><type><name>FileID</name></type> <name>file</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>file</name> <operator>==</operator> <name><name>Cache</name><operator>.</operator><name>File</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>Cache</name><operator>.</operator><name>Nullability</name></name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Cache</name><operator>.</operator><name>File</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>Map</name><index>[<expr><name><name>Cache</name><operator>.</operator><name>File</name></name></expr>]</index></name> <operator>=</operator> <name><name>Cache</name><operator>.</operator><name>Nullability</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>Cache</name><operator>.</operator><name>File</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Cache</name><operator>.</operator><name>Nullability</name></name> <operator>=</operator> <name><name>Map</name><index>[<expr><name>file</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><name><name>Cache</name><operator>.</operator><name>Nullability</name></name></expr>;</return>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>PreferredTypeBuilder</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>PreferredTypeBuilder</name><argument_list>(<argument>bool Enabled</argument>)</argument_list></macro> : <macro><name>Enabled</name><argument_list>(<argument>Enabled</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<function_decl><type><name>void</name></type> <name>enterCondition</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>enterReturn</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Tok</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>enterVariableInit</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Tok</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>enterDesignatedInitializer</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Tok</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Designation</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>









<decl_stmt><decl><type><name>void</name></type> <name>enterFunctionArgument</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Tok</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>ComputeType</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>enterParenExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Tok</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>enterUnary</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Tok</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>OpKind</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>enterBinary</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Tok</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>LHS</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Op</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>enterMemAccess</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Tok</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>enterSubscript</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Tok</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>enterTypeCast</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Tok</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>CastType</name></decl></parameter>)</parameter_list>;</function_decl>







<decl_stmt><decl><type><name>QualType</name></type> <name>get</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Tok</name></expr></argument>)</argument_list> const <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Enabled</name> <operator>||</operator> <name>Tok</name> <operator>!=</operator> <name>ExpectedLoc</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Type</name><operator>.</operator><name>isNull</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>Type</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>ComputeType</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>ComputeType</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>bool</name></type> <name>Enabled</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ExpectedLoc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>QualType</name></type> <name>Type</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>ComputeType</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name> <name>Sema</name></type> <name>final</name> <block>{<block_content>
<expr_stmt><expr><call><name>Sema</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Sema</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>Sema</name> <operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ExternalSemaSource</name> <modifier>*</modifier></type><name>ExternalSource</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>isMultiplexExternalSource</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>mightHaveNonExternalLinkage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclaratorDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>isVisibleSlow</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>




<function><type><name>bool</name></type> <name>shouldLinkPossiblyHiddenDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>isVisible</name><argument_list>(<argument><expr><name>Old</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name><name>New</name><operator>-&gt;</operator><name>isExternallyDeclarable</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Old</name><operator>-&gt;</operator><name>isExternallyDeclarable</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"should not have found a non-externally-declarable previous decl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<function_decl><type><name>bool</name></type> <name>shouldLinkPossiblyHiddenDecl</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Old</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>setupImplicitSpecialMemberType</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>SpecialMem</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ResultTy</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>







<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name></type> <name>MaxAlignmentExponent</name> <init>= <expr><literal type="number">29</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name></type> <name>MaximumAlignment</name> <init>= <expr><literal type="number">1u</literal> <operator>&lt;&lt;</operator> <name>MaxAlignmentExponent</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><name><name>OpaquePtr</name><argument_list type="generic">&lt;<argument><expr><name>DeclGroupRef</name></expr></argument>&gt;</argument_list></name></type> <name>DeclGroupPtrTy</name>;</typedef>
<typedef>typedef <type><name><name>OpaquePtr</name><argument_list type="generic">&lt;<argument><expr><name>TemplateName</name></expr></argument>&gt;</argument_list></name></type> <name>TemplateTy</name>;</typedef>
<typedef>typedef <type><name><name>OpaquePtr</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name></type> <name>TypeTy</name>;</typedef>

<decl_stmt><decl><type><name>OpenCLOptions</name></type> <name>OpenCLFeatures</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FPOptions</name></type> <name>CurFPFeatures</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>LangOptions</name> <modifier>&amp;</modifier></type><name>LangOpts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ASTContext</name> <modifier>&amp;</modifier></type><name>Context</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ASTConsumer</name> <modifier>&amp;</modifier></type><name>Consumer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DiagnosticsEngine</name> <modifier>&amp;</modifier></type><name>Diags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceManager</name> <modifier>&amp;</modifier></type><name>SourceMgr</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>CollectStats</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CodeCompleteConsumer</name> <modifier>*</modifier></type><name>CodeCompleter</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>CurContext</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>OriginalLexicalContext</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>DeclarationName</name></type> <name>VAListTagName</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>MSStructPragmaOn</name></decl>;</decl_stmt>


<expr_stmt><expr><name>LangOptions</name><operator>::</operator><name>PragmaMSPointersToMembersKind</name>
<name>MSPointerToMemberRepresentationMethod</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Scope</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>CurrentSEHFinally</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ImplicitMSInheritanceAttrLoc</name></decl>;</decl_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>TypoExpr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>TypoExprs</name></expr>;</expr_stmt>


<enum>enum <name>PragmaClangSectionKind</name> <block>{
<decl><name>PCSK_Invalid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>PCSK_BSS</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
<decl><name>PCSK_Data</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
<decl><name>PCSK_Rodata</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,
<decl><name>PCSK_Text</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,
<decl><name>PCSK_Relro</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>
}</block>;</enum>

<enum>enum <name>PragmaClangSectionAction</name> <block>{
<decl><name>PCSA_Set</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>PCSA_Clear</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>
}</block>;</enum>

<struct>struct <name>PragmaClangSection</name> <block>{
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>SectionName</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>PragmaLocation</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>PragmaClangSection</name></type> <name>PragmaClangBSSSection</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PragmaClangSection</name></type> <name>PragmaClangDataSection</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PragmaClangSection</name></type> <name>PragmaClangRodataSection</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PragmaClangSection</name></type> <name>PragmaClangRelroSection</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PragmaClangSection</name></type> <name>PragmaClangTextSection</name></decl>;</decl_stmt>

<enum>enum <name>PragmaMsStackAction</name> <block>{
<decl><name>PSK_Reset</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>,
<decl><name>PSK_Set</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,
<decl><name>PSK_Push</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,
<decl><name>PSK_Pop</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>,
<decl><name>PSK_Show</name> <init>= <expr><literal type="number">0x8</literal></expr></init></decl>,
<decl><name>PSK_Push_Set</name> <init>= <expr><name>PSK_Push</name> <operator>|</operator> <name>PSK_Set</name></expr></init></decl>,
<decl><name>PSK_Pop_Set</name> <init>= <expr><name>PSK_Pop</name> <operator>|</operator> <name>PSK_Set</name></expr></init></decl>,
}</block>;</enum>


<decl_stmt><decl><type><name>class</name></type> <name>AlignPackInfo</name> <block>{<block_content>
<label><name>public</name>:</label>


<enum>enum <name>Mode</name> : <type><name>unsigned</name> <name>char</name></type> <block>{ <decl><name>Native</name></decl>, <decl><name>Natural</name></decl>, <decl><name>Packed</name></decl>, <decl><name>Mac68k</name></decl> }</block>;</enum>


<macro><name>AlignPackInfo</name><argument_list>(<argument>AlignPackInfo::Mode M</argument>, <argument>unsigned Num</argument>, <argument>bool IsXL</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>PackAttr</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>AlignMode</name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>PackNumber</name><argument_list>(<argument><expr><name>Num</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>XLStack</name><argument_list>(<argument>IsXL</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Num</name> <operator>==</operator> <name>PackNumber</name> <operator>&amp;&amp;</operator> <literal type="string">"The pack number has been truncated."</literal></expr></argument>)</argument_list></call></expr>;
}</block>


<macro><name>AlignPackInfo</name><argument_list>(<argument>AlignPackInfo::Mode M</argument>, <argument>bool IsXL</argument>)</argument_list></macro>
<operator>:</operator> <call><name>PackAttr</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>AlignMode</name><argument_list>(<argument><expr><name>M</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>PackNumber</name><argument_list>(<argument><expr><ternary><condition><expr><name>M</name> <operator>==</operator> <name>Packed</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>UninitPackVal</name></expr></else></ternary></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>XLStack</name><argument_list>(<argument>IsXL</argument>)</argument_list></macro> <expr><block>{}</block>

<name>explicit</name> <macro><name>AlignPackInfo</name><argument_list>(<argument>bool IsXL</argument>)</argument_list></macro> <operator>:</operator> <macro><name>AlignPackInfo</name><argument_list>(<argument>Native</argument>, <argument>IsXL</argument>)</argument_list></macro> <block>{}</block>

<call><name>AlignPackInfo</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>AlignPackInfo</name><argument_list>(<argument>Native</argument>, <argument>false</argument>)</argument_list></macro> <block>{}</block>




<specifier>static</specifier> <name>uint32_t</name> <macro><name>getRawEncoding</name><argument_list>(<argument>const AlignPackInfo &amp;Info</argument>)</argument_list></macro> <block>{
<expr><name>std</name><operator>::</operator><name>uint32_t</name> <name>Encoding</name><block>{}</block></expr>;
<if_stmt><if>if <condition>(<expr><call><name><name>Info</name><operator>.</operator><name>IsXLStack</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Encoding</name> <operator>|=</operator> <name>IsXLMask</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<name>Encoding</name> <operator>|=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Info</name><operator>.</operator><name>getAlignMode</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">1</literal></block></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name><name>Info</name><operator>.</operator><name>IsPackAttr</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>Encoding</name> <operator>|=</operator> <name>PackAttrMask</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>Encoding</name> <operator>|=</operator> <call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>uint32_t</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Info</name><operator>.</operator><name>getPackNumber</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<return>return <expr><name>Encoding</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>AlignPackInfo</name></type> <name>getFromRawEncoding</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Encoding</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>IsXL</name> <init>= <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Encoding</name> <operator>&amp;</operator> <name>IsXLMask</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>AlignPackInfo</name><operator>::</operator><name>Mode</name> <name>M</name> <operator>=</operator>
<call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>AlignPackInfo</name><operator>::</operator><name>Mode</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><operator>(</operator><name>Encoding</name> <operator>&amp;</operator> <name>AlignModeMask</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>PackNumber</name> <init>= <expr><operator>(</operator><name>Encoding</name> <operator>&amp;</operator> <name>PackNumMask</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>Encoding</name> <operator>&amp;</operator> <name>PackAttrMask</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>AlignPackInfo</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>PackNumber</name></expr></argument>, <argument><expr><name>IsXL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>AlignPackInfo</name><argument_list>(<argument><expr><name>M</name></expr></argument>, <argument><expr><name>IsXL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>bool</name> <macro><name>IsPackAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PackAttr</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>IsAlignAttr</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><name>PackAttr</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>Mode</name> <macro><name>getAlignMode</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AlignMode</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>unsigned</name> <macro><name>getPackNumber</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PackNumber</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>IsPackSet</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{


<return>return <expr><name>PackNumber</name> <operator>!=</operator> <name>UninitPackVal</name> <operator>&amp;&amp;</operator> <name>PackNumber</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>IsXLStack</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>XLStack</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>AlignPackInfo</name> <operator>&amp;</operator><name>Info</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name>tie</name><argument_list>(<argument><expr><name>AlignMode</name></expr></argument>, <argument><expr><name>PackNumber</name></expr></argument>, <argument><expr><name>PackAttr</name></expr></argument>, <argument><expr><name>XLStack</name></expr></argument>)</argument_list></call> <operator>==</operator>
<name>std</name><operator>::</operator><call><name>tie</name><argument_list>(<argument><expr><name><name>Info</name><operator>.</operator><name>AlignMode</name></name></expr></argument>, <argument><expr><name><name>Info</name><operator>.</operator><name>PackNumber</name></name></expr></argument>, <argument><expr><name><name>Info</name><operator>.</operator><name>PackAttr</name></name></expr></argument>,
<argument><expr><name><name>Info</name><operator>.</operator><name>XLStack</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <name>operator</name><operator>!=</operator><operator>(</operator><specifier>const</specifier> <name>AlignPackInfo</name> <operator>&amp;</operator><name>Info</name><operator>)</operator> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><operator>(</operator><operator>*</operator><name>this</name> <operator>==</operator> <name>Info</name><operator>)</operator></expr>;</return>
}</block></expr></expr_stmt>

<label><name>private</name>:</label>


<decl_stmt><decl><type><name>bool</name></type> <name>PackAttr</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Mode</name></type> <name>AlignMode</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>PackNumber</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>XLStack</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>constexpr</name> <name>unsigned</name> <name>char</name></type> <name>UninitPackVal</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>constexpr</name> <name>uint32_t</name></type> <name>IsXLMask</name><block>{<block_content><expr><literal type="number">0x0000</literal><literal type="char">'0001};
static constexpr uint32_t AlignModeMask{0x0000'</literal><literal type="number">0006</literal></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>constexpr</name> <name>uint32_t</name></type> <name>PackAttrMask</name><block>{<block_content><expr><literal type="number">0x00000</literal><literal type="char">'0008};
static constexpr uint32_t PackNumMask{0x0000'</literal><literal type="number">01F0</literal></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<macro><name>template</name></macro><expr_stmt><expr><operator>&lt;</operator><name>typename</name> <name>ValueType</name><operator>&gt;</operator>
struct <name>PragmaStack</name> <block>{
struct <expr><name>Slot</name> <block>{
<expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>StackSlotLabel</name></expr>;
<expr><name>ValueType</name> <name>Value</name></expr>;
<expr><name>SourceLocation</name> <name>PragmaLocation</name></expr>;
<expr><name>SourceLocation</name> <name>PragmaPushLocation</name></expr>;
<macro><name>Slot</name><argument_list>(<argument>llvm::StringRef StackSlotLabel</argument>, <argument>ValueType Value</argument>,
<argument>SourceLocation PragmaLocation</argument>, <argument>SourceLocation PragmaPushLocation</argument>)</argument_list></macro>
<operator>:</operator> <expr><call><name>StackSlotLabel</name><argument_list>(<argument><expr><name>StackSlotLabel</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>Value</name><argument_list>(<argument><expr><name>Value</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>PragmaLocation</name><argument_list>(<argument><expr><name>PragmaLocation</name></expr></argument>)</argument_list></call></expr>,
<macro><name>PragmaPushLocation</name><argument_list>(<argument>PragmaPushLocation</argument>)</argument_list></macro> <expr><block>{}</block></expr>
}</block></expr>;

<expr><name>void</name> <macro><name>Act</name><argument_list>(<argument>SourceLocation PragmaLocation</argument>, <argument>PragmaMsStackAction Action</argument>,
<argument>llvm::StringRef StackSlotLabel</argument>, <argument>ValueType Value</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>Action</name> <operator>==</operator> <name>PSK_Reset</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>CurrentValue</name> <operator>=</operator> <name>DefaultValue</name></expr>;</expr_stmt>
<expr_stmt><expr><name>CurrentPragmaLocation</name> <operator>=</operator> <name>PragmaLocation</name></expr>;</expr_stmt>
<return>return;</return>
<expr_stmt/>}</block_content>
if (Action &amp; PSK_Push</block></if></if_stmt>)
<call><name><name>Stack</name><operator>.</operator><name>emplace_back</name></name><argument_list>(<argument><expr><name>StackSlotLabel</name></expr></argument>, <argument><expr><name>CurrentValue</name></expr></argument>, <argument><expr><name>CurrentPragmaLocation</name></expr></argument>,
<argument><expr><name>PragmaLocation</name></expr></argument>)</argument_list></call></block></expr>;
<if_stmt><if type="elseif">else if <condition>(<expr><name>Action</name> <operator>&amp;</operator> <name>PSK_Pop</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>StackSlotLabel</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>auto</name></type> <name>I</name> <init>= <expr><name>llvm</name><operator>::</operator><call><name>find_if</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><call><name>reverse</name><argument_list>(<argument><expr><name>Stack</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><index>[<expr><operator>&amp;</operator></expr>]</index><operator>(</operator><specifier>const</specifier> <name>Slot</name> <operator>&amp;</operator><name>x</name><operator>)</operator> <block>{
<return>return <expr><name><name>x</name><operator>.</operator><name>StackSlotLabel</name></name> <operator>==</operator> <name>StackSlotLabel</name></expr>;</return>
}</block></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>I</name> <operator>!=</operator> <call><name><name>Stack</name><operator>.</operator><name>rend</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>CurrentValue</name> <operator>=</operator> <name><name>I</name><operator>-&gt;</operator><name>Value</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>CurrentPragmaLocation</name> <operator>=</operator> <name><name>I</name><operator>-&gt;</operator><name>PragmaLocation</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Stack</name><operator>.</operator><name>erase</name></name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name>prev</name><argument_list>(<argument><expr><call><name><name>I</name><operator>.</operator><name>base</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name><name>Stack</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
} else if (!Stack.empty(</block></if></if_stmt>)</block_content></block></if></if_stmt>)</block_content> <block>{<block_content>

<expr_stmt><expr><name>CurrentValue</name> <operator>=</operator> <call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>Value</name></expr>;</expr_stmt>
<expr_stmt><expr><name>CurrentPragmaLocation</name> <operator>=</operator> <call><name><name>Stack</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>PragmaLocation</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Stack</name><operator>.</operator><name>pop_back</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
if (Action &amp; PSK_Set</block></block></if></if_stmt>) <block>{
<expr><name>CurrentValue</name> <operator>=</operator> <name>Value</name></expr>;
<expr><name>CurrentPragmaLocation</name> <operator>=</operator> <name>PragmaLocation</name></expr>;
}</block></block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt>















<function><type><name>void</name></type> <name>SentinelAction</name><parameter_list>(<parameter><decl><type><name>PragmaMsStackAction</name></type> <name>Action</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Label</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>Action</name> <operator>==</operator> <name>PSK_Push</name> <operator>||</operator> <name>Action</name> <operator>==</operator> <name>PSK_Pop</name><operator>)</operator> <operator>&amp;&amp;</operator>
<literal type="string">"Can only push / pop #pragma stack sentinels!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Act</name><argument_list>(<argument><expr><name>CurrentPragmaLocation</name></expr></argument>, <argument><expr><name>Action</name></expr></argument>, <argument><expr><name>Label</name></expr></argument>, <argument><expr><name>CurrentValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>PragmaStack</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueType</name> <operator>&amp;</operator><name>Default</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>DefaultValue</name><argument_list>(<argument><expr><name>Default</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>CurrentValue</name><argument_list>(<argument>Default</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>hasValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CurrentValue</name> <operator>!=</operator> <name>DefaultValue</name></expr>;</return> }</block></expr></expr_stmt>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Slot</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Stack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ValueType</name></type> <name>DefaultValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ValueType</name></type> <name>CurrentValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>CurrentPragmaLocation</name></decl>;</decl_stmt>
};











<decl_stmt><decl><type><name><name>PragmaStack</name><argument_list type="generic">&lt;<argument><expr><name>MSVtorDispMode</name></expr></argument>&gt;</argument_list></name></type> <name>VtorDispStack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>PragmaStack</name><argument_list type="generic">&lt;<argument><expr><name>AlignPackInfo</name></expr></argument>&gt;</argument_list></name></type> <name>AlignPackStack</name></decl>;</decl_stmt>

<struct>struct <name>AlignPackIncludeState</name> <block>{
<decl_stmt><decl><type><name>AlignPackInfo</name></type> <name>CurrentValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>CurrentPragmaLocation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasNonDefaultValue</name></decl>, <decl><type ref="prev"/><name>ShouldWarnOnInclude</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>AlignPackIncludeState</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>AlignPackIncludeStack</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>PragmaStack</name><argument_list type="generic">&lt;<argument><expr><name>StringLiteral</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>DataSegStack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>PragmaStack</name><argument_list type="generic">&lt;<argument><expr><name>StringLiteral</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>BSSSegStack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>PragmaStack</name><argument_list type="generic">&lt;<argument><expr><name>StringLiteral</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>ConstSegStack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>PragmaStack</name><argument_list type="generic">&lt;<argument><expr><name>StringLiteral</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>CodeSegStack</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>PragmaStack</name><argument_list type="generic">&lt;<argument><expr><name>FPOptionsOverride</name></expr></argument>&gt;</argument_list></name></type> <name>FpPragmaStack</name></decl>;</decl_stmt>
<function><type><name>FPOptionsOverride</name></type> <name>CurFPFeatureOverrides</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>FPOptionsOverride</name></type> <name>result</name></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>FpPragmaStack</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FPOptionsOverride</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>FpPragmaStack</name><operator>.</operator><name>CurrentValue</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name>class</name></type> <name>PragmaStackSentinelRAII</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>PragmaStackSentinelRAII</name><argument_list>(<argument>Sema &amp;S</argument>, <argument>StringRef SlotLabel</argument>, <argument>bool ShouldAct</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><operator>~</operator><call><name>PragmaStackSentinelRAII</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>StringRef</name></type> <name>SlotLabel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ShouldAct</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>FileNullabilityMap</name></type> <name>NullabilityMap</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>StringLiteral</name> <modifier>*</modifier></type><name>CurInitSeg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>CurInitSegLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>VisContext</name></decl>;</decl_stmt>


<struct>struct <name>PragmaAttributeEntry</name> <block>{
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParsedAttr</name> <modifier>*</modifier></type><name>Attribute</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>attr</name><operator>::</operator><name>SubjectMatchRule</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>MatchRules</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>IsUsed</name></decl>;</decl_stmt>
}</block>;</struct>


<struct>struct <name>PragmaAttributeGroup</name> <block>{

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Namespace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>PragmaAttributeEntry</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Entries</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>PragmaAttributeGroup</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>PragmaAttributeStack</name></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>PragmaAttributeCurrentTargetDecl</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>SourceLocation</name></type> <name>OptimizeOffPragmaLocation</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>IsBuildingRecoveryCallExpr</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CleanupInfo</name></type> <name>Cleanup</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ExprWithCleanups</name><operator>::</operator><name>CleanupObject</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>ExprCleanupObjects</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>using</name></type> <name>MaybeODRUseExprSet</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>SetVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MaybeODRUseExprSet</name></type> <name>MaybeODRUseExprs</name></decl>;</decl_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>sema</name><operator>::</operator><name>FunctionScopeInfo</name></expr></argument>&gt;</argument_list></name> <name>CachedFunctionScope</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>sema</name><operator>::</operator><name>FunctionScopeInfo</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>FunctionScopes</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>FunctionScopesStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>sema</name><operator>::</operator><name>FunctionScopeInfo</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>getFunctionScopes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>FunctionScopes</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator> <name>FunctionScopesStart</name></expr></argument>,
<argument><expr><call><name><name>FunctionScopes</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>






<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>InventedTemplateParameterInfo</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>InventedParameterInfos</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>InventedParameterInfosStart</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>InventedTemplateParameterInfo</name></expr></argument>&gt;</argument_list></name> <macro><name>getInventedParameterInfos</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>llvm</name><operator>::</operator><call><name>makeArrayRef</name><argument_list>(<argument><expr><call><name><name>InventedParameterInfos</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call> <operator>+</operator>
<name>InventedParameterInfosStart</name></expr></argument>,
<argument><expr><call><name><name>InventedParameterInfos</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<typedef>typedef <type><name><name>LazyVector</name><argument_list type="generic">&lt;<argument><expr><name>TypedefNameDecl</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>ExternalSemaSource</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ExternalSemaSource</name><operator>::</operator><name>ReadExtVectorDecls</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type>
<name>ExtVectorDeclsType</name>;</typedef>




<decl_stmt><decl><type><name>ExtVectorDeclsType</name></type> <name>ExtVectorDecls</name></decl>;</decl_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>CXXFieldCollector</name></expr></argument>&gt;</argument_list></name> <name>FieldCollector</name></expr>;</expr_stmt>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallSetVector</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>NamedDeclSetType</name></expr>;</expr_stmt></typedef>


<decl_stmt><decl><type><name>NamedDeclSetType</name></type> <name>UnusedPrivateFields</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallSetVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>TypedefNameDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name>
<name>UnusedLocalTypedefNameCandidates</name></expr>;</expr_stmt>






<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>DeleteExprLoc</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>DeleteExprLoc</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>DeleteLocs</name></expr>;</expr_stmt></typedef>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>DeleteLocs</name></expr></argument>&gt;</argument_list></name> <name>DeleteExprs</name></expr>;</expr_stmt>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXRecordDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>RecordDeclSetTy</name></expr>;</expr_stmt></typedef>




<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>RecordDeclSetTy</name></expr></argument>&gt;</argument_list></name> <name>PureVirtualClassDiagSet</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Decl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>ParsingInitForAutoVars</name></expr>;</expr_stmt>


<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>findLocallyScopedExternCDecl</name><parameter_list>(<parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><name><name>LazyVector</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>ExternalSemaSource</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ExternalSemaSource</name><operator>::</operator><name>ReadTentativeDefinitions</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type>
<name>TentativeDefinitionsType</name>;</typedef>


<decl_stmt><decl><type><name>TentativeDefinitionsType</name></type> <name>TentativeDefinitions</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>ExternalDeclarations</name></decl>;</decl_stmt>

<typedef>typedef <type><name><name>LazyVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>DeclaratorDecl</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>ExternalSemaSource</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ExternalSemaSource</name><operator>::</operator><name>ReadUnusedFileScopedDecls</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type>
<name>UnusedFileScopedDeclsType</name>;</typedef>



<decl_stmt><decl><type><name>UnusedFileScopedDeclsType</name></type> <name>UnusedFileScopedDecls</name></decl>;</decl_stmt>

<typedef>typedef <type><name><name>LazyVector</name><argument_list type="generic">&lt;<argument><expr><name>CXXConstructorDecl</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>ExternalSemaSource</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name>ExternalSemaSource</name><operator>::</operator><name>ReadDelegatingConstructors</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type>
<name>DelegatingCtorDeclsType</name>;</typedef>



<decl_stmt><decl><type><name>DelegatingCtorDeclsType</name></type> <name>DelegatingCtorDecls</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>CXXMethodDecl</name><modifier>*</modifier></expr></argument>, <argument><expr><specifier>const</specifier> <name>CXXMethodDecl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type>
<name>DelayedOverridingExceptionSpecChecks</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name><modifier>*</modifier></expr></argument>, <argument><expr><name>FunctionDecl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type>
<name>DelayedEquivalentExceptionSpecChecks</name></decl>;</decl_stmt>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>*</operator></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>LateParsedTemplate</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>LateParsedTemplateMapT</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>LateParsedTemplateMapT</name></type> <name>LateParsedTemplateMap</name></decl>;</decl_stmt>


<typedef>typedef <function_decl><type><name>void</name></type> <name>LateTemplateParserCB</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><name>LateParsedTemplate</name> <modifier>&amp;</modifier></type><name>LPT</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> <name>LateTemplateParserCleanupCB</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>P</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<decl_stmt><decl><type><name>LateTemplateParserCB</name> <modifier>*</modifier></type><name>LateTemplateParser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LateTemplateParserCleanupCB</name> <modifier>*</modifier></type><name>LateTemplateParserCleanup</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>OpaqueParser</name></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>SetLateTemplateParser</name><parameter_list>(<parameter><decl><type><name>LateTemplateParserCB</name> <modifier>*</modifier></type><name>LTP</name></decl></parameter>,
<parameter><decl><type><name>LateTemplateParserCleanupCB</name> <modifier>*</modifier></type><name>LTPCleanup</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>P</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>LateTemplateParser</name> <operator>=</operator> <name>LTP</name></expr>;</expr_stmt>
<expr_stmt><expr><name>LateTemplateParserCleanup</name> <operator>=</operator> <name>LTPCleanup</name></expr>;</expr_stmt>
<expr_stmt><expr><name>OpaqueParser</name> <operator>=</operator> <name>P</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>AddSYCLKernelLambda</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>class</name></type> <name>DelayedDiagnostics</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>DelayedDiagnosticsState</name> <block>{<block_content>
<expr_stmt><expr><name>sema</name><operator>::</operator><name>DelayedDiagnosticPool</name> <operator>*</operator><name>SavedPool</name></expr>;</expr_stmt>
<expr_stmt><expr><name>friend</name> <name>class</name> <name>Sema</name><operator>::</operator><name>DelayedDiagnostics</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<typedef>typedef <type><name>DelayedDiagnosticsState</name></type> <name>ParsingDeclState</name>;</typedef>
<typedef>typedef <type><name>DelayedDiagnosticsState</name></type> <name>ProcessingContextState</name>;</typedef>



<decl_stmt><decl><type><name>class</name></type> <name>DelayedDiagnostics</name> <block>{<block_content>


<expr_stmt><expr><name>sema</name><operator>::</operator><name>DelayedDiagnosticPool</name> <operator>*</operator><name>CurPool</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>DelayedDiagnostics</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>CurPool</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <block>{}</block>


<name>void</name> <call><name>add</name><argument_list>(<argument><expr><specifier>const</specifier> <name>sema</name><operator>::</operator><name>DelayedDiagnostic</name> <operator>&amp;</operator><name>diag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<function><type><name>bool</name></type> <name>shouldDelayDiagnostics</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>CurPool</name> <operator>!=</operator> <name>nullptr</name></expr>;</return> </block_content>}</block></function>


<expr_stmt><expr><name>sema</name><operator>::</operator><name>DelayedDiagnosticPool</name> <operator>*</operator><macro><name>getCurrentPool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>CurPool</name></expr>;</return>
}</block></expr></expr_stmt>



<decl_stmt><decl><type><name>DelayedDiagnosticsState</name></type> <name>push</name><argument_list>(<argument><expr><name>sema</name><operator>::</operator><name>DelayedDiagnosticPool</name> <operator>&amp;</operator><name>pool</name></expr></argument>)</argument_list> <block>{<block_content>
<decl_stmt><decl><type><name>DelayedDiagnosticsState</name></type> <name>state</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>SavedPool</name></name> <operator>=</operator> <name>CurPool</name></expr>;</expr_stmt>
<expr_stmt><expr><name>CurPool</name> <operator>=</operator> <operator>&amp;</operator><name>pool</name></expr>;</expr_stmt>
<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<function><type><name>void</name></type> <name>popWithoutEmitting</name><parameter_list>(<parameter><decl><type><name>DelayedDiagnosticsState</name></type> <name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>CurPool</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>SavedPool</name></name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><name>DelayedDiagnosticsState</name></type> <name>pushUndelayed</name><parameter_list>()</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>DelayedDiagnosticsState</name></type> <name>state</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>state</name><operator>.</operator><name>SavedPool</name></name> <operator>=</operator> <name>CurPool</name></expr>;</expr_stmt>
<expr_stmt><expr><name>CurPool</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>popUndelayed</name><parameter_list>(<parameter><decl><type><name>DelayedDiagnosticsState</name></type> <name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>CurPool</name> <operator>==</operator> <name>nullptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>CurPool</name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>SavedPool</name></name></expr>;</expr_stmt>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt> <expr_stmt><expr><name>DelayedDiagnostics</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ContextRAII</name> <block>{<block_content>
<label><name>private</name>:</label>
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>SavedContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ProcessingContextState</name></type> <name>SavedContextState</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>SavedCXXThisTypeOverride</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>SavedFunctionScopesStart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>SavedInventedParameterInfosStart</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>ContextRAII</name><argument_list>(<argument>Sema &amp;S</argument>, <argument>DeclContext *ContextToPush</argument>, <argument>bool NewThisContext = true</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>SavedContext</name><argument_list>(<argument><expr><name><name>S</name><operator>.</operator><name>CurContext</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>SavedContextState</name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>DelayedDiagnostics</name><operator>.</operator><name>pushUndelayed</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>SavedCXXThisTypeOverride</name><argument_list>(<argument><expr><name><name>S</name><operator>.</operator><name>CXXThisTypeOverride</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>SavedFunctionScopesStart</name><argument_list>(<argument><expr><name><name>S</name><operator>.</operator><name>FunctionScopesStart</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>SavedInventedParameterInfosStart</name><argument_list>(<argument>S.InventedParameterInfosStart</argument>)</argument_list></macro>
<expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>ContextToPush</name> <operator>&amp;&amp;</operator> <literal type="string">"pushing null context"</literal></expr></argument>)</argument_list></call></expr>;
<expr><name><name>S</name><operator>.</operator><name>CurContext</name></name> <operator>=</operator> <name>ContextToPush</name></expr>;
<if_stmt><if>if <condition>(<expr><name>NewThisContext</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>CXXThisTypeOverride</name></name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<name><name>S</name><operator>.</operator><name>FunctionScopesStart</name></name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>FunctionScopes</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></block></expr>;</expr_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>InventedParameterInfosStart</name></name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>InventedParameterInfos</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>pop</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>SavedContext</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>CurContext</name></name> <operator>=</operator> <name>SavedContext</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>DelayedDiagnostics</name><operator>.</operator><name>popUndelayed</name></name><argument_list>(<argument><expr><name>SavedContextState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>CXXThisTypeOverride</name></name> <operator>=</operator> <name>SavedCXXThisTypeOverride</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>FunctionScopesStart</name></name> <operator>=</operator> <name>SavedFunctionScopesStart</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>InventedParameterInfosStart</name></name> <operator>=</operator> <name>SavedInventedParameterInfosStart</name></expr>;</expr_stmt>
<expr_stmt><expr><name>SavedContext</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><operator>~</operator><macro><name>ContextRAII</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>pop</name><argument_list>()</argument_list></call></expr>;
}</block></expr></expr_stmt>
};




<decl_stmt><decl><type><name>bool</name></type> <name>RebuildingImmediateInvocation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>isConstantEvaluatedOverride</name></decl>;</decl_stmt>

<function><type><name>bool</name></type> <name>isConstantEvaluated</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>ExprEvalContexts</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isConstantEvaluated</name><argument_list>()</argument_list></call> <operator>||</operator>
<name>isConstantEvaluatedOverride</name></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name>class</name></type> <name>SynthesizedFunctionScope</name> <block>{<block_content>
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl>;</decl_stmt>
<expr_stmt><expr><name>Sema</name><operator>::</operator><name>ContextRAII</name> <name>SavedContext</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>PushedCodeSynthesisContext</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>SynthesizedFunctionScope</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>, <argument><expr><name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>S</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>SavedContext</name><argument_list>(<argument>S</argument>, <argument>DC</argument>)</argument_list></macro> <expr><block>{
<expr><call><name><name>S</name><operator>.</operator><name>PushFunctionScope</name></name><argument_list>()</argument_list></call></expr>;
<expr><call><name><name>S</name><operator>.</operator><name>PushExpressionEvaluationContext</name></name><argument_list>(
<argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>PotentiallyEvaluated</name></expr></argument>)</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>FD</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>FD</name><operator>-&gt;</operator><name>setWillHaveBody</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>addContextNote</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>UseLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>PushedCodeSynthesisContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>Sema</name><operator>::</operator><name>CodeSynthesisContext</name> <name>Ctx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Ctx</name><operator>.</operator><name>Kind</name></name> <operator>=</operator> <name>Sema</name><operator>::</operator><name>CodeSynthesisContext</name><operator>::</operator><name>DefiningSynthesizedFunction</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Ctx</name><operator>.</operator><name>PointOfInstantiation</name></name> <operator>=</operator> <name>UseLoc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Ctx</name><operator>.</operator><name>Entity</name></name> <operator>=</operator> <call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>S</name><operator>.</operator><name>CurContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>pushCodeSynthesisContext</name></name><argument_list>(<argument><expr><name>Ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>PushedCodeSynthesisContext</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><operator>~</operator><macro><name>SynthesizedFunctionScope</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>PushedCodeSynthesisContext</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>popCodeSynthesisContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>FD</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name><name>S</name><operator>.</operator><name>CurContext</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>FD</name><operator>-&gt;</operator><name>setWillHaveBody</name></name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>PopExpressionEvaluationContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>PopFunctionScopeInfo</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>
};




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>WeakInfo</name></expr></argument>&gt;</argument_list></name> <name>WeakUndeclaredIdentifiers</name></expr>;</expr_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name><operator>*</operator></expr></argument>,<argument><expr><name>AsmLabelAttr</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ExtnameUndeclaredIdentifiers</name></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>LoadExternalWeakUndeclaredIdentifiers</name><parameter_list>()</parameter_list>;</function_decl>






<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name><modifier>*</modifier></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>WeakTopLevelDecl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IdentifierResolver</name></type> <name>IdResolver</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>Scope</name> <modifier>*</modifier></type><name>TUScope</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>LazyDeclPtr</name></type> <name>StdNamespace</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>LazyDeclPtr</name></type> <name>StdBadAlloc</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>LazyDeclPtr</name></type> <name>StdAlignValT</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>NamespaceDecl</name> <modifier>*</modifier></type><name>StdExperimentalNamespaceCache</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>ClassTemplateDecl</name> <modifier>*</modifier></type><name>StdInitializerList</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>ClassTemplateDecl</name> <modifier>*</modifier></type><name>StdCoroutineTraitsCache</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>CXXTypeInfoDecl</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>MSVCGuidDecl</name></decl>;</decl_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>NSAPI</name></expr></argument>&gt;</argument_list></name> <name>NSAPIObj</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>NSNumberDecl</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>NSValueDecl</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>NSNumberPointer</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>NSValuePointer</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name><name>NSNumberLiteralMethods</name><index>[<expr><name>NSAPI</name><operator>::</operator><name>NumNSNumberLiteralMethods</name></expr>]</index></name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>NSStringDecl</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>NSStringPointer</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>StringWithUTF8StringMethod</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>ValueWithBytesObjCTypeMethod</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>NSArrayDecl</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>ArrayWithObjectsMethod</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>NSDictionaryDecl</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>DictionaryWithObjectsMethod</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>QualType</name></type> <name>QIDNSCopying</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Selector</name></type> <name>RespondsToSelectorSel</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>GlobalNewDeleteDeclared</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>ExpressionEvaluationContext</name> <block>{<block_content>





<expr_stmt><expr><name>Unevaluated</name></expr><operator>,</operator>





<expr><name>UnevaluatedList</name></expr><operator>,</operator>




<expr><name>DiscardedStatement</name></expr><operator>,</operator>




<expr><name>UnevaluatedAbstract</name></expr><operator>,</operator>




<expr><name>ConstantEvaluated</name></expr><operator>,</operator>




<expr><name>PotentiallyEvaluated</name></expr><operator>,</operator>









<expr><name>PotentiallyEvaluatedIfUsed</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>ImmediateInvocationCandidate</name> <init>= <expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>ConstantExpr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>



<struct>struct <name>ExpressionEvaluationContextRecord</name> <block>{

<decl_stmt><decl><type><name>ExpressionEvaluationContext</name></type> <name>Context</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CleanupInfo</name></type> <name>ParentCleanup</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumCleanupObjects</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>NumTypos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>MaybeODRUseExprSet</name></type> <name>SavedMaybeODRUseExprs</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>LambdaExpr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>Lambdas</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ManglingContextDecl</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CallExpr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>DelayedDecltypeCalls</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CXXBindTemporaryExpr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>DelayedDecltypeBinds</name></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>PossibleDerefs</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name></type> <name>VolatileAssignmentLHSs</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ImmediateInvocationCandidate</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>ImmediateInvocationCandidates</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>DeclRefExpr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>ReferenceToConsteval</name></expr>;</expr_stmt>



<enum>enum <name>ExpressionKind</name> <block>{
<decl><name>EK_Decltype</name></decl>, <decl><name>EK_TemplateArgument</name></decl>, <decl><name>EK_Other</name></decl>
}</block> <decl><name>ExprContext</name></decl>;</enum>

<macro><name>ExpressionEvaluationContextRecord</name><argument_list>(<argument>ExpressionEvaluationContext Context</argument>,
<argument>unsigned NumCleanupObjects</argument>,
<argument>CleanupInfo ParentCleanup</argument>,
<argument>Decl *ManglingContextDecl</argument>,
<argument>ExpressionKind ExprContext</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Context</name><argument_list>(<argument><expr><name>Context</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ParentCleanup</name><argument_list>(<argument><expr><name>ParentCleanup</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>NumCleanupObjects</name><argument_list>(<argument><expr><name>NumCleanupObjects</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>NumTypos</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>ManglingContextDecl</name><argument_list>(<argument><expr><name>ManglingContextDecl</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>ExprContext</name><argument_list>(<argument>ExprContext</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>isUnevaluated</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Context</name> <operator>==</operator> <name>ExpressionEvaluationContext</name><operator>::</operator><name>Unevaluated</name> <operator>||</operator>
<name>Context</name> <operator>==</operator> <name>ExpressionEvaluationContext</name><operator>::</operator><name>UnevaluatedAbstract</name> <operator>||</operator>
<name>Context</name> <operator>==</operator> <name>ExpressionEvaluationContext</name><operator>::</operator><name>UnevaluatedList</name></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isConstantEvaluated</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Context</name> <operator>==</operator> <name>ExpressionEvaluationContext</name><operator>::</operator><name>ConstantEvaluated</name></expr>;</return>
}</block></expr></expr_stmt>
}</block>;</struct>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ExpressionEvaluationContextRecord</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name></type> <name>ExprEvalContexts</name></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>WarnOnPendingNoDerefs</name><parameter_list>(<parameter><decl><type><name>ExpressionEvaluationContextRecord</name> <modifier>&amp;</modifier></type><name>Rec</name></decl></parameter>)</parameter_list>;</function_decl>






<expr_stmt><expr><name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>MangleNumberingContext</name> <operator>*</operator></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<call><name>getCurrentMangleNumberContext</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><name>DC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<decl_stmt><decl><type><name>class</name></type> <name>SpecialMemberOverloadResult</name> <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>Kind</name> <block>{
<decl><name>NoMemberOrDeleted</name></decl>,
<decl><name>Ambiguous</name></decl>,
<decl><name>Success</name></decl>
}</block>;</enum>

<label><name>private</name>:</label>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>Pair</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>SpecialMemberOverloadResult</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>Pair</name><argument_list>()</argument_list></macro> <block>{}</block>
<call><name>SpecialMemberOverloadResult</name><argument_list>(<argument><expr><name>CXXMethodDecl</name> <operator>*</operator><name>MD</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>Pair</name><argument_list>(<argument>MD</argument>, <argument>MD-&gt;isDeleted() ? NoMemberOrDeleted : Success</argument>)</argument_list></macro> <block>{}</block>

<name>CXXMethodDecl</name> <operator>*</operator><macro><name>getMethod</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Pair</name><operator>.</operator><name>getPointer</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setMethod</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Pair</name><operator>.</operator><name>setPointer</name></name><argument_list>(<argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>

<expr_stmt><expr><name>Kind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>static_cast</name><argument_list type="generic">&lt;<argument><expr><name>Kind</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>Pair</name><operator>.</operator><name>getInt</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>setKind</name><parameter_list>(<parameter><decl><type><name>Kind</name></type> <name>K</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name><name>Pair</name><operator>.</operator><name>setInt</name></name><argument_list>(<argument><expr><name>K</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>SpecialMemberOverloadResultEntry</name>
<range>: <expr><name>public</name> <name>llvm</name><operator>::</operator><name>FastFoldingSetNode</name></expr></range></decl>,
<decl><type ref="prev"/><name>public</name> <name>SpecialMemberOverloadResult</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>SpecialMemberOverloadResultEntry</name><argument_list>(<argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>FoldingSetNodeID</name> <operator>&amp;</operator><name>ID</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>FastFoldingSetNode</name><argument_list>(<argument>ID</argument>)</argument_list></macro>
<block>{}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>FoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>SpecialMemberOverloadResultEntry</name></expr></argument>&gt;</argument_list></name> <name>SpecialMemberCache</name></expr>;</expr_stmt>



<expr_stmt><expr><name>mutable</name> <name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>EnumDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>APInt</name></expr></argument>&gt;</argument_list></name> <name>FlagBitsCache</name></expr>;</expr_stmt>








<decl_stmt><decl><type><specifier>const</specifier> <name>TranslationUnitKind</name></type> <name>TUKind</name></decl>;</decl_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name>BumpPtrAllocator</name> <name>BumpAlloc</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>NumSFINAEErrors</name></decl>;</decl_stmt>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>TinyPtrVector</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>UnparsedDefaultArgInstantiationsMap</name></expr>;</expr_stmt></typedef>








<decl_stmt><decl><type><name>UnparsedDefaultArgInstantiationsMap</name></type> <name>UnparsedDefaultArgInstantiations</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <name>UnparsedDefaultArgLocs</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <name>UndefinedButUsed</name></expr>;</expr_stmt>




<function_decl><type><name>bool</name></type> <name>isExternalWithNoLinkageType</name><parameter_list>(<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>getUndefinedButUsed</name><parameter_list>(
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Undefined</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>FieldDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>DeleteLocs</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator>
<macro><name>getMismatchingDeleteExpressions</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodList</name></expr></argument>, <argument><expr><name>ObjCMethodList</name></expr></argument>&gt;</argument_list></name> <name>GlobalMethods</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Selector</name></expr></argument>, <argument><expr><name>GlobalMethods</name></expr></argument>&gt;</argument_list></name> <name>GlobalMethodPool</name></expr>;</expr_stmt></typedef>







<decl_stmt><decl><type><name>GlobalMethodPool</name></type> <name>MethodPool</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>Selector</name></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <name>ReferencedSelectors</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>BlockDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name>
<name>ImplicitlyRetainedSelfLocs</name></expr>;</expr_stmt>


<enum>enum <name>CXXSpecialMember</name> <block>{
<decl><name>CXXDefaultConstructor</name></decl>,
<decl><name>CXXCopyConstructor</name></decl>,
<decl><name>CXXMoveConstructor</name></decl>,
<decl><name>CXXCopyAssignment</name></decl>,
<decl><name>CXXMoveAssignment</name></decl>,
<decl><name>CXXDestructor</name></decl>,
<decl><name>CXXInvalid</name></decl>
}</block>;</enum>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>PointerIntPair</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>CXXSpecialMember</name></expr></argument>&gt;</argument_list></name>
<name>SpecialMemberDecl</name></expr>;</expr_stmt></typedef>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>SpecialMemberDecl</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>SpecialMembersBeingDeclared</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>DefaultedComparisonKind</name> <range>: <expr><name>unsigned</name> <name>char</name> <block>{

<expr><name>None</name></expr>,


<expr><name>Equal</name></expr>,


<expr><name>ThreeWay</name></expr>,


<expr><name>NotEqual</name></expr>,


<expr><name>Relational</name></expr>,
}</block></expr></range></decl>;</decl_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>TypoCorrectedFunctionDefinitions</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>CurrentParameterCopyTypes</name></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>ReadMethodPool</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>updateOutOfDateSelector</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>isSelfExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isSelfExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RExpr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>EmitCurrentDiagnostic</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>class</name></type> <name>FPFeaturesStateRAII</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>FPFeaturesStateRAII</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>S</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>OldFPFeaturesState</name><argument_list>(<argument>S.CurFPFeatures</argument>)</argument_list></macro> <expr><block>{
<expr><name>OldOverrides</name> <operator>=</operator> <name><name>S</name><operator>.</operator><name>FpPragmaStack</name><operator>.</operator><name>CurrentValue</name></name></expr>;
}</block>
<operator>~</operator><macro><name>FPFeaturesStateRAII</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>S</name><operator>.</operator><name>CurFPFeatures</name></name> <operator>=</operator> <name>OldFPFeaturesState</name></expr>;
<expr><name><name>S</name><operator>.</operator><name>FpPragmaStack</name><operator>.</operator><name>CurrentValue</name></name> <operator>=</operator> <name>OldOverrides</name></expr>;
}</block>
<name>FPOptionsOverride</name> <macro><name>getOverrides</name><argument_list>()</argument_list></macro> <block>{ <return>return <expr><name>OldOverrides</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>Sema</name><modifier>&amp;</modifier></type> <name>S</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FPOptions</name></type> <name>OldFPFeaturesState</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FPOptionsOverride</name></type> <name>OldOverrides</name></decl>;</decl_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<function_decl><type><name>void</name></type> <name>addImplicitTypedef</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Name</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>WarnedStackExhausted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>int</name></expr></argument>&gt;</argument_list></name> <name>RefsMinusAssignments</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>DarwinSDKInfo</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>CachedDarwinSDKInfo</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>Sema</name><argument_list>(<argument>Preprocessor &amp;pp</argument>, <argument>ASTContext &amp;ctxt</argument>, <argument>ASTConsumer &amp;consumer</argument>,
<argument>TranslationUnitKind TUKind = TU_Complete</argument>,
<argument>CodeCompleteConsumer *CompletionConsumer = nullptr</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><operator>~</operator><call><name>Sema</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>Initialize</name><parameter_list>()</parameter_list>;</function_decl>






<function_decl><type><name>virtual</name> <name>void</name></type> <name>anchor</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>const</specifier> <name>LangOptions</name> <operator>&amp;</operator><macro><name>getLangOpts</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>LangOpts</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><name>OpenCLOptions</name> <modifier>&amp;</modifier></type><name>getOpenCLOptions</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>OpenCLFeatures</name></expr>;</return> </block_content>}</block></function>
<function><type><name>FPOptions</name> <modifier>&amp;</modifier></type><name>getCurFPFeatures</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>CurFPFeatures</name></expr>;</return> </block_content>}</block></function>

<expr_stmt><expr><name>DiagnosticsEngine</name> <operator>&amp;</operator><macro><name>getDiagnostics</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Diags</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>SourceManager</name> <operator>&amp;</operator><macro><name>getSourceManager</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SourceMgr</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>Preprocessor</name> <operator>&amp;</operator><macro><name>getPreprocessor</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>PP</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>ASTContext</name> <operator>&amp;</operator><macro><name>getASTContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Context</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>ASTConsumer</name> <operator>&amp;</operator><macro><name>getASTConsumer</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Consumer</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>ASTMutationListener</name> <operator>*</operator><macro><name>getASTMutationListener</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>ExternalSemaSource</name><operator>*</operator> <macro><name>getExternalSource</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>ExternalSource</name></expr>;</return> }</block></expr></expr_stmt>
<function_decl><type><name>DarwinSDKInfo</name> <modifier>*</modifier></type><name>getDarwinSDKInfoForAvailabilityChecking</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Platform</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>addExternalSource</name><parameter_list>(<parameter><decl><type><name>ExternalSemaSource</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>void</name> <macro><name>PrintStats</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>warnStackExhausted</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>void</name></type> <name>runWithSufficientStackSpace</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>Fn</name></expr></argument>)</argument_list></decl>;</decl_stmt>










<decl_stmt><decl><type><name>class</name></type> <name>ImmediateDiagBuilder</name> <range>: <expr><name>public</name> <name>DiagnosticBuilder</name> <block>{
<expr><name>Sema</name> <operator>&amp;</operator><name>SemaRef</name></expr>;
<expr><name>unsigned</name> <name>DiagID</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ImmediateDiagBuilder</name><argument_list>(<argument>DiagnosticBuilder &amp;DB</argument>, <argument>Sema &amp;SemaRef</argument>, <argument>unsigned DiagID</argument>)</argument_list></macro>
<operator>:</operator> <call><name>DiagnosticBuilder</name><argument_list>(<argument><expr><name>DB</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>SemaRef</name><argument_list>(<argument><expr><name>SemaRef</name></expr></argument>)</argument_list></call></expr>, <macro><name>DiagID</name><argument_list>(<argument>DiagID</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>ImmediateDiagBuilder</name><argument_list>(<argument>DiagnosticBuilder &amp;&amp;DB</argument>, <argument>Sema &amp;SemaRef</argument>, <argument>unsigned DiagID</argument>)</argument_list></macro>
<operator>:</operator> <call><name>DiagnosticBuilder</name><argument_list>(<argument><expr><name>DB</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>SemaRef</name><argument_list>(<argument><expr><name>SemaRef</name></expr></argument>)</argument_list></call></expr>, <macro><name>DiagID</name><argument_list>(<argument>DiagID</argument>)</argument_list></macro> <expr><block>{}</block>







<call><name>ImmediateDiagBuilder</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ImmediateDiagBuilder</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;

<expr><operator>~</operator><macro><name>ImmediateDiagBuilder</name><argument_list>()</argument_list></macro> <block>{

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>









<call><name>Clear</name><argument_list>()</argument_list></call></block></expr>;


<expr><call><name><name>SemaRef</name><operator>.</operator><name>EmitCurrentDiagnostic</name></name><argument_list>(<argument><expr><name>DiagID</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <specifier>const</specifier> <name>ImmediateDiagBuilder</name> <operator>&amp;</operator>
<name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><specifier>const</specifier> <name>ImmediateDiagBuilder</name> <operator>&amp;</operator><name>Diag</name>, <specifier>const</specifier> <name>T</name> <operator>&amp;</operator><name>Value</name><operator>)</operator> <block>{
<expr><specifier>const</specifier> <name>DiagnosticBuilder</name> <operator>&amp;</operator><name>BaseDiag</name> <operator>=</operator> <name>Diag</name></expr>;
<expr><name>BaseDiag</name> <operator>&lt;&lt;</operator> <name>Value</name></expr>;
<return>return <expr><name>Diag</name></expr>;</return>
}</block></expr></range></decl></decl_stmt>




<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <operator>=</operator> <name>typename</name> <name>std</name><operator>::</operator><name><name>enable_if</name><argument_list type="generic">&lt;
<argument><expr><operator>!</operator><name>std</name><operator>::</operator><name><name>is_lvalue_reference</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>ImmediateDiagBuilder</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>T</name> <operator>&amp;&amp;</operator><name>V</name><operator>)</operator> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>DiagnosticBuilder</name> <operator>&amp;</operator><name>BaseDiag</name> <operator>=</operator> <operator>*</operator><name>this</name></expr>;
<expr><name>BaseDiag</name> <operator>&lt;&lt;</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}</block></expr></expr_stmt>
};















<decl_stmt><decl><type><name>class</name></type> <name>SemaDiagnosticBuilder</name> <block>{<block_content>
<label><name>public</name>:</label>
<enum>enum <name>Kind</name> <block>{

<decl><name>K_Nop</name></decl>,

<decl><name>K_Immediate</name></decl>,



<decl><name>K_ImmediateWithCallStack</name></decl>,



<decl><name>K_Deferred</name></decl>
}</block>;</enum>

<macro><name>SemaDiagnosticBuilder</name><argument_list>(<argument>Kind K</argument>, <argument>SourceLocation Loc</argument>, <argument>unsigned DiagID</argument>,
<argument>FunctionDecl *Fn</argument>, <argument>Sema &amp;S</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><call><name>SemaDiagnosticBuilder</name><argument_list>(<argument><expr><name>SemaDiagnosticBuilder</name> <operator>&amp;&amp;</operator><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SemaDiagnosticBuilder</name><argument_list>(<argument><expr><specifier>const</specifier> <name>SemaDiagnosticBuilder</name> <operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> default</expr>;</expr_stmt>
<expr_stmt><expr><operator>~</operator><call><name>SemaDiagnosticBuilder</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isImmediate</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>ImmediateDiag</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>











<expr_stmt><expr><name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isImmediate</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>&gt;</argument_list></name>
<name>friend</name> <specifier>const</specifier> <name>SemaDiagnosticBuilder</name> <operator>&amp;</operator>
<name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><specifier>const</specifier> <name>SemaDiagnosticBuilder</name> <operator>&amp;</operator><name>Diag</name><operator>,</operator> <specifier>const</specifier> <name>T</name> <operator>&amp;</operator><name>Value</name><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Diag</name><operator>.</operator><name>ImmediateDiag</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name><name>Diag</name><operator>.</operator><name>ImmediateDiag</name></name> <operator>&lt;&lt;</operator> <name>Value</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>Diag</name><operator>.</operator><name>PartialDiagId</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>Diag</name><operator>.</operator><name>S</name><operator>.</operator><name>DeviceDeferredDiags</name><index>[<expr><name><name>Diag</name><operator>.</operator><name>Fn</name></name></expr>]</index><index>[<expr><operator>*</operator><name><name>Diag</name><operator>.</operator><name>PartialDiagId</name></name></expr>]</index></name><operator>.</operator><name>second</name>
<operator>&lt;&lt;</operator> <name>Value</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>Diag</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>




<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name> <name>T</name></expr></argument>, <argument><expr><name>typename</name> <operator>=</operator> <name>typename</name> <name>std</name><operator>::</operator><name><name>enable_if</name><argument_list type="generic">&lt;
<argument><expr><operator>!</operator><name>std</name><operator>::</operator><name><name>is_lvalue_reference</name><argument_list type="generic">&lt;<argument><expr><name>T</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>value</name></expr></argument>&gt;</argument_list></name><operator>::</operator><name>type</name></expr></argument>&gt;</argument_list></name>
<specifier>const</specifier> <name>SemaDiagnosticBuilder</name> <operator>&amp;</operator><name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><name>T</name> <operator>&amp;&amp;</operator><name>V</name><operator>)</operator> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>ImmediateDiag</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>ImmediateDiag</name> <operator>&lt;&lt;</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>PartialDiagId</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>DeviceDeferredDiags</name><index>[<expr><name>Fn</name></expr>]</index><index>[<expr><operator>*</operator><name>PartialDiagId</name></expr>]</index></name><operator>.</operator><name>second</name> <operator>&lt;&lt;</operator> <name>std</name><operator>::</operator><call><name>move</name><argument_list>(<argument><expr><name>V</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><operator>*</operator><name>this</name></expr>;</return>
}

friend <expr_stmt><expr><specifier>const</specifier> <name>SemaDiagnosticBuilder</name> <operator>&amp;</operator>
<name>operator</name><operator>&lt;&lt;</operator><operator>(</operator><specifier>const</specifier> <name>SemaDiagnosticBuilder</name> <operator>&amp;</operator><name>Diag</name><operator>,</operator> <specifier>const</specifier> <name>PartialDiagnostic</name> <operator>&amp;</operator><name>PD</name><operator>)</operator> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>Diag</name><operator>.</operator><name>ImmediateDiag</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>PD</name><operator>.</operator><name>Emit</name></name><argument_list>(<argument><expr><operator>*</operator><name><name>Diag</name><operator>.</operator><name>ImmediateDiag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>Diag</name><operator>.</operator><name>PartialDiagId</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>Diag</name><operator>.</operator><name>S</name><operator>.</operator><name>DeviceDeferredDiags</name><index>[<expr><name><name>Diag</name><operator>.</operator><name>Fn</name></name></expr>]</index><index>[<expr><operator>*</operator><name><name>Diag</name><operator>.</operator><name>PartialDiagId</name></name></expr>]</index></name><operator>.</operator><name>second</name> <operator>=</operator> <name>PD</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>Diag</name></expr>;</return>
}

void <macro><name>AddFixItHint</name><argument_list>(<argument>const FixItHint &amp;Hint</argument>)</argument_list></macro> <expr_stmt><expr><specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><call><name><name>ImmediateDiag</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>ImmediateDiag</name><operator>-&gt;</operator><name>AddFixItHint</name></name><argument_list>(<argument><expr><name>Hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name><name>PartialDiagId</name><operator>.</operator><name>hasValue</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>S</name><operator>.</operator><name>DeviceDeferredDiags</name><index>[<expr><name>Fn</name></expr>]</index><index>[<expr><operator>*</operator><name>PartialDiagId</name></expr>]</index></name><operator>.</operator><call><name><name>second</name><operator>.</operator><name>AddFixItHint</name></name><argument_list>(<argument><expr><name>Hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>

<function><type><name>friend</name> <name>ExprResult</name></type> <name>ExprError</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SemaDiagnosticBuilder</name> <modifier>&amp;</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>friend</name> <name>StmtResult</name></type> <name>StmtError</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SemaDiagnosticBuilder</name> <modifier>&amp;</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<expr_stmt><expr><name>operator</name> <macro><name>ExprResult</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>ExprError</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>operator</name> <macro><name>StmtResult</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>StmtError</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>operator</name> <macro><name>TypeResult</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>TypeError</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>operator</name> <macro><name>DeclResult</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>DeclResult</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>operator</name> <macro><name>MemInitResult</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>MemInitResult</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>DiagID</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Fn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ShowCallStack</name></decl>;</decl_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>ImmediateDiagBuilder</name></expr></argument>&gt;</argument_list></name> <name>ImmediateDiag</name></expr>;</expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>PartialDiagId</name></expr>;</expr_stmt>
};



<decl_stmt><decl><type><name>bool</name></type> <name>IsLastErrorImmediate</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>


<function_decl><type><name>SemaDiagnosticBuilder</name></type> <name>Diag</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DeferHint</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>SemaDiagnosticBuilder</name></type> <name>Diag</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>PD</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DeferHint</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>PartialDiagnostic</name></type> <name>PDiag</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>DiagID</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>bool</name></type> <name>DeferDiags</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>DeferDiagsRAII</name> <block>{<block_content>
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>SavedDeferDiags</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>DeferDiagsRAII</name><argument_list>(<argument>Sema &amp;S</argument>, <argument>bool DeferDiags</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>SavedDeferDiags</name><argument_list>(<argument>S.DeferDiags</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>S</name><operator>.</operator><name>DeferDiags</name></name> <operator>=</operator> <name>DeferDiags</name></expr>;
}</block>
<operator>~</operator><macro><name>DeferDiagsRAII</name><argument_list>()</argument_list></macro> <block>{ <expr><name><name>S</name><operator>.</operator><name>DeferDiags</name></name> <operator>=</operator> <name>SavedDeferDiags</name></expr>; }</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>hasUncompilableErrorOccurred</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><name>bool</name></type> <name>findMacroSpelling</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>loc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>name</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name>
<macro><name>getFixItZeroInitializerForType</name><argument_list>(<argument>QualType T</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getFixItZeroLiteralForType</name><argument_list>(<argument>QualType T</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function_decl><type><name>SourceLocation</name></type> <name>getLocForEndOfToken</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>ModuleLoader</name> <operator>&amp;</operator><macro><name>getModuleLoader</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function_decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type>
<name>InventAbbreviatedTemplateParameterTypeName</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ParamName</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Index</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>emitAndClearUnusedLocalTypedefWarnings</name><parameter_list>()</parameter_list>;</function_decl>

<label><name>private</name>:</label>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallSetVector</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>DeclsToCheckForDeferredDiags</name></expr>;</expr_stmt>

<label><name>public</name>:</label>

<function_decl><type><name>void</name></type> <name>emitDeferredDiags</name><parameter_list>()</parameter_list>;</function_decl>

<enum>enum <name>TUFragmentKind</name> <block>{

<decl><name>Global</name></decl>,



<decl><name>Normal</name></decl>,


<decl><name>Private</name></decl>
}</block>;</enum>

<function_decl><type><name>void</name></type> <name>ActOnStartOfTranslationUnit</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnEndOfTranslationUnit</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnEndOfTranslationUnitFragment</name><parameter_list>(<parameter><decl><type><name>TUFragmentKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckDelegatingCtorCycles</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>Scope</name> <modifier>*</modifier></type><name>getScopeForContext</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>Ctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>PushFunctionScope</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>PushBlockScope</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>BlockScope</name></decl></parameter>, <parameter><decl><type><name>BlockDecl</name> <modifier>*</modifier></type><name>Block</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>sema</name><operator>::</operator><name>LambdaScopeInfo</name> <operator>*</operator><call><name>PushLambdaScope</name><argument_list>()</argument_list></call></expr>;</expr_stmt>




<function_decl><type><name>void</name></type> <name>RecordParsingTemplateParameterDepth</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Depth</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>PushCapturedRegionScope</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>RegionScope</name></decl></parameter>, <parameter><decl><type><name>CapturedDecl</name> <modifier>*</modifier></type><name>CD</name></decl></parameter>,
<parameter><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>, <parameter><decl><type><name>CapturedRegionKind</name></type> <name>K</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>OpenMPCaptureLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>class</name></type> <name>PoppedFunctionScopeDeleter</name> <block>{<block_content>
<decl_stmt><decl><type><name>Sema</name> <modifier>*</modifier></type><name>Self</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>PoppedFunctionScopeDeleter</name><argument_list>(<argument><expr><name>Sema</name> <operator>*</operator><name>Self</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Self</name><argument_list>(<argument>Self</argument>)</argument_list></macro> <block>{}</block>
<name>void</name> <macro><name>operator</name><argument_list>()</argument_list></macro><operator>(</operator><name>sema</name><operator>::</operator><name>FunctionScopeInfo</name> <operator>*</operator><name>Scope</name><operator>)</operator> <specifier>const</specifier></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>using</name></type> <name>PoppedFunctionScopePtr</name> <init>=
<expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>sema</name><operator>::</operator><name>FunctionScopeInfo</name></expr></argument>, <argument><expr><name>PoppedFunctionScopeDeleter</name></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PoppedFunctionScopePtr</name></type>
<name>PopFunctionScopeInfo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>sema</name><operator>::</operator><name>AnalysisBasedWarnings</name><operator>::</operator><name>Policy</name> <operator>*</operator><name>WP</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Decl</name> <operator>*</operator><name>D</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>QualType</name> <name>BlockType</name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><name>sema</name><operator>::</operator><name>FunctionScopeInfo</name> <operator>*</operator><macro><name>getCurFunction</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>FunctionScopes</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>?</operator> <name>nullptr</name> <operator>:</operator> <call><name><name>FunctionScopes</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>sema</name><operator>::</operator><name>FunctionScopeInfo</name> <operator>*</operator><macro><name>getEnclosingFunction</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><name>void</name></type> <name>setFunctionHasBranchIntoScope</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setFunctionHasBranchProtectedScope</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setFunctionHasIndirectGoto</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setFunctionHasMustTail</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>PushCompoundScope</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsStmtExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>PopCompoundScope</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>sema</name><operator>::</operator><name>CompoundScopeInfo</name> <operator>&amp;</operator><macro><name>getCurCompoundScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>hasAnyUnrecoverableErrorsInThisFunction</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<expr_stmt><expr><name>sema</name><operator>::</operator><name>BlockScopeInfo</name> <operator>*</operator><call><name>getCurBlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>sema</name><operator>::</operator><name>LambdaScopeInfo</name> <operator>*</operator><macro><name>getEnclosingLambda</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>





<expr_stmt><expr><name>sema</name><operator>::</operator><name>LambdaScopeInfo</name> <operator>*</operator>
<macro><name>getCurLambda</name><argument_list>(<argument>bool IgnoreNonLambdaCapturingScope = false</argument>)</argument_list></macro></expr>;</expr_stmt>


<expr_stmt><expr><name>sema</name><operator>::</operator><name>LambdaScopeInfo</name> <operator>*</operator><call><name>getCurGenericLambda</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>sema</name><operator>::</operator><name>CapturedRegionScopeInfo</name> <operator>*</operator><call><name>getCurCapturedRegion</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>sema</name><operator>::</operator><name>FunctionScopeInfo</name> <operator>*</operator><call><name>getCurFunctionAvailabilityContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt>


<function><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>WeakTopLevelDecls</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><name>WeakTopLevelDecl</name></expr>;</return> </block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>ActOnStartFunctionDeclarationDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>TemplateParameterDepth</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ActOnFinishFunctionDeclarationDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnComment</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>Comment</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>QualType</name></type> <name>BuildQualifiedType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Qualifiers</name></type> <name>Qs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>*</modifier></type><name>DS</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>BuildQualifiedType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>CVRA</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>*</modifier></type><name>DS</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>BuildPointerType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>Entity</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>BuildReferenceType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>LValueRef</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>Entity</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>QualType</name></type> <name>BuildArrayType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>, <argument><expr><name>ArrayType</name><operator>::</operator><name>ArraySizeModifier</name> <name>ASM</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>ArraySize</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Quals</name></expr></argument>,
<argument><expr><name>SourceRange</name> <name>Brackets</name></expr></argument>, <argument><expr><name>DeclarationName</name> <name>Entity</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>QualType</name></type> <name>BuildVectorType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>VecSize</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>AttrLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>BuildExtVectorType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ArraySize</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AttrLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>BuildMatrixType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NumRows</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NumColumns</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AttrLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>BuildAddressSpaceAttr</name><parameter_list>(<parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>LangAS</name></type> <name>ASIdx</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>AddrSpace</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AttrLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>BuildAddressSpaceAttr</name><parameter_list>(<parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>AddrSpace</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AttrLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckQualifiedFunctionForTypeId</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckFunctionReturnType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>




























<decl_stmt><decl><type><name>QualType</name></type> <name>BuildFunctionType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>,
<argument><expr><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <name>ParamTypes</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>DeclarationName</name> <name>Entity</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionProtoType</name><operator>::</operator><name>ExtProtoInfo</name> <operator>&amp;</operator><name>EPI</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>QualType</name></type> <name>BuildMemberPointerType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Class</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>DeclarationName</name></type> <name>Entity</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>BuildBlockPointerType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>Entity</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>BuildParenType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>BuildAtomicType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>BuildReadPipeType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>BuildWritePipeType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>BuildExtIntType</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsUnsigned</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BitWidth</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>GetTypeForDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>GetTypeForDeclaratorCast</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>FromTy</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ParsedType</name></type> <name>CreateParsedType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclarationNameInfo</name></type> <name>GetNameForDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclarationNameInfo</name></type> <name>GetNameFromUnqualifiedId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>QualType</name></type> <name>GetTypeFromParser</name><parameter_list>(<parameter><decl><type><name>ParsedType</name></type> <name>Ty</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>TInfo</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CanThrowResult</name></type> <name>canThrow</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>CanThrowResult</name></type> <name>canCalleeThrow</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>ResolveExceptionSpec</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>FPT</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>UpdateExceptionSpec</name><argument_list>(<argument><expr><name>FunctionDecl</name> <operator>*</operator><name>FD</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionProtoType</name><operator>::</operator><name>ExceptionSpecInfo</name> <operator>&amp;</operator><name>ESI</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>bool</name></type> <name>CheckSpecifiedExceptionType</name><parameter_list>(<parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckDistantExceptionSpec</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckEquivalentExceptionSpec</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckEquivalentExceptionSpec</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OldLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>New</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>NewLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckEquivalentExceptionSpec</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type> <name>NoteID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OldLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>New</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>NewLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>handlerCanCatch</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>HandlerType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ExceptionType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckExceptionSpecSubset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>DiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>NestedDiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>NoteID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>NoThrowDiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Superset</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Subset</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>SubLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckParamExceptionSpec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>NestedDiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>NoteID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Target</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TargetLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Source</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>SourceLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TypeResult</name></type> <name>ActOnTypeName</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ParsedType</name></type> <name>ActOnObjCInstanceType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>


<struct>struct <name>TypeDiagnoser</name> <block>{
<macro><name>TypeDiagnoser</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block>

<function_decl><type><name>virtual</name> <name>void</name></type> <name>diagnose</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>TypeDiagnoser</name><argument_list>()</argument_list></macro> <block>{}</block></expr></expr_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>getPrintable</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>I</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>getPrintable</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>I</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>I</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>getPrintable</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>B</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>B</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>getPrintable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>S</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>StringRef</name></type> <name>getPrintable</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>S</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>S</name></expr>;</return> </block_content>}</block></function>
<expr_stmt><expr><specifier>static</specifier> <specifier>const</specifier> <name>std</name><operator>::</operator><name>string</name> <operator>&amp;</operator><macro><name>getPrintable</name><argument_list>(<argument>const std::string &amp;S</argument>)</argument_list></macro> <block>{ <return>return <expr><name>S</name></expr>;</return> }</block></expr></expr_stmt>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>getPrintable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>II</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>DeclarationName</name></type> <name>getPrintable</name><parameter_list>(<parameter><decl><type><name>DeclarationName</name></type> <name>N</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>N</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>QualType</name></type> <name>getPrintable</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>T</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>SourceRange</name></type> <name>getPrintable</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>R</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>SourceRange</name></type> <name>getPrintable</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><name>L</name></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>SourceRange</name></type> <name>getPrintable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>E</name><operator>-&gt;</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr>;</return> </block_content>}</block></function>
<function><type><specifier>static</specifier> <name>SourceRange</name></type> <name>getPrintable</name><parameter_list>(<parameter><decl><type><name>TypeLoc</name></type> <name>TL</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name><name>TL</name><operator>.</operator><name>getSourceRange</name></name><argument_list>()</argument_list></call></expr>;</return></block_content>}</block></function>

<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name> <name>class</name></type> <name>BoundTypeDiagnoser</name> <range>: <expr><name>public</name> <name>TypeDiagnoser</name> <block>{
<expr><name>protected</name><operator>:</operator>
<name>unsigned</name> <name>DiagID</name></expr>;
<expr><name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Ts</name> <operator>&amp;</operator><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <name>Args</name></expr>;

<expr><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name>size_t</name><modifier>...</modifier> <name>Is</name></expr></argument>&gt;</argument_list></name>
<name>void</name> <macro><name>emit</name><argument_list>(<argument>const SemaDiagnosticBuilder &amp;DB</argument>,
<argument>std::index_sequence&lt;Is...&gt;</argument>)</argument_list></macro> <specifier>const</specifier> <block>{

<expr><name>bool</name> <name><name>Dummy</name><index>[]</index></name> <operator>=</operator> <block>{<expr><name>false</name></expr>, <expr><operator>(</operator><name>DB</name> <operator>&lt;&lt;</operator> <call><name>getPrintable</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><call><name><name>get</name><argument_list type="generic">&lt;<argument><expr><name>Is</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>Args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>...</operator></expr>}</block></expr>;
<expr><operator>(</operator><name>void</name><operator>)</operator><name>Dummy</name></expr>;
}</block>

<name>public</name><operator>:</operator>
<macro><name>BoundTypeDiagnoser</name><argument_list>(<argument>unsigned DiagID</argument>, <argument>const Ts &amp;...Args</argument>)</argument_list></macro>
<operator>:</operator> <call><name>TypeDiagnoser</name><argument_list>()</argument_list></call></expr>, <expr><call><name>DiagID</name><argument_list>(<argument><expr><name>DiagID</name></expr></argument>)</argument_list></call></expr>, <macro><name>Args</name><argument_list>(<argument>Args...</argument>)</argument_list></macro> <expr><block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>DiagID</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <literal type="string">"no diagnostic for type diagnoser"</literal></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>diagnose</name><argument_list>(<argument>Sema &amp;S</argument>, <argument>SourceLocation Loc</argument>, <argument>QualType T</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><specifier>const</specifier> <name>SemaDiagnosticBuilder</name> <operator>&amp;</operator><name>DB</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>DiagID</name></expr></argument>)</argument_list></call></expr>;
<expr><call><name>emit</name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name><name>index_sequence_for</name><argument_list type="generic">&lt;<argument><expr><name>Ts</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>DB</name> <operator>&lt;&lt;</operator> <name>T</name></expr>;
}</block></expr>
}</block></expr></range></decl>;</decl_stmt>








<function_decl><type><name>bool</name></type> <name>DiagnoseSwiftName</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Name</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttr</name> <modifier>&amp;</modifier></type><name>AL</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsAsync</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name>
<name>class</name></type> <name>SizelessTypeDiagnoser</name> <range>: <expr><name>public</name> <name><name>BoundTypeDiagnoser</name><argument_list type="generic">&lt;<argument><expr><name>Ts</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>public</name><operator>:</operator>
<macro><name>SizelessTypeDiagnoser</name><argument_list>(<argument>unsigned DiagID</argument>, <argument>const Ts &amp;... Args</argument>)</argument_list></macro>
<operator>:</operator> <macro><name>BoundTypeDiagnoser</name></macro><operator>&lt;</operator><name>Ts</name><operator>...</operator><operator>&gt;</operator><operator>(</operator><name>DiagID</name>, <name>Args</name><operator>...</operator><operator>)</operator> <block>{}</block>

<name>void</name> <macro><name>diagnose</name><argument_list>(<argument>Sema &amp;S</argument>, <argument>SourceLocation Loc</argument>, <argument>QualType T</argument>)</argument_list></macro> <name>override</name> <block>{
<expr><specifier>const</specifier> <name>SemaDiagnosticBuilder</name> <operator>&amp;</operator><name>DB</name> <operator>=</operator> <call><name><name>S</name><operator>.</operator><name>Diag</name></name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name><name>this</name><operator>-&gt;</operator><name>DiagID</name></name></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>this</name><operator>-&gt;</operator><name>emit</name></name><argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>std</name><operator>::</operator><call><name><name>index_sequence_for</name><argument_list type="generic">&lt;<argument><expr><name>Ts</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;
<expr><name>DB</name> <operator>&lt;&lt;</operator> <call><name><name>T</name><operator>-&gt;</operator><name>isSizelessType</name></name><argument_list>()</argument_list></call> <operator>&lt;&lt;</operator> <name>T</name></expr>;
}</block></expr>
}</block></expr></range></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>CompleteTypeKind</name> <block>{<block_content>


<expr_stmt><expr><name>Normal</name></expr><operator>,</operator>



<expr><name>AcceptSizeless</name></expr><operator>,</operator>



<expr><name>Default</name> <operator>=</operator> <name>AcceptSizeless</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<label><name>private</name>:</label>







<function_decl><type><name>void</name></type> <name>CheckSubscriptAccessOfNoDeref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArraySubscriptExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckAddressOfNoDeref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckMemberAccessOfNoDeref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MemberExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>RequireCompleteTypeImpl</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>CompleteTypeKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>TypeDiagnoser</name> <modifier>*</modifier></type><name>Diagnoser</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>ModuleScope</name> <block>{
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>BeginLoc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>clang</name><operator>::</operator><name>Module</name> <operator>*</operator><name>Module</name> <operator>=</operator> <name>nullptr</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ModuleInterface</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ImplicitGlobalModuleFragment</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VisibleModuleSet</name></type> <name>OuterVisibleModules</name></decl>;</decl_stmt>
}</block>;</struct>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>ModuleScope</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>ModuleScopes</name></expr>;</expr_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>NamespaceDecl</name><operator>*</operator></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>DeferredExportedNamespaces</name></expr>;</expr_stmt>


<expr_stmt><expr><name>Module</name> <operator>*</operator><macro><name>getCurrentModule</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>ModuleScopes</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>?</operator> <name>nullptr</name> <operator>:</operator> <call><name><name>ModuleScopes</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>Module</name></expr>;</return>
}</block></expr></expr_stmt>

<decl_stmt><decl><type><name>VisibleModuleSet</name></type> <name>VisibleModules</name></decl>;</decl_stmt>

<label><name>public</name>:</label>

<function><type><name>Module</name> <modifier>*</modifier></type><name>getOwningModule</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>Entity</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>Entity</name><operator>-&gt;</operator><name>getOwningModule</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>makeMergedDefinitionVisible</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>isModuleVisible</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Module</name> <modifier>*</modifier></type><name>M</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ModulePrivate</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function><type><name>void</name></type> <name>makeModuleVisible</name><parameter_list>(<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>Mod</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ImportLoc</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>VisibleModules</name><operator>.</operator><name>setVisible</name></name><argument_list>(<argument><expr><name>Mod</name></expr></argument>, <argument><expr><name>ImportLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>bool</name></type> <name>isVisible</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name><name>D</name><operator>-&gt;</operator><name>isUnconditionallyVisible</name></name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isVisibleSlow</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>bool</name></type>
<name>hasVisibleDeclaration</name><argument_list>(<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Module</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>Modules</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>isVisible</name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>hasVisibleDeclarationSlow</name><argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>Modules</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>hasVisibleDeclarationSlow</name><argument_list>(<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Module</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>Modules</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>bool</name></type> <name>hasVisibleMergedDefinition</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Def</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>hasMergedDefinitionInCurrentModule</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Def</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>hasStructuralCompatLayout</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Suggested</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>hasVisibleDefinition</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier><modifier>*</modifier></type><name>Suggested</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>OnlyNeedComplete</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>bool</name></type> <name>hasVisibleDefinition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Hidden</name></decl>;</decl_stmt>
<return>return <expr><call><name>hasVisibleDefinition</name><argument_list>(<argument><expr><call><name><name>const_cast</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>Hidden</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name>bool</name></type>
<name>hasVisibleDefaultArgument</name><argument_list>(<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>D</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Module</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>Modules</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<decl_stmt><decl><type><name>bool</name></type> <name>hasVisibleExplicitSpecialization</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Module</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>Modules</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>hasVisibleMemberSpecialization</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Module</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>Modules</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function_decl><type><name>bool</name></type> <name>isEquivalentInternalLinkageDeclaration</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>A</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>B</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>diagnoseEquivalentInternalLinkageDeclarations</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Equiv</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>isUsualDeallocationFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>bool</name></type> <name>isCompleteType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>CompleteTypeKind</name></type> <name>Kind</name> <init>= <expr><name>CompleteTypeKind</name><operator>::</operator><name>Default</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><operator>!</operator><call><name>RequireCompleteTypeImpl</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>Kind</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function_decl><type><name>bool</name></type> <name>RequireCompleteType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>CompleteTypeKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>TypeDiagnoser</name> <modifier>&amp;</modifier></type><name>Diagnoser</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>RequireCompleteType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>CompleteTypeKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>bool</name></type> <name>RequireCompleteType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>TypeDiagnoser</name> <modifier>&amp;</modifier></type><name>Diagnoser</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>RequireCompleteType</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>CompleteTypeKind</name><operator>::</operator><name>Default</name></expr></argument>, <argument><expr><name>Diagnoser</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>bool</name></type> <name>RequireCompleteType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>RequireCompleteType</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>CompleteTypeKind</name><operator>::</operator><name>Default</name></expr></argument>, <argument><expr><name>DiagID</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>RequireCompleteType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Ts</name> <modifier>&amp;</modifier><modifier>...</modifier></type><name>Args</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>BoundTypeDiagnoser</name><argument_list type="generic">&lt;<argument><expr><name>Ts</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></type> <name>Diagnoser</name><argument_list>(<argument><expr><name>DiagID</name></expr></argument>, <argument><expr><name>Args</name><operator>...</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<return>return <expr><call><name>RequireCompleteType</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>Diagnoser</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>RequireCompleteSizedType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Ts</name> <modifier>&amp;</modifier><modifier>...</modifier></type> <name>Args</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>SizelessTypeDiagnoser</name><argument_list type="generic">&lt;<argument><expr><name>Ts</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></type> <name>Diagnoser</name><argument_list>(<argument><expr><name>DiagID</name></expr></argument>, <argument><expr><name>Args</name><operator>...</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<return>return <expr><call><name>RequireCompleteType</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>CompleteTypeKind</name><operator>::</operator><name>Normal</name></expr></argument>, <argument><expr><name>Diagnoser</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function_decl><type><name>QualType</name></type> <name>getCompletedType</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>completeExprArrayBound</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>RequireCompleteExprType</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>CompleteTypeKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>TypeDiagnoser</name> <modifier>&amp;</modifier></type><name>Diagnoser</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>RequireCompleteExprType</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>RequireCompleteExprType</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Ts</name> <modifier>&amp;</modifier><modifier>...</modifier></type><name>Args</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>BoundTypeDiagnoser</name><argument_list type="generic">&lt;<argument><expr><name>Ts</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></type> <name>Diagnoser</name><argument_list>(<argument><expr><name>DiagID</name></expr></argument>, <argument><expr><name>Args</name><operator>...</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<return>return <expr><call><name>RequireCompleteExprType</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>CompleteTypeKind</name><operator>::</operator><name>Default</name></expr></argument>, <argument><expr><name>Diagnoser</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>RequireCompleteSizedExprType</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Ts</name> <modifier>&amp;</modifier><modifier>...</modifier></type> <name>Args</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>SizelessTypeDiagnoser</name><argument_list type="generic">&lt;<argument><expr><name>Ts</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></type> <name>Diagnoser</name><argument_list>(<argument><expr><name>DiagID</name></expr></argument>, <argument><expr><name>Args</name><operator>...</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<return>return <expr><call><name>RequireCompleteExprType</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>CompleteTypeKind</name><operator>::</operator><name>Normal</name></expr></argument>, <argument><expr><name>Diagnoser</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>bool</name></type> <name>RequireLiteralType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>TypeDiagnoser</name> <modifier>&amp;</modifier></type><name>Diagnoser</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>RequireLiteralType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>RequireLiteralType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Ts</name> <modifier>&amp;</modifier><modifier>...</modifier></type><name>Args</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>BoundTypeDiagnoser</name><argument_list type="generic">&lt;<argument><expr><name>Ts</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></type> <name>Diagnoser</name><argument_list>(<argument><expr><name>DiagID</name></expr></argument>, <argument><expr><name>Args</name><operator>...</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<return>return <expr><call><name>RequireLiteralType</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>Diagnoser</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>QualType</name></type> <name>getElaboratedType</name><parameter_list>(<parameter><decl><type><name>ElaboratedTypeKeyword</name></type> <name>Keyword</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>TagDecl</name> <modifier>*</modifier></type><name>OwnedTagDecl</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>getDecltypeForParenthesizedExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>BuildTypeofExprType</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>BuildDecltypeType</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AsUnevaluated</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>QualType</name></type> <name>BuildUnaryTransformType</name><argument_list>(<argument><expr><name>QualType</name> <name>BaseType</name></expr></argument>,
<argument><expr><name>UnaryTransformType</name><operator>::</operator><name>UTTKind</name> <name>UKind</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<struct>struct <name>SkipBodyInfo</name> <block>{
<expr_stmt><expr><call><name>SkipBodyInfo</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>ShouldSkip</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>CheckSameAsPrevious</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Previous</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>New</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>
<name>bool</name> <name>ShouldSkip</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>CheckSameAsPrevious</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Previous</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>New</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ConvertDeclToDeclGroup</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Ptr</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>OwnedType</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseUseOfUnimplementedSelectors</name><parameter_list>()</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>isSimpleTypeSpecifier</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><name>ParsedType</name></type> <name>getTypeName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>*</modifier></type><name>SS</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isClassName</name> <init>= <expr><name>false</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>HasTrailingDot</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ObjectType</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsCtorOrDtorName</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>WantNontrivialTypeSourceInfo</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsClassTemplateDeductionContext</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>CorrectedII</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>TypeSpecifierType</name></type> <name>isTagName</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isMicrosoftMissingTypename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>*</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DiagnoseUnknownTypeName</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IILoc</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>*</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name> <modifier>&amp;</modifier></type><name>SuggestedType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsTemplateName</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>ParsedType</name></type> <name>ActOnMSVCUnknownTypeName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsTemplateTypeArg</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>NameClassificationKind</name> <block>{


<decl><name>NC_Unknown</name></decl>,

<decl><name>NC_Error</name></decl>,

<decl><name>NC_Keyword</name></decl>,

<decl><name>NC_Type</name></decl>,



<decl><name>NC_NonType</name></decl>,



<decl><name>NC_UndeclaredNonType</name></decl>,



<decl><name>NC_DependentNonType</name></decl>,




<decl><name>NC_OverloadSet</name></decl>,

<decl><name>NC_TypeTemplate</name></decl>,

<decl><name>NC_VarTemplate</name></decl>,

<decl><name>NC_FunctionTemplate</name></decl>,

<decl><name>NC_UndeclaredTemplate</name></decl>,

<decl><name>NC_Concept</name></decl>,
}</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>NameClassification</name> <block>{<block_content>
<decl_stmt><decl><type><name>NameClassificationKind</name></type> <name>Kind</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>ExprResult</name></type> <name>Expr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>NonTypeDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TemplateName</name></type> <name>Template</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParsedType</name></type> <name>Type</name></decl>;</decl_stmt>
}</block>;</union>

<macro><name>explicit</name></macro> <macro><name>NameClassification</name><argument_list>(<argument>NameClassificationKind Kind</argument>)</argument_list></macro> : <macro><name>Kind</name><argument_list>(<argument>Kind</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<label><name>public</name>:</label>
<macro><name>NameClassification</name><argument_list>(<argument>ParsedType Type</argument>)</argument_list></macro> : <expr_stmt><expr><call><name>Kind</name><argument_list>(<argument><expr><name>NC_Type</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Type</name><argument_list>(<argument>Type</argument>)</argument_list></macro> <expr><block>{}</block>

<call><name>NameClassification</name><argument_list>(<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator><name>Keyword</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>Kind</name><argument_list>(<argument>NC_Keyword</argument>)</argument_list></macro> <block>{}</block>

<specifier>static</specifier> <name>NameClassification</name> <macro><name>Error</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><call><name>NameClassification</name><argument_list>(<argument><expr><name>NC_Error</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>NameClassification</name></type> <name>Unknown</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>NameClassification</name><argument_list>(<argument><expr><name>NC_Unknown</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NameClassification</name></type> <name>OverloadSet</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>E</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>NameClassification</name></type> <name>Result</name><argument_list>(<argument><expr><name>NC_OverloadSet</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>Expr</name></name> <operator>=</operator> <name>E</name></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NameClassification</name></type> <name>NonType</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>NameClassification</name></type> <name>Result</name><argument_list>(<argument><expr><name>NC_NonType</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>NonTypeDecl</name></name> <operator>=</operator> <name>D</name></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NameClassification</name></type> <name>UndeclaredNonType</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>NameClassification</name><argument_list>(<argument><expr><name>NC_UndeclaredNonType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NameClassification</name></type> <name>DependentNonType</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>NameClassification</name><argument_list>(<argument><expr><name>NC_DependentNonType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NameClassification</name></type> <name>TypeTemplate</name><parameter_list>(<parameter><decl><type><name>TemplateName</name></type> <name>Name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>NameClassification</name></type> <name>Result</name><argument_list>(<argument><expr><name>NC_TypeTemplate</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>Template</name></name> <operator>=</operator> <name>Name</name></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NameClassification</name></type> <name>VarTemplate</name><parameter_list>(<parameter><decl><type><name>TemplateName</name></type> <name>Name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>NameClassification</name></type> <name>Result</name><argument_list>(<argument><expr><name>NC_VarTemplate</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>Template</name></name> <operator>=</operator> <name>Name</name></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NameClassification</name></type> <name>FunctionTemplate</name><parameter_list>(<parameter><decl><type><name>TemplateName</name></type> <name>Name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>NameClassification</name></type> <name>Result</name><argument_list>(<argument><expr><name>NC_FunctionTemplate</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>Template</name></name> <operator>=</operator> <name>Name</name></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NameClassification</name></type> <name>Concept</name><parameter_list>(<parameter><decl><type><name>TemplateName</name></type> <name>Name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>NameClassification</name></type> <name>Result</name><argument_list>(<argument><expr><name>NC_Concept</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>Template</name></name> <operator>=</operator> <name>Name</name></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>NameClassification</name></type> <name>UndeclaredTemplate</name><parameter_list>(<parameter><decl><type><name>TemplateName</name></type> <name>Name</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>NameClassification</name></type> <name>Result</name><argument_list>(<argument><expr><name>NC_UndeclaredTemplate</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<expr_stmt><expr><name><name>Result</name><operator>.</operator><name>Template</name></name> <operator>=</operator> <name>Name</name></expr>;</expr_stmt>
<return>return <expr><name>Result</name></expr>;</return>
</block_content>}</block></function>

<expr_stmt><expr><name>NameClassificationKind</name> <macro><name>getKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Kind</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>ExprResult</name> <macro><name>getExpression</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>==</operator> <name>NC_OverloadSet</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Expr</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>ParsedType</name> <macro><name>getType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>==</operator> <name>NC_Type</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Type</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>NamedDecl</name> <operator>*</operator><macro><name>getNonTypeDecl</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>==</operator> <name>NC_NonType</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>NonTypeDecl</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>TemplateName</name> <macro><name>getTemplateName</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>==</operator> <name>NC_TypeTemplate</name> <operator>||</operator> <name>Kind</name> <operator>==</operator> <name>NC_FunctionTemplate</name> <operator>||</operator>
<name>Kind</name> <operator>==</operator> <name>NC_VarTemplate</name> <operator>||</operator> <name>Kind</name> <operator>==</operator> <name>NC_Concept</name> <operator>||</operator>
<name>Kind</name> <operator>==</operator> <name>NC_UndeclaredTemplate</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>Template</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>TemplateNameKind</name> <macro><name>getTemplateNameKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<switch>switch <condition>(<expr><name>Kind</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>NC_TypeTemplate</name></expr>:</case>
<return>return <expr><name>TNK_Type_template</name></expr>;</return>
<case>case <expr><name>NC_FunctionTemplate</name></expr>:</case>
<return>return <expr><name>TNK_Function_template</name></expr>;</return>
<case>case <expr><name>NC_VarTemplate</name></expr>:</case>
<return>return <expr><name>TNK_Var_template</name></expr>;</return>
<case>case <expr><name>NC_Concept</name></expr>:</case>
<return>return <expr><name>TNK_Concept_template</name></expr>;</return>
<case>case <expr><name>NC_UndeclaredTemplate</name></expr>:</case>
<return>return <expr><name>TNK_Undeclared_template</name></expr>;</return>
<default>default:</default>
<expr_stmt><expr><call><name>llvm_unreachable</name><argument_list>(<argument><expr><literal type="string">"unsupported name classification."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}
}</block><empty_stmt>;</empty_stmt></switch>





















<expr><name>NameClassification</name> <macro><name>ClassifyName</name><argument_list>(<argument>Scope *S</argument>, <argument>CXXScopeSpec &amp;SS</argument>,
<argument>IdentifierInfo *&amp;Name</argument>, <argument>SourceLocation NameLoc</argument>,
<argument>const Token &amp;NextToken</argument>,
<argument>CorrectionCandidateCallback *CCC = nullptr</argument>)</argument_list></macro></expr>;



<expr><name>ExprResult</name> <macro><name>ActOnNameClassifiedAsUndeclaredNonType</name><argument_list>(<argument>IdentifierInfo *Name</argument>,
<argument>SourceLocation NameLoc</argument>)</argument_list></macro></expr>;


<expr><name>ExprResult</name> <macro><name>ActOnNameClassifiedAsDependentNonType</name><argument_list>(<argument>const CXXScopeSpec &amp;SS</argument>,
<argument>IdentifierInfo *Name</argument>,
<argument>SourceLocation NameLoc</argument>,
<argument>bool IsAddressOfOperand</argument>)</argument_list></macro></expr>;


<expr><name>ExprResult</name> <macro><name>ActOnNameClassifiedAsNonType</name><argument_list>(<argument>Scope *S</argument>, <argument>const CXXScopeSpec &amp;SS</argument>,
<argument>NamedDecl *Found</argument>,
<argument>SourceLocation NameLoc</argument>,
<argument>const Token &amp;NextToken</argument>)</argument_list></macro></expr>;

<expr><name>ExprResult</name> <call><name>ActOnNameClassifiedAsOverloadSet</name><argument_list>(<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>OverloadSet</name></expr></argument>)</argument_list></call></expr>;


enum <expr><name>class</name> <name>TemplateNameKindForDiagnostics</name> <block>{
<expr><name>ClassTemplate</name></expr>,
<expr><name>FunctionTemplate</name></expr>,
<expr><name>VarTemplate</name></expr>,
<expr><name>AliasTemplate</name></expr>,
<expr><name>TemplateTemplateParam</name></expr>,
<expr><name>Concept</name></expr>,
<expr><name>DependentTemplate</name></expr>
}</block></expr>;
<expr><name>TemplateNameKindForDiagnostics</name>
<macro><name>getTemplateNameKindForDiagnostics</name><argument_list>(<argument>TemplateName Name</argument>)</argument_list></macro></expr>;



<expr><name>bool</name> <macro><name>mightBeIntendedToBeTemplateName</name><argument_list>(<argument>ExprResult E</argument>, <argument>bool &amp;Dependent</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getLangOpts</name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus</name> <operator>||</operator> <call><name><name>E</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
<name>Dependent</name> <operator>=</operator> <name>false</name></block></expr>;
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>DRE</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>DeclRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>!</operator><call><name><name>DRE</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>ME</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>MemberExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>!</operator><call><name><name>ME</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>Dependent</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>DSDRE</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>DependentScopeDeclRefExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>!</operator><call><name><name>DSDRE</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>auto</name> <operator>*</operator><name>DSME</name> <operator>=</operator> <call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>CXXDependentScopeMemberExpr</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><call><name><name>E</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>!</operator><call><name><name>DSME</name><operator>-&gt;</operator><name>hasExplicitTemplateArgs</name></name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>


<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<function_decl><type><name>void</name></type> <name>diagnoseExprIntendedAsTemplateName</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name></type> <name>TemplateName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Less</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Greater</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>warnOnReservedIdentifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnDeclarator</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>HandleDeclarator</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParameterLists</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>tryToFixVariablyModifiedVarType</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>FailedFoldDiagID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>RegisterLocallyScopedExternCDecl</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>DiagnoseClassNameShadow</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>, <parameter><decl><type><name>DeclarationNameInfo</name></type> <name>Info</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>diagnoseQualifiedDeclaration</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>,
<parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsTemplateId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>
<name>diagnoseIgnoredQualifiers</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Quals</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>FallbackLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ConstQualLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>VolatileQualLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RestrictQualLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AtomicQualLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>UnalignedQualLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>adjustContextForLocalExternDecl</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DiagnoseFunctionSpecifiers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>getShadowedDeclaration</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TypedefNameDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>getShadowedDeclaration</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>getShadowedDeclaration</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BindingDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckShadow</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ShadowedDecl</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckShadow</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>CheckShadowingDeclModification</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>DiagnoseShadowingLambdaDecls</name><argument_list>(<argument><expr><specifier>const</specifier> <name>sema</name><operator>::</operator><name>LambdaScopeInfo</name> <operator>*</operator><name>LSI</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<label><name>private</name>:</label>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>ShadowingDecls</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<function_decl><type><name>void</name></type> <name>CheckCastAlign</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Op</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>TRange</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>handleTagNumbering</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TagDecl</name> <modifier>*</modifier></type><name>Tag</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>TagScope</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>setTagNameForLinkagePurposes</name><parameter_list>(<parameter><decl><type><name>TagDecl</name> <modifier>*</modifier></type><name>TagFromDeclSpec</name></decl></parameter>,
<parameter><decl><type><name>TypedefNameDecl</name> <modifier>*</modifier></type><name>NewTD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckTypedefForVariablyModifiedType</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>TypedefNameDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name><modifier>*</modifier></type> <name>ActOnTypedefDeclarator</name><parameter_list>(<parameter><decl><type><name>Scope</name><modifier>*</modifier></type> <name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name><modifier>&amp;</modifier></type> <name>D</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name><modifier>*</modifier></type> <name>DC</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name><modifier>*</modifier></type> <name>ActOnTypedefNameDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name><modifier>*</modifier></type> <name>S</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name><modifier>*</modifier></type> <name>DC</name></decl></parameter>, <parameter><decl><type><name>TypedefNameDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>Redeclaration</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ActOnVariableDeclarator</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParamLists</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>AddToScope</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>BindingDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Bindings</name> <init>= <expr><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type>
<name>ActOnDecompositionDeclarator</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParamLists</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckVariableDeclaration</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>NewVD</name></decl></parameter>, <parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckVariableDeclarationType</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>NewVD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>DeduceVariableDeclarationType</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>VDecl</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>DirectInit</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckCompleteVariableDeclaration</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckCompleteDecompositionDeclaration</name><parameter_list>(<parameter><decl><type><name>DecompositionDecl</name> <modifier>*</modifier></type><name>DD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MaybeSuggestAddingStaticToDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>NamedDecl</name><modifier>*</modifier></type> <name>ActOnFunctionDeclarator</name><parameter_list>(<parameter><decl><type><name>Scope</name><modifier>*</modifier></type> <name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name><modifier>&amp;</modifier></type> <name>D</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name><modifier>*</modifier></type> <name>DC</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParamLists</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>AddToScope</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>AddOverriddenMethods</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>, <parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>CheckConstexprKind</name> <block>{<block_content>

<expr_stmt><expr><name>Diagnose</name></expr><operator>,</operator>


<expr><name>CheckValid</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<function_decl><type><name>bool</name></type> <name>CheckConstexprFunctionDefinition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><name>CheckConstexprKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseHiddenVirtualMethods</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>FindHiddenVirtualMethods</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>OverloadedMethods</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>NoteHiddenVirtualMethods</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>OverloadedMethods</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckFunctionDeclaration</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>NewFD</name></decl></parameter>, <parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsMemberSpecialization</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>shouldLinkDependentDeclWithPrevious</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>OldDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>canFullyTypeCheckRedeclaration</name><parameter_list>(<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>NewD</name></decl></parameter>, <parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>OldD</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>NewT</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>OldT</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckMain</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckMSVCRTEntryPoint</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Attr</name> <modifier>*</modifier></type><name>getImplicitCodeSegOrSectionAttrForFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsDefinition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckFunctionOrTemplateParamDeclarator</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnParamDeclarator</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>BuildParmVarDeclForTypedef</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>CheckParameter</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSInfo</name></decl></parameter>,
<parameter><decl><type><name>StorageClass</name></type> <name>SC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnParamDefaultArgument</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>param</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EqualLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>defarg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnParamUnparsedDefaultArgument</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EqualLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ArgLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnParamDefaultArgumentError</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EqualLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ConvertParamDefaultArgument</name><parameter_list>(<parameter><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>DefaultArg</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EqualLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>SetParamDefaultArgument</name><parameter_list>(<parameter><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>DefaultArg</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EqualLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>NonTrivialCUnionContext</name> <block>{

<decl><name>NTCUC_FunctionParam</name></decl>,

<decl><name>NTCUC_FunctionReturn</name></decl>,

<decl><name>NTCUC_DefaultInitializedObject</name></decl>,

<decl><name>NTCUC_AutoVar</name></decl>,

<decl><name>NTCUC_CopyInit</name></decl>,

<decl><name>NTCUC_Assignment</name></decl>,

<decl><name>NTCUC_CompoundLiteral</name></decl>,

<decl><name>NTCUC_BlockCapture</name></decl>,

<decl><name>NTCUC_LValueToRValueVolatile</name></decl>,
}</block>;</enum>





<function_decl><type><name>void</name></type> <name>checkNonTrivialCUnionInInitializer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>NonTrivialCUnionKind</name> <block>{
<decl><name>NTCUK_Init</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,
<decl><name>NTCUK_Destruct</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,
<decl><name>NTCUK_Copy</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>,
}</block>;</enum>



<function_decl><type><name>void</name></type> <name>checkNonTrivialCUnion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>QT</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>NonTrivialCUnionContext</name></type> <name>UseContext</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NonTrivialKind</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>AddInitializerToDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>dcl</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>init</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>DirectInit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnUninitializedDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>dcl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnInitializerError</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Dcl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnPureSpecifier</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>PureSpecLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnCXXForRangeDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnCXXForRangeIdentifier</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>IdentLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AttrEnd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>SetDeclDeleted</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>dcl</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>DelLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>SetDeclDefaulted</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>dcl</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>DefaultLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckStaticLocalForDllExport</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>FinalizeDeclaration</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclGroupPtrTy</name></type> <name>FinalizeDeclaratorGroup</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclGroupPtrTy</name></type> <name>BuildDeclaratorGroup</name><parameter_list>(<parameter><decl><type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Group</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ActOnDocumentableDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnDocumentableDecls</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Group</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnFinishKNRParamDeclarations</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LocAfterDecls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckForFunctionRedefinition</name><parameter_list>(
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>EffectiveDefinition</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>SkipBodyInfo</name> <modifier>*</modifier></type><name>SkipBody</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnStartOfFunctionDef</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParamLists</name></decl></parameter>,
<parameter><decl><type><name>SkipBodyInfo</name> <modifier>*</modifier></type><name>SkipBody</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnStartOfFunctionDef</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>SkipBodyInfo</name> <modifier>*</modifier></type><name>SkipBody</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnStartTrailingRequiresClause</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnFinishTrailingRequiresClause</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>ConstraintExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnRequiresClause</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>ConstraintExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnStartOfObjCMethodDef</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>bool</name></type> <name>isObjCMethodDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>D</name> <operator>&amp;&amp;</operator> <call><name><name>isa</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>









<function_decl><type><name>bool</name></type> <name>canDelayFunctionBody</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>bool</name></type> <name>canSkipFunctionBody</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>computeNRVO</name><argument_list>(<argument><expr><name>Stmt</name> <operator>*</operator><name>Body</name></expr></argument>, <argument><expr><name>sema</name><operator>::</operator><name>FunctionScopeInfo</name> <operator>*</operator><name>Scope</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnFinishFunctionBody</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnFinishFunctionBody</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsInstantiation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnSkippedFunctionBody</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnFinishInlineFunctionDef</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ActOnFinishDelayedAttribute</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DiagnoseUnusedParameters</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Parameters</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type>
<name>DiagnoseSizeOfParametersAndReturnValue</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Parameters</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ReturnTy</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseInvalidJumps</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnFileScopeAsmDecl</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AsmLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnEmptyDeclaration</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>SemiLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>ModuleDeclKind</name> <block>{<block_content>
<expr_stmt><expr><name>Interface</name></expr><operator>,</operator>
<expr><name>Implementation</name></expr><operator>,</operator></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ActOnModuleDecl</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ModuleLoc</name></decl></parameter>, <parameter><decl><type><name>ModuleDeclKind</name></type> <name>MDK</name></decl></parameter>,
<parameter><decl><type><name>ModuleIdPath</name></type> <name>Path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsFirstDecl</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ActOnGlobalModuleFragmentDecl</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ModuleLoc</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ActOnPrivateModuleFragmentDecl</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ModuleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PrivateLoc</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>DeclResult</name></type> <name>ActOnModuleImport</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ExportLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ImportLoc</name></decl></parameter>, <parameter><decl><type><name>ModuleIdPath</name></type> <name>Path</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>DeclResult</name></type> <name>ActOnModuleImport</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>StartLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>ExportLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>ImportLoc</name></expr></argument>, <argument><expr><name>Module</name> <operator>*</operator><name>M</name></expr></argument>,
<argument><expr><name>ModuleIdPath</name> <name>Path</name> <operator>=</operator> <block>{}</block></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>ActOnModuleInclude</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>DirectiveLoc</name></decl></parameter>, <parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>Mod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>BuildModuleInclude</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>DirectiveLoc</name></decl></parameter>, <parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>Mod</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnModuleBegin</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>DirectiveLoc</name></decl></parameter>, <parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>Mod</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnModuleEnd</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>DirectiveLoc</name></decl></parameter>, <parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>Mod</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>void</name></type> <name>createImplicitModuleImportForErrorRecovery</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>Module</name> <modifier>*</modifier></type><name>Mod</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>MissingImportKind</name> <block>{<block_content>
<expr_stmt><expr><name>Declaration</name></expr><operator>,</operator>
<expr><name>Definition</name></expr><operator>,</operator>
<expr><name>DefaultArgument</name></expr><operator>,</operator>
<expr><name>ExplicitSpecialization</name></expr><operator>,</operator>
<expr><name>PartialSpecialization</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<function_decl><type><name>void</name></type> <name>diagnoseMissingImport</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>,
<parameter><decl><type><name>MissingImportKind</name></type> <name>MIK</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Recover</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>diagnoseMissingImport</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>DeclLoc</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Module</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Modules</name></decl></parameter>,
<parameter><decl><type><name>MissingImportKind</name></type> <name>MIK</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Recover</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnStartExportDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ExportLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBraceLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnFinishExportDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ExportDecl</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBraceLoc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>checkSpecializationVisibility</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Spec</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>PrintingPolicy</name> <macro><name>getPrintingPolicy</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>getPrintingPolicy</name><argument_list>(<argument><expr><name>Context</name></expr></argument>, <argument><expr><name>PP</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>


<function_decl><type><specifier>static</specifier> <name>PrintingPolicy</name></type> <name>getPrintingPolicy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTContext</name> <modifier>&amp;</modifier></type><name>Ctx</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Preprocessor</name> <modifier>&amp;</modifier></type><name>PP</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnPopScope</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnTranslationUnitScope</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParsedFreeStandingDeclSpec</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>, <parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>RecordDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>AnonRecord</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ParsedFreeStandingDeclSpec</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>, <parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParams</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsExplicitInstantiation</name></decl></parameter>,
<parameter><decl><type><name>RecordDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>AnonRecord</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>BuildAnonymousStructOrUnion</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>,
<parameter><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>Record</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PrintingPolicy</name> <modifier>&amp;</modifier></type><name>Policy</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>BuildMicrosoftCAnonymousStruct</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>NonTagKind</name> <block>{
<decl><name>NTK_NonStruct</name></decl>,
<decl><name>NTK_NonClass</name></decl>,
<decl><name>NTK_NonUnion</name></decl>,
<decl><name>NTK_NonEnum</name></decl>,
<decl><name>NTK_Typedef</name></decl>,
<decl><name>NTK_TypeAlias</name></decl>,
<decl><name>NTK_Template</name></decl>,
<decl><name>NTK_TypeAliasTemplate</name></decl>,
<decl><name>NTK_TemplateTemplateArgument</name></decl>,
}</block>;</enum>



<function_decl><type><name>NonTagKind</name></type> <name>getNonTagTypeDeclKind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>TagTypeKind</name></type> <name>TTK</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>isAcceptableTagRedeclaration</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TagDecl</name> <modifier>*</modifier></type><name>Previous</name></decl></parameter>,
<parameter><decl><type><name>TagTypeKind</name></type> <name>NewTag</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isDefinition</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NewTagLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>TagUseKind</name> <block>{
<decl><name>TUK_Reference</name></decl>,
<decl><name>TUK_Declaration</name></decl>,
<decl><name>TUK_Definition</name></decl>,
<decl><name>TUK_Friend</name></decl>
}</block>;</enum>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnTag</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>TagSpec</name></decl></parameter>, <parameter><decl><type><name>TagUseKind</name></type> <name>TUK</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>Attr</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ModulePrivateLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParameterLists</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>OwnedDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>IsDependent</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ScopedEnumKWLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ScopedEnumUsesClassTag</name></decl></parameter>, <parameter><decl><type><name>TypeResult</name></type> <name>UnderlyingType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsTypeSpecifier</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsTemplateParamOrArg</name></decl></parameter>,
<parameter><decl><type><name>SkipBodyInfo</name> <modifier>*</modifier></type><name>SkipBody</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnTemplatedFriendTag</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>FriendLoc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>TagSpec</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TagLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>Attr</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TempParamLists</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TypeResult</name></type> <name>ActOnDependentTag</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>TagSpec</name></decl></parameter>,
<parameter><decl><type><name>TagUseKind</name></type> <name>TUK</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TagLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnDefs</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>TagD</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>DeclStart</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ClassName</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Decls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnField</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>TagD</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>DeclStart</name></decl></parameter>,
<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BitfieldWidth</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>HandleField</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>TagD</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>DeclStart</name></decl></parameter>,
<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BitfieldWidth</name></decl></parameter>,
<parameter><decl><type><name>InClassInitStyle</name></type> <name>InitStyle</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>MSPropertyDecl</name> <modifier>*</modifier></type><name>HandleMSProperty</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>TagD</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>DeclStart</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BitfieldWidth</name></decl></parameter>,
<parameter><decl><type><name>InClassInitStyle</name></type> <name>InitStyle</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttr</name> <modifier>&amp;</modifier></type><name>MSPropertyAttr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>CheckFieldDecl</name><parameter_list>(<parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Mutable</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BitfieldWidth</name></decl></parameter>,
<parameter><decl><type><name>InClassInitStyle</name></type> <name>InitStyle</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TSSL</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>PrevDecl</name></decl></parameter>,
<parameter><decl><type><name>Declarator</name> <modifier>*</modifier></type><name>D</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckNontrivialField</name><parameter_list>(<parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DiagnoseNontrivial</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Record</name></decl></parameter>, <parameter><decl><type><name>CXXSpecialMember</name></type> <name>CSM</name></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>TrivialABIHandling</name> <block>{

<decl><name>TAH_IgnoreTrivialABI</name></decl>,


<decl><name>TAH_ConsiderTrivialABI</name></decl>
}</block>;</enum>

<function_decl><type><name>bool</name></type> <name>SpecialMemberIsTrivial</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>, <parameter><decl><type><name>CXXSpecialMember</name></type> <name>CSM</name></decl></parameter>,
<parameter><decl><type><name>TrivialABIHandling</name></type> <name>TAH</name> <init>= <expr><name>TAH_IgnoreTrivialABI</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>class</name></type> <name>DefaultedFunctionKind</name> <block>{<block_content>
<decl_stmt><decl><type><name>CXXSpecialMember</name></type> <name>SpecialMember</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DefaultedComparisonKind</name></type> <name>Comparison</name> <range>: <expr><literal type="number">8</literal></expr></range></decl>;</decl_stmt>

<label><name>public</name>:</label>
<expr_stmt><expr><call><name>DefaultedFunctionKind</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>SpecialMember</name><argument_list>(<argument><expr><name>CXXInvalid</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Comparison</name><argument_list>(<argument>DefaultedComparisonKind::None</argument>)</argument_list></macro> <expr><block>{
}</block>
<macro><name>DefaultedFunctionKind</name><argument_list>(<argument>CXXSpecialMember CSM</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SpecialMember</name><argument_list>(<argument><expr><name>CSM</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Comparison</name><argument_list>(<argument>DefaultedComparisonKind::None</argument>)</argument_list></macro> <expr><block>{}</block>
<macro><name>DefaultedFunctionKind</name><argument_list>(<argument>DefaultedComparisonKind Comp</argument>)</argument_list></macro>
<operator>:</operator> <call><name>SpecialMember</name><argument_list>(<argument><expr><name>CXXInvalid</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Comparison</name><argument_list>(<argument>Comp</argument>)</argument_list></macro> <expr><block>{}</block>

<name>bool</name> <macro><name>isSpecialMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SpecialMember</name> <operator>!=</operator> <name>CXXInvalid</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isComparison</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>Comparison</name> <operator>!=</operator> <name>DefaultedComparisonKind</name><operator>::</operator><name>None</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name>isSpecialMember</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>isComparison</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>CXXSpecialMember</name> <macro><name>asSpecialMember</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>SpecialMember</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>DefaultedComparisonKind</name> <macro><name>asComparison</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Comparison</name></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>getDiagnosticIndex</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>static_assert</name><argument_list>(<argument><expr><name>CXXInvalid</name> <operator>&gt;</operator> <name>CXXDestructor</name></expr></argument>,
<argument><expr><literal type="string">"invalid should have highest index"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>static_assert</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>DefaultedComparisonKind</name><operator>::</operator><name>None</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>,
<argument><expr><literal type="string">"none should be equal to zero"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>SpecialMember</name> <operator>+</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>Comparison</name></expr>;</return>
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<function_decl><type><name>DefaultedFunctionKind</name></type> <name>getDefaultedFunctionKind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>CXXSpecialMember</name></type> <name>getSpecialMember</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getDefaultedFunctionKind</name><argument_list>(<argument><expr><name>MD</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>asSpecialMember</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>DefaultedComparisonKind</name></type> <name>getDefaultedComparisonKind</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>getDefaultedFunctionKind</name><argument_list>(<argument><expr><name>FD</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>asComparison</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>ActOnLastBitfield</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>DeclStart</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>AllIvarDecls</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnIvar</name><argument_list>(<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>DeclStart</name></expr></argument>,
<argument><expr><name>Declarator</name> <operator>&amp;</operator><name>D</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>BitfieldWidth</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>ObjCKeywordKind</name> <name>visibility</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>ActOnFields</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RecLoc</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>TagDecl</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Fields</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LBrac</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBrac</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>ActOnTagStartDefinition</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>TagDecl</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>ActOnDuplicateDefinition</name><parameter_list>(<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Prev</name></decl></parameter>,
<parameter><decl><type><name>SkipBodyInfo</name> <modifier>&amp;</modifier></type><name>SkipBody</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><name>void</name> <modifier>*</modifier></type><name>SkippedDefinitionContext</name>;</typedef>


<function_decl><type><name>SkippedDefinitionContext</name></type> <name>ActOnTagStartSkippedDefinition</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>TD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnObjCContainerStartDefinition</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>IDecl</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>ActOnStartCXXMemberDeclarations</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>TagDecl</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>FinalLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsFinalSpelledSealed</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsAbstract</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBraceLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ActOnTagFinishDefinition</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>TagDecl</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>BraceRange</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnTagFinishSkippedDefinition</name><parameter_list>(<parameter><decl><type><name>SkippedDefinitionContext</name></type> <name>Context</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnObjCContainerFinishDefinition</name><parameter_list>()</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>ActOnObjCTemporaryExitContainerContext</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnObjCReenterContainerContext</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ActOnTagDefinitionError</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>TagDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>EnumConstantDecl</name> <modifier>*</modifier></type><name>CheckEnumConstant</name><parameter_list>(<parameter><decl><type><name>EnumDecl</name> <modifier>*</modifier></type><name>Enum</name></decl></parameter>,
<parameter><decl><type><name>EnumConstantDecl</name> <modifier>*</modifier></type><name>LastEnumConst</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckEnumUnderlyingType</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TI</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckEnumRedeclaration</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>EnumLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsScoped</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>EnumUnderlyingTy</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsFixed</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>EnumDecl</name> <modifier>*</modifier></type><name>Prev</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>SkipBodyInfo</name></type> <name>shouldSkipAnonEnumBody</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IILoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnEnumConstant</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>EnumDecl</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>LastEnumConstant</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EqualLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnEnumBody</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>EnumLoc</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>BraceRange</name></decl></parameter>,
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>EnumDecl</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Elements</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>Attr</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>PushDeclContext</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>PopDeclContext</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EnterDeclaratorContext</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ExitDeclaratorContext</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>EnterTemplatedContext</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnReenterFunctionContext</name><parameter_list>(<parameter><decl><type><name>Scope</name><modifier>*</modifier></type> <name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name><modifier>*</modifier></type> <name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnExitFunctionContext</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>getFunctionLevelDeclContext</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>getCurFunctionDecl</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>getCurMethodDecl</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>getCurFunctionOrMethodDecl</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>PushOnScopeChains</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AddToContext</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>bool</name></type> <name>isDeclInScope</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>Ctx</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowInlineNamespace</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><specifier>static</specifier> <name>Scope</name> <modifier>*</modifier></type><name>getScopeForDeclContext</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>TypedefDecl</name> <modifier>*</modifier></type><name>ParseTypedefDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isIncompatibleTypedef</name><parameter_list>(<parameter><decl><type><name>TypeDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>, <parameter><decl><type><name>TypedefNameDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>AvailabilityMergeKind</name> <block>{

<decl><name>AMK_None</name></decl>,


<decl><name>AMK_Redeclaration</name></decl>,


<decl><name>AMK_Override</name></decl>,


<decl><name>AMK_ProtocolImplementation</name></decl>,


<decl><name>AMK_OptionalProtocolImplementation</name></decl>
}</block>;</enum>













<enum>enum <name>AvailabilityPriority</name> : <type><name>int</name></type> <block>{


<decl><name>AP_Explicit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,


<decl><name>AP_PragmaClangAttribute</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,



<decl><name>AP_InferredFromOtherPlatform</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>
}</block>;</enum>


<function_decl><type><name>AvailabilityAttr</name> <modifier>*</modifier></type>
<name>mergeAvailabilityAttr</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Platform</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Implicit</name></decl></parameter>,
<parameter><decl><type><name>VersionTuple</name></type> <name>Introduced</name></decl></parameter>, <parameter><decl><type><name>VersionTuple</name></type> <name>Deprecated</name></decl></parameter>,
<parameter><decl><type><name>VersionTuple</name></type> <name>Obsoleted</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsUnavailable</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Message</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsStrict</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Replacement</name></decl></parameter>,
<parameter><decl><type><name>AvailabilityMergeKind</name></type> <name>AMK</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>Priority</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>TypeVisibilityAttr</name> <modifier>*</modifier></type>
<name>mergeTypeVisibilityAttr</name><argument_list>(<argument><expr><name>Decl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>AttributeCommonInfo</name> <operator>&amp;</operator><name>CI</name></expr></argument>,
<argument><expr><name>TypeVisibilityAttr</name><operator>::</operator><name>VisibilityType</name> <name>Vis</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>VisibilityAttr</name> <modifier>*</modifier></type><name>mergeVisibilityAttr</name><argument_list>(<argument><expr><name>Decl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>AttributeCommonInfo</name> <operator>&amp;</operator><name>CI</name></expr></argument>,
<argument><expr><name>VisibilityAttr</name><operator>::</operator><name>VisibilityType</name> <name>Vis</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>UuidAttr</name> <modifier>*</modifier></type><name>mergeUuidAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>UuidAsWritten</name></decl></parameter>, <parameter><decl><type><name>MSGuidDecl</name> <modifier>*</modifier></type><name>GuidDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DLLImportAttr</name> <modifier>*</modifier></type><name>mergeDLLImportAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DLLExportAttr</name> <modifier>*</modifier></type><name>mergeDLLExportAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>MSInheritanceAttr</name> <modifier>*</modifier></type><name>mergeMSInheritanceAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>BestCase</name></decl></parameter>,
<parameter><decl><type><name>MSInheritanceModel</name></type> <name>Model</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>FormatAttr</name> <modifier>*</modifier></type><name>mergeFormatAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Format</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>FormatIdx</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>FirstArg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>SectionAttr</name> <modifier>*</modifier></type><name>mergeSectionAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CodeSegAttr</name> <modifier>*</modifier></type><name>mergeCodeSegAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>AlwaysInlineAttr</name> <modifier>*</modifier></type><name>mergeAlwaysInlineAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>MinSizeAttr</name> <modifier>*</modifier></type><name>mergeMinSizeAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>SwiftNameAttr</name> <modifier>*</modifier></type><name>mergeSwiftNameAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SwiftNameAttr</name> <modifier>&amp;</modifier></type><name>SNA</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>OptimizeNoneAttr</name> <modifier>*</modifier></type><name>mergeOptimizeNoneAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>InternalLinkageAttr</name> <modifier>*</modifier></type><name>mergeInternalLinkageAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParsedAttr</name> <modifier>&amp;</modifier></type><name>AL</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>InternalLinkageAttr</name> <modifier>*</modifier></type><name>mergeInternalLinkageAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InternalLinkageAttr</name> <modifier>&amp;</modifier></type><name>AL</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>WebAssemblyImportNameAttr</name> <modifier>*</modifier></type><name>mergeImportNameAttr</name><parameter_list>(
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WebAssemblyImportNameAttr</name> <modifier>&amp;</modifier></type><name>AL</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>WebAssemblyImportModuleAttr</name> <modifier>*</modifier></type><name>mergeImportModuleAttr</name><parameter_list>(
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WebAssemblyImportModuleAttr</name> <modifier>&amp;</modifier></type><name>AL</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>EnforceTCBAttr</name> <modifier>*</modifier></type><name>mergeEnforceTCBAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>EnforceTCBAttr</name> <modifier>&amp;</modifier></type><name>AL</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>EnforceTCBLeafAttr</name> <modifier>*</modifier></type><name>mergeEnforceTCBLeafAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>EnforceTCBLeafAttr</name> <modifier>&amp;</modifier></type><name>AL</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>mergeDeclAttributes</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>,
<parameter><decl><type><name>AvailabilityMergeKind</name></type> <name>AMK</name> <init>= <expr><name>AMK_Redeclaration</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MergeTypedefNameDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>TypedefNameDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>OldDecls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>MergeFunctionDecl</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>Old</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>MergeTypeWithOld</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>MergeCompatibleFunctionDecls</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>MergeTypeWithOld</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>mergeObjCMethodDecls</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>, <parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MergeVarDecl</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>, <parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MergeVarDeclTypes</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>, <parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>MergeTypeWithOld</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MergeVarDeclExceptionSpecs</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>, <parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>checkVarDeclRedefinition</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>OldDefn</name></decl></parameter>, <parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>NewDefn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>notePreviousDefinition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>New</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>MergeCXXFunctionDecl</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>AssignmentAction</name> <block>{
<decl><name>AA_Assigning</name></decl>,
<decl><name>AA_Passing</name></decl>,
<decl><name>AA_Returning</name></decl>,
<decl><name>AA_Converting</name></decl>,
<decl><name>AA_Initializing</name></decl>,
<decl><name>AA_Sending</name></decl>,
<decl><name>AA_Casting</name></decl>,
<decl><name>AA_Passing_CFAudited</name></decl>
}</block>;</enum>


<enum>enum <name>OverloadKind</name> <block>{


<decl><name>Ovl_Overload</name></decl>,



<decl><name>Ovl_Match</name></decl>,



<decl><name>Ovl_NonFunction</name></decl>
}</block>;</enum>
<function_decl><type><name>OverloadKind</name></type> <name>CheckOverload</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LookupResult</name> <modifier>&amp;</modifier></type><name>OldDecls</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>OldDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsForUsingDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>IsOverload</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsForUsingDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ConsiderCudaAttrs</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ConsiderRequiresClauses</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>AllowedExplicit</name> <block>{<block_content>

<expr_stmt><expr><name>None</name></expr><operator>,</operator>

<expr><name>Conversions</name></expr><operator>,</operator>

<expr><name>All</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<function_decl><type><name>ImplicitConversionSequence</name></type>
<name>TryImplicitConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>SuppressUserConversions</name></decl></parameter>,
<parameter><decl><type><name>AllowedExplicit</name></type> <name>AllowExplicit</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>InOverloadResolution</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>CStyle</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowObjCWritebackConversion</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>IsIntegralPromotion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>FromType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>IsFloatingPointPromotion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>FromType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>IsComplexPromotion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>FromType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>IsPointerConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>FromType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>InOverloadResolution</name></decl></parameter>,
<parameter><decl><type><name>QualType</name><modifier>&amp;</modifier></type> <name>ConvertedType</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>IncompatibleObjC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isObjCPointerConversion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>FromType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><name>QualType</name><modifier>&amp;</modifier></type> <name>ConvertedType</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>IncompatibleObjC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isObjCWritebackConversion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>FromType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>ConvertedType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>IsBlockPointerConversion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>FromType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><name>QualType</name><modifier>&amp;</modifier></type> <name>ConvertedType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>FunctionParamTypesAreEqual</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>OldType</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>NewType</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>ArgPos</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HandleFunctionTypeMismatch</name><parameter_list>(<parameter><decl><type><name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>PDiag</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>FromType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>maybeExtendBlockObject</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CastKind</name></type> <name>PrepareCastToObjCObjectPointer</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckPointerConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><name>CastKind</name> <modifier>&amp;</modifier></type><name>Kind</name></decl></parameter>,
<parameter><decl><type><name>CXXCastPath</name><modifier>&amp;</modifier></type> <name>BasePath</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IgnoreBaseAccess</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>IsMemberPointerConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>FromType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>InOverloadResolution</name></decl></parameter>,
<parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>ConvertedType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckMemberPointerConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><name>CastKind</name> <modifier>&amp;</modifier></type><name>Kind</name></decl></parameter>,
<parameter><decl><type><name>CXXCastPath</name> <modifier>&amp;</modifier></type><name>BasePath</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IgnoreBaseAccess</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>IsQualificationConversion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>FromType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>CStyle</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>ObjCLifetimeConversion</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>IsFunctionConversion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>FromType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>ResultTy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>DiagnoseMultipleUserDefinedConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isSameOrCompatibleFunctionType</name><parameter_list>(<parameter><decl><type><name>CanQualType</name></type> <name>Param</name></decl></parameter>, <parameter><decl><type><name>CanQualType</name></type> <name>Arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CanPerformAggregateInitializationForOverloadResolution</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>&amp;</modifier></type><name>Entity</name></decl></parameter>, <parameter><decl><type><name>InitListExpr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>IsStringInit</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ArrayType</name> <modifier>*</modifier></type><name>AT</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CanPerformCopyInitialization</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>&amp;</modifier></type><name>Entity</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name></type> <name>Init</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>PerformCopyInitialization</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>&amp;</modifier></type><name>Entity</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EqualLoc</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name></type> <name>Init</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>TopLevelOfInitList</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowExplicit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>PerformObjectArgumentInitialization</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifier</name> <modifier>*</modifier></type><name>Qualifier</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>checkInitializerLifetime</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>&amp;</modifier></type><name>Entity</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>PerformContextuallyConvertToBool</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>PerformContextuallyConvertToObjCPointer</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>CCEKind</name> <block>{
<decl><name>CCEK_CaseValue</name></decl>,
<decl><name>CCEK_Enumerator</name></decl>,
<decl><name>CCEK_TemplateArg</name></decl>,
<decl><name>CCEK_ArrayBound</name></decl>,
<decl><name>CCEK_ExplicitBool</name></decl>
}</block>;</enum>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>CheckConvertedConstantExpression</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>From</name></expr></argument>, <argument><expr><name>QualType</name> <name>T</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <operator>&amp;</operator><name>Value</name></expr></argument>, <argument><expr><name>CCEKind</name> <name>CCE</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>ExprResult</name></type> <name>CheckConvertedConstantExpression</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>APValue</name> <modifier>&amp;</modifier></type><name>Value</name></decl></parameter>, <parameter><decl><type><name>CCEKind</name></type> <name>CCE</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Dest</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>class</name></type> <name>ContextualImplicitConverter</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>bool</name></type> <name>Suppress</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>SuppressConversion</name></decl>;</decl_stmt>

<macro><name>ContextualImplicitConverter</name><argument_list>(<argument>bool Suppress = false</argument>,
<argument>bool SuppressConversion = false</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Suppress</name><argument_list>(<argument><expr><name>Suppress</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>SuppressConversion</name><argument_list>(<argument>SuppressConversion</argument>)</argument_list></macro> <expr><block>{}</block>



<name>virtual</name> <name>bool</name> <macro><name>match</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<function_decl><type><name>virtual</name> <name>SemaDiagnosticBuilder</name></type>
<name>diagnoseNoMatch</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>SemaDiagnosticBuilder</name></type>
<name>diagnoseIncomplete</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>



<function_decl><type><name>virtual</name> <name>SemaDiagnosticBuilder</name></type> <name>diagnoseExplicitConv</name><parameter_list>(
<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ConvTy</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>SemaDiagnosticBuilder</name></type>
<name>noteExplicitConv</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXConversionDecl</name> <modifier>*</modifier></type><name>Conv</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ConvTy</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>



<function_decl><type><name>virtual</name> <name>SemaDiagnosticBuilder</name></type>
<name>diagnoseAmbiguous</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>


<function_decl><type><name>virtual</name> <name>SemaDiagnosticBuilder</name></type>
<name>noteAmbiguous</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXConversionDecl</name> <modifier>*</modifier></type><name>Conv</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ConvTy</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>



<function_decl><type><name>virtual</name> <name>SemaDiagnosticBuilder</name></type> <name>diagnoseConversion</name><parameter_list>(
<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ConvTy</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>

<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>ContextualImplicitConverter</name><argument_list>()</argument_list></macro> <block>{}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>ICEConvertDiagnoser</name> <range>: <expr><name>public</name> <name>ContextualImplicitConverter</name> <block>{
<expr><name>bool</name> <name>AllowScopedEnumerations</name></expr>;

<expr><name>public</name><operator>:</operator>
<macro><name>ICEConvertDiagnoser</name><argument_list>(<argument>bool AllowScopedEnumerations</argument>,
<argument>bool Suppress</argument>, <argument>bool SuppressConversion</argument>)</argument_list></macro>
<operator>:</operator> <call><name>ContextualImplicitConverter</name><argument_list>(<argument><expr><name>Suppress</name></expr></argument>, <argument><expr><name>SuppressConversion</name></expr></argument>)</argument_list></call></expr>,
<macro><name>AllowScopedEnumerations</name><argument_list>(<argument>AllowScopedEnumerations</argument>)</argument_list></macro> <expr><block>{}</block>


<name>bool</name> <macro><name>match</name><argument_list>(<argument>QualType T</argument>)</argument_list></macro> <name>override</name></expr>;

<expr><name>SemaDiagnosticBuilder</name>
<macro><name>diagnoseNoMatch</name><argument_list>(<argument>Sema &amp;S</argument>, <argument>SourceLocation Loc</argument>, <argument>QualType T</argument>)</argument_list></macro> <name>override</name> <block>{
<return>return <expr><call><name>diagnoseNotInt</name><argument_list>(<argument><expr><name>S</name></expr></argument>, <argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>



<name>virtual</name> <name>SemaDiagnosticBuilder</name>
<macro><name>diagnoseNotInt</name><argument_list>(<argument>Sema &amp;S</argument>, <argument>SourceLocation Loc</argument>, <argument>QualType T</argument>)</argument_list></macro> <operator>=</operator> <literal type="number">0</literal></expr>;
}</block></expr></range></decl>;</decl_stmt>


<function_decl><type><name>ExprResult</name></type> <name>PerformContextualImplicitConversion</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>FromE</name></decl></parameter>, <parameter><decl><type><name>ContextualImplicitConverter</name> <modifier>&amp;</modifier></type><name>Converter</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>ObjCSubscriptKind</name> <block>{
<decl><name>OS_Array</name></decl>,
<decl><name>OS_Dictionary</name></decl>,
<decl><name>OS_Error</name></decl>
}</block>;</enum>
<function_decl><type><name>ObjCSubscriptKind</name></type> <name>CheckSubscriptingKind</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>FromE</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>ObjCLiteralKind</name> <block>{
<decl><name>LK_Array</name></decl>,
<decl><name>LK_Dictionary</name></decl>,
<decl><name>LK_Numeric</name></decl>,
<decl><name>LK_Boxed</name></decl>,
<decl><name>LK_String</name></decl>,
<decl><name>LK_Block</name></decl>,
<decl><name>LK_None</name></decl>
}</block>;</enum>
<function_decl><type><name>ObjCLiteralKind</name></type> <name>CheckLiteralKind</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>FromE</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>PerformObjectMemberConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifier</name> <modifier>*</modifier></type><name>Qualifier</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>)</parameter_list>;</function_decl>



<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallSetVector</name><argument_list type="generic">&lt;<argument><expr><name>DeclContext</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>AssociatedNamespaceSet</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallSetVector</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name> <name>AssociatedClassSet</name></expr>;</expr_stmt></typedef>

<decl_stmt><decl><type><name>using</name></type> <name>ADLCallKind</name> <init>= <expr><name>CallExpr</name><operator>::</operator><name>ADLCallKind</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>AddOverloadCandidate</name><argument_list>(<argument><expr><name>FunctionDecl</name> <operator>*</operator><name>Function</name></expr></argument>, <argument><expr><name>DeclAccessPair</name> <name>FoundDecl</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>OverloadCandidateSet</name> <operator>&amp;</operator><name>CandidateSet</name></expr></argument>,
<argument><expr><name>bool</name> <name>SuppressUserConversions</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>PartialOverloading</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>AllowExplicit</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>bool</name> <name>AllowExplicitConversion</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>ADLCallKind</name> <name>IsADLCandidate</name> <operator>=</operator> <name>ADLCallKind</name><operator>::</operator><name>NotADL</name></expr></argument>,
<argument><expr><name>ConversionSequenceList</name> <name>EarlyConversions</name> <operator>=</operator> <name>None</name></expr></argument>,
<argument><expr><name>OverloadCandidateParamOrder</name> <name>PO</name> <operator>=</operator> <block>{}</block></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>AddFunctionCandidates</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnresolvedSetImpl</name> <modifier>&amp;</modifier></type><name>Functions</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>OverloadCandidateSet</name> <modifier>&amp;</modifier></type><name>CandidateSet</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>ExplicitTemplateArgs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>SuppressUserConversions</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>PartialOverloading</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>FirstArgumentIsBase</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>AddMethodCandidate</name><argument_list>(<argument><expr><name>DeclAccessPair</name> <name>FoundDecl</name></expr></argument>,
<argument><expr><name>QualType</name> <name>ObjectType</name></expr></argument>,
<argument><expr><name>Expr</name><operator>::</operator><name>Classification</name> <name>ObjectClassification</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>OverloadCandidateSet</name><operator>&amp;</operator> <name>CandidateSet</name></expr></argument>,
<argument><expr><name>bool</name> <name>SuppressUserConversion</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>OverloadCandidateParamOrder</name> <name>PO</name> <operator>=</operator> <block>{}</block></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>AddMethodCandidate</name><argument_list>(<argument><expr><name>CXXMethodDecl</name> <operator>*</operator><name>Method</name></expr></argument>,
<argument><expr><name>DeclAccessPair</name> <name>FoundDecl</name></expr></argument>,
<argument><expr><name>CXXRecordDecl</name> <operator>*</operator><name>ActingContext</name></expr></argument>, <argument><expr><name>QualType</name> <name>ObjectType</name></expr></argument>,
<argument><expr><name>Expr</name><operator>::</operator><name>Classification</name> <name>ObjectClassification</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>OverloadCandidateSet</name><operator>&amp;</operator> <name>CandidateSet</name></expr></argument>,
<argument><expr><name>bool</name> <name>SuppressUserConversions</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>PartialOverloading</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>ConversionSequenceList</name> <name>EarlyConversions</name> <operator>=</operator> <name>None</name></expr></argument>,
<argument><expr><name>OverloadCandidateParamOrder</name> <name>PO</name> <operator>=</operator> <block>{}</block></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>AddMethodTemplateCandidate</name><argument_list>(<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator><name>MethodTmpl</name></expr></argument>,
<argument><expr><name>DeclAccessPair</name> <name>FoundDecl</name></expr></argument>,
<argument><expr><name>CXXRecordDecl</name> <operator>*</operator><name>ActingContext</name></expr></argument>,
<argument><expr><name>TemplateArgumentListInfo</name> <operator>*</operator><name>ExplicitTemplateArgs</name></expr></argument>,
<argument><expr><name>QualType</name> <name>ObjectType</name></expr></argument>,
<argument><expr><name>Expr</name><operator>::</operator><name>Classification</name> <name>ObjectClassification</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>OverloadCandidateSet</name><operator>&amp;</operator> <name>CandidateSet</name></expr></argument>,
<argument><expr><name>bool</name> <name>SuppressUserConversions</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>PartialOverloading</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>OverloadCandidateParamOrder</name> <name>PO</name> <operator>=</operator> <block>{}</block></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>AddTemplateOverloadCandidate</name><argument_list>(
<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator><name>FunctionTemplate</name></expr></argument>, <argument><expr><name>DeclAccessPair</name> <name>FoundDecl</name></expr></argument>,
<argument><expr><name>TemplateArgumentListInfo</name> <operator>*</operator><name>ExplicitTemplateArgs</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>OverloadCandidateSet</name> <operator>&amp;</operator><name>CandidateSet</name></expr></argument>, <argument><expr><name>bool</name> <name>SuppressUserConversions</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>bool</name> <name>PartialOverloading</name> <operator>=</operator> <name>false</name></expr></argument>, <argument><expr><name>bool</name> <name>AllowExplicit</name> <operator>=</operator> <name>true</name></expr></argument>,
<argument><expr><name>ADLCallKind</name> <name>IsADLCandidate</name> <operator>=</operator> <name>ADLCallKind</name><operator>::</operator><name>NotADL</name></expr></argument>,
<argument><expr><name>OverloadCandidateParamOrder</name> <name>PO</name> <operator>=</operator> <block>{}</block></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>CheckNonDependentConversions</name><argument_list>(
<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator><name>FunctionTemplate</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <name>ParamTypes</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>, <argument><expr><name>OverloadCandidateSet</name> <operator>&amp;</operator><name>CandidateSet</name></expr></argument>,
<argument><expr><name>ConversionSequenceList</name> <operator>&amp;</operator><name>Conversions</name></expr></argument>, <argument><expr><name>bool</name> <name>SuppressUserConversions</name></expr></argument>,
<argument><expr><name>CXXRecordDecl</name> <operator>*</operator><name>ActingContext</name> <operator>=</operator> <name>nullptr</name></expr></argument>, <argument><expr><name>QualType</name> <name>ObjectType</name> <operator>=</operator> <call><name>QualType</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>Expr</name><operator>::</operator><name>Classification</name> <name>ObjectClassification</name> <operator>=</operator> <block>{}</block></expr></argument>,
<argument><expr><name>OverloadCandidateParamOrder</name> <name>PO</name> <operator>=</operator> <block>{}</block></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>AddConversionCandidate</name><parameter_list>(
<parameter><decl><type><name>CXXConversionDecl</name> <modifier>*</modifier></type><name>Conversion</name></decl></parameter>, <parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ActingContext</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><name>OverloadCandidateSet</name> <modifier>&amp;</modifier></type><name>CandidateSet</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AllowObjCConversionOnExplicit</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowExplicit</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AllowResultConversion</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AddTemplateConversionCandidate</name><parameter_list>(
<parameter><decl><type><name>FunctionTemplateDecl</name> <modifier>*</modifier></type><name>FunctionTemplate</name></decl></parameter>, <parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ActingContext</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><name>OverloadCandidateSet</name> <modifier>&amp;</modifier></type><name>CandidateSet</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AllowObjCConversionOnExplicit</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowExplicit</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AllowResultConversion</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AddSurrogateCandidate</name><parameter_list>(<parameter><decl><type><name>CXXConversionDecl</name> <modifier>*</modifier></type><name>Conversion</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ActingContext</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Proto</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Object</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>OverloadCandidateSet</name><modifier>&amp;</modifier></type> <name>CandidateSet</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AddNonMemberOperatorCandidates</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>UnresolvedSetImpl</name> <modifier>&amp;</modifier></type><name>Functions</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>OverloadCandidateSet</name> <modifier>&amp;</modifier></type><name>CandidateSet</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>ExplicitTemplateArgs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>AddMemberOperatorCandidates</name><argument_list>(<argument><expr><name>OverloadedOperatorKind</name> <name>Op</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>OverloadCandidateSet</name> <operator>&amp;</operator><name>CandidateSet</name></expr></argument>,
<argument><expr><name>OverloadCandidateParamOrder</name> <name>PO</name> <operator>=</operator> <block>{}</block></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>AddBuiltinCandidate</name><parameter_list>(<parameter><decl><type><name>QualType</name> <modifier>*</modifier></type><name>ParamTys</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>OverloadCandidateSet</name><modifier>&amp;</modifier></type> <name>CandidateSet</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsAssignmentOperator</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumContextualBoolArguments</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AddBuiltinOperatorCandidates</name><parameter_list>(<parameter><decl><type><name>OverloadedOperatorKind</name></type> <name>Op</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>OverloadCandidateSet</name><modifier>&amp;</modifier></type> <name>CandidateSet</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AddArgumentDependentLookupCandidates</name><parameter_list>(<parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>ExplicitTemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>OverloadCandidateSet</name><modifier>&amp;</modifier></type> <name>CandidateSet</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>PartialOverloading</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>NoteOverloadCandidate</name><parameter_list>(
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Found</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Fn</name></decl></parameter>,
<parameter><decl><type><name>OverloadCandidateRewriteKind</name></type> <name>RewriteKind</name> <init>= <expr><call><name>OverloadCandidateRewriteKind</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>DestType</name> <init>= <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>TakingAddress</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>NoteAllOverloadCandidates</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>DestType</name> <init>= <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>TakingAddress</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>EnableIfAttr</name> <modifier>*</modifier></type><name>CheckEnableIf</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Function</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>CallLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>MissingImplicitThis</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><name>std</name><operator>::</operator><name>string</name></expr></argument>&gt;</argument_list></name> <call><name>findFailedBooleanCondition</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>Cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>








<function_decl><type><name>bool</name></type> <name>diagnoseArgDependentDiagnoseIfAttrs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Function</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>ThisArg</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>bool</name></type> <name>diagnoseArgIndependentDiagnoseIfAttrs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>checkAddressOfFunctionIsAvailable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Function</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Complain</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>QualType</name></type> <name>ExtractUnqualifiedFunctionType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>PossiblyAFunctionType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>FunctionDecl</name> <modifier>*</modifier></type>
<name>ResolveAddressOfOverloadedFunction</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>AddressOfExpr</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>TargetType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Complain</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name> <modifier>&amp;</modifier></type><name>Found</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>pHadMultipleCandidates</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>FunctionDecl</name> <modifier>*</modifier></type>
<name>resolveAddressOfSingleOverloadCandidate</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>DeclAccessPair</name> <modifier>&amp;</modifier></type><name>FoundResult</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>resolveAndFixAddressOfSingleOverloadCandidate</name><parameter_list>(
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>SrcExpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>DoFunctionPointerConversion</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>FunctionDecl</name> <modifier>*</modifier></type>
<name>ResolveSingleFunctionTemplateSpecialization</name><parameter_list>(<parameter><decl><type><name>OverloadExpr</name> <modifier>*</modifier></type><name>ovl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Complain</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name> <modifier>*</modifier></type><name>Found</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>ResolveAndFixSingleFunctionTemplateSpecialization</name><parameter_list>(
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>SrcExpr</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DoFunctionPointerConverion</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Complain</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>OpRangeForComplaining</name> <init>= <expr><call><name>SourceRange</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>DestTypeForComplaining</name> <init>= <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>DiagIDForComplaining</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>Expr</name> <modifier>*</modifier></type><name>FixOverloadedFunctionReference</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Fn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>FixOverloadedFunctionReference</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Fn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>AddOverloadedCallCandidates</name><parameter_list>(<parameter><decl><type><name>UnresolvedLookupExpr</name> <modifier>*</modifier></type><name>ULE</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>OverloadCandidateSet</name> <modifier>&amp;</modifier></type><name>CandidateSet</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>PartialOverloading</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AddOverloadedCallCandidates</name><parameter_list>(
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>ExplicitTemplateArgs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>, <parameter><decl><type><name>OverloadCandidateSet</name> <modifier>&amp;</modifier></type><name>CandidateSet</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>ForRangeStatus</name> <block>{
<decl><name>FRS_Success</name></decl>,
<decl><name>FRS_NoViableFunction</name></decl>,
<decl><name>FRS_DiagnosticIssued</name></decl>
}</block>;</enum>

<function_decl><type><name>ForRangeStatus</name></type> <name>BuildForRangeBeginEndCall</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RangeLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>MemberLookup</name></decl></parameter>,
<parameter><decl><type><name>OverloadCandidateSet</name> <modifier>*</modifier></type><name>CandidateSet</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Range</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>*</modifier></type><name>CallExpr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildOverloadedCallExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Fn</name></decl></parameter>,
<parameter><decl><type><name>UnresolvedLookupExpr</name> <modifier>*</modifier></type><name>ULE</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ExecConfig</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowTypoCorrection</name><init>=<expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>CalleesAddressIsTaken</name><init>=<expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>buildOverloadedCallSet</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Fn</name></decl></parameter>, <parameter><decl><type><name>UnresolvedLookupExpr</name> <modifier>*</modifier></type><name>ULE</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>OverloadCandidateSet</name> <modifier>*</modifier></type><name>CandidateSet</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name> <modifier>*</modifier></type><name>Result</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>CreateUnresolvedLookupExpr</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>NamingClass</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>NNSLoc</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name></type> <name>DNI</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UnresolvedSetImpl</name> <modifier>&amp;</modifier></type><name>Fns</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>PerformADL</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>CreateOverloadedUnaryOp</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>UnaryOperatorKind</name></type> <name>Opc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UnresolvedSetImpl</name> <modifier>&amp;</modifier></type><name>Fns</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>RequiresADL</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>LookupOverloadedBinOp</name><parameter_list>(<parameter><decl><type><name>OverloadCandidateSet</name> <modifier>&amp;</modifier></type><name>CandidateSet</name></decl></parameter>,
<parameter><decl><type><name>OverloadedOperatorKind</name></type> <name>Op</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UnresolvedSetImpl</name> <modifier>&amp;</modifier></type><name>Fns</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>RequiresADL</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>CreateOverloadedBinOp</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UnresolvedSetImpl</name> <modifier>&amp;</modifier></type><name>Fns</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RequiresADL</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowRewrittenCandidates</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>DefaultedFn</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildSynthesizedThreeWayComparison</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UnresolvedSetImpl</name> <modifier>&amp;</modifier></type><name>Fns</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>DefaultedFn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>CreateOverloadedArraySubscriptExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>,<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Idx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildCallToMemberFunction</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>MemExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowRecovery</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type>
<name>BuildCallToObjectOfClassType</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Object</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildOverloadedArrowExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>NoArrowOperatorFound</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>CheckCallReturnType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ReturnType</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>CE</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckParmsForFunctionDef</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Parameters</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>CheckParameterNames</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckCXXDefaultArguments</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckExtraCXXDefaultArguments</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Scope</name> <modifier>*</modifier></type><name>getNonFieldDeclScope</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>





























<enum>enum <name>LookupNameKind</name> <block>{



<decl><name>LookupOrdinaryName</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,


<decl><name>LookupTagName</name></decl>,

<decl><name>LookupLabel</name></decl>,


<decl><name>LookupMemberName</name></decl>,



<decl><name>LookupOperatorName</name></decl>,


<decl><name>LookupDestructorName</name></decl>,



<decl><name>LookupNestedNameSpecifierName</name></decl>,



<decl><name>LookupNamespaceName</name></decl>,



<decl><name>LookupUsingDeclName</name></decl>,




<decl><name>LookupRedeclarationWithLinkage</name></decl>,


<decl><name>LookupLocalFriendName</name></decl>,

<decl><name>LookupObjCProtocolName</name></decl>,

<decl><name>LookupObjCImplicitSelfParam</name></decl>,

<decl><name>LookupOMPReductionName</name></decl>,

<decl><name>LookupOMPMapperName</name></decl>,

<decl><name>LookupAnyName</name></decl>
}</block>;</enum>



<enum>enum <name>RedeclarationKind</name> <block>{


<decl><name>NotForRedeclaration</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,


<decl><name>ForVisibleRedeclaration</name></decl>,



<decl><name>ForExternalRedeclaration</name></decl>
}</block>;</enum>

<function><type><name>RedeclarationKind</name></type> <name>forRedeclarationInCurContext</name><parameter_list>()</parameter_list> <block>{<block_content>




<if_stmt><if>if <condition>(<expr><call><name><name>cast</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CurContext</name></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><call><name>getOwningModuleForLinkage</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>ForVisibleRedeclaration</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>ForExternalRedeclaration</name></expr>;</return>
</block_content>}</block></function>


<enum>enum <name>LiteralOperatorLookupResult</name> <block>{

<decl><name>LOLR_Error</name></decl>,

<decl><name>LOLR_ErrorNoDiagnostic</name></decl>,


<decl><name>LOLR_Cooked</name></decl>,


<decl><name>LOLR_Raw</name></decl>,



<decl><name>LOLR_Template</name></decl>,



<decl><name>LOLR_StringTemplatePack</name></decl>,
}</block>;</enum>

<function_decl><type><name>SpecialMemberOverloadResult</name></type> <name>LookupSpecialMember</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>CXXSpecialMember</name></type> <name>SM</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ConstArg</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>VolatileArg</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RValueThis</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ConstThis</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>VolatileThis</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>function</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><specifier>const</specifier> <name>TypoCorrection</name> <operator>&amp;</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>TypoDiagnosticGenerator</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>function</name><argument_list type="generic">&lt;<argument><expr><name>ExprResult</name><operator>(</operator><name>Sema</name> <operator>&amp;</operator>, <name>TypoExpr</name> <operator>*</operator>, <name>TypoCorrection</name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>TypoRecoveryCallback</name></expr>;</expr_stmt></typedef>

<label><name>private</name>:</label>
<function_decl><type><name>bool</name></type> <name>CppLookupName</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>TypoExprState</name> <block>{
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TypoCorrectionConsumer</name></expr></argument>&gt;</argument_list></name> <name>Consumer</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>TypoDiagnosticGenerator</name></type> <name>DiagHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TypoRecoveryCallback</name></type> <name>RecoveryHandler</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>TypoExprState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<macro><name>TypoExprState</name><argument_list>(<argument>TypoExprState &amp;&amp;other</argument>)</argument_list></macro> <expr_stmt><expr><name>noexcept</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>TypoExprState</name> <modifier>&amp;</modifier></type><name>operator</name><init>=<expr><operator>(</operator><name>TypoExprState</name> <operator>&amp;&amp;</operator><name>other</name><operator>)</operator> <name>noexcept</name></expr></init></decl>;</decl_stmt>
}</block>;</struct>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>TypoExpr</name> <operator>*</operator></expr></argument>, <argument><expr><name>TypoExprState</name></expr></argument>&gt;</argument_list></name> <name>DelayedTypos</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>TypoExpr</name> <modifier>*</modifier></type><name>createDelayedTypo</name><argument_list>(<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TypoCorrectionConsumer</name></expr></argument>&gt;</argument_list></name> <name>TCC</name></expr></argument>,
<argument><expr><name>TypoDiagnosticGenerator</name> <name>TDG</name></expr></argument>,
<argument><expr><name>TypoRecoveryCallback</name> <name>TRC</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>TypoLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>MapVector</name><argument_list type="generic">&lt;<argument><expr><name>NamespaceDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>KnownNamespaces</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>LoadedExternalKnownNamespaces</name></decl>;</decl_stmt>




<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TypoCorrectionConsumer</name></expr></argument>&gt;</argument_list></name>
<macro><name>makeTypoCorrectionConsumer</name><argument_list>(<argument>const DeclarationNameInfo &amp;Typo</argument>,
<argument>Sema::LookupNameKind LookupKind</argument>, <argument>Scope *S</argument>,
<argument>CXXScopeSpec *SS</argument>,
<argument>CorrectionCandidateCallback &amp;CCC</argument>,
<argument>DeclContext *MemberContext</argument>, <argument>bool EnteringContext</argument>,
<argument>const ObjCObjectPointerType *OPT</argument>,
<argument>bool ErrorRecovery</argument>)</argument_list></macro></expr>;</expr_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><specifier>const</specifier> <name>TypoExprState</name> <modifier>&amp;</modifier></type><name>getTypoExprState</name><argument_list>(<argument><expr><name>TypoExpr</name> <operator>*</operator><name>TE</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>clearDelayedTypo</name><parameter_list>(<parameter><decl><type><name>TypoExpr</name> <modifier>*</modifier></type><name>TE</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>LookupSingleName</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>LookupNameKind</name></type> <name>NameKind</name></decl></parameter>,
<parameter><decl><type><name>RedeclarationKind</name></type> <name>Redecl</name>
<init>= <expr><name>NotForRedeclaration</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>LookupBuiltin</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>LookupNecessaryTypesForBuiltin</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>LookupName</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowBuiltinCreation</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>LookupQualifiedName</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>LookupCtx</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>InUnqualifiedLookup</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>LookupQualifiedName</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>LookupCtx</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>LookupParsedName</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>*</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowBuiltinCreation</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ObjCProtocolDecl</name> <modifier>*</modifier></type><name>LookupProtocol</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>,
<parameter><decl><type><name>RedeclarationKind</name></type> <name>Redecl</name>
<init>= <expr><name>NotForRedeclaration</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>LookupInSuper</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>LookupOverloadedOperatorName</name><parameter_list>(<parameter><decl><type><name>OverloadedOperatorKind</name></type> <name>Op</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>UnresolvedSetImpl</name> <modifier>&amp;</modifier></type><name>Functions</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>LabelDecl</name> <modifier>*</modifier></type><name>LookupOrCreateLabel</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>IdentLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>GnuLabelLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclContextLookupResult</name></type> <name>LookupConstructors</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>LookupDefaultConstructor</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>LookupCopyingConstructor</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Quals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>LookupCopyingAssignment</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Quals</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RValueThis</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ThisQuals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>LookupMovingConstructor</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Quals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>LookupMovingAssignment</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Quals</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RValueThis</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ThisQuals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>LookupDestructor</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>checkLiteralOperatorId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Id</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsUDSuffix</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LiteralOperatorLookupResult</name></type>
<name>LookupLiteralOperator</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name></type> <name>ArgTys</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowRaw</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AllowTemplate</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowStringTemplate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>DiagnoseMissing</name></decl></parameter>,
<parameter><decl><type><name>StringLiteral</name> <modifier>*</modifier></type><name>StringLit</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isKnownName</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>name</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>FunctionEmissionStatus</name> <block>{<block_content>
<expr_stmt><expr><name>Emitted</name></expr><operator>,</operator>
<expr><name>CUDADiscarded</name></expr><operator>,</operator>
<expr><name>OMPDiscarded</name></expr><operator>,</operator>
<expr><name>TemplateDiscarded</name></expr><operator>,</operator>
<expr><name>Unknown</name></expr><operator>,</operator></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<function_decl><type><name>FunctionEmissionStatus</name></type> <name>getEmissionStatus</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Final</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>shouldIgnoreInHostDeviceCheck</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Callee</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ArgumentDependentLookup</name><parameter_list>(<parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>, <parameter><decl><type><name>ADLResult</name> <modifier>&amp;</modifier></type><name>Functions</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>LookupVisibleDecls</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>LookupNameKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>VisibleDeclConsumer</name> <modifier>&amp;</modifier></type><name>Consumer</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IncludeGlobalScope</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>LoadExternal</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>LookupVisibleDecls</name><parameter_list>(<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>Ctx</name></decl></parameter>, <parameter><decl><type><name>LookupNameKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>VisibleDeclConsumer</name> <modifier>&amp;</modifier></type><name>Consumer</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IncludeGlobalScope</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IncludeDependentBases</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>LoadExternal</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>CorrectTypoKind</name> <block>{
<decl><name>CTK_NonError</name></decl>,
<decl><name>CTK_ErrorRecovery</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><name>TypoCorrection</name></type> <name>CorrectTypo</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclarationNameInfo</name> <operator>&amp;</operator><name>Typo</name></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>LookupNameKind</name> <name>LookupKind</name></expr></argument>,
<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>CXXScopeSpec</name> <operator>*</operator><name>SS</name></expr></argument>,
<argument><expr><name>CorrectionCandidateCallback</name> <operator>&amp;</operator><name>CCC</name></expr></argument>,
<argument><expr><name>CorrectTypoKind</name> <name>Mode</name></expr></argument>,
<argument><expr><name>DeclContext</name> <operator>*</operator><name>MemberContext</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>bool</name> <name>EnteringContext</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCObjectPointerType</name> <operator>*</operator><name>OPT</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>bool</name> <name>RecordFailure</name> <operator>=</operator> <name>true</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TypoExpr</name> <modifier>*</modifier></type><name>CorrectTypoDelayed</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclarationNameInfo</name> <operator>&amp;</operator><name>Typo</name></expr></argument>,
<argument><expr><name>Sema</name><operator>::</operator><name>LookupNameKind</name> <name>LookupKind</name></expr></argument>, <argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>,
<argument><expr><name>CXXScopeSpec</name> <operator>*</operator><name>SS</name></expr></argument>,
<argument><expr><name>CorrectionCandidateCallback</name> <operator>&amp;</operator><name>CCC</name></expr></argument>,
<argument><expr><name>TypoDiagnosticGenerator</name> <name>TDG</name></expr></argument>,
<argument><expr><name>TypoRecoveryCallback</name> <name>TRC</name></expr></argument>, <argument><expr><name>CorrectTypoKind</name> <name>Mode</name></expr></argument>,
<argument><expr><name>DeclContext</name> <operator>*</operator><name>MemberContext</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>bool</name> <name>EnteringContext</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCObjectPointerType</name> <operator>*</operator><name>OPT</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>


















<decl_stmt><decl><type><name>ExprResult</name></type> <name>CorrectDelayedTyposInExpr</name><argument_list>(
<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><name>VarDecl</name> <operator>*</operator><name>InitDecl</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>bool</name> <name>RecoverUncorrectedTypos</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>ExprResult</name><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>Filter</name> <operator>=</operator>
<index>[]</index><operator>(</operator><name>Expr</name> <operator>*</operator><name>E</name><operator>)</operator> <operator>-&gt;</operator> <name>ExprResult</name> <block>{ <return>return <expr><name>E</name></expr>;</return> }</block></expr></argument></argument_list></decl></decl_stmt>)<empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>CorrectDelayedTyposInExpr</name><argument_list>(
<argument><expr><name>ExprResult</name> <name>ER</name></expr></argument>, <argument><expr><name>VarDecl</name> <operator>*</operator><name>InitDecl</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>bool</name> <name>RecoverUncorrectedTypos</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>ExprResult</name><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>Filter</name> <operator>=</operator>
<index>[]</index><operator>(</operator><name>Expr</name> <operator>*</operator><name>E</name><operator>)</operator> <operator>-&gt;</operator> <name>ExprResult</name> <block>{ <return>return <expr><name>E</name></expr>;</return> }</block></expr></argument></argument_list></decl></decl_stmt>) <block>{<block_content>
<return>return <expr><ternary><condition><expr><call><name><name>ER</name><operator>.</operator><name>isInvalid</name></name><argument_list>()</argument_list></call></expr>
?</condition><then> <expr><name>ER</name></expr>
</then><else>: <expr><call><name>CorrectDelayedTyposInExpr</name><argument_list>(<argument><expr><call><name><name>ER</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>InitDecl</name></expr></argument>,
<argument><expr><name>RecoverUncorrectedTypos</name></expr></argument>, <argument><expr><name>Filter</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block>

<function_decl><type><name>void</name></type> <name>diagnoseTypo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TypoCorrection</name> <modifier>&amp;</modifier></type><name>Correction</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>TypoDiag</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ErrorRecovery</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>diagnoseTypo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TypoCorrection</name> <modifier>&amp;</modifier></type><name>Correction</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>TypoDiag</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>PrevNote</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ErrorRecovery</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>MarkTypoCorrectedFunctionDefinition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>F</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>FindAssociatedClassesAndNamespaces</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>InstantiationLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>AssociatedNamespaceSet</name> <modifier>&amp;</modifier></type><name>AssociatedNamespaces</name></decl></parameter>,
<parameter><decl><type><name>AssociatedClassSet</name> <modifier>&amp;</modifier></type><name>AssociatedClasses</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>FilterLookupForScope</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>Ctx</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ConsiderLinkage</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AllowInlineNamespace</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckRedeclarationModuleOwnership</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseAmbiguousLookup</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>CreateRecoveryExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Begin</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>End</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>SubExprs</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>T</name> <init>= <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>getObjCInterfaceDecl</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>Id</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>TypoCorrection</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>CreateBuiltin</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>LazilyCreateBuiltin</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ID</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ForRedeclaration</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ImplicitlyDefineFunction</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AddKnownFunctionAttributesForReplaceableGlobalAllocationFunction</name><parameter_list>(
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AddKnownFunctionAttributes</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ProcessPragmaWeak</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ProcessDeclAttributes</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Declarator</name> <modifier>&amp;</modifier></type><name>PD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ProcessDeclAttributeDelayed</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ProcessDeclAttributeList</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AL</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IncludeCXX11Attributes</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ProcessAccessDeclAttributeList</name><parameter_list>(<parameter><decl><type><name>AccessSpecDecl</name> <modifier>*</modifier></type><name>ASDecl</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>checkUnusedDeclAttributes</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>checkCommonAttributeFeatures</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParsedAttr</name> <modifier>&amp;</modifier></type><name>A</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>checkCommonAttributeFeatures</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParsedAttr</name> <modifier>&amp;</modifier></type><name>A</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>isValidPointerAttrType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>RefOkay</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckRegparmAttr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParsedAttr</name> <modifier>&amp;</modifier></type><name>attr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckCallingConvAttr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParsedAttr</name> <modifier>&amp;</modifier></type><name>attr</name></decl></parameter>, <parameter><decl><type><name>CallingConv</name> <modifier>&amp;</modifier></type><name>CC</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckAttrTarget</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParsedAttr</name> <modifier>&amp;</modifier></type><name>CurrAttr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckAttrNoArgs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParsedAttr</name> <modifier>&amp;</modifier></type><name>CurrAttr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>checkStringLiteralArgumentAttr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParsedAttr</name> <modifier>&amp;</modifier></type><name>Attr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ArgNum</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name> <modifier>&amp;</modifier></type><name>Str</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>ArgLocation</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name>Error</name> <macro><name>isValidSectionSpecifier</name><argument_list>(<argument>StringRef Str</argument>)</argument_list></macro></expr>;</expr_stmt>
<function_decl><type><name>bool</name></type> <name>checkSectionName</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LiteralLoc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>checkTargetAttr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LiteralLoc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>checkMSInheritanceAttrOnDefinition</name><parameter_list>(
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>BestCase</name></decl></parameter>,
<parameter><decl><type><name>MSInheritanceModel</name></type> <name>SemanticSpelling</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckAlignasUnderalignment</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>adjustMemberFunctionCC</name><parameter_list>(<parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsStatic</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsCtorOrDtor</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>hasExplicitCallingConv</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><specifier>const</specifier> <name>AttributedType</name> <modifier>*</modifier></type><name>getCallingConvAttributedType</name><argument_list>(<argument><expr><name>QualType</name> <name>T</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>ProcessStmtAttributes</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Stmt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>InAttrs</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>OutAttrs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>WarnConflictingTypedMethods</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>MethodDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsProtocolMethodDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckConflictingOverridingMethod</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Overridden</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsProtocolMethodDecl</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>WarnExactTypedMethods</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>MethodDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsProtocolMethodDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>Selector</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>&gt;</argument_list></name> <name>SelectorSet</name></expr>;</expr_stmt></typedef>



<function_decl><type><name>void</name></type> <name>CheckImplementationIvars</name><parameter_list>(<parameter><decl><type><name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>ImpDecl</name></decl></parameter>,
<parameter><decl><type><name>ObjCIvarDecl</name> <modifier>*</modifier><modifier>*</modifier></type><name>Fields</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>nIvars</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ImplMethodsVsClassMethods</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>ObjCImplDecl</name><modifier>*</modifier></type> <name>IMPDecl</name></decl></parameter>,
<parameter><decl><type><name>ObjCContainerDecl</name><modifier>*</modifier></type> <name>IDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IncompleteImpl</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DiagnoseUnimplementedProperties</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>ObjCImplDecl</name><modifier>*</modifier></type> <name>IMPDecl</name></decl></parameter>,
<parameter><decl><type><name>ObjCContainerDecl</name> <modifier>*</modifier></type><name>CDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>SynthesizeProperties</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>diagnoseNullResettableSynthesizedSetters</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCImplDecl</name> <modifier>*</modifier></type><name>impDecl</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DefaultSynthesizeProperties</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>ObjCImplDecl</name> <modifier>*</modifier></type><name>IMPDecl</name></decl></parameter>,
<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>IDecl</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AtEnd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DefaultSynthesizeProperties</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>AtEnd</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>IvarBacksCurrentMethodAccessor</name><parameter_list>(<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>IFace</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>, <parameter><decl><type><name>ObjCIvarDecl</name> <modifier>*</modifier></type><name>IV</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DiagnoseUnusedBackingIvarInAccessor</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>ImplD</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>ObjCIvarDecl</name> <modifier>*</modifier></type><name>GetIvarBackingPropertyAccessor</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ObjCMethodDecl</name> <operator>*</operator><name>Method</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ObjCPropertyDecl</name> <operator>*</operator><operator>&amp;</operator><name>PDecl</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>ObjCPropertyDecl</name> <modifier>*</modifier></type><name>HandlePropertyInClassExtension</name><argument_list>(<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AtLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>LParenLoc</name></expr></argument>,
<argument><expr><name>FieldDeclarator</name> <operator>&amp;</operator><name>FD</name></expr></argument>,
<argument><expr><name>Selector</name> <name>GetterSel</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>GetterNameLoc</name></expr></argument>,
<argument><expr><name>Selector</name> <name>SetterSel</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>SetterNameLoc</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>bool</name> <name>isReadWrite</name></expr></argument>,
<argument><expr><name>unsigned</name> <operator>&amp;</operator><name>Attributes</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>unsigned</name> <name>AttributesAsWritten</name></expr></argument>,
<argument><expr><name>QualType</name> <name>T</name></expr></argument>,
<argument><expr><name>TypeSourceInfo</name> <operator>*</operator><name>TSI</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>ObjCKeywordKind</name> <name>MethodImplKind</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>ObjCPropertyDecl</name> <modifier>*</modifier></type><name>CreatePropertyDecl</name><argument_list>(<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>,
<argument><expr><name>ObjCContainerDecl</name> <operator>*</operator><name>CDecl</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AtLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>LParenLoc</name></expr></argument>,
<argument><expr><name>FieldDeclarator</name> <operator>&amp;</operator><name>FD</name></expr></argument>,
<argument><expr><name>Selector</name> <name>GetterSel</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>GetterNameLoc</name></expr></argument>,
<argument><expr><name>Selector</name> <name>SetterSel</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>SetterNameLoc</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>bool</name> <name>isReadWrite</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>unsigned</name> <name>Attributes</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>unsigned</name> <name>AttributesAsWritten</name></expr></argument>,
<argument><expr><name>QualType</name> <name>T</name></expr></argument>,
<argument><expr><name>TypeSourceInfo</name> <operator>*</operator><name>TSI</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>ObjCKeywordKind</name> <name>MethodImplKind</name></expr></argument>,
<argument><expr><name>DeclContext</name> <operator>*</operator><name>lexicalDC</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function_decl><type><name>void</name></type> <name>AtomicPropertySetterGetterRules</name><parameter_list>(<parameter><decl><type><name>ObjCImplDecl</name><modifier>*</modifier></type> <name>IMPDecl</name></decl></parameter>,
<parameter><decl><type><name>ObjCInterfaceDecl</name><modifier>*</modifier></type> <name>IDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseOwningPropertyGetterSynthesis</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseMissingDesignatedInitOverrides</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>ImplD</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>IFD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseDuplicateIvars</name><parameter_list>(<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>ID</name></decl></parameter>, <parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>SID</name></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>MethodMatchStrategy</name> <block>{
<decl><name>MMS_loose</name></decl>,
<decl><name>MMS_strict</name></decl>
}</block>;</enum>



<function_decl><type><name>bool</name></type> <name>MatchTwoMethodDeclarations</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>PrevMethod</name></decl></parameter>,
<parameter><decl><type><name>MethodMatchStrategy</name></type> <name>strategy</name> <init>= <expr><name>MMS_strict</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>MatchAllMethodDeclarations</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SelectorSet</name> <modifier>&amp;</modifier></type><name>InsMap</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SelectorSet</name> <modifier>&amp;</modifier></type><name>ClsMap</name></decl></parameter>,
<parameter><decl><type><name>SelectorSet</name> <modifier>&amp;</modifier></type><name>InsMapSeen</name></decl></parameter>,
<parameter><decl><type><name>SelectorSet</name> <modifier>&amp;</modifier></type><name>ClsMapSeen</name></decl></parameter>,
<parameter><decl><type><name>ObjCImplDecl</name><modifier>*</modifier></type> <name>IMPDecl</name></decl></parameter>,
<parameter><decl><type><name>ObjCContainerDecl</name><modifier>*</modifier></type> <name>IDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>IncompleteImpl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ImmediateClass</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>WarnCategoryMethodImpl</name><init>=<expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>CheckCategoryVsClassMethodMatches</name><parameter_list>(<parameter><decl><type><name>ObjCCategoryImplDecl</name> <modifier>*</modifier></type><name>CatIMP</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>addMethodToGlobalList</name><parameter_list>(<parameter><decl><type><name>ObjCMethodList</name> <modifier>*</modifier></type><name>List</name></decl></parameter>, <parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>LangAS</name> <macro><name>getDefaultCXXMethodAddrSpace</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>private</name>:</label>


<function_decl><type><name>void</name></type> <name>AddMethodToGlobalPool</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>impl</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>instance</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>LookupMethodInGlobalPool</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>receiverIdOrClass</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>instance</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>





<function_decl><type><name>bool</name></type>
<name>CollectMultipleMethodsInGlobalPool</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>Methods</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>InstanceFirst</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>CheckTheOther</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectType</name> <modifier>*</modifier></type><name>TypeBound</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type>
<name>AreMultipleMethodsInGlobalPool</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>, <parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>BestMethod</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>receiverIdOrClass</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>Methods</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type>
<name>DiagnoseMultipleMethodInGlobalPool</name><parameter_list>(<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Methods</name></decl></parameter>,
<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>receiverIdOrClass</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>


<function_decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>SelectBestMethod</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>, <parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsInstance</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ObjCMethodDecl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name><modifier>&amp;</modifier></type> <name>Methods</name></decl></parameter>)</parameter_list>;</function_decl>



<function><type><name>TypoCorrection</name></type> <name>FailedCorrection</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Typo</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TypoLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RecordFailure</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>RecordFailure</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>TypoCorrectionFailures</name><index>[<expr><name>Typo</name></expr>]</index></name><operator>.</operator><call><name>insert</name><argument_list>(<argument><expr><name>TypoLoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><call><name>TypoCorrection</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<label><name>public</name>:</label>




<function><type><name>void</name></type> <name>AddInstanceMethodToGlobalPool</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>impl</name><init>=<expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>AddMethodToGlobalPool</name><argument_list>(<argument><expr><name>Method</name></expr></argument>, <argument><expr><name>impl</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>AddFactoryMethodToGlobalPool</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>impl</name><init>=<expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name>AddMethodToGlobalPool</name><argument_list>(<argument><expr><name>Method</name></expr></argument>, <argument><expr><name>impl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>AddAnyMethodToGlobalPool</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<function><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>LookupInstanceMethodInGlobalPool</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>receiverIdOrClass</name><init>=<expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>LookupMethodInGlobalPool</name><argument_list>(<argument><expr><name>Sel</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>receiverIdOrClass</name></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>LookupFactoryMethodInGlobalPool</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>receiverIdOrClass</name><init>=<expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>LookupMethodInGlobalPool</name><argument_list>(<argument><expr><name>Sel</name></expr></argument>, <argument><expr><name>R</name></expr></argument>, <argument><expr><name>receiverIdOrClass</name></expr></argument>,
<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>SelectorsForTypoCorrection</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ObjectType</name><init>=<expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>LookupImplementedMethodInGlobalPool</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>CollectIvarsToConstructOrDestruct</name><parameter_list>(<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>OI</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ObjCIvarDecl</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Ivars</name></decl></parameter>)</parameter_list>;</function_decl>



<label><name>public</name>:</label>
<decl_stmt><decl><type><name>class</name></type> <name>FullExprArg</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>FullExprArg</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>E</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <block>{ }</block>
<call><name>FullExprArg</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>actions</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>E</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <block>{ }</block>

<name>ExprResult</name> <macro><name>release</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><name>E</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>Expr</name> <operator>*</operator><macro><name>get</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>E</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>Expr</name> <operator>*</operator><name><name>operator</name><operator>-&gt;</operator><name/></name>(</expr></expr_stmt>)</block_content> <block>{<block_content>
<return>return <expr><name>E</name></expr>;</return>
</block_content>}</block>

private:


friend class Sema</block></decl>;</decl_stmt>

<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>FullExprArg</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>expr</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>E</name><argument_list>(<argument>expr</argument>)</argument_list></macro> <block>{}</block>

<name>Expr</name> <operator>*</operator><name>E</name></expr>;</expr_stmt>
};

<function><type><name>FullExprArg</name></type> <name>MakeFullExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>MakeFullExpr</name><argument_list>(<argument><expr><name>Arg</name></expr></argument>, <argument><expr><ternary><condition><expr><name>Arg</name></expr> ?</condition><then> <expr><call><name><name>Arg</name><operator>-&gt;</operator><name>getExprLoc</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>FullExprArg</name></type> <name>MakeFullExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Arg</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>CC</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>FullExprArg</name><argument_list>(
<argument><expr><call><name>ActOnFinishFullExpr</name><argument_list>(<argument><expr><name>Arg</name></expr></argument>, <argument><expr><name>CC</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>FullExprArg</name></type> <name>MakeFullDiscardedValueExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Arg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>FE</name> <init>=
<expr><call><name>ActOnFinishFullExpr</name><argument_list>(<argument><expr><name>Arg</name></expr></argument>, <argument><expr><ternary><condition><expr><name>Arg</name></expr> ?</condition><then> <expr><call><name><name>Arg</name><operator>-&gt;</operator><name>getExprLoc</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>,
<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>FullExprArg</name><argument_list>(<argument><expr><call><name><name>FE</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>StmtResult</name></type> <name>ActOnExprStmt</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>Arg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>DiscardedValue</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnExprStmtError</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnNullStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>SemiLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HasLeadingEmptyMacro</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnStartOfCompoundStmt</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsStmtExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnAfterCompoundStatementLeadingPragmas</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnFinishOfCompoundStmt</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnCompoundStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>R</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Elts</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isStmtExpr</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>class</name></type> <name>CompoundScopeRAII</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>CompoundScopeRAII</name><argument_list>(<argument>Sema &amp;S</argument>, <argument>bool IsStmtExpr = false</argument>)</argument_list></macro> : <macro><name>S</name><argument_list>(<argument>S</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>ActOnStartOfCompoundStmt</name></name><argument_list>(<argument><expr><name>IsStmtExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<expr_stmt><expr><operator>~</operator><macro><name>CompoundScopeRAII</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name><name>S</name><operator>.</operator><name>ActOnFinishOfCompoundStmt</name></name><argument_list>()</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>Sema</name> <operator>&amp;</operator><name>S</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<struct>struct <name>FunctionScopeRAII</name> <block>{
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Active</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>FunctionScopeRAII</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>)</argument_list></call> <operator>:</operator> <call><name>S</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Active</name><argument_list>(<argument>true</argument>)</argument_list></macro> <expr><block>{}</block>
<operator>~</operator><macro><name>FunctionScopeRAII</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><name>Active</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>PopFunctionScopeInfo</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>
<function><type><name>void</name></type> <name>disable</name><parameter_list>()</parameter_list> <block>{<block_content> <expr_stmt><expr><name>Active</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> </block_content>}</block></function>
}</block>;</struct>

<function_decl><type><name>StmtResult</name></type> <name>ActOnDeclStmt</name><parameter_list>(<parameter><decl><type><name>DeclGroupPtrTy</name></type> <name>Decl</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnForEachDeclStmt</name><parameter_list>(<parameter><decl><type><name>DeclGroupPtrTy</name></type> <name>Decl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnForEachLValueExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnCaseExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CaseLoc</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name></type> <name>Val</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnCaseStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CaseLoc</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name></type> <name>LHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>DotDotDotLoc</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name></type> <name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnCaseStmtBody</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>CaseStmt</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnDefaultStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>DefaultLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnLabelStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>IdentLoc</name></decl></parameter>, <parameter><decl><type><name>LabelDecl</name> <modifier>*</modifier></type><name>TheDecl</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>BuildAttributedStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AttrsLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Attrs</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnAttributedStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesWithRange</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>class</name></type> <name>ConditionResult</name></decl>;</decl_stmt>
<function_decl><type><name>StmtResult</name></type> <name>ActOnIfStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>IfLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsConstexpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>InitStmt</name></decl></parameter>,
<parameter><decl><type><name>ConditionResult</name></type> <name>Cond</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>ThenVal</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ElseLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>ElseVal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>BuildIfStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>IfLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsConstexpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>InitStmt</name></decl></parameter>,
<parameter><decl><type><name>ConditionResult</name></type> <name>Cond</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>ThenVal</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ElseLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>ElseVal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnStartOfSwitchStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>SwitchLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>InitStmt</name></decl></parameter>,
<parameter><decl><type><name>ConditionResult</name></type> <name>Cond</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnFinishSwitchStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>SwitchLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Switch</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnWhileStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>WhileLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>ConditionResult</name></type> <name>Cond</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnDoStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>DoLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>WhileLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>CondLParen</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Cond</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>CondRParen</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnForStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ForLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>First</name></decl></parameter>,
<parameter><decl><type><name>ConditionResult</name></type> <name>Second</name></decl></parameter>,
<parameter><decl><type><name>FullExprArg</name></type> <name>Third</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>CheckObjCForCollectionOperand</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>forLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>collection</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnObjCForCollectionStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ForColLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>First</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>collection</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>FinishObjCForCollectionStmt</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>ForCollection</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>BuildForRangeKind</name> <block>{

<decl><name>BFRK_Build</name></decl>,


<decl><name>BFRK_Rebuild</name></decl>,


<decl><name>BFRK_Check</name></decl>
}</block>;</enum>

<function_decl><type><name>StmtResult</name></type> <name>ActOnCXXForRangeStmt</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ForLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CoawaitLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>InitStmt</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>LoopVar</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Collection</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>BuildForRangeKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>BuildCXXForRangeStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ForLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CoawaitLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>InitStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>RangeDecl</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Begin</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>End</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Cond</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Inc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>LoopVarDecl</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>BuildForRangeKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>FinishCXXForRangeStmt</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>ForRange</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnGotoStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>GotoLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LabelLoc</name></decl></parameter>,
<parameter><decl><type><name>LabelDecl</name> <modifier>*</modifier></type><name>TheDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnIndirectGotoStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>GotoLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StarLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>DestExp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnContinueStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ContinueLoc</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnBreakStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>BreakLoc</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnCapturedRegionStart</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>,
<parameter><decl><type><name>CapturedRegionKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumParams</name></decl></parameter>)</parameter_list>;</function_decl>
<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>, <argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <name>CapturedParamNameType</name></expr>;</expr_stmt></typedef>
<function_decl><type><name>void</name></type> <name>ActOnCapturedRegionStart</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>,
<parameter><decl><type><name>CapturedRegionKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>CapturedParamNameType</name></expr></argument>&gt;</argument_list></name></type> <name>Params</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>OpenMPCaptureLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnCapturedRegionEnd</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnCapturedRegionError</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>CreateCapturedStmtRecordDecl</name><parameter_list>(<parameter><decl><type><name>CapturedDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>CD</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumParams</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>NamedReturnInfo</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>Candidate</name></decl>;</decl_stmt>

<enum>enum <name>Status</name> : <type><name>uint8_t</name></type> <block>{ <decl><name>None</name></decl>, <decl><name>MoveEligible</name></decl>, <decl><name>MoveEligibleAndCopyElidable</name></decl> }</block>;</enum>
<decl_stmt><decl><type><name>Status</name></type> <name>S</name></decl>;</decl_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isMoveEligible</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>S</name> <operator>!=</operator> <name>None</name></expr>;</return> }</block></expr></expr_stmt><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isCopyElidable</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>S</name> <operator>==</operator> <name>MoveEligibleAndCopyElidable</name></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>
<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>SimplerImplicitMoveMode</name> <block>{<block_content> <expr_stmt><expr><name>ForceOff</name></expr><operator>,</operator> <expr><name>Normal</name></expr><operator>,</operator> <expr><name>ForceOn</name></expr></expr_stmt> </block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<function_decl><type><name>NamedReturnInfo</name></type> <name>getNamedReturnInfo</name><parameter_list>(
<parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>SimplerImplicitMoveMode</name></type> <name>Mode</name> <init>= <expr><name>SimplerImplicitMoveMode</name><operator>::</operator><name>Normal</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedReturnInfo</name></type> <name>getNamedReturnInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>getCopyElisionCandidate</name><parameter_list>(<parameter><decl><type><name>NamedReturnInfo</name> <modifier>&amp;</modifier></type><name>Info</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ReturnType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type>
<name>PerformMoveOrCopyInitialization</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>&amp;</modifier></type><name>Entity</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>NamedReturnInfo</name> <modifier>&amp;</modifier></type><name>NRInfo</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Value</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>SupressSimplerImplicitMoves</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnReturnStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ReturnLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RetValExp</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>BuildReturnStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ReturnLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RetValExp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnCapScopeReturnStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ReturnLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RetValExp</name></decl></parameter>,
<parameter><decl><type><name>NamedReturnInfo</name> <modifier>&amp;</modifier></type><name>NRInfo</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>SupressSimplerImplicitMoves</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnGCCAsmStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AsmLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsSimple</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsVolatile</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumOutputs</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumInputs</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>Names</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Constraints</name></decl></parameter>, <parameter><decl><type><name>MultiExprArg</name></type> <name>Exprs</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>AsmString</name></decl></parameter>, <parameter><decl><type><name>MultiExprArg</name></type> <name>Clobbers</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumLabels</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>FillInlineAsmIdentifierInfo</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>Res</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>InlineAsmIdentifierInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>ExprResult</name></type> <name>LookupInlineAsmIdentifier</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Id</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsUnevaluatedContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>LookupInlineAsmField</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>Base</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Member</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>Offset</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>AsmLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>LookupInlineAsmVarDeclField</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RefExpr</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Member</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AsmLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnMSAsmStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AsmLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LBraceLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Token</name></expr></argument>&gt;</argument_list></name></type> <name>AsmToks</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>AsmString</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumOutputs</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumInputs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name></type> <name>Constraints</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name></type> <name>Clobbers</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Exprs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>LabelDecl</name> <modifier>*</modifier></type><name>GetOrCreateMSAsmLabel</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>ExternalLabelName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Location</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AlwaysCreate</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>BuildObjCExceptionDecl</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ExceptionType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Invalid</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnObjCExceptionDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnObjCAtCatchStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RParen</name></decl></parameter>,
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Parm</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnObjCAtFinallyStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnObjCAtTryStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Try</name></decl></parameter>,
<parameter><decl><type><name>MultiStmtArg</name></type> <name>Catch</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Finally</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>BuildObjCAtThrowStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Throw</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnObjCAtThrowStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Throw</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnObjCAtSynchronizedOperand</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>atLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>operand</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnObjCAtSynchronizedStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SynchExpr</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SynchBody</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnObjCAutoreleasePoolStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>BuildExceptionDeclaration</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnExceptionDeclarator</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnCXXCatchBlock</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CatchLoc</name></decl></parameter>,
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ExDecl</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>HandlerBlock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnCXXTryBlock</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>TryLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>TryBlock</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Handlers</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnSEHTryBlock</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsCXXTry</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TryLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>TryBlock</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Handler</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnSEHExceptBlock</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>FilterExpr</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Block</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnStartSEHFinallyBlock</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnAbortSEHFinallyBlock</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnFinishSEHFinallyBlock</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Block</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnSEHLeaveStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseReturnInConstructorExceptionHandler</name><parameter_list>(<parameter><decl><type><name>CXXTryStmt</name> <modifier>*</modifier></type><name>TryBlock</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>ShouldWarnIfUnusedFileScopedDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>DeclaratorDecl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>MarkUnusedFileScopedDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclaratorDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DiagnoseUnusedExprResult</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DiagnoseUnusedNestedTypedefs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RecordDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DiagnoseUnusedDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DiagnoseUnusedButSetDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>void</name></type> <name>DiagnoseEmptyStmtBody</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StmtLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DiagnoseEmptyLoopBody</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>PossibleBody</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>DiagnoseSelfMove</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>LHSExpr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>RHSExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>diagnoseNullableToNonnullConversion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>DstType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>SrcType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>diagnoseZeroToNullptrConversion</name><parameter_list>(<parameter><decl><type><name>CastKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>ParsingDeclState</name></type> <name>PushParsingDeclaration</name><argument_list>(<argument><expr><name>sema</name><operator>::</operator><name>DelayedDiagnosticPool</name> <operator>&amp;</operator><name>pool</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name><name>DelayedDiagnostics</name><operator>.</operator><name>push</name></name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<function_decl><type><name>void</name></type> <name>PopParsingDeclaration</name><parameter_list>(<parameter><decl><type><name>ParsingDeclState</name></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><name>ProcessingContextState</name></type> <name>ParsingClassState</name>;</typedef>
<function><type><name>ParsingClassState</name></type> <name>PushParsingClass</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ParsingClassDepth</name><operator>++</operator></expr>;</expr_stmt>
<return>return <expr><call><name><name>DelayedDiagnostics</name><operator>.</operator><name>pushUndelayed</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function><type><name>void</name></type> <name>PopParsingClass</name><parameter_list>(<parameter><decl><type><name>ParsingClassState</name></type> <name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
<expr_stmt><expr><name>ParsingClassDepth</name><operator>--</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>DelayedDiagnostics</name><operator>.</operator><name>popUndelayed</name></name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><name>void</name></type> <name>redelayDiagnostics</name><argument_list>(<argument><expr><name>sema</name><operator>::</operator><name>DelayedDiagnosticPool</name> <operator>&amp;</operator><name>pool</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>DiagnoseAvailabilityOfDecl</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>Locs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>UnknownObjCClass</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ObjCPropertyAccess</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AvoidPartialAvailabilityChecks</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>ClassReceiver</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>makeUnavailableInSystemHeader</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>loc</name></expr></argument>,
<argument><expr><name>UnavailableAttr</name><operator>::</operator><name>ImplicitReason</name> <name>reason</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>DiagnoseUnguardedAvailabilityViolations</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>handleDelayedAvailabilityCheck</name><argument_list>(<argument><expr><name>sema</name><operator>::</operator><name>DelayedDiagnostic</name> <operator>&amp;</operator><name>DD</name></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function_decl><type><name>bool</name></type> <name>CanUseDecl</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>TreatUnavailableAsInvalid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>DiagnoseUseOfDecl</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>Locs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>UnknownObjCClass</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ObjCPropertyAccess</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AvoidPartialAvailabilityChecks</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>ClassReciever</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>NoteDeletedFunction</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>NoteDeletedInheritingConstructor</name><parameter_list>(<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>CD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>DiagnosePropertyAccessorMismatch</name><parameter_list>(<parameter><decl><type><name>ObjCPropertyDecl</name> <modifier>*</modifier></type><name>PD</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Getter</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DiagnoseSentinelCalls</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>PushExpressionEvaluationContext</name><argument_list>(
<argument><expr><name>ExpressionEvaluationContext</name> <name>NewContext</name></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator><name>LambdaContextDecl</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>ExpressionEvaluationContextRecord</name><operator>::</operator><name>ExpressionKind</name> <name>Type</name> <operator>=</operator>
<name>ExpressionEvaluationContextRecord</name><operator>::</operator><name>EK_Other</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<enum>enum <name>ReuseLambdaContextDecl_t</name> <block>{ <decl><name>ReuseLambdaContextDecl</name></decl> }</block>;</enum>
<decl_stmt><decl><type><name>void</name></type> <name>PushExpressionEvaluationContext</name><argument_list>(
<argument><expr><name>ExpressionEvaluationContext</name> <name>NewContext</name></expr></argument>, <argument><expr><name>ReuseLambdaContextDecl_t</name></expr></argument>,
<argument><expr><name>ExpressionEvaluationContextRecord</name><operator>::</operator><name>ExpressionKind</name> <name>Type</name> <operator>=</operator>
<name>ExpressionEvaluationContextRecord</name><operator>::</operator><name>EK_Other</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>PopExpressionEvaluationContext</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiscardCleanupsInEvaluationContext</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>TransformToPotentiallyEvaluated</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>HandleExprEvaluationContextForTypeof</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>CheckUnevaluatedOperand</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckUnusedVolatileAssignment</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnConstantExpression</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>Res</name></decl></parameter>)</parameter_list>;</function_decl>













<function_decl><type><name>void</name></type> <name>MarkAnyDeclReferenced</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>MightBeOdrUse</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MarkFunctionReferenced</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Func</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>MightBeOdrUse</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MarkVariableReferenced</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Var</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MarkDeclRefReferenced</name><parameter_list>(<parameter><decl><type><name>DeclRefExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Base</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MarkMemberReferenced</name><parameter_list>(<parameter><decl><type><name>MemberExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MarkFunctionParmPackReferenced</name><parameter_list>(<parameter><decl><type><name>FunctionParmPackExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MarkCaptureUsedInEnclosingContext</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Capture</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>CapturingScopeIndex</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>CheckLValueToRValueConversionOperand</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CleanupVarDeclMarking</name><parameter_list>()</parameter_list>;</function_decl>

<enum>enum <name>TryCaptureKind</name> <block>{
<decl><name>TryCapture_Implicit</name></decl>, <decl><name>TryCapture_ExplicitByVal</name></decl>, <decl><name>TryCapture_ExplicitByRef</name></decl>
}</block>;</enum>


































<function_decl><type><name>bool</name></type> <name>tryCaptureVariable</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Var</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>TryCaptureKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>BuildAndDiagnose</name></decl></parameter>,
<parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>CaptureType</name></decl></parameter>,
<parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>DeclRefType</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <modifier>*</modifier><specifier>const</specifier></type> <name>FunctionScopeIndexToStopAt</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>tryCaptureVariable</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Var</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>TryCaptureKind</name></type> <name>Kind</name> <init>= <expr><name>TryCapture_Implicit</name></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>NeedToCaptureVariable</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Var</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>QualType</name></type> <name>getCapturedDeclRefType</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Var</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>MarkDeclarationsReferencedInType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MarkDeclarationsReferencedInExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>SkipLocalVariables</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>tryToRecoverWithCall</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>PD</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForceComplain</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>IsPlausibleResult</name>)<parameter_list>(<parameter><decl><type><name>QualType</name></type></decl></parameter>)</parameter_list> <init>= <expr><name>nullptr</name></expr></init></function_decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>tryExprAsCall</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>&amp;</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>ZeroArgCallReturnTy</name></decl></parameter>,
<parameter><decl><type><name>UnresolvedSetImpl</name> <modifier>&amp;</modifier></type><name>NonTemplateOverloads</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>tryConvertExprToType</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>bool</name></type> <name>DiagRuntimeBehavior</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>Statement</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>PD</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>DiagRuntimeBehavior</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Stmt</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Stmts</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>PD</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>SourceRange</name></type> <name>getExprRange</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><name>ExprResult</name></type> <name>ActOnIdExpression</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>HasTrailingLParen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsAddressOfOperand</name></decl></parameter>,
<parameter><decl><type><name>CorrectionCandidateCallback</name> <modifier>*</modifier></type><name>CCC</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsInlineAsmIdentifier</name> <init>= <expr><name>false</name></expr></init></decl></parameter>, <parameter><decl><type><name>Token</name> <modifier>*</modifier></type><name>KeywordReplacement</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DecomposeUnqualifiedId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Id</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>Buffer</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>DiagnoseDependentMemberLookup</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type>
<name>DiagnoseEmptyLookup</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><name>CorrectionCandidateCallback</name> <modifier>&amp;</modifier></type><name>CCC</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>ExplicitTemplateArgs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name> <init>= <expr><name>None</name></expr></init></decl></parameter>, <parameter><decl><type><name>TypoExpr</name> <modifier>*</modifier><modifier>*</modifier></type><name>Out</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclResult</name></type> <name>LookupIvarInObjCMethod</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Lookup</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildIvarRefExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>ObjCIvarDecl</name> <modifier>*</modifier></type><name>IV</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>LookupInObjCMethod</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>LookUp</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowBuiltinCreation</name><init>=<expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnDependentIdExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isAddressOfOperand</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>NonOdrUseReason</name></type> <name>getNonOdrUseReasonInCurrentContext</name><parameter_list>(<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclRefExpr</name> <modifier>*</modifier></type><name>BuildDeclRefExpr</name><parameter_list>(<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>, <parameter><decl><type><name>ExprValueKind</name></type> <name>VK</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>*</modifier></type><name>SS</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclRefExpr</name> <modifier>*</modifier></type>
<name>BuildDeclRefExpr</name><parameter_list>(<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>, <parameter><decl><type><name>ExprValueKind</name></type> <name>VK</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>*</modifier></type><name>SS</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FoundD</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclRefExpr</name> <modifier>*</modifier></type>
<name>BuildDeclRefExpr</name><parameter_list>(<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>, <parameter><decl><type><name>ExprValueKind</name></type> <name>VK</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>NNS</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FoundD</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type>
<name>BuildAnonymousStructUnionMemberReference</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>nameLoc</name></decl></parameter>,
<parameter><decl><type><name>IndirectFieldDecl</name> <modifier>*</modifier></type><name>indirectField</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name> <init>= <expr><name>DeclAccessPair</name><operator>::</operator><call><name>make</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>, <name>AS_none</name>)</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>baseObjectExpr</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>opLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildPossibleImplicitMemberExpr</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>, <parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>UnresolvedLookupExpr</name> <modifier>*</modifier></type><name>AsULE</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildImplicitMemberExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsDefiniteInstance</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>UseArgumentDependentLookup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HasTrailingLParen</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type>
<name>BuildQualifiedDeclarationNameExpr</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsAddressOfOperand</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>RecoveryTSI</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildDependentDeclRefExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildDeclarationNameExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>NeedsADL</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AcceptInvalidDecl</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildDeclarationNameExpr</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FoundD</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AcceptInvalidDecl</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildLiteralOperatorCall</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>SuffixInfo</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LitEndLoc</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>ExplicitTemplateArgs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>BuildPredefinedExpr</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>PredefinedExpr</name><operator>::</operator><name>IdentKind</name> <name>IK</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>ActOnPredefinedExpr</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>ExprResult</name></type> <name>ActOnIntegerConstant</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>Val</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildSYCLUniqueStableNameExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParen</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParen</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSI</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnSYCLUniqueStableNameExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParen</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParen</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ParsedTy</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckLoopHintExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnNumericConstant</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>UDLScope</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnCharacterConstant</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Tok</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>UDLScope</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnParenExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>R</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnParenListExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>R</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Val</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ActOnStringLiteral</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Token</name></expr></argument>&gt;</argument_list></name></type> <name>StringToks</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>UDLScope</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnGenericSelectionExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KeyLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>DefaultLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ControllingExpr</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParsedType</name></expr></argument>&gt;</argument_list></name></type> <name>ArgTypes</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>ArgExprs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>CreateGenericSelectionExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KeyLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>DefaultLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ControllingExpr</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Types</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Exprs</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>CreateBuiltinUnaryOp</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>, <parameter><decl><type><name>UnaryOperatorKind</name></type> <name>Opc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>InputExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildUnaryOp</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>UnaryOperatorKind</name></type> <name>Opc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Input</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>ActOnUnaryOp</name><argument_list>(<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Op</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>Input</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>bool</name></type> <name>isQualifiedMemberAccess</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckAddressOfOperand</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>Operand</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>CreateUnaryExprOrTypeTraitExpr</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>UnaryExprOrTypeTrait</name></type> <name>ExprKind</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>CreateUnaryExprOrTypeTraitExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>UnaryExprOrTypeTrait</name></type> <name>ExprKind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type>
<name>ActOnUnaryExprOrTypeTraitExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>UnaryExprOrTypeTrait</name></type> <name>ExprKind</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsType</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>TyOrEx</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>ArgRange</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>CheckPlaceholderExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckVecStepExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckUnaryExprOrTypeTraitOperand</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>UnaryExprOrTypeTrait</name></type> <name>ExprKind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckUnaryExprOrTypeTraitOperand</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ExprType</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>ExprRange</name></decl></parameter>,
<parameter><decl><type><name>UnaryExprOrTypeTrait</name></type> <name>ExprKind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnSizeofParameterPackExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>ActOnPostfixUnaryOp</name><argument_list>(<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>Input</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>ExprResult</name></type> <name>ActOnArraySubscriptExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Idx</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>CreateBuiltinArraySubscriptExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Idx</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>CreateBuiltinMatrixSubscriptExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RowIdx</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ColumnIdx</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnOMPArraySectionExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LBLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LowerBound</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLocFirst</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLocSecond</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Length</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Stride</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnOMPArrayShapingExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Dims</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceRange</name></expr></argument>&gt;</argument_list></name></type> <name>Brackets</name></decl></parameter>)</parameter_list>;</function_decl>


<struct>struct <name>OMPIteratorData</name> <block>{
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>DeclIdent</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>DeclIdentLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ParsedType</name></type> <name>Type</name></decl>;</decl_stmt>
<expr_stmt><expr><name>OMPIteratorExpr</name><operator>::</operator><name>IteratorRange</name> <name>Range</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>AssignLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>SecColonLoc</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><name>ExprResult</name></type> <name>ActOnOMPIteratorExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>IteratorKwLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPIteratorData</name></expr></argument>&gt;</argument_list></name></type> <name>Data</name></decl></parameter>)</parameter_list>;</function_decl>






<struct>struct <name>ActOnMemberAccessExtraArgs</name> <block>{
<decl_stmt><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ObjCImpDecl</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><name>ExprResult</name></type> <name>BuildMemberReferenceExpr</name><parameter_list>(
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsArrow</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>ActOnMemberAccessExtraArgs</name> <modifier>*</modifier></type><name>ExtraArgs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type>
<name>BuildMemberReferenceExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsArrow</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name></decl></parameter>, <parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>SuppressQualifierCheck</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>ActOnMemberAccessExtraArgs</name> <modifier>*</modifier></type><name>ExtraArgs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildFieldReferenceExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BaseExpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsArrow</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Field</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>MemberNameInfo</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>PerformMemberExprBaseConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsArrow</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckQualifiedMemberReference</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BaseExpr</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnDependentMemberExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsArrow</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FirstQualifierInScope</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>ActOnMemberAccessExpr</name><argument_list>(<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>Base</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>OpKind</name></expr></argument>,
<argument><expr><name>CXXScopeSpec</name> <operator>&amp;</operator><name>SS</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>TemplateKWLoc</name></expr></argument>,
<argument><expr><name>UnqualifiedId</name> <operator>&amp;</operator><name>Member</name></expr></argument>,
<argument><expr><name>Decl</name> <operator>*</operator><name>ObjCImpDecl</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>MemberExpr</name> <modifier>*</modifier></type>
<name>BuildMemberExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsArrow</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>*</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>, <parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HadMultipleCandidates</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>MemberNameInfo</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>,
<parameter><decl><type><name>ExprValueKind</name></type> <name>VK</name></decl></parameter>, <parameter><decl><type><name>ExprObjectKind</name></type> <name>OK</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>MemberExpr</name> <modifier>*</modifier></type>
<name>BuildMemberExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsArrow</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>NNS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>, <parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HadMultipleCandidates</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>MemberNameInfo</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>,
<parameter><decl><type><name>ExprValueKind</name></type> <name>VK</name></decl></parameter>, <parameter><decl><type><name>ExprObjectKind</name></type> <name>OK</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnDefaultCtorInitializers</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>CDtorDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>ConvertArgumentsForCall</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>Call</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Fn</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FDecl</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Proto</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ExecConfig</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckStaticArrayArgument</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CallLoc</name></decl></parameter>,
<parameter><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>ArgExpr</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>ActOnCallExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Fn</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>ArgExprs</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ExecConfig</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildCallExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Fn</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>ArgExprs</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ExecConfig</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsExecConfig</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowRecovery</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BuildBuiltinCallExpr</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>Builtin</name><operator>::</operator><name>ID</name> <name>Id</name></expr></argument>,
<argument><expr><name>MultiExprArg</name> <name>CallArgs</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>AtomicArgumentOrder</name> <block>{<block_content> <expr_stmt><expr><name>API</name></expr><operator>,</operator> <expr><name>AST</name></expr></expr_stmt> </block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type>
<name>BuildAtomicExpr</name><argument_list>(<argument><expr><name>SourceRange</name> <name>CallRange</name></expr></argument>, <argument><expr><name>SourceRange</name> <name>ExprRange</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>RParenLoc</name></expr></argument>, <argument><expr><name>MultiExprArg</name> <name>Args</name></expr></argument>,
<argument><expr><name>AtomicExpr</name><operator>::</operator><name>AtomicOp</name> <name>Op</name></expr></argument>,
<argument><expr><name>AtomicArgumentOrder</name> <name>ArgOrder</name> <operator>=</operator> <name>AtomicArgumentOrder</name><operator>::</operator><name>API</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>ExprResult</name></type>
<name>BuildResolvedCallExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Fn</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>NDecl</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Arg</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Config</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsExecConfig</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>ADLCallKind</name></type> <name>UsesADL</name> <init>= <expr><name>ADLCallKind</name><operator>::</operator><name>NotADL</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnCUDAExecConfigExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LLLLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>ExecConfig</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>GGGLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnCastExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>ParsedType</name> <modifier>&amp;</modifier></type><name>Ty</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CastExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildCStyleCastExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>Ty</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Op</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CastKind</name></type> <name>PrepareScalarCast</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>destType</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>BuildVectorLiteral</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>MaybeConvertParenListExprToParenExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ME</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnCompoundLiteral</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>Ty</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>InitExpr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildCompoundLiteralExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LiteralExpr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnInitList</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LBraceLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>InitArgList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBraceLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildInitList</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LBraceLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>InitArgList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBraceLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnDesignatedInitializer</name><parameter_list>(<parameter><decl><type><name>Designation</name> <modifier>&amp;</modifier></type><name>Desig</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EqualOrColonLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>GNUSyntax</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name></type> <name>Init</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<decl_stmt><decl><type><specifier>static</specifier> <name>BinaryOperatorKind</name></type> <name>ConvertTokenKindToBinaryOpcode</name><argument_list>(<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>ActOnBinOp</name><argument_list>(<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>TokLoc</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>LHSExpr</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>RHSExpr</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>ExprResult</name></type> <name>BuildBinOp</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHSExpr</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHSExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>CreateBuiltinBinOp</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>, <parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHSExpr</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHSExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>LookupBinOp</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>, <parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name></decl></parameter>,
<parameter><decl><type><name>UnresolvedSetImpl</name> <modifier>&amp;</modifier></type><name>Functions</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseCommaOperator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ActOnConditionalOp</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>QuestionLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CondExpr</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHSExpr</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHSExpr</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ActOnAddrLabel</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LabLoc</name></decl></parameter>,
<parameter><decl><type><name>LabelDecl</name> <modifier>*</modifier></type><name>TheDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnStartStmtExpr</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnStmtExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LPLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RPLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildStmtExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LPLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RPLoc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>TemplateDepth</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnStmtExprResult</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnStmtExprError</name><parameter_list>()</parameter_list>;</function_decl>


<struct>struct <name>OffsetOfComponent</name> <block>{
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>LocStart</name></decl>, <decl><type ref="prev"/><name>LocEnd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>isBrackets</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>IdentInfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl>;</decl_stmt>
}</block> <decl><name>U</name></decl>;</union>
}</block>;</struct>


<function_decl><type><name>ExprResult</name></type> <name>BuildBuiltinOffsetOf</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>BuiltinLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OffsetOfComponent</name></expr></argument>&gt;</argument_list></name></type> <name>Components</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnBuiltinOffsetOf</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>BuiltinLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ParsedArgTy</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OffsetOfComponent</name></expr></argument>&gt;</argument_list></name></type> <name>Components</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ActOnChooseExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>BuiltinLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CondExpr</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHSExpr</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHSExpr</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RPLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ActOnVAArg</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>BuiltinLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>ParsedType</name></type> <name>Ty</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RPLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildVAArgExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>BuiltinLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RPLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>ExprResult</name></type> <name>ActOnSourceLocExpr</name><argument_list>(<argument><expr><name>SourceLocExpr</name><operator>::</operator><name>IdentKind</name> <name>Kind</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>BuiltinLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>RPLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ExprResult</name></type> <name>BuildSourceLocExpr</name><argument_list>(<argument><expr><name>SourceLocExpr</name><operator>::</operator><name>IdentKind</name> <name>Kind</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>BuiltinLoc</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>RPLoc</name></expr></argument>,
<argument><expr><name>DeclContext</name> <operator>*</operator><name>ParentContext</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>ExprResult</name></type> <name>ActOnGNUNullExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>TokenLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckCaseExpression</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>IfExistsResult</name> <block>{

<decl><name>IER_Exists</name></decl>,


<decl><name>IER_DoesNotExist</name></decl>,



<decl><name>IER_Dependent</name></decl>,


<decl><name>IER_Error</name></decl>
}</block>;</enum>

<function_decl><type><name>IfExistsResult</name></type>
<name>CheckMicrosoftIfExistsSymbol</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>TargetNameInfo</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>IfExistsResult</name></type>
<name>CheckMicrosoftIfExistsSymbol</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KeywordLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsIfExists</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>BuildMSDependentExistsStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KeywordLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsIfExists</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Nested</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnMSDependentExistsStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KeywordLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsIfExists</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Nested</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>ActOnBlockStart</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CaretLoc</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ActOnBlockArguments</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CaretLoc</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>ParamInfo</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ActOnBlockError</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CaretLoc</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ActOnBlockStmtExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CaretLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>ActOnConvertVectorExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>ParsedType</name></type> <name>ParsedDestTy</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>BuiltinLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>ActOnAsTypeExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>ParsedType</name></type> <name>ParsedDestTy</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>BuiltinLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildAsTypeExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>DestTy</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>BuiltinLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnStartNamespaceDef</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>InlineLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NamespaceLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdentLoc</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBrace</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>,
<parameter><decl><type><name>UsingDirectiveDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>UsingDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnFinishNamespaceDef</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Dcl</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RBrace</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>NamespaceDecl</name> <operator>*</operator><macro><name>getStdNamespace</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<function_decl><type><name>NamespaceDecl</name> <modifier>*</modifier></type><name>getOrCreateStdNamespace</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>NamespaceDecl</name> <modifier>*</modifier></type><name>lookupStdExperimentalNamespace</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><name>CXXRecordDecl</name> <operator>*</operator><macro><name>getStdBadAlloc</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>EnumDecl</name> <operator>*</operator><macro><name>getStdAlignValT</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<label><name>private</name>:</label>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name>SmallBitVector</name> <name>FullyCheckedComparisonCategories</name></expr>;</expr_stmt>

<function_decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>tryLookupCtorInitMemberDecl</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>TemplateTypeTy</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>MemberOrBase</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>ComparisonCategoryUsage</name> <block>{<block_content>


<expr_stmt><expr><name>OperatorInExpression</name></expr><operator>,</operator>



<expr><name>DefaultedOperator</name></expr><operator>,</operator></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>







<function_decl><type><name>QualType</name></type> <name>CheckComparisonCategoryType</name><parameter_list>(<parameter><decl><type><name>ComparisonCategoryType</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>ComparisonCategoryUsage</name></type> <name>Usage</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>isStdInitializerList</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>, <parameter><decl><type><name>QualType</name> <modifier>*</modifier></type><name>Element</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>QualType</name></type> <name>BuildStdInitializerList</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Element</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>isInitListConstructor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Ctor</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnUsingDirective</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>UsingLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NamespcLoc</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdentLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>NamespcName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>PushUsingDirective</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>UsingDirectiveDecl</name> <modifier>*</modifier></type><name>UDir</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnNamespaceAliasDef</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NamespaceLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AliasLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Alias</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdentLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>FilterUsingLookup</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>lookup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>HideUsingShadowDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>UsingShadowDecl</name> <modifier>*</modifier></type><name>Shadow</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckUsingShadowDecl</name><parameter_list>(<parameter><decl><type><name>BaseUsingDecl</name> <modifier>*</modifier></type><name>BUD</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Target</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LookupResult</name> <modifier>&amp;</modifier></type><name>PreviousDecls</name></decl></parameter>,
<parameter><decl><type><name>UsingShadowDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>PrevShadow</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>UsingShadowDecl</name> <modifier>*</modifier></type><name>BuildUsingShadowDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>BaseUsingDecl</name> <modifier>*</modifier></type><name>BUD</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Target</name></decl></parameter>,
<parameter><decl><type><name>UsingShadowDecl</name> <modifier>*</modifier></type><name>PrevDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckUsingDeclRedeclaration</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>UsingLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HasTypenameKeyword</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckUsingDeclQualifier</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>UsingLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>HasTypename</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LookupResult</name> <modifier>*</modifier></type><name>R</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UsingDecl</name> <modifier>*</modifier></type><name>UD</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>BuildUsingDeclaration</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>UsingLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HasTypenameKeyword</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TypenameLoc</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsInstantiation</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsUsingIfExists</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>BuildUsingEnumDeclaration</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>UsingLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EnumLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>, <parameter><decl><type><name>EnumDecl</name> <modifier>*</modifier></type><name>ED</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>BuildUsingPackDecl</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>InstantiatedFrom</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Expansions</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckInheritingConstructorUsingDecl</name><parameter_list>(<parameter><decl><type><name>UsingDecl</name> <modifier>*</modifier></type><name>UD</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type>
<name>findInheritingConstructor</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>BaseCtor</name></decl></parameter>,
<parameter><decl><type><name>ConstructorUsingShadowDecl</name> <modifier>*</modifier></type><name>DerivedShadow</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnUsingDeclaration</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>UsingLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypenameLoc</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnUsingEnumDeclaration</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>UsingLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EnumLoc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnAliasDeclaration</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParams</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>UsingLoc</name></decl></parameter>, <parameter><decl><type><name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>,
<parameter><decl><type><name>TypeResult</name></type> <name>Type</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>DeclFromDeclSpec</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>ExprResult</name></type>
<name>BuildCXXConstructExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ConstructLoc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>DeclInitType</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>, <parameter><decl><type><name>MultiExprArg</name></type> <name>Exprs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HadMultipleCandidates</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsListInitialization</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsStdInitListInitialization</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RequiresZeroInit</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ConstructKind</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>ParenRange</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type>
<name>BuildCXXConstructExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ConstructLoc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>DeclInitType</name></decl></parameter>,
<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Elidable</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Exprs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HadMultipleCandidates</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsListInitialization</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsStdInitListInitialization</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RequiresZeroInit</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ConstructKind</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>ParenRange</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type>
<name>BuildCXXConstructExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ConstructLoc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>DeclInitType</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Elidable</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Exprs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>HadMultipleCandidates</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsListInitialization</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsStdInitListInitialization</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>RequiresZeroInit</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>ConstructKind</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>ParenRange</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildCXXDefaultInitExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Field</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>CheckCXXDefaultArgExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CallLoc</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>BuildCXXDefaultArgExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CallLoc</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>FinalizeVarWithDestructor</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecordType</name> <modifier>*</modifier></type><name>DeclInitType</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>class</name></type> <name>ImplicitExceptionSpecification</name> <block>{<block_content>

<decl_stmt><decl><type><name>Sema</name> <modifier>*</modifier></type><name>Self</name></decl>;</decl_stmt>






<decl_stmt><decl><type><name>ExceptionSpecificationType</name></type> <name>ComputedEST</name></decl>;</decl_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSet</name><argument_list type="generic">&lt;<argument><expr><name>CanQualType</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name> <name>ExceptionsSeen</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>Exceptions</name></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>ClearExceptions</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>ExceptionsSeen</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Exceptions</name><operator>.</operator><name>clear</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>ImplicitExceptionSpecification</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>Self</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>Self</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Self</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>ComputedEST</name><argument_list>(<argument>EST_BasicNoexcept</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>Self</name><operator>.</operator><name>getLangOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus11</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>ComputedEST</name> <operator>=</operator> <name>EST_DynamicNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>ExceptionSpecificationType</name> <macro><name>getExceptionSpecType</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>isComputedNoexcept</name><argument_list>(<argument><expr><name>ComputedEST</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"noexcept(expr) should not be a possible result"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>ComputedEST</name></expr>;</return>
}</block></expr></expr_stmt>


<expr_stmt><expr><name>unsigned</name> <macro><name>size</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Exceptions</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><specifier>const</specifier> <name>QualType</name> <operator>*</operator><macro><name>data</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name><name>Exceptions</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<function_decl><type><name>void</name></type> <name>CalledDecl</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CallLoc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>void</name></type> <name>CalledExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list> <block>{<block_content> <expr_stmt><expr><call><name>CalledStmt</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> </block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>CalledStmt</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>FunctionProtoType</name><operator>::</operator><name>ExceptionSpecInfo</name> <macro><name>getExceptionSpec</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><name>FunctionProtoType</name><operator>::</operator><name>ExceptionSpecInfo</name> <name>ESI</name></expr>;
<expr><name><name>ESI</name><operator>.</operator><name>Type</name></name> <operator>=</operator> <call><name>getExceptionSpecType</name><argument_list>()</argument_list></call></expr>;
<if_stmt><if>if <condition>(<expr><name><name>ESI</name><operator>.</operator><name>Type</name></name> <operator>==</operator> <name>EST_Dynamic</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ESI</name><operator>.</operator><name>Exceptions</name></name> <operator>=</operator> <name>Exceptions</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content> else if (ESI.Type == EST_None</block></if></if_stmt>) <block>{



<expr><name><name>ESI</name><operator>.</operator><name>Type</name></name> <operator>=</operator> <name>EST_NoexceptFalse</name></expr>;
<expr><name><name>ESI</name><operator>.</operator><name>NoexceptExpr</name></name> <operator>=</operator> <call><name><name>Self</name><operator>-&gt;</operator><name>ActOnCXXBoolLiteral</name></name><argument_list>(<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>kw_false</name></expr></argument>)</argument_list></call><operator>.</operator><call><name>get</name><argument_list>()</argument_list></call></expr>;
}</block></block></expr></expr_stmt>
<return>return <expr><name>ESI</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
};



<function_decl><type><name>void</name></type> <name>EvaluateImplicitExceptionSpec</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ActOnNoexceptSpec</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>NoexceptLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NoexceptExpr</name></decl></parameter>,
<parameter><decl><type><name>ExceptionSpecificationType</name> <modifier>&amp;</modifier></type><name>EST</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>checkExceptionSpecification</name><argument_list>(<argument><expr><name>bool</name> <name>IsTopLevel</name></expr></argument>,
<argument><expr><name>ExceptionSpecificationType</name> <name>EST</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParsedType</name></expr></argument>&gt;</argument_list></name> <name>DynamicExceptions</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceRange</name></expr></argument>&gt;</argument_list></name> <name>DynamicExceptionRanges</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>NoexceptExpr</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Exceptions</name></expr></argument>,
<argument><expr><name>FunctionProtoType</name><operator>::</operator><name>ExceptionSpecInfo</name> <operator>&amp;</operator><name>ESI</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>bool</name></type> <name>isLibstdcxxEagerExceptionSpecHack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>actOnDelayedExceptionSpecification</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><name>ExceptionSpecificationType</name></type> <name>EST</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>SpecificationRange</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParsedType</name></expr></argument>&gt;</argument_list></name></type> <name>DynamicExceptions</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceRange</name></expr></argument>&gt;</argument_list></name></type> <name>DynamicExceptionRanges</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NoexceptExpr</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>class</name></type> <name>InheritedConstructorInfo</name></decl>;</decl_stmt>



<function_decl><type><name>bool</name></type> <name>ShouldDeleteSpecialMember</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>, <parameter><decl><type><name>CXXSpecialMember</name></type> <name>CSM</name></decl></parameter>,
<parameter><decl><type><name>InheritedConstructorInfo</name> <modifier>*</modifier></type><name>ICI</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>DiagnoseDeletedDefaultedFunction</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>DeclareImplicitDefaultConstructor</name><parameter_list>(
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DefineImplicitDefaultConstructor</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CurrentLocation</name></decl></parameter>,
<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>DeclareImplicitDestructor</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DefineImplicitDestructor</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CurrentLocation</name></decl></parameter>,
<parameter><decl><type><name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>Destructor</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>AdjustDestructorExceptionSpec</name><parameter_list>(<parameter><decl><type><name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>Destructor</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>DefineInheritingConstructor</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>UseLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>DeclareImplicitCopyConstructor</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DefineImplicitCopyConstructor</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CurrentLocation</name></decl></parameter>,
<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>DeclareImplicitMoveConstructor</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DefineImplicitMoveConstructor</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CurrentLocation</name></decl></parameter>,
<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>DeclareImplicitCopyAssignment</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>DefineImplicitCopyAssignment</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CurrentLocation</name></decl></parameter>,
<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MethodDecl</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>DeclareImplicitMoveAssignment</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>DefineImplicitMoveAssignment</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CurrentLocation</name></decl></parameter>,
<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MethodDecl</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ForceDeclarationOfImplicitMembers</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>CheckImplicitSpecialMemberDeclaration</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>isImplicitlyDeleted</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>checkThisInStaticMemberFunctionType</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>checkThisInStaticMemberFunctionExceptionSpec</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>checkThisInStaticMemberFunctionAttributes</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>MaybeBindToTemporary</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>CheckForImmediateInvocation</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>E</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CompleteConstructorCall</name><parameter_list>(<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>DeclInitType</name></decl></parameter>, <parameter><decl><type><name>MultiExprArg</name></type> <name>ArgsPtr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>ConvertedArgs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowExplicit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsListInitialization</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ParsedType</name></type> <name>getInheritingConstructorName</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ParsedType</name></type> <name>getConstructorName</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ParsedType</name></type> <name>getDestructorName</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>TildeLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ObjectType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ParsedType</name></type> <name>getDestructorTypeForDecltype</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ObjectType</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>CheckCompatibleReinterpretCast</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>SrcType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>DestType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsDereference</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>ShouldSplatAltivecScalarInCast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VectorType</name> <modifier>*</modifier></type><name>VecTy</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>ExprResult</name></type> <name>ActOnCXXNamedCast</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>LAngleBracketLoc</name></expr></argument>,
<argument><expr><name>Declarator</name> <operator>&amp;</operator><name>D</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>RAngleBracketLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>LParenLoc</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>RParenLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>BuildCXXNamedCast</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name></expr></argument>,
<argument><expr><name>TypeSourceInfo</name> <operator>*</operator><name>Ty</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>SourceRange</name> <name>AngleBrackets</name></expr></argument>,
<argument><expr><name>SourceRange</name> <name>Parens</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>ExprResult</name></type> <name>ActOnBuiltinBitCastExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>Dcl</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name></type> <name>Operand</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildBuiltinBitCastExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSI</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildCXXTypeId</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>TypeInfoType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeidLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildCXXTypeId</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>TypeInfoType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeidLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ActOnCXXTypeid</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isType</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>TyOrExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildCXXUuidof</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>TypeInfoType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeidLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildCXXUuidof</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>TypeInfoType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeidLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ActOnCXXUuidof</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isType</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>TyOrExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>ExprResult</name></type> <name>ActOnCXXFoldExpr</name><argument_list>(<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>LParenLoc</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>LHS</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Operator</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>EllipsisLoc</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>RHS</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>RParenLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>ExprResult</name></type> <name>BuildCXXFoldExpr</name><parameter_list>(<parameter><decl><type><name>UnresolvedLookupExpr</name> <modifier>*</modifier></type><name>Callee</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Operator</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildEmptyCXXFoldExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Operator</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ActOnCXXThis</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>loc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>Expr</name> <modifier>*</modifier></type><name>BuildCXXThisExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsImplicit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MarkThisReferenced</name><parameter_list>(<parameter><decl><type><name>CXXThisExpr</name> <modifier>*</modifier></type><name>This</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>QualType</name></type> <name>getCurrentThisType</name><parameter_list>()</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>QualType</name></type> <name>CXXThisTypeOverride</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>class</name></type> <name>CXXThisScopeRAII</name> <block>{<block_content>
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>OldCXXThisTypeOverride</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Enabled</name></decl>;</decl_stmt>

<label><name>public</name>:</label>




<macro><name>CXXThisScopeRAII</name><argument_list>(<argument>Sema &amp;S</argument>, <argument>Decl *ContextDecl</argument>, <argument>Qualifiers CXXThisTypeQuals</argument>,
<argument>bool Enabled = true</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><operator>~</operator><call><name>CXXThisScopeRAII</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
















<function_decl><type><name>bool</name></type> <name>CheckCXXThisCapture</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Explicit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>BuildAndDiagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <modifier>*</modifier><specifier>const</specifier></type> <name>FunctionScopeIndexToStopAt</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ByCopy</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>isThisOutsideMemberFunctionBody</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>ExprResult</name></type> <name>ActOnCXXBoolLiteral</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>ExprResult</name></type> <name>ActOnObjCBoolLiteral</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>Kind</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type>
<name>ActOnObjCAvailabilityCheckExpr</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>AvailabilitySpec</name></expr></argument>&gt;</argument_list></name> <name>AvailSpecs</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>AtLoc</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>RParen</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>ExprResult</name></type> <name>ActOnCXXNullPtrLiteral</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ActOnCXXThrow</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildCXXThrow</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Ex</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsThrownVarInScope</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckCXXThrowOperand</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ThrowLoc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ThrowTy</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>ExprResult</name></type> <name>ActOnCXXTypeConstructExpr</name><parameter_list>(<parameter><decl><type><name>ParsedType</name></type> <name>TypeRep</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenOrBraceLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Exprs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenOrBraceLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ListInitialization</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildCXXTypeConstructExpr</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>Type</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Exprs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ListInitialization</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ActOnCXXNew</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>UseGlobal</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PlacementLParen</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>PlacementArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PlacementRParen</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>TypeIdParens</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Initializer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildCXXNew</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>UseGlobal</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PlacementLParen</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>PlacementArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PlacementRParen</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>TypeIdParens</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>AllocType</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>AllocTypeInfo</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>ArraySize</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>DirectInitRange</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Initializer</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>bool</name></type> <name>isUnavailableAlignedAllocationFunction</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FunctionDecl</name> <operator>&amp;</operator><name>FD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>diagnoseUnavailableAlignedAllocation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>&amp;</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckAllocatedType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>AllocType</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>AllocationFunctionScope</name> <block>{

<decl><name>AFS_Global</name></decl>,


<decl><name>AFS_Class</name></decl>,


<decl><name>AFS_Both</name></decl>
}</block>;</enum>



<function_decl><type><name>bool</name></type> <name>FindAllocationFunctions</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>,
<parameter><decl><type><name>AllocationFunctionScope</name></type> <name>NewScope</name></decl></parameter>,
<parameter><decl><type><name>AllocationFunctionScope</name></type> <name>DeleteScope</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>AllocType</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsArray</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>PassAlignment</name></decl></parameter>, <parameter><decl><type><name>MultiExprArg</name></type> <name>PlaceArgs</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>OperatorNew</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>OperatorDelete</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DeclareGlobalNewDelete</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DeclareGlobalAllocationFunction</name><parameter_list>(<parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Return</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name></type> <name>Params</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>FindDeallocationFunction</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>,
<parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name><modifier>*</modifier> <modifier>&amp;</modifier></type><name>Operator</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FindUsualDeallocationFunction</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>CanProvideSize</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Overaligned</name></decl></parameter>,
<parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FindDeallocationFunctionForDestructor</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ActOnCXXDelete</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>UseGlobal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ArrayForm</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckVirtualDtorCall</name><parameter_list>(<parameter><decl><type><name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>dtor</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsDelete</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>CallCanBeVirtual</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>WarnOnNonAbstractTypes</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>DtorLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnNoexceptExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KeyLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParen</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RParen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildCXXNoexceptExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KeyLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Operand</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParen</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ActOnTypeTrait</name><parameter_list>(<parameter><decl><type><name>TypeTrait</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParsedType</name></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildTypeTrait</name><parameter_list>(<parameter><decl><type><name>TypeTrait</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ActOnArrayTypeTrait</name><parameter_list>(<parameter><decl><type><name>ArrayTypeTrait</name></type> <name>ATT</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>LhsTy</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>DimExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParen</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildArrayTypeTrait</name><parameter_list>(<parameter><decl><type><name>ArrayTypeTrait</name></type> <name>ATT</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSInfo</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>DimExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParen</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ActOnExpressionTrait</name><parameter_list>(<parameter><decl><type><name>ExpressionTrait</name></type> <name>OET</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Queried</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParen</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildExpressionTrait</name><parameter_list>(<parameter><decl><type><name>ExpressionTrait</name></type> <name>OET</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Queried</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParen</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>ActOnStartCXXMemberReference</name><argument_list>(<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>Base</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>OpKind</name></expr></argument>,
<argument><expr><name>ParsedType</name> <operator>&amp;</operator><name>ObjectType</name></expr></argument>,
<argument><expr><name>bool</name> <operator>&amp;</operator><name>MayBePseudoDestructor</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>BuildPseudoDestructorExpr</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>Base</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>OpKind</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>CXXScopeSpec</name> <operator>&amp;</operator><name>SS</name></expr></argument>,
<argument><expr><name>TypeSourceInfo</name> <operator>*</operator><name>ScopeType</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>CCLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>TildeLoc</name></expr></argument>,
<argument><expr><name>PseudoDestructorTypeStorage</name> <name>DestroyedType</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>ActOnPseudoDestructorExpr</name><argument_list>(<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>Base</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>OpKind</name></expr></argument>,
<argument><expr><name>CXXScopeSpec</name> <operator>&amp;</operator><name>SS</name></expr></argument>,
<argument><expr><name>UnqualifiedId</name> <operator>&amp;</operator><name>FirstTypeName</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>CCLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>TildeLoc</name></expr></argument>,
<argument><expr><name>UnqualifiedId</name> <operator>&amp;</operator><name>SecondTypeName</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ExprResult</name></type> <name>ActOnPseudoDestructorExpr</name><argument_list>(<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator><name>Base</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>OpLoc</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>OpKind</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>TildeLoc</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>DeclSpec</name><operator>&amp;</operator> <name>DS</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function_decl><type><name>Expr</name> <modifier>*</modifier></type><name>MaybeCreateExprWithCleanups</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Stmt</name> <modifier>*</modifier></type><name>MaybeCreateStmtWithCleanups</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>SubStmt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>MaybeCreateExprWithCleanups</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>SubExpr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>MaterializeTemporaryExpr</name> <modifier>*</modifier></type>
<name>CreateMaterializeTemporaryExpr</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Temporary</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>BoundToLvalueReference</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>ExprResult</name></type> <name>ActOnFinishFullExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Expr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>DiscardedValue</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>ActOnFinishFullExpr</name><argument_list>(
<argument><expr><name>Expr</name></expr></argument>, <argument><expr><ternary><condition><expr><name>Expr</name></expr> ?</condition><then> <expr><call><name><name>Expr</name><operator>-&gt;</operator><name>getExprLoc</name></name><argument_list>()</argument_list></call></expr> </then><else>: <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>, <argument><expr><name>DiscardedValue</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function_decl><type><name>ExprResult</name></type> <name>ActOnFinishFullExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Expr</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>CC</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DiscardedValue</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsConstexpr</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnFinishFullStmt</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Stmt</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>RequireCompleteDeclContext</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>RequireCompleteEnumDecl</name><parameter_list>(<parameter><decl><type><name>EnumDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>L</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>*</modifier></type><name>SS</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>computeDeclContext</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>computeDeclContext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isDependentScopeSpecifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>getCurrentInstantiationOf</name><parameter_list>(<parameter><decl><type><name>NestedNameSpecifier</name> <modifier>*</modifier></type><name>NNS</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>bool</name></type> <name>ActOnCXXGlobalScopeSpecifier</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CCLoc</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>











<function_decl><type><name>bool</name></type> <name>ActOnSuperScopeSpecifier</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonColonLoc</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>isAcceptableNestedNameSpecifier</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>SD</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>CanCorrect</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FindFirstQualifierInScope</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>NestedNameSpecifier</name> <modifier>*</modifier></type><name>NNS</name></decl></parameter>)</parameter_list>;</function_decl>



<struct>struct <name>NestedNameSpecInfo</name> <block>{


<decl_stmt><decl><type><name>ParsedType</name></type> <name>ObjectType</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Identifier</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>IdentifierLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>CCLoc</name></decl>;</decl_stmt>


<macro><name>NestedNameSpecInfo</name><argument_list>(<argument>IdentifierInfo *II</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>SourceLocation ColonColonLoc</argument>, <argument>ParsedType ObjectType = ParsedType()</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>ObjectType</name><argument_list>(<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Identifier</name><argument_list>(<argument><expr><name>II</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>IdentifierLoc</name><argument_list>(<argument><expr><name>IdLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>CCLoc</name><argument_list>(<argument>ColonColonLoc</argument>)</argument_list></macro> <expr><block>{
}</block>

<macro><name>NestedNameSpecInfo</name><argument_list>(<argument>IdentifierInfo *II</argument>, <argument>SourceLocation IdLoc</argument>,
<argument>SourceLocation ColonColonLoc</argument>, <argument>QualType ObjectType</argument>)</argument_list></macro>
<operator>:</operator> <call><name>ObjectType</name><argument_list>(<argument><expr><name>ParsedType</name><operator>::</operator><call><name>make</name><argument_list>(<argument><expr><name>ObjectType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Identifier</name><argument_list>(<argument><expr><name>II</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>IdentifierLoc</name><argument_list>(<argument><expr><name>IdLoc</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>CCLoc</name><argument_list>(<argument>ColonColonLoc</argument>)</argument_list></macro> <expr><block>{
}</block></expr></expr_stmt>
}</block>;</struct>

<function_decl><type><name>bool</name></type> <name>isNonTypeNestedNameSpecifier</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecInfo</name> <modifier>&amp;</modifier></type><name>IdInfo</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>BuildCXXNestedNameSpecifier</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecInfo</name> <modifier>&amp;</modifier></type><name>IdInfo</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ScopeLookupResult</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ErrorRecoveryLookup</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>IsCorrectedToColon</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>OnlyNamespace</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


























<function_decl><type><name>bool</name></type> <name>ActOnCXXNestedNameSpecifier</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecInfo</name> <modifier>&amp;</modifier></type><name>IdInfo</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ErrorRecoveryLookup</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>IsCorrectedToColon</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>OnlyNamespace</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnDecltypeExpression</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>ActOnCXXNestedNameSpecifierDecltype</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonColonLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>IsInvalidUnlessNestedName</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecInfo</name> <modifier>&amp;</modifier></type><name>IdInfo</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>)</parameter_list>;</function_decl>
























<function_decl><type><name>bool</name></type> <name>ActOnCXXNestedNameSpecifier</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>TemplateTy</name></type> <name>TemplateName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateNameLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>ASTTemplateArgsPtr</name></type> <name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CCLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>void</name> <modifier>*</modifier></type><name>SaveNestedNameSpecifierAnnotation</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>











<function_decl><type><name>void</name></type> <name>RestoreNestedNameSpecifierAnnotation</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>Annotation</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>AnnotationRange</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>ShouldEnterDeclaratorScope</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>bool</name></type> <name>ActOnCXXEnterDeclaratorScope</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>ActOnCXXExitDeclaratorScope</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>ActOnCXXEnterDeclInitializer</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Dcl</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ActOnCXXExitDeclInitializer</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Dcl</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>createLambdaClosureType</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>IntroducerRange</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>Info</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>KnownDependent</name></decl></parameter>,
<parameter><decl><type><name>LambdaCaptureDefault</name></type> <name>CaptureDefault</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>startLambdaDefinition</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>IntroducerRange</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>MethodType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Params</name></decl></parameter>,
<parameter><decl><type><name>ConstexprSpecKind</name></type> <name>ConstexprKind</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>TrailingRequiresClause</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>handleLambdaNumbering</name><parameter_list>(
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>, <parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>tuple</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>Mangling</name> <init>= <expr><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>buildLambdaScope</name><argument_list>(<argument><expr><name>sema</name><operator>::</operator><name>LambdaScopeInfo</name> <operator>*</operator><name>LSI</name></expr></argument>,
<argument><expr><name>CXXMethodDecl</name> <operator>*</operator><name>CallOperator</name></expr></argument>,
<argument><expr><name>SourceRange</name> <name>IntroducerRange</name></expr></argument>,
<argument><expr><name>LambdaCaptureDefault</name> <name>CaptureDefault</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>CaptureDefaultLoc</name></expr></argument>,
<argument><expr><name>bool</name> <name>ExplicitParams</name></expr></argument>,
<argument><expr><name>bool</name> <name>ExplicitResultType</name></expr></argument>,
<argument><expr><name>bool</name> <name>Mutable</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function><type><name>ParsedType</name></type> <name>actOnLambdaInitCaptureInitialization</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ByRef</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>, <parameter><decl><type><name>LambdaCaptureInitKind</name></type> <name>InitKind</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>Init</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>ParsedType</name><operator>::</operator><call><name>make</name><argument_list>(<argument><expr><call><name>buildLambdaInitCaptureInitialization</name><argument_list>(
<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>ByRef</name></expr></argument>, <argument><expr><name>EllipsisLoc</name></expr></argument>, <argument><expr><name>None</name></expr></argument>, <argument><expr><name>Id</name></expr></argument>,
<argument><expr><name>InitKind</name> <operator>!=</operator> <name>LambdaCaptureInitKind</name><operator>::</operator><name>CopyInit</name></expr></argument>, <argument><expr><name>Init</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<function_decl><type><name>QualType</name></type> <name>buildLambdaInitCaptureInitialization</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ByRef</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>DirectInit</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>createLambdaInitCaptureVarDecl</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>InitCaptureType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Id</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>InitStyle</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>addInitCapture</name><argument_list>(<argument><expr><name>sema</name><operator>::</operator><name>LambdaScopeInfo</name> <operator>*</operator><name>LSI</name></expr></argument>, <argument><expr><name>VarDecl</name> <operator>*</operator><name>Var</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>void</name></type> <name>finishLambdaExplicitCaptures</name><argument_list>(<argument><expr><name>sema</name><operator>::</operator><name>LambdaScopeInfo</name> <operator>*</operator><name>LSI</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>ActOnLambdaExplicitTemplateParameterList</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>TParams</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name></type> <name>RequiresClause</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>addLambdaParameters</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>LambdaIntroducer</name><operator>::</operator><name>LambdaCapture</name></expr></argument>&gt;</argument_list></name></type> <name>Captures</name></decl></parameter>,
<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>CallOperator</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>deduceClosureReturnType</name><argument_list>(<argument><expr><name>sema</name><operator>::</operator><name>CapturingScopeInfo</name> <operator>&amp;</operator><name>CSI</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<function_decl><type><name>void</name></type> <name>ActOnStartOfLambdaDefinition</name><parameter_list>(<parameter><decl><type><name>LambdaIntroducer</name> <modifier>&amp;</modifier></type><name>Intro</name></decl></parameter>,
<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>ParamInfo</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ActOnLambdaError</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsInstantiation</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>ActOnLambdaExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>bool</name></type> <name>CaptureHasSideEffects</name><argument_list>(<argument><expr><specifier>const</specifier> <name>sema</name><operator>::</operator><name>Capture</name> <operator>&amp;</operator><name>From</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>DiagnoseUnusedLambdaCapture</name><argument_list>(<argument><expr><name>SourceRange</name> <name>CaptureRange</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>sema</name><operator>::</operator><name>Capture</name> <operator>&amp;</operator><name>From</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>BuildCaptureField</name><argument_list>(<argument><expr><name>RecordDecl</name> <operator>*</operator><name>RD</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>sema</name><operator>::</operator><name>Capture</name> <operator>&amp;</operator><name>Capture</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ExprResult</name></type> <name>BuildCaptureInit</name><argument_list>(<argument><expr><specifier>const</specifier> <name>sema</name><operator>::</operator><name>Capture</name> <operator>&amp;</operator><name>Capture</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>ImplicitCaptureLoc</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsOpenMPMapping</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>ExprResult</name></type> <name>BuildLambdaExpr</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>StartLoc</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>EndLoc</name></expr></argument>,
<argument><expr><name>sema</name><operator>::</operator><name>LambdaScopeInfo</name> <operator>*</operator><name>LSI</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>QualType</name></type>
<name>getLambdaConversionFunctionResultType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>CallOpType</name></decl></parameter>,
<parameter><decl><type><name>CallingConv</name></type> <name>CC</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>void</name></type> <name>DefineImplicitLambdaToFunctionPointerConversion</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>CurrentLoc</name></decl></parameter>, <parameter><decl><type><name>CXXConversionDecl</name> <modifier>*</modifier></type><name>Conv</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>void</name></type> <name>DefineImplicitLambdaToBlockPointerConversion</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CurrentLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXConversionDecl</name> <modifier>*</modifier></type><name>Conv</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildBlockForLambdaConversion</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CurrentLocation</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ConvLocation</name></decl></parameter>,
<parameter><decl><type><name>CXXConversionDecl</name> <modifier>*</modifier></type><name>Conv</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Src</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>CheckConstraintExpression</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>CE</name></decl></parameter>, <parameter><decl><type><name>Token</name></type> <name>NextToken</name> <init>= <expr><call><name>Token</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>PossibleNonPrimary</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsTrailingRequiresClause</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>SubsumptionCache</name></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>NormalizedConstraint</name> <operator>*</operator></expr></argument>&gt;</argument_list></name>
<name>NormalizationCache</name></expr>;</expr_stmt>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>ContextualFoldingSet</name><argument_list type="generic">&lt;<argument><expr><name>ConstraintSatisfaction</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>ASTContext</name> <operator>&amp;</operator></expr></argument>&gt;</argument_list></name>
<name>SatisfactionCache</name></expr>;</expr_stmt>

<label><name>public</name>:</label>
<function_decl><type><specifier>const</specifier> <name>NormalizedConstraint</name> <modifier>*</modifier></type>
<name>getNormalizedAssociatedConstraints</name><parameter_list>(
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ConstrainedDecl</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>AssociatedConstraints</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>bool</name></type> <name>IsAtLeastAsConstrained</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D1</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>AC1</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D2</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>AC2</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>MaybeEmitAmbiguousAtomicConstraintsDiagnostic</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D1</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>AC1</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D2</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>AC2</name></decl></parameter>)</parameter_list>;</function_decl>
















<function_decl><type><name>bool</name></type> <name>CheckConstraintSatisfaction</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>ConstraintExprs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name></type> <name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>TemplateIDRange</name></decl></parameter>, <parameter><decl><type><name>ConstraintSatisfaction</name> <modifier>&amp;</modifier></type><name>Satisfaction</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>bool</name></type> <name>CheckConstraintSatisfaction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>ConstraintExpr</name></decl></parameter>,
<parameter><decl><type><name>ConstraintSatisfaction</name> <modifier>&amp;</modifier></type><name>Satisfaction</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>bool</name></type> <name>CheckFunctionConstraints</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><name>ConstraintSatisfaction</name> <modifier>&amp;</modifier></type><name>Satisfaction</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>UsageLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>















<function_decl><type><name>bool</name></type> <name>EnsureTemplateArgumentListConstraints</name><parameter_list>(<parameter><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name></type> <name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>TemplateIDRange</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type>
<name>DiagnoseUnsatisfiedConstraint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ConstraintSatisfaction</name> <modifier>&amp;</modifier></type><name>Satisfaction</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>First</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type>
<name>DiagnoseUnsatisfiedConstraint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTConstraintSatisfaction</name> <modifier>&amp;</modifier></type><name>Satisfaction</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>First</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ParseObjCStringLiteral</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>AtLocs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Strings</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildObjCStringLiteral</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>, <parameter><decl><type><name>StringLiteral</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>BuildObjCNumericLiteral</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Number</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnObjCBoolLiteral</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ValueLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Value</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildObjCArrayLiteral</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>SR</name></decl></parameter>, <parameter><decl><type><name>MultiExprArg</name></type> <name>Elements</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>ExprResult</name></type> <name>BuildObjCBoxedExpr</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>SR</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ValueExpr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildObjCSubscriptExpression</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>RB</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BaseExpr</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>IndexExpr</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>getterMethod</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>setterMethod</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildObjCDictionaryLiteral</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>SR</name></decl></parameter>,
<parameter><decl><type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ObjCDictionaryElement</name></expr></argument>&gt;</argument_list></name></type> <name>Elements</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildObjCEncodeExpression</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>EncodedTypeInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildCXXMemberCallExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Exp</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>CXXConversionDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HadMultipleCandidates</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ParseObjCEncodeExpression</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EncodeLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>Ty</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ParseObjCSelectorExpression</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>SelLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>WarnMultipleSelectors</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>ParseObjCProtocolExpression</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type> <name>ProtocolName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtoLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtoIdLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnStartLinkageSpecification</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ExternLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LangStr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBraceLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnFinishLinkageSpecification</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>LinkageSpec</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBraceLoc</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>getCurrentClass</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>*</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isCurrentClassName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>*</modifier></type><name>SS</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isCurrentClassNameTypo</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>II</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>*</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>ActOnAccessSpecifier</name><parameter_list>(<parameter><decl><type><name>AccessSpecifier</name></type> <name>Access</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ASLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ActOnCXXMemberDeclarator</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>,
<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParameterLists</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BitfieldWidth</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VirtSpecifiers</name> <modifier>&amp;</modifier></type><name>VS</name></decl></parameter>,
<parameter><decl><type><name>InClassInitStyle</name></type> <name>InitStyle</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnStartCXXInClassMemberInitializer</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnFinishCXXInClassMemberInitializer</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>VarDecl</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EqualLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>MemInitResult</name></type> <name>ActOnMemInitializer</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ConstructorD</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>MemberOrBase</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>TemplateTypeTy</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>MemInitResult</name></type> <name>ActOnMemInitializer</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ConstructorD</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>MemberOrBase</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>TemplateTypeTy</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>InitList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>MemInitResult</name></type> <name>BuildMemInitializer</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ConstructorD</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>MemberOrBase</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>TemplateTypeTy</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>MemInitResult</name></type> <name>BuildMemberInitializer</name><parameter_list>(<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>MemInitResult</name></type> <name>BuildBaseInitializer</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>BaseTInfo</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>MemInitResult</name></type> <name>BuildDelegatingInitializer</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>SetDelegatingInitializer</name><parameter_list>(<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>,
<parameter><decl><type><name>CXXCtorInitializer</name> <modifier>*</modifier></type><name>Initializer</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>SetCtorInitializers</name><parameter_list>(<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AnyErrors</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>CXXCtorInitializer</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Initializers</name> <init>= <expr><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>SetIvarInitializers</name><parameter_list>(<parameter><decl><type><name>ObjCImplementationDecl</name> <modifier>*</modifier></type><name>ObjCImplementation</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>MarkBaseAndMemberDestructorsReferenced</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>





<decl_stmt><decl><type><name>void</name></type> <name>MarkVirtualBaseDestructorsReferenced</name><argument_list>(
<argument><expr><name>SourceLocation</name> <name>Location</name></expr></argument>, <argument><expr><name>CXXRecordDecl</name> <operator>*</operator><name>ClassDecl</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>SmallPtrSetImpl</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>RecordType</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>DirectVirtualBases</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<function_decl><type><name>void</name></type> <name>CheckCompleteDestructorVariant</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CurrentLocation</name></decl></parameter>,
<parameter><decl><type><name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>Dtor</name></decl></parameter>)</parameter_list>;</function_decl>




<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <name>VTableUse</name></expr>;</expr_stmt></typedef>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>VTableUse</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>VTableUses</name></decl>;</decl_stmt>





<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <name>VTablesUsed</name></expr>;</expr_stmt>


<function_decl><type><name>void</name></type> <name>LoadExternalVTableUses</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>MarkVTableUsed</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DefinitionRequired</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>MarkVirtualMemberExceptionSpecsNeeded</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>MarkVirtualMembersReferenced</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ConstexprOnly</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>bool</name></type> <name>DefineUsedVTables</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>AddImplicitlyDeclaredMembersToClass</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnMemInitializers</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ConstructorDecl</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>CXXCtorInitializer</name><modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>MemInits</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AnyErrors</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>checkClassLevelDLLAttribute</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>checkClassLevelCodeSegAttribute</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>referenceDLLExportedClassMethods</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>propagateDLLAttrToBaseClassTemplate</name><parameter_list>(
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>, <parameter><decl><type><name>Attr</name> <modifier>*</modifier></type><name>ClassAttr</name></decl></parameter>,
<parameter><decl><type><name>ClassTemplateSpecializationDecl</name> <modifier>*</modifier></type><name>BaseTemplateSpec</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>BaseLoc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>inferGslPointerAttribute</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>, <parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>UnderlyingRecord</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>inferGslOwnerPointerAttribute</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>inferGslPointerAttribute</name><parameter_list>(<parameter><decl><type><name>TypedefNameDecl</name> <modifier>*</modifier></type><name>TD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckCompletedCXXClass</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>checkIllFormedTrivialABIStruct</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>&amp;</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnFinishCXXMemberSpecification</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RLoc</name></decl></parameter>,
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>TagDecl</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LBrac</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBrac</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnFinishCXXMemberDecls</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnFinishCXXNonNestedClass</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnReenterCXXMethodParameter</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ActOnReenterTemplateScope</name><argument_list>(<argument><expr><name>Decl</name> <operator>*</operator><name>Template</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>Scope</name> <operator>*</operator><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>EnterScope</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>ActOnStartDelayedMemberDeclarations</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnStartDelayedCXXMethodDeclaration</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnDelayedCXXMethodParameter</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnFinishDelayedMemberDeclarations</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnFinishDelayedCXXMethodDeclaration</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnFinishDelayedMemberInitializers</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>MarkAsLateParsedTemplate</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>FnD</name></decl></parameter>,
<parameter><decl><type><name>CachedTokens</name> <modifier>&amp;</modifier></type><name>Toks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>UnmarkAsLateParsedTemplate</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>IsInsideALocalClassWithinATemplateFunction</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnStaticAssertDeclaration</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StaticAssertLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>AssertExpr</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>AssertMessageExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>BuildStaticAssertDeclaration</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StaticAssertLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>AssertExpr</name></decl></parameter>,
<parameter><decl><type><name>StringLiteral</name> <modifier>*</modifier></type><name>AssertMessageExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Failed</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>FriendDecl</name> <modifier>*</modifier></type><name>CheckFriendTypeDecl</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LocStart</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>FriendLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnFriendTypeDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParams</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ActOnFriendFunctionDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParams</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>CheckConstructorDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>R</name></decl></parameter>,
<parameter><decl><type><name>StorageClass</name><modifier>&amp;</modifier></type> <name>SC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckConstructor</name><parameter_list>(<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckDestructorDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>R</name></decl></parameter>,
<parameter><decl><type><name>StorageClass</name><modifier>&amp;</modifier></type> <name>SC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckDestructor</name><parameter_list>(<parameter><decl><type><name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>Destructor</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckConversionDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><name>StorageClass</name><modifier>&amp;</modifier></type> <name>SC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnConversionDeclarator</name><parameter_list>(<parameter><decl><type><name>CXXConversionDecl</name> <modifier>*</modifier></type><name>Conversion</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckDeductionGuideDeclarator</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><name>StorageClass</name> <modifier>&amp;</modifier></type><name>SC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckDeductionGuideTemplate</name><parameter_list>(<parameter><decl><type><name>FunctionTemplateDecl</name> <modifier>*</modifier></type><name>TD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckExplicitlyDefaultedFunction</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckExplicitlyDefaultedSpecialMember</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>,
<parameter><decl><type><name>CXXSpecialMember</name></type> <name>CSM</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckDelayedMemberExceptionSpecs</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckExplicitlyDefaultedComparison</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>,
<parameter><decl><type><name>DefaultedComparisonKind</name></type> <name>DCK</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DeclareImplicitEqualityComparison</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Spaceship</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DefineDefaultedComparison</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><name>DefaultedComparisonKind</name></type> <name>DCK</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>CXXBaseSpecifier</name> <modifier>*</modifier></type><name>CheckBaseSpecifier</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>SpecifierRange</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Virtual</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>Access</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>BaseResult</name></type> <name>ActOnBaseSpecifier</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>classdecl</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>SpecifierRange</name></decl></parameter>,
<parameter><decl><type><name>ParsedAttributes</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Virtual</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>Access</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>basetype</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>BaseLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>AttachBaseSpecifiers</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Class</name></decl></parameter>,
<parameter><decl><type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>CXXBaseSpecifier</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Bases</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnBaseSpecifiers</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>,
<parameter><decl><type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>CXXBaseSpecifier</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Bases</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>IsDerivedFrom</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Derived</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Base</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>IsDerivedFrom</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Derived</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Base</name></decl></parameter>,
<parameter><decl><type><name>CXXBasePaths</name> <modifier>&amp;</modifier></type><name>Paths</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>BuildBasePathArray</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXBasePaths</name> <modifier>&amp;</modifier></type><name>Paths</name></decl></parameter>, <parameter><decl><type><name>CXXCastPath</name> <modifier>&amp;</modifier></type><name>BasePath</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckDerivedToBaseConversion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Derived</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Base</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>,
<parameter><decl><type><name>CXXCastPath</name> <modifier>*</modifier></type><name>BasePath</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IgnoreAccess</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckDerivedToBaseConversion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Derived</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Base</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>InaccessibleBaseID</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>AmbiguousBaseConvID</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>,
<parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>,
<parameter><decl><type><name>CXXCastPath</name> <modifier>*</modifier></type><name>BasePath</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IgnoreAccess</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <call><name>getAmbiguousPathsDisplayString</name><argument_list>(<argument><expr><name>CXXBasePaths</name> <operator>&amp;</operator><name>Paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><name>bool</name></type> <name>CheckOverridingFunctionAttributes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>CheckOverridingFunctionReturnType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>CheckOverridingFunctionExceptionSpec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckPureMethod</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>InitRange</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>CheckOverrideControl</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DiagnoseAbsenceOfOverrideControl</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Inconsistent</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>CheckIfOverriddenFunctionIsMarkedFinal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>)</parameter_list>;</function_decl>






<enum>enum <name>AccessResult</name> <block>{
<decl><name>AR_accessible</name></decl>,
<decl><name>AR_inaccessible</name></decl>,
<decl><name>AR_dependent</name></decl>,
<decl><name>AR_delayed</name></decl>
}</block>;</enum>

<function_decl><type><name>bool</name></type> <name>SetMemberAccessSpecifier</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>MemberDecl</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>PrevMemberDecl</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>LexicalAS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>AccessResult</name></type> <name>CheckUnresolvedMemberAccess</name><parameter_list>(<parameter><decl><type><name>UnresolvedMemberExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>AccessResult</name></type> <name>CheckUnresolvedLookupAccess</name><parameter_list>(<parameter><decl><type><name>UnresolvedLookupExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>AccessResult</name></type> <name>CheckAllocationAccess</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OperatorLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>PlacementRange</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>NamingClass</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>AccessResult</name></type> <name>CheckConstructorAccess</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>&amp;</modifier></type><name>Entity</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsCopyBindingRefToTemp</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>AccessResult</name></type> <name>CheckConstructorAccess</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>&amp;</modifier></type><name>Entity</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>PDiag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>AccessResult</name></type> <name>CheckDestructorAccess</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>Dtor</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>PDiag</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>objectType</name> <init>= <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>AccessResult</name></type> <name>CheckFriendAccess</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>AccessResult</name></type> <name>CheckMemberAccess</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>UseLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>NamingClass</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>Found</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>AccessResult</name></type>
<name>CheckStructuredBindingMemberAccess</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>UseLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>DecomposedClass</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>Field</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>AccessResult</name></type> <name>CheckMemberOperatorAccess</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ObjectExpr</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ArgExpr</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>AccessResult</name></type> <name>CheckAddressOfMemberAccess</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>OvlExpr</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>FoundDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>AccessResult</name></type> <name>CheckBaseClassAccess</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AccessLoc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Base</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Derived</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXBasePath</name> <modifier>&amp;</modifier></type><name>Path</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForceCheck</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ForceUnprivileged</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckLookupAccess</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>IsSimplyAccessible</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>, <parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>NamingClass</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isMemberAccessibleForDeletion</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>NamingClass</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>Found</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ObjectType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>Diag</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>bool</name></type> <name>isMemberAccessibleForDeletion</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>NamingClass</name></decl></parameter>,
<parameter><decl><type><name>DeclAccessPair</name></type> <name>Found</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ObjectType</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>isMemberAccessibleForDeletion</name><argument_list>(<argument><expr><name>NamingClass</name></expr></argument>, <argument><expr><name>Found</name></expr></argument>, <argument><expr><name>ObjectType</name></expr></argument>,
<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>PDiag</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>HandleDependentAccessCheck</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DependentDiagnostic</name> <modifier>&amp;</modifier></type><name>DD</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>PerformDependentDiagnostics</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclContext</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>HandleDelayedAccessCheck</name><argument_list>(<argument><expr><name>sema</name><operator>::</operator><name>DelayedDiagnostic</name> <operator>&amp;</operator><name>DD</name></expr></argument>, <argument><expr><name>Decl</name> <operator>*</operator><name>Ctx</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>AccessCheckingSFINAE</name></decl>;</decl_stmt>

<enum>enum <name>AbstractDiagSelID</name> <block>{
<decl><name>AbstractNone</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
<decl><name>AbstractReturnType</name></decl>,
<decl><name>AbstractParamType</name></decl>,
<decl><name>AbstractVariableType</name></decl>,
<decl><name>AbstractFieldType</name></decl>,
<decl><name>AbstractIvarType</name></decl>,
<decl><name>AbstractSynthesizedIvarType</name></decl>,
<decl><name>AbstractArrayType</name></decl>
}</block>;</enum>

<function_decl><type><name>bool</name></type> <name>isAbstractType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>RequireNonAbstractType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name>TypeDiagnoser</name> <modifier>&amp;</modifier></type><name>Diagnoser</name></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name><name>template</name> <argument_list type="generic">&lt;<argument><expr><name>typename</name><modifier>...</modifier> <name>Ts</name></expr></argument>&gt;</argument_list></name>
<name>bool</name></type> <name>RequireNonAbstractType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Ts</name> <modifier>&amp;</modifier><modifier>...</modifier></type><name>Args</name></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name><name>BoundTypeDiagnoser</name><argument_list type="generic">&lt;<argument><expr><name>Ts</name><modifier>...</modifier></expr></argument>&gt;</argument_list></name></type> <name>Diagnoser</name><argument_list>(<argument><expr><name>DiagID</name></expr></argument>, <argument><expr><name>Args</name><operator>...</operator></expr></argument>)</argument_list></decl>;</decl_stmt>
<return>return <expr><call><name>RequireNonAbstractType</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>T</name></expr></argument>, <argument><expr><name>Diagnoser</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>void</name></type> <name>DiagnoseAbstractType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>CheckOverloadedOperatorDeclaration</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FnDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckLiteralOperatorDeclaration</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FnDecl</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>FilterAcceptableTemplateNames</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowFunctionTemplates</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowDependent</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>hasAnyAcceptableTemplateNames</name><parameter_list>(<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowFunctionTemplates</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowDependent</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowNonTemplateFunctions</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><specifier>static</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>getAsTemplateNameDecl</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowFunctionTemplates</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowDependent</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>TemplateNameIsRequiredTag</name> <block>{ <decl><name>TemplateNameIsRequired</name></decl> }</block>;</enum>

<decl_stmt><decl><type><name>class</name></type> <name>RequiredTemplateKind</name> <block>{<block_content>
<label><name>public</name>:</label>

<macro><name>RequiredTemplateKind</name><argument_list>(<argument>SourceLocation TemplateKWLoc = SourceLocation()</argument>)</argument_list></macro>
: <macro><name>TemplateKW</name><argument_list>(<argument>TemplateKWLoc</argument>)</argument_list></macro> <block>{<block_content/>}</block>

<expr_stmt><expr><call><name>RequiredTemplateKind</name><argument_list>(<argument><expr><name>TemplateNameIsRequiredTag</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>TemplateKW</name><argument_list>()</argument_list></macro> <block>{}</block>

<name>SourceLocation</name> <macro><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>TemplateKW</name><operator>.</operator><name>getValueOr</name></name><argument_list>(<argument><expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>hasTemplateKeyword</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>getTemplateKeywordLoc</name><argument_list>()</argument_list></call><operator>.</operator><call><name>isValid</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>bool</name> <macro><name>isRequired</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>TemplateKW</name> <operator>!=</operator> <call><name>SourceLocation</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>explicit</name> <name>operator</name> <macro><name>bool</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><call><name>isRequired</name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <name>TemplateKW</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>AssumedTemplateKind</name> <block>{<block_content>

<expr_stmt><expr><name>None</name></expr><operator>,</operator>

<expr><name>FoundNothing</name></expr><operator>,</operator>


<expr><name>FoundFunctions</name></expr><operator>,</operator></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<function_decl><type><name>bool</name></type> <name>LookupTemplateName</name><parameter_list>(
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ObjectType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>MemberOfUnknownSpecialization</name></decl></parameter>,
<parameter><decl><type><name>RequiredTemplateKind</name></type> <name>RequiredTemplate</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>AssumedTemplateKind</name> <modifier>*</modifier></type><name>ATK</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AllowTypoCorrection</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TemplateNameKind</name></type> <name>isTemplateName</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>hasTemplateKeyword</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ObjectType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>,
<parameter><decl><type><name>TemplateTy</name> <modifier>&amp;</modifier></type><name>Template</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>MemberOfUnknownSpecialization</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Disambiguation</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>ActOnUndeclaredTypeTemplateName</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>TemplateTy</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>TemplateNameKind</name> <modifier>&amp;</modifier></type><name>TNK</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>II</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>resolveAssumedTemplateNameAsType</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>TemplateName</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>isDeductionGuideName</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedTemplateTy</name> <modifier>*</modifier></type><name>Template</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>DiagnoseUnknownTemplateName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IILoc</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>*</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>TemplateTy</name> <modifier>&amp;</modifier></type><name>SuggestedTemplate</name></decl></parameter>,
<parameter><decl><type><name>TemplateNameKind</name> <modifier>&amp;</modifier></type><name>SuggestedKind</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>DiagnoseUninstantiableTemplate</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Instantiation</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>InstantiatedFromMember</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>NamedDecl</name> <modifier>*</modifier></type><name>PatternDef</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Complain</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseTemplateParameterShadow</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>PrevDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>AdjustDeclIfTemplate</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>Decl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ActOnTypeParameter</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Typename</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KeyLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ParamName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ParamNameLoc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Depth</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Position</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EqualLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>DefaultArg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>HasTypeConstraint</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>ActOnTypeConstraint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>TemplateIdAnnotation</name> <modifier>*</modifier></type><name>TypeConstraint</name></decl></parameter>,
<parameter><decl><type><name>TemplateTypeParmDecl</name> <modifier>*</modifier></type><name>ConstrainedParameter</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>BuildTypeConstraint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>TemplateIdAnnotation</name> <modifier>*</modifier></type><name>TypeConstraint</name></decl></parameter>,
<parameter><decl><type><name>TemplateTypeParmDecl</name> <modifier>*</modifier></type><name>ConstrainedParameter</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowUnexpandedPack</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>AttachTypeConstraint</name><parameter_list>(<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>NS</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name></type> <name>NameInfo</name></decl></parameter>,
<parameter><decl><type><name>ConceptDecl</name> <modifier>*</modifier></type><name>NamedConcept</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>TemplateTypeParmDecl</name> <modifier>*</modifier></type><name>ConstrainedParameter</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>AttachTypeConstraint</name><parameter_list>(<parameter><decl><type><name>AutoTypeLoc</name></type> <name>TL</name></decl></parameter>,
<parameter><decl><type><name>NonTypeTemplateParmDecl</name> <modifier>*</modifier></type><name>ConstrainedParameter</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>RequireStructuralType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>CheckNonTypeTemplateParameterType</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>TSI</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckNonTypeTemplateParameterType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ActOnNonTypeTemplateParameter</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Depth</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Position</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EqualLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>DefaultArg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ActOnTemplateTemplateParameter</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TmpLoc</name></decl></parameter>,
<parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>Params</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ParamName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ParamNameLoc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Depth</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Position</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EqualLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedTemplateArgument</name></type> <name>DefaultArg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type>
<name>ActOnTemplateParameterList</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>Depth</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ExportLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Params</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RequiresClause</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>TemplateParamListContext</name> <block>{
<decl><name>TPC_ClassTemplate</name></decl>,
<decl><name>TPC_VarTemplate</name></decl>,
<decl><name>TPC_FunctionTemplate</name></decl>,
<decl><name>TPC_ClassTemplateMember</name></decl>,
<decl><name>TPC_FriendClassTemplate</name></decl>,
<decl><name>TPC_FriendFunctionTemplate</name></decl>,
<decl><name>TPC_FriendFunctionTemplateDefinition</name></decl>,
<decl><name>TPC_TypeAliasTemplate</name></decl>
}</block>;</enum>

<function_decl><type><name>bool</name></type> <name>CheckTemplateParameterList</name><parameter_list>(<parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>NewParams</name></decl></parameter>,
<parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>OldParams</name></decl></parameter>,
<parameter><decl><type><name>TemplateParamListContext</name></type> <name>TPC</name></decl></parameter>,
<parameter><decl><type><name>SkipBodyInfo</name> <modifier>*</modifier></type><name>SkipBody</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>MatchTemplateParametersToScopeSpecifier</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>DeclStartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>DeclLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>TemplateIdAnnotation</name> <modifier>*</modifier></type><name>TemplateId</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateParameterList</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>ParamLists</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsFriend</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>IsMemberSpecialization</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>Invalid</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>SuppressDiagnostic</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclResult</name></type> <name>CheckClassTemplate</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>TagSpec</name></decl></parameter>, <parameter><decl><type><name>TagUseKind</name></type> <name>TUK</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>Attr</name></decl></parameter>, <parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>TemplateParams</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ModulePrivateLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>FriendLoc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumOuterTemplateParamLists</name></decl></parameter>,
<parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier><modifier>*</modifier></type><name>OuterTemplateParamLists</name></decl></parameter>,
<parameter><decl><type><name>SkipBodyInfo</name> <modifier>*</modifier></type><name>SkipBody</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TemplateArgumentLoc</name></type> <name>getTrivialTemplateArgumentLoc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>Arg</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>NTTPType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>TemplateArgumentLoc</name></type> <name>getIdentityTemplateArgumentLoc</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Location</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>translateTemplateArguments</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ASTTemplateArgsPtr</name> <modifier>&amp;</modifier></type><name>In</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>Out</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ParsedTemplateArgument</name></type> <name>ActOnTemplateTypeArgument</name><parameter_list>(<parameter><decl><type><name>TypeResult</name></type> <name>ParsedType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>NoteAllFoundTemplates</name><parameter_list>(<parameter><decl><type><name>TemplateName</name></type> <name>Name</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>CheckTemplateIdType</name><parameter_list>(<parameter><decl><type><name>TemplateName</name></type> <name>Template</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TypeResult</name></type>
<name>ActOnTemplateIdType</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>TemplateTy</name></type> <name>Template</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>TemplateII</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateIILoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>ASTTemplateArgsPtr</name></type> <name>TemplateArgs</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsCtorOrDtorName</name> <init>= <expr><name>false</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsClassName</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>TypeResult</name></type> <name>ActOnTagTemplateIdType</name><parameter_list>(<parameter><decl><type><name>TagUseKind</name></type> <name>TUK</name></decl></parameter>,
<parameter><decl><type><name>TypeSpecifierType</name></type> <name>TagSpec</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TagLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>TemplateTy</name></type> <name>TemplateD</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>ASTTemplateArgsPtr</name></type> <name>TemplateArgsIn</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclResult</name></type> <name>ActOnVarTemplateSpecialization</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>DI</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>, <parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>TemplateParams</name></decl></parameter>,
<parameter><decl><type><name>StorageClass</name></type> <name>SC</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsPartialSpecialization</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>DeclResult</name></type> <name>CheckVarTemplateId</name><parameter_list>(<parameter><decl><type><name>VarTemplateDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateNameLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>CheckVarTemplateId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><name>VarTemplateDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type>
<name>CheckConceptTemplateId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>ConceptNameInfo</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FoundDecl</name></decl></parameter>, <parameter><decl><type><name>ConceptDecl</name> <modifier>*</modifier></type><name>NamedConcept</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>diagnoseMissingTemplateArguments</name><parameter_list>(<parameter><decl><type><name>TemplateName</name></type> <name>Name</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildTemplateIdExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>R</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RequiresADL</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildQualifiedTemplateIdExpr</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TemplateNameKind</name></type> <name>ActOnTemplateName</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TemplateKWLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>UnqualifiedId</name> <modifier>&amp;</modifier></type><name>Name</name></decl></parameter>, <parameter><decl><type><name>ParsedType</name></type> <name>ObjectType</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>,
<parameter><decl><type><name>TemplateTy</name> <modifier>&amp;</modifier></type><name>Template</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AllowInjectedClassName</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclResult</name></type> <name>ActOnClassTemplateSpecialization</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>TagSpec</name></decl></parameter>, <parameter><decl><type><name>TagUseKind</name></type> <name>TUK</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ModulePrivateLoc</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>TemplateIdAnnotation</name> <modifier>&amp;</modifier></type><name>TemplateId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>Attr</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParameterLists</name></decl></parameter>,
<parameter><decl><type><name>SkipBodyInfo</name> <modifier>*</modifier></type><name>SkipBody</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckTemplatePartialSpecializationArgs</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>PrimaryTemplate</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumExplicitArgs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckTemplatePartialSpecialization</name><parameter_list>(
<parameter><decl><type><name>ClassTemplatePartialSpecializationDecl</name> <modifier>*</modifier></type><name>Partial</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckTemplatePartialSpecialization</name><parameter_list>(
<parameter><decl><type><name>VarTemplatePartialSpecializationDecl</name> <modifier>*</modifier></type><name>Partial</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnTemplateDeclarator</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParameterLists</name></decl></parameter>,
<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type>
<name>CheckSpecializationInstantiationRedecl</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>NewLoc</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>NewTSK</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>PrevDecl</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>PrevTSK</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PrevPtOfInstantiation</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>SuppressNew</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckDependentFunctionTemplateSpecialization</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>ExplicitTemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckFunctionTemplateSpecialization</name><parameter_list>(
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>*</modifier></type><name>ExplicitTemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>QualifiedFriend</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckMemberSpecialization</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>, <parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CompleteMemberSpecialization</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Member</name></decl></parameter>, <parameter><decl><type><name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclResult</name></type> <name>ActOnExplicitInstantiation</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ExternLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>TagSpec</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>TemplateTy</name></type> <name>Template</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TemplateNameLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LAngleLoc</name></decl></parameter>, <parameter><decl><type><name>ASTTemplateArgsPtr</name></type> <name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>Attr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclResult</name></type> <name>ActOnExplicitInstantiation</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ExternLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>TagSpec</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KWLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>Attr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclResult</name></type> <name>ActOnExplicitInstantiation</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ExternLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TemplateArgumentLoc</name></type>
<name>SubstDefaultTemplateArgumentIfAvailable</name><parameter_list>(<parameter><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name>
<modifier>&amp;</modifier></type><name>Converted</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>HasDefaultArg</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>CheckTemplateArgumentKind</name> <block>{


<decl><name>CTAK_Specified</name></decl>,



<decl><name>CTAK_Deduced</name></decl>,



<decl><name>CTAK_DeducedFromArrayBound</name></decl>
}</block>;</enum>

<function_decl><type><name>bool</name></type> <name>CheckTemplateArgument</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentLoc</name> <modifier>&amp;</modifier></type><name>Arg</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>ArgumentPackIndex</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Converted</name></decl></parameter>,
<parameter><decl><type><name>CheckTemplateArgumentKind</name></type> <name>CTAK</name> <init>= <expr><name>CTAK_Specified</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>






























<function_decl><type><name>bool</name></type> <name>CheckTemplateArgumentList</name><parameter_list>(<parameter><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>PartialTemplateArgs</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Converted</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>UpdateArgsWithConversions</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>ConstraintsNotSatisfied</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckTemplateTypeArgument</name><parameter_list>(<parameter><decl><type><name>TemplateTypeParmDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentLoc</name> <modifier>&amp;</modifier></type><name>Arg</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Converted</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckTemplateArgument</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>Arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>CheckTemplateArgument</name><parameter_list>(<parameter><decl><type><name>NonTypeTemplateParmDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>InstantiatedParamType</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Arg</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>Converted</name></decl></parameter>,
<parameter><decl><type><name>CheckTemplateArgumentKind</name></type> <name>CTAK</name> <init>= <expr><name>CTAK_Specified</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckTemplateTemplateArgument</name><parameter_list>(<parameter><decl><type><name>TemplateTemplateParmDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>,
<parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>Params</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentLoc</name> <modifier>&amp;</modifier></type><name>Arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type>
<name>BuildExpressionFromDeclTemplateArgument</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>Arg</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ParamType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type>
<name>BuildExpressionFromIntegralTemplateArgument</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>&amp;</modifier></type><name>Arg</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>TemplateParameterListEqualKind</name> <block>{







<decl><name>TPL_TemplateMatch</name></decl>,









<decl><name>TPL_TemplateTemplateParmMatch</name></decl>,










<decl><name>TPL_TemplateTemplateArgumentMatch</name></decl>
}</block>;</enum>

<function_decl><type><name>bool</name></type> <name>TemplateParameterListsAreEqual</name><parameter_list>(<parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>New</name></decl></parameter>,
<parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>Old</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Complain</name></decl></parameter>,
<parameter><decl><type><name>TemplateParameterListEqualKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateArgLoc</name>
<init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckTemplateDeclScope</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>TemplateParams</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>TypeResult</name></type>
<name>ActOnTypenameType</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TypenameLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name></decl></parameter>)</parameter_list>;</function_decl>















<function_decl><type><name>TypeResult</name></type>
<name>ActOnTypenameType</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TypenameLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateLoc</name></decl></parameter>,
<parameter><decl><type><name>TemplateTy</name></type> <name>TemplateName</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>TemplateII</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TemplateIILoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>ASTTemplateArgsPtr</name></type> <name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RAngleLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>CheckTypenameType</name><parameter_list>(<parameter><decl><type><name>ElaboratedTypeKeyword</name></type> <name>Keyword</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KeywordLoc</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IILoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>TSI</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DeducedTSTContext</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>CheckTypenameType</name><parameter_list>(<parameter><decl><type><name>ElaboratedTypeKeyword</name></type> <name>Keyword</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KeywordLoc</name></decl></parameter>,
<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IILoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DeducedTSTContext</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>RebuildTypeInCurrentInstantiation</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>T</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>RebuildNestedNameSpecifierInCurrentInstantiation</name><parameter_list>(<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>RebuildExprInCurrentInstantiation</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>RebuildTemplateParamsInCurrentInstantiation</name><parameter_list>(
<parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>Params</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name>
<call><name>getTemplateArgumentBindingsText</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateParameterList</name> <operator>*</operator><name>Params</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>&amp;</operator><name>Args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name>
<macro><name>getTemplateArgumentBindingsText</name><argument_list>(<argument>const TemplateParameterList *Params</argument>,
<argument>const TemplateArgument *Args</argument>,
<argument>unsigned NumArgs</argument>)</argument_list></macro></expr>;</expr_stmt>




<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnConceptDefinition</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParameterLists</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ConstraintExpr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>RequiresExprBodyDecl</name> <modifier>*</modifier></type>
<name>ActOnStartRequiresExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>RequiresKWLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>LocalParameters</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>BodyScope</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ActOnFinishRequiresExpr</name><parameter_list>()</parameter_list>;</function_decl>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>Requirement</name> <operator>*</operator><call><name>ActOnSimpleRequirement</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>Requirement</name> <operator>*</operator><macro><name>ActOnTypeRequirement</name><argument_list>(
<argument>SourceLocation TypenameKWLoc</argument>, <argument>CXXScopeSpec &amp;SS</argument>, <argument>SourceLocation NameLoc</argument>,
<argument>IdentifierInfo *TypeName</argument>, <argument>TemplateIdAnnotation *TemplateId</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>Requirement</name> <operator>*</operator><macro><name>ActOnCompoundRequirement</name><argument_list>(<argument>Expr *E</argument>,
<argument>SourceLocation NoexceptLoc</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>Requirement</name> <operator>*</operator>
<macro><name>ActOnCompoundRequirement</name><argument_list>(
<argument>Expr *E</argument>, <argument>SourceLocation NoexceptLoc</argument>, <argument>CXXScopeSpec &amp;SS</argument>,
<argument>TemplateIdAnnotation *TypeConstraint</argument>, <argument>unsigned Depth</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>Requirement</name> <operator>*</operator><call><name>ActOnNestedRequirement</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>ExprRequirement</name> <operator>*</operator>
<macro><name>BuildExprRequirement</name><argument_list>(
<argument>Expr *E</argument>, <argument>bool IsSatisfied</argument>, <argument>SourceLocation NoexceptLoc</argument>,
<argument>concepts::ExprRequirement::ReturnTypeRequirement ReturnTypeRequirement</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>ExprRequirement</name> <operator>*</operator>
<macro><name>BuildExprRequirement</name><argument_list>(
<argument>concepts::Requirement::SubstitutionDiagnostic *ExprSubstDiag</argument>,
<argument>bool IsSatisfied</argument>, <argument>SourceLocation NoexceptLoc</argument>,
<argument>concepts::ExprRequirement::ReturnTypeRequirement ReturnTypeRequirement</argument>)</argument_list></macro></expr>;</expr_stmt>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>TypeRequirement</name> <operator>*</operator><call><name>BuildTypeRequirement</name><argument_list>(<argument><expr><name>TypeSourceInfo</name> <operator>*</operator><name>Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>TypeRequirement</name> <operator>*</operator>
<call><name>BuildTypeRequirement</name><argument_list>(
<argument><expr><name>concepts</name><operator>::</operator><name>Requirement</name><operator>::</operator><name>SubstitutionDiagnostic</name> <operator>*</operator><name>SubstDiag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>NestedRequirement</name> <operator>*</operator><call><name>BuildNestedRequirement</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>concepts</name><operator>::</operator><name>NestedRequirement</name> <operator>*</operator>
<call><name>BuildNestedRequirement</name><argument_list>(
<argument><expr><name>concepts</name><operator>::</operator><name>Requirement</name><operator>::</operator><name>SubstitutionDiagnostic</name> <operator>*</operator><name>SubstDiag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function_decl><type><name>ExprResult</name></type> <name>ActOnRequiresExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>RequiresKWLoc</name></decl></parameter>,
<parameter><decl><type><name>RequiresExprBodyDecl</name> <modifier>*</modifier></type><name>Body</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>LocalParameters</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>concepts</name><operator>::</operator><name>Requirement</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Requirements</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ClosingBraceLoc</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>bool</name></type> <name>isUnexpandedParameterPackPermitted</name><parameter_list>()</parameter_list>;</function_decl>






<enum>enum <name>UnexpandedParameterPackContext</name> <block>{

<decl><name>UPPC_Expression</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,


<decl><name>UPPC_BaseType</name></decl>,


<decl><name>UPPC_DeclarationType</name></decl>,


<decl><name>UPPC_DataMemberType</name></decl>,


<decl><name>UPPC_BitFieldWidth</name></decl>,


<decl><name>UPPC_StaticAssertExpression</name></decl>,


<decl><name>UPPC_FixedUnderlyingType</name></decl>,


<decl><name>UPPC_EnumeratorValue</name></decl>,


<decl><name>UPPC_UsingDeclaration</name></decl>,


<decl><name>UPPC_FriendDeclaration</name></decl>,


<decl><name>UPPC_DeclarationQualifier</name></decl>,


<decl><name>UPPC_Initializer</name></decl>,


<decl><name>UPPC_DefaultArgument</name></decl>,


<decl><name>UPPC_NonTypeTemplateParameterType</name></decl>,


<decl><name>UPPC_ExceptionType</name></decl>,


<decl><name>UPPC_PartialSpecialization</name></decl>,


<decl><name>UPPC_IfExists</name></decl>,


<decl><name>UPPC_IfNotExists</name></decl>,


<decl><name>UPPC_Lambda</name></decl>,


<decl><name>UPPC_Block</name></decl>,


<decl><name>UPPC_TypeConstraint</name></decl>,


<decl><name>UPPC_Requirement</name></decl>,


<decl><name>UPPC_RequiresClause</name></decl>,
}</block>;</enum>











<function_decl><type><name>bool</name></type> <name>DiagnoseUnexpandedParameterPacks</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>UnexpandedParameterPackContext</name></type> <name>UPPC</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>&gt;</argument_list></name></type> <name>Unexpanded</name></decl></parameter>)</parameter_list>;</function_decl>










<function_decl><type><name>bool</name></type> <name>DiagnoseUnexpandedParameterPack</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>T</name></decl></parameter>,
<parameter><decl><type><name>UnexpandedParameterPackContext</name></type> <name>UPPC</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>bool</name></type> <name>DiagnoseUnexpandedParameterPack</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>UnexpandedParameterPackContext</name></type> <name>UPPC</name> <init>= <expr><name>UPPC_Expression</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>bool</name></type> <name>DiagnoseUnexpandedParameterPackInRequiresExpr</name><parameter_list>(<parameter><decl><type><name>RequiresExpr</name> <modifier>*</modifier></type><name>RE</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>bool</name></type> <name>DiagnoseUnexpandedParameterPack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>,
<parameter><decl><type><name>UnexpandedParameterPackContext</name></type> <name>UPPC</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>bool</name></type> <name>DiagnoseUnexpandedParameterPack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><name>UnexpandedParameterPackContext</name></type> <name>UPPC</name></decl></parameter>)</parameter_list>;</function_decl>










<function_decl><type><name>bool</name></type> <name>DiagnoseUnexpandedParameterPack</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>TemplateName</name></type> <name>Template</name></decl></parameter>,
<parameter><decl><type><name>UnexpandedParameterPackContext</name></type> <name>UPPC</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>bool</name></type> <name>DiagnoseUnexpandedParameterPack</name><parameter_list>(<parameter><decl><type><name>TemplateArgumentLoc</name></type> <name>Arg</name></decl></parameter>,
<parameter><decl><type><name>UnexpandedParameterPackContext</name></type> <name>UPPC</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>collectUnexpandedParameterPacks</name><parameter_list>(<parameter><decl><type><name>TemplateArgument</name></type> <name>Arg</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Unexpanded</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>collectUnexpandedParameterPacks</name><parameter_list>(<parameter><decl><type><name>TemplateArgumentLoc</name></type> <name>Arg</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Unexpanded</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>collectUnexpandedParameterPacks</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Unexpanded</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>collectUnexpandedParameterPacks</name><parameter_list>(<parameter><decl><type><name>TypeLoc</name></type> <name>TL</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Unexpanded</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>collectUnexpandedParameterPacks</name><parameter_list>(<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>NNS</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Unexpanded</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>collectUnexpandedParameterPacks</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Unexpanded</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>ParsedTemplateArgument</name></type> <name>ActOnPackExpansion</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParsedTemplateArgument</name> <modifier>&amp;</modifier></type><name>Arg</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>TypeResult</name></type> <name>ActOnPackExpansion</name><parameter_list>(<parameter><decl><type><name>ParsedType</name></type> <name>Type</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>CheckPackExpansion</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>QualType</name></type> <name>CheckPackExpansion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Pattern</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>PatternRange</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>ExprResult</name></type> <name>ActOnPackExpansion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>ExprResult</name></type> <name>CheckPackExpansion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl></parameter>)</parameter_list>;</function_decl>



































<function_decl><type><name>bool</name></type> <name>CheckParameterPacksForExpansion</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>EllipsisLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>PatternRange</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>UnexpandedParameterPack</name></expr></argument>&gt;</argument_list></name></type> <name>Unexpanded</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>ShouldExpand</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>&amp;</modifier></type><name>RetainExpansion</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>NumExpansions</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>getNumArgumentsInExpansion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>
















<function_decl><type><name>bool</name></type> <name>containsUnexpandedParameterPacks</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>









<decl_stmt><decl><type><name>TemplateArgumentLoc</name></type> <name>getTemplateArgumentPackExpansionPattern</name><argument_list>(
<argument><expr><name>TemplateArgumentLoc</name> <name>OrigLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <operator>&amp;</operator><name>Ellipsis</name></expr></argument>,
<argument><expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>NumExpansions</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>







<function_decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>getFullyPackExpandedSize</name><parameter_list>(<parameter><decl><type><name>TemplateArgument</name></type> <name>Arg</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>QualType</name></type> <name>adjustCCAndNoReturn</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ArgFunctionType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>FunctionType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AdjustExceptionSpec</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>










<enum>enum <name>TemplateDeductionResult</name> <block>{

<decl><name>TDK_Success</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,

<decl><name>TDK_Invalid</name></decl>,


<decl><name>TDK_InstantiationDepth</name></decl>,


<decl><name>TDK_Incomplete</name></decl>,


<decl><name>TDK_IncompletePack</name></decl>,


<decl><name>TDK_Inconsistent</name></decl>,




<decl><name>TDK_Underqualified</name></decl>,


<decl><name>TDK_SubstitutionFailure</name></decl>,


<decl><name>TDK_DeducedMismatch</name></decl>,



<decl><name>TDK_DeducedMismatchNested</name></decl>,


<decl><name>TDK_NonDeducedMismatch</name></decl>,


<decl><name>TDK_TooManyArguments</name></decl>,


<decl><name>TDK_TooFewArguments</name></decl>,


<decl><name>TDK_InvalidExplicitArguments</name></decl>,

<decl><name>TDK_NonDependentConversionFailure</name></decl>,


<decl><name>TDK_ConstraintsNotSatisfied</name></decl>,

<decl><name>TDK_MiscellaneousDeductionFailure</name></decl>,

<decl><name>TDK_CUDATargetMismatch</name></decl>
}</block>;</enum>

<decl_stmt><decl><type><name>TemplateDeductionResult</name></type>
<name>DeduceTemplateArguments</name><argument_list>(<argument><expr><name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator><name>Partial</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>&amp;</operator><name>TemplateArgs</name></expr></argument>,
<argument><expr><name>sema</name><operator>::</operator><name>TemplateDeductionInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TemplateDeductionResult</name></type>
<name>DeduceTemplateArguments</name><argument_list>(<argument><expr><name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator><name>Partial</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>&amp;</operator><name>TemplateArgs</name></expr></argument>,
<argument><expr><name>sema</name><operator>::</operator><name>TemplateDeductionInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TemplateDeductionResult</name></type> <name>SubstituteExplicitTemplateArguments</name><argument_list>(
<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator><name>FunctionTemplate</name></expr></argument>,
<argument><expr><name>TemplateArgumentListInfo</name> <operator>&amp;</operator><name>ExplicitTemplateArgs</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>DeducedTemplateArgument</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Deduced</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>ParamTypes</name></expr></argument>, <argument><expr><name>QualType</name> <operator>*</operator><name>FunctionType</name></expr></argument>,
<argument><expr><name>sema</name><operator>::</operator><name>TemplateDeductionInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<struct>struct <name>OriginalCallArg</name> <block>{
<macro><name>OriginalCallArg</name><argument_list>(<argument>QualType OriginalParamType</argument>, <argument>bool DecomposedParam</argument>,
<argument>unsigned ArgIdx</argument>, <argument>QualType OriginalArgType</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>OriginalParamType</name><argument_list>(<argument><expr><name>OriginalParamType</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>DecomposedParam</name><argument_list>(<argument><expr><name>DecomposedParam</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>ArgIdx</name><argument_list>(<argument><expr><name>ArgIdx</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>OriginalArgType</name><argument_list>(<argument>OriginalArgType</argument>)</argument_list></macro> <expr><block>{}</block>

<name>QualType</name> <name>OriginalParamType</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>DecomposedParam</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ArgIdx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>OriginalArgType</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>TemplateDeductionResult</name></type> <name>FinishTemplateArgumentDeduction</name><argument_list>(
<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator><name>FunctionTemplate</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>DeducedTemplateArgument</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>Deduced</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>NumExplicitlySpecified</name></expr></argument>, <argument><expr><name>FunctionDecl</name> <operator>*</operator><operator>&amp;</operator><name>Specialization</name></expr></argument>,
<argument><expr><name>sema</name><operator>::</operator><name>TemplateDeductionInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>OriginalCallArg</name></expr></argument>&gt;</argument_list></name> <specifier>const</specifier> <operator>*</operator><name>OriginalCallArgs</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>bool</name> <name>PartialOverloading</name> <operator>=</operator> <name>false</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>CheckNonDependent</name> <operator>=</operator> <index>[]</index><block>{ <return>return <expr><name>false</name></expr>;</return> }</block></expr></argument></argument_list></decl></decl_stmt>)<empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>TemplateDeductionResult</name></type> <name>DeduceTemplateArguments</name><argument_list>(
<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator><name>FunctionTemplate</name></expr></argument>,
<argument><expr><name>TemplateArgumentListInfo</name> <operator>*</operator><name>ExplicitTemplateArgs</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>FunctionDecl</name> <operator>*</operator><operator>&amp;</operator><name>Specialization</name></expr></argument>, <argument><expr><name>sema</name><operator>::</operator><name>TemplateDeductionInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>,
<argument><expr><name>bool</name> <name>PartialOverloading</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>bool</name><operator>(</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name><operator>)</operator></expr></argument>&gt;</argument_list></name> <name>CheckNonDependent</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TemplateDeductionResult</name></type>
<name>DeduceTemplateArguments</name><argument_list>(<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator><name>FunctionTemplate</name></expr></argument>,
<argument><expr><name>TemplateArgumentListInfo</name> <operator>*</operator><name>ExplicitTemplateArgs</name></expr></argument>,
<argument><expr><name>QualType</name> <name>ArgFunctionType</name></expr></argument>,
<argument><expr><name>FunctionDecl</name> <operator>*</operator><operator>&amp;</operator><name>Specialization</name></expr></argument>,
<argument><expr><name>sema</name><operator>::</operator><name>TemplateDeductionInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsAddressOfFunction</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TemplateDeductionResult</name></type>
<name>DeduceTemplateArguments</name><argument_list>(<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator><name>FunctionTemplate</name></expr></argument>,
<argument><expr><name>QualType</name> <name>ToType</name></expr></argument>,
<argument><expr><name>CXXConversionDecl</name> <operator>*</operator><operator>&amp;</operator><name>Specialization</name></expr></argument>,
<argument><expr><name>sema</name><operator>::</operator><name>TemplateDeductionInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>TemplateDeductionResult</name></type>
<name>DeduceTemplateArguments</name><argument_list>(<argument><expr><name>FunctionTemplateDecl</name> <operator>*</operator><name>FunctionTemplate</name></expr></argument>,
<argument><expr><name>TemplateArgumentListInfo</name> <operator>*</operator><name>ExplicitTemplateArgs</name></expr></argument>,
<argument><expr><name>FunctionDecl</name> <operator>*</operator><operator>&amp;</operator><name>Specialization</name></expr></argument>,
<argument><expr><name>sema</name><operator>::</operator><name>TemplateDeductionInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsAddressOfFunction</name> <operator>=</operator> <name>false</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>QualType</name></type> <name>SubstAutoType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>TypeWithAuto</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Replacement</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TypeSourceInfo</name><modifier>*</modifier></type> <name>SubstAutoTypeSourceInfo</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TypeWithAuto</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Replacement</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>ReplaceAutoType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>TypeWithAuto</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Replacement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>ReplaceAutoTypeSourceInfo</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TypeWithAuto</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Replacement</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>DeduceAutoResult</name> <block>{
<decl><name>DAR_Succeeded</name></decl>,
<decl><name>DAR_Failed</name></decl>,
<decl><name>DAR_FailedAlreadyDiagnosed</name></decl>
}</block>;</enum>

<function_decl><type><name>DeduceAutoResult</name></type>
<name>DeduceAutoType</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>AutoType</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>Initializer</name></decl></parameter>, <parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>DependentDeductionDepth</name> <init>= <expr><name>None</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IgnoreConstraints</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeduceAutoResult</name></type>
<name>DeduceAutoType</name><parameter_list>(<parameter><decl><type><name>TypeLoc</name></type> <name>AutoTypeLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>Initializer</name></decl></parameter>, <parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>DependentDeductionDepth</name> <init>= <expr><name>None</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IgnoreConstraints</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DiagnoseAutoDeductionFailure</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>VDecl</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>DeduceReturnType</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DeclareImplicitDeductionGuides</name><parameter_list>(<parameter><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>Template</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>DeduceTemplateSpecializationFromInitializer</name><parameter_list>(
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InitializedEntity</name> <modifier>&amp;</modifier></type><name>Entity</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>InitializationKind</name> <modifier>&amp;</modifier></type><name>Kind</name></decl></parameter>, <parameter><decl><type><name>MultiExprArg</name></type> <name>Init</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>deduceVarTypeFromInitializer</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>VDecl</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSI</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>DirectInit</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>TypeLoc</name></type> <name>getReturnTypeLoc</name><argument_list>(<argument><expr><name>FunctionDecl</name> <operator>*</operator><name>FD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><name>bool</name></type> <name>DeduceFunctionTypeFromReturnExpr</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ReturnLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>RetExpr</name></decl></parameter>, <parameter><decl><type><name>AutoType</name> <modifier>*</modifier></type><name>AT</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>FunctionTemplateDecl</name> <modifier>*</modifier></type><name>getMoreSpecializedTemplate</name><parameter_list>(
<parameter><decl><type><name>FunctionTemplateDecl</name> <modifier>*</modifier></type><name>FT1</name></decl></parameter>, <parameter><decl><type><name>FunctionTemplateDecl</name> <modifier>*</modifier></type><name>FT2</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>TemplatePartialOrderingContext</name></type> <name>TPOC</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumCallArguments1</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumCallArguments2</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Reversed</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>UnresolvedSetIterator</name></type>
<name>getMostSpecialized</name><parameter_list>(<parameter><decl><type><name>UnresolvedSetIterator</name></type> <name>SBegin</name></decl></parameter>, <parameter><decl><type><name>UnresolvedSetIterator</name></type> <name>SEnd</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecCandidateSet</name> <modifier>&amp;</modifier></type><name>FailedCandidates</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>NoneDiag</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>AmbigDiag</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>CandidateDiag</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Complain</name> <init>= <expr><name>true</name></expr></init></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>TargetType</name> <init>= <expr><call><name>QualType</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ClassTemplatePartialSpecializationDecl</name> <modifier>*</modifier></type>
<name>getMoreSpecializedPartialSpecialization</name><parameter_list>(
<parameter><decl><type><name>ClassTemplatePartialSpecializationDecl</name> <modifier>*</modifier></type><name>PS1</name></decl></parameter>,
<parameter><decl><type><name>ClassTemplatePartialSpecializationDecl</name> <modifier>*</modifier></type><name>PS2</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>isMoreSpecializedThanPrimary</name><argument_list>(<argument><expr><name>ClassTemplatePartialSpecializationDecl</name> <operator>*</operator><name>T</name></expr></argument>,
<argument><expr><name>sema</name><operator>::</operator><name>TemplateDeductionInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>VarTemplatePartialSpecializationDecl</name> <modifier>*</modifier></type><name>getMoreSpecializedPartialSpecialization</name><parameter_list>(
<parameter><decl><type><name>VarTemplatePartialSpecializationDecl</name> <modifier>*</modifier></type><name>PS1</name></decl></parameter>,
<parameter><decl><type><name>VarTemplatePartialSpecializationDecl</name> <modifier>*</modifier></type><name>PS2</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>bool</name></type> <name>isMoreSpecializedThanPrimary</name><argument_list>(<argument><expr><name>VarTemplatePartialSpecializationDecl</name> <operator>*</operator><name>T</name></expr></argument>,
<argument><expr><name>sema</name><operator>::</operator><name>TemplateDeductionInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>bool</name></type> <name>isTemplateTemplateParameterAtLeastAsSpecializedAs</name><parameter_list>(
<parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>PParam</name></decl></parameter>, <parameter><decl><type><name>TemplateDecl</name> <modifier>*</modifier></type><name>AArg</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>MarkUsedTemplateParameters</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><name>bool</name> <name>OnlyDeduced</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>Depth</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>SmallBitVector</name> <operator>&amp;</operator><name>Used</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name></type> <name>MarkUsedTemplateParameters</name><argument_list>(<argument><expr><specifier>const</specifier> <name>TemplateArgumentList</name> <operator>&amp;</operator><name>TemplateArgs</name></expr></argument>,
<argument><expr><name>bool</name> <name>OnlyDeduced</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>Depth</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>SmallBitVector</name> <operator>&amp;</operator><name>Used</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name></type> <name>MarkDeducedTemplateParameters</name><argument_list>(
<argument><expr><specifier>const</specifier> <name>FunctionTemplateDecl</name> <operator>*</operator><name>FunctionTemplate</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>SmallBitVector</name> <operator>&amp;</operator><name>Deduced</name></expr></argument>)</argument_list> <block>{<block_content>
<return>return <expr><call><name>MarkDeducedTemplateParameters</name><argument_list>(<argument><expr><name>Context</name></expr></argument>, <argument><expr><name>FunctionTemplate</name></expr></argument>, <argument><expr><name>Deduced</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>MarkDeducedTemplateParameters</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Ctx</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionTemplateDecl</name> <operator>*</operator><name>FunctionTemplate</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>SmallBitVector</name> <operator>&amp;</operator><name>Deduced</name></expr></argument>)</argument_list></decl>;</decl_stmt>





<function_decl><type><name>MultiLevelTemplateArgumentList</name></type>
<name>getTemplateInstantiationArgs</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentList</name> <modifier>*</modifier></type><name>Innermost</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>RelativeToPrimary</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Pattern</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<struct>struct <name>CodeSynthesisContext</name> <block>{

<enum>enum <name>SynthesisKind</name> <block>{


<decl><name>TemplateInstantiation</name></decl>,






<decl><name>DefaultTemplateArgumentInstantiation</name></decl>,




<decl><name>DefaultFunctionArgumentInstantiation</name></decl>,



<decl><name>ExplicitTemplateArgumentSubstitution</name></decl>,






<decl><name>DeducedTemplateArgumentSubstitution</name></decl>,




<decl><name>PriorTemplateArgumentSubstitution</name></decl>,



<decl><name>DefaultTemplateArgumentChecking</name></decl>,



<decl><name>ExceptionSpecEvaluation</name></decl>,



<decl><name>ExceptionSpecInstantiation</name></decl>,


<decl><name>RequirementInstantiation</name></decl>,



<decl><name>NestedRequirementConstraintsCheck</name></decl>,


<decl><name>DeclaringSpecialMember</name></decl>,



<decl><name>DeclaringImplicitEqualityComparison</name></decl>,



<decl><name>DefiningSynthesizedFunction</name></decl>,





<decl><name>ConstraintsCheck</name></decl>,


<decl><name>ConstraintSubstitution</name></decl>,


<decl><name>ConstraintNormalization</name></decl>,



<decl><name>ParameterMappingSubstitution</name></decl>,


<decl><name>RewritingOperatorAsSpaceship</name></decl>,


<decl><name>InitializingStructuredBinding</name></decl>,


<decl><name>MarkingClassDllexported</name></decl>,





<decl><name>Memoization</name></decl>
}</block> <decl><name>Kind</name></decl>;</enum>


<decl_stmt><decl><type><name>bool</name></type> <name>SavedInNonInstantiationSFINAEContext</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Entity</name></decl>;</decl_stmt>




<decl_stmt><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>Template</name></decl>;</decl_stmt>



<decl_stmt><decl><type><specifier>const</specifier> <name>TemplateArgument</name> <modifier>*</modifier></type><name>TemplateArgs</name></decl>;</decl_stmt>



<union>union <block>{

<decl_stmt><decl><type><name>unsigned</name></type> <name>NumTemplateArgs</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>CXXSpecialMember</name></type> <name>SpecialMember</name></decl>;</decl_stmt>
}</block>;</union>

<expr_stmt><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <macro><name>template_arguments</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><name>Kind</name> <operator>!=</operator> <name>DeclaringSpecialMember</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><block>{<expr><name>TemplateArgs</name></expr>, <expr><name>NumTemplateArgs</name></expr>}</block></expr>;</return>
}</block></expr></expr_stmt>



<expr_stmt><expr><name>sema</name><operator>::</operator><name>TemplateDeductionInfo</name> <operator>*</operator><name>DeductionInfo</name></expr>;</expr_stmt>




<decl_stmt><decl><type><name>SourceRange</name></type> <name>InstantiationRange</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>CodeSynthesisContext</name><argument_list>()</argument_list></call>
<operator>:</operator> <call><name>Kind</name><argument_list>(<argument><expr><name>TemplateInstantiation</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>SavedInNonInstantiationSFINAEContext</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Entity</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>Template</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>TemplateArgs</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>NumTemplateArgs</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>DeductionInfo</name><argument_list>(<argument>nullptr</argument>)</argument_list></macro> <expr><block>{}</block>



<name>bool</name> <macro><name>isInstantiationRecord</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
}</block>;</struct>





<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CodeSynthesisContext</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>CodeSynthesisContexts</name></decl>;</decl_stmt>


<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <name>InstantiatingSpecializations</name></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <name>InstantiatedNonDependentTypes</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>Module</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>CodeSynthesisContextLookupModules</name></decl>;</decl_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><name>Module</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>LookupModulesCache</name></expr>;</expr_stmt>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><name>Module</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><call><name>getLookupModules</name><argument_list>()</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name><operator>*</operator></expr></argument>, <argument><expr><name>NamedDecl</name><operator>*</operator></expr></argument>&gt;</argument_list></name> <name>VisibleNamespaceCache</name></expr>;</expr_stmt>






<decl_stmt><decl><type><name>bool</name></type> <name>InNonInstantiationSFINAEContext</name></decl>;</decl_stmt>








<decl_stmt><decl><type><name>unsigned</name></type> <name>NonInstantiationEntries</name></decl>;</decl_stmt>







<decl_stmt><decl><type><name>unsigned</name></type> <name>LastEmittedCodeSynthesisContextDepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>






<expr_stmt><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>TemplateInstantiationCallback</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>TemplateInstCallbacks</name></expr>;</expr_stmt>







<decl_stmt><decl><type><name>int</name></type> <name>ArgumentPackSubstitutionIndex</name></decl>;</decl_stmt>





<decl_stmt><decl><type><name>class</name></type> <name>ArgumentPackSubstitutionIndexRAII</name> <block>{<block_content>
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>Self</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>OldSubstitutionIndex</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>ArgumentPackSubstitutionIndexRAII</name><argument_list>(<argument>Sema &amp;Self</argument>, <argument>int NewSubstitutionIndex</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Self</name><argument_list>(<argument><expr><name>Self</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>OldSubstitutionIndex</name><argument_list>(<argument>Self.ArgumentPackSubstitutionIndex</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>Self</name><operator>.</operator><name>ArgumentPackSubstitutionIndex</name></name> <operator>=</operator> <name>NewSubstitutionIndex</name></expr>;
}</block>

<operator>~</operator><macro><name>ArgumentPackSubstitutionIndexRAII</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>Self</name><operator>.</operator><name>ArgumentPackSubstitutionIndex</name></name> <operator>=</operator> <name>OldSubstitutionIndex</name></expr>;
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ArgumentPackSubstitutionRAII</name></decl>;</decl_stmt>






<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>PartialDiagnosticAt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></expr></argument> &gt;</argument_list></name>
<name>SuppressedDiagnosticsMap</name></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>SuppressedDiagnosticsMap</name></type> <name>SuppressedDiagnostics</name></decl>;</decl_stmt>












<struct>struct <name>InstantiatingTemplate</name> <block>{



<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>Decl *Entity</argument>,
<argument>SourceRange InstantiationRange = SourceRange()</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<struct>struct <name>ExceptionSpecification</name> <block>{}</block>;</struct>


<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>FunctionDecl *Entity</argument>, <argument>ExceptionSpecification</argument>,
<argument>SourceRange InstantiationRange = SourceRange()</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>



<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>TemplateParameter Param</argument>, <argument>TemplateDecl *Template</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; TemplateArgs</argument>,
<argument>SourceRange InstantiationRange = SourceRange()</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>



<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>FunctionTemplateDecl *FunctionTemplate</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; TemplateArgs</argument>,
<argument>CodeSynthesisContext::SynthesisKind Kind</argument>,
<argument>sema::TemplateDeductionInfo &amp;DeductionInfo</argument>,
<argument>SourceRange InstantiationRange = SourceRange()</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>



<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>TemplateDecl *Template</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; TemplateArgs</argument>,
<argument>sema::TemplateDeductionInfo &amp;DeductionInfo</argument>,
<argument>SourceRange InstantiationRange = SourceRange()</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>




<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>ClassTemplatePartialSpecializationDecl *PartialSpec</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; TemplateArgs</argument>,
<argument>sema::TemplateDeductionInfo &amp;DeductionInfo</argument>,
<argument>SourceRange InstantiationRange = SourceRange()</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>




<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>VarTemplatePartialSpecializationDecl *PartialSpec</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; TemplateArgs</argument>,
<argument>sema::TemplateDeductionInfo &amp;DeductionInfo</argument>,
<argument>SourceRange InstantiationRange = SourceRange()</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>



<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>ParmVarDecl *Param</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; TemplateArgs</argument>,
<argument>SourceRange InstantiationRange = SourceRange()</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>



<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>NamedDecl *Template</argument>,
<argument>NonTypeTemplateParmDecl *Param</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; TemplateArgs</argument>,
<argument>SourceRange InstantiationRange</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>



<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>NamedDecl *Template</argument>,
<argument>TemplateTemplateParmDecl *Param</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; TemplateArgs</argument>,
<argument>SourceRange InstantiationRange</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>



<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>TemplateDecl *Template</argument>,
<argument>NamedDecl *Param</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; TemplateArgs</argument>,
<argument>SourceRange InstantiationRange</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<struct>struct <name>ConstraintsCheck</name> <block>{}</block>;</struct>



<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>ConstraintsCheck</argument>, <argument>NamedDecl *Template</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; TemplateArgs</argument>,
<argument>SourceRange InstantiationRange</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<struct>struct <name>ConstraintSubstitution</name> <block>{}</block>;</struct>



<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>ConstraintSubstitution</argument>, <argument>NamedDecl *Template</argument>,
<argument>sema::TemplateDeductionInfo &amp;DeductionInfo</argument>,
<argument>SourceRange InstantiationRange</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<struct>struct <name>ConstraintNormalization</name> <block>{}</block>;</struct>

<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>ConstraintNormalization</argument>, <argument>NamedDecl *Template</argument>,
<argument>SourceRange InstantiationRange</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<struct>struct <name>ParameterMappingSubstitution</name> <block>{}</block>;</struct>


<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>ParameterMappingSubstitution</argument>, <argument>NamedDecl *Template</argument>,
<argument>SourceRange InstantiationRange</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>



<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>concepts::Requirement *Req</argument>,
<argument>sema::TemplateDeductionInfo &amp;DeductionInfo</argument>,
<argument>SourceRange InstantiationRange = SourceRange()</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>



<macro><name>InstantiatingTemplate</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>SourceLocation PointOfInstantiation</argument>,
<argument>concepts::NestedRequirement *Req</argument>, <argument>ConstraintsCheck</argument>,
<argument>SourceRange InstantiationRange = SourceRange()</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<function_decl><type><name>void</name></type> <name>Clear</name><parameter_list>()</parameter_list>;</function_decl>

<expr_stmt><expr><operator>~</operator><macro><name>InstantiatingTemplate</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name>Clear</name><argument_list>()</argument_list></call></expr>; }</block>



<name>bool</name> <macro><name>isInvalid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Invalid</name></expr>;</return> }</block></expr></expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isAlreadyInstantiating</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>AlreadyInstantiating</name></expr>;</return> }</block></expr></expr_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Invalid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>AlreadyInstantiating</name></decl>;</decl_stmt>
<function_decl><type><name>bool</name></type> <name>CheckInstantiationDepth</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>InstantiationRange</name></decl></parameter>)</parameter_list>;</function_decl>

<macro><name>InstantiatingTemplate</name><argument_list>(
<argument>Sema &amp;SemaRef</argument>, <argument>CodeSynthesisContext::SynthesisKind Kind</argument>,
<argument>SourceLocation PointOfInstantiation</argument>, <argument>SourceRange InstantiationRange</argument>,
<argument>Decl *Entity</argument>, <argument>NamedDecl *Template = nullptr</argument>,
<argument>ArrayRef&lt;TemplateArgument&gt; TemplateArgs = None</argument>,
<argument>sema::TemplateDeductionInfo *DeductionInfo = nullptr</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<expr_stmt><expr><call><name>InstantiatingTemplate</name><argument_list>(<argument><expr><specifier>const</specifier> <name>InstantiatingTemplate</name><operator>&amp;</operator></expr></argument>)</argument_list></call> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>InstantiatingTemplate</name><modifier>&amp;</modifier></type>
<name>operator</name><init>=<expr><operator>(</operator><specifier>const</specifier> <name>InstantiatingTemplate</name><operator>&amp;</operator><operator>)</operator> <operator>=</operator> <name>delete</name></expr></init></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><name>void</name></type> <name>pushCodeSynthesisContext</name><parameter_list>(<parameter><decl><type><name>CodeSynthesisContext</name></type> <name>Ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>popCodeSynthesisContext</name><parameter_list>()</parameter_list>;</function_decl>


<expr_stmt><expr><name>bool</name> <macro><name>inTemplateInstantiation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>CodeSynthesisContexts</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>NonInstantiationEntries</name></expr>;</return>
}</block></expr></expr_stmt>

<function><type><name>void</name></type> <name>PrintContextStack</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>CodeSynthesisContexts</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>CodeSynthesisContexts</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>!=</operator> <name>LastEmittedCodeSynthesisContextDepth</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>PrintInstantiationStack</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>LastEmittedCodeSynthesisContextDepth</name> <operator>=</operator> <call><name><name>CodeSynthesisContexts</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>PragmaAttributeCurrentTargetDecl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PrintPragmaAttributeInstantiationPoint</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<function_decl><type><name>void</name></type> <name>PrintInstantiationStack</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>PrintPragmaAttributeInstantiationPoint</name><parameter_list>()</parameter_list>;</function_decl>









<expr_stmt><expr><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>sema</name><operator>::</operator><name>TemplateDeductionInfo</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>isSFINAEContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>



<expr_stmt><expr><name>bool</name> <macro><name>isUnevaluatedContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><call><name><name>ExprEvalContexts</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"Must be in an expression evaluation context"</literal></expr></argument>)</argument_list></call></expr>;
<return>return <expr><call><name><name>ExprEvalContexts</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>isUnevaluated</name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>




<decl_stmt><decl><type><name>class</name></type> <name>SFINAETrap</name> <block>{<block_content>
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>PrevSFINAEErrors</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>PrevInNonInstantiationSFINAEContext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>PrevAccessCheckingSFINAE</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>PrevLastDiagnosticIgnored</name></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <macro><name>SFINAETrap</name><argument_list>(<argument>Sema &amp;SemaRef</argument>, <argument>bool AccessCheckingSFINAE = false</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>SemaRef</name><argument_list>(<argument><expr><name>SemaRef</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>PrevSFINAEErrors</name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>NumSFINAEErrors</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>PrevInNonInstantiationSFINAEContext</name><argument_list>(
<argument><expr><name><name>SemaRef</name><operator>.</operator><name>InNonInstantiationSFINAEContext</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>PrevAccessCheckingSFINAE</name><argument_list>(<argument><expr><name><name>SemaRef</name><operator>.</operator><name>AccessCheckingSFINAE</name></name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>PrevLastDiagnosticIgnored</name><argument_list>(
<argument>SemaRef.getDiagnostics().isLastDiagnosticIgnored()</argument>)</argument_list></macro>
<expr><block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>SemaRef</name><operator>.</operator><name>isSFINAEContext</name></name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>SemaRef</name><operator>.</operator><name>InNonInstantiationSFINAEContext</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<name><name>SemaRef</name><operator>.</operator><name>AccessCheckingSFINAE</name></name> <operator>=</operator> <name>AccessCheckingSFINAE</name></block></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<expr_stmt><expr><operator>~</operator><macro><name>SFINAETrap</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>SemaRef</name><operator>.</operator><name>NumSFINAEErrors</name></name> <operator>=</operator> <name>PrevSFINAEErrors</name></expr>;
<expr><name><name>SemaRef</name><operator>.</operator><name>InNonInstantiationSFINAEContext</name></name>
<operator>=</operator> <name>PrevInNonInstantiationSFINAEContext</name></expr>;
<expr><name><name>SemaRef</name><operator>.</operator><name>AccessCheckingSFINAE</name></name> <operator>=</operator> <name>PrevAccessCheckingSFINAE</name></expr>;
<expr><call><name><name>SemaRef</name><operator>.</operator><name>getDiagnostics</name></name><argument_list>()</argument_list></call><operator>.</operator><call><name>setLastDiagnosticIgnored</name><argument_list>(
<argument><expr><name>PrevLastDiagnosticIgnored</name></expr></argument>)</argument_list></call></expr>;
}</block>


<name>bool</name> <macro><name>hasErrorOccurred</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name><name>SemaRef</name><operator>.</operator><name>NumSFINAEErrors</name></name> <operator>&gt;</operator> <name>PrevSFINAEErrors</name></expr>;</return>
}</block></expr></expr_stmt>
};





<decl_stmt><decl><type><name>class</name></type> <name>TentativeAnalysisScope</name> <block>{<block_content>
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>SemaRef</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SFINAETrap</name></type> <name>Trap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>PrevDisableTypoCorrection</name></decl>;</decl_stmt>
<label><name>public</name>:</label>
<macro><name>explicit</name></macro> <expr_stmt><expr><call><name>TentativeAnalysisScope</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>SemaRef</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>SemaRef</name><argument_list>(<argument><expr><name>SemaRef</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Trap</name><argument_list>(<argument><expr><name>SemaRef</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>PrevDisableTypoCorrection</name><argument_list>(<argument>SemaRef.DisableTypoCorrection</argument>)</argument_list></macro> <expr><block>{
<expr><name><name>SemaRef</name><operator>.</operator><name>DisableTypoCorrection</name></name> <operator>=</operator> <name>true</name></expr>;
}</block>
<operator>~</operator><macro><name>TentativeAnalysisScope</name><argument_list>()</argument_list></macro> <block>{
<expr><name><name>SemaRef</name><operator>.</operator><name>DisableTypoCorrection</name></name> <operator>=</operator> <name>PrevDisableTypoCorrection</name></expr>;
}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<decl_stmt><decl><type><name>LocalInstantiationScope</name> <modifier>*</modifier></type><name>CurrentInstantiationScope</name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>bool</name></type> <name>DisableTypoCorrection</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>unsigned</name></type> <name>TyposCorrected</name></decl>;</decl_stmt>

<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>SmallSet</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>&gt;</argument_list></name> <name>SrcLocSet</name></expr>;</expr_stmt></typedef>
<typedef>typedef <expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>SrcLocSet</name></expr></argument>&gt;</argument_list></name> <name>IdentifierSourceLocations</name></expr>;</expr_stmt></typedef>




<decl_stmt><decl><type><name>IdentifierSourceLocations</name></type> <name>TypoCorrectionFailures</name></decl>;</decl_stmt>


<expr_stmt><expr><name>sema</name><operator>::</operator><name>AnalysisBasedWarnings</name> <name>AnalysisWarnings</name></expr>;</expr_stmt>
<expr_stmt><expr><name>threadSafety</name><operator>::</operator><name>BeforeSet</name> <operator>*</operator><name>ThreadSafetyDeclCache</name></expr>;</expr_stmt>









<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <name>PendingImplicitInstantiation</name></expr>;</expr_stmt></typedef>



<expr_stmt><expr><name>std</name><operator>::</operator><name><name>deque</name><argument_list type="generic">&lt;<argument><expr><name>PendingImplicitInstantiation</name></expr></argument>&gt;</argument_list></name> <name>PendingInstantiations</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>PendingImplicitInstantiation</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>&gt;</argument_list></name></type> <name>LateParsedInstantiations</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>GlobalEagerInstantiationScope</name> <block>{<block_content>
<label><name>public</name>:</label>
<macro><name>GlobalEagerInstantiationScope</name><argument_list>(<argument>Sema &amp;S</argument>, <argument>bool Enabled</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>S</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Enabled</name><argument_list>(<argument>Enabled</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Enabled</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>

<call><name><name>SavedPendingInstantiations</name><operator>.</operator><name>swap</name></name><argument_list>(<argument><expr><name><name>S</name><operator>.</operator><name>PendingInstantiations</name></name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SavedVTableUses</name><operator>.</operator><name>swap</name></name><argument_list>(<argument><expr><name><name>S</name><operator>.</operator><name>VTableUses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><name>void</name></type> <name>perform</name><parameter_list>()</parameter_list> <block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>Enabled</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>DefineUsedVTables</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>PerformPendingInstantiations</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<expr_stmt><expr><operator>~</operator><macro><name>GlobalEagerInstantiationScope</name><argument_list>()</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Enabled</name></expr>)</condition><block type="pseudo"><block_content> <return>return;</return></block_content></block></if></if_stmt>


<call><name>assert</name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>VTableUses</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"VTableUses should be empty before it is discarded."</literal></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>VTableUses</name><operator>.</operator><name>swap</name></name><argument_list>(<argument><expr><name>SavedVTableUses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>S</name><operator>.</operator><name>TUKind</name></name> <operator>!=</operator> <name>TU_Prefix</name> <operator>||</operator> <operator>!</operator><name><name>S</name><operator>.</operator><name>LangOpts</name><operator>.</operator><name>PCHInstantiateTemplates</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>PendingInstantiations</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"PendingInstantiations should be empty before it is discarded."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>PendingInstantiations</name><operator>.</operator><name>swap</name></name><argument_list>(<argument><expr><name>SavedPendingInstantiations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>PendingInstantiations</name><operator>.</operator><name>swap</name></name><argument_list>(<argument><expr><name>SavedPendingInstantiations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>S</name><operator>.</operator><name>PendingInstantiations</name><operator>.</operator><name>insert</name></name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>PendingInstantiations</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SavedPendingInstantiations</name><operator>.</operator><name>begin</name></name><argument_list>()</argument_list></call></expr></argument>,
<argument><expr><call><name><name>SavedPendingInstantiations</name><operator>.</operator><name>end</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
}

private:
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>VTableUse</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>SavedVTableUses</name></decl>;</decl_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>deque</name><argument_list type="generic">&lt;<argument><expr><name>PendingImplicitInstantiation</name></expr></argument>&gt;</argument_list></name> <name>SavedPendingInstantiations</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Enabled</name></decl>;</decl_stmt>
};








<expr_stmt><expr><name>std</name><operator>::</operator><name><name>deque</name><argument_list type="generic">&lt;<argument><expr><name>PendingImplicitInstantiation</name></expr></argument>&gt;</argument_list></name> <name>PendingLocalImplicitInstantiations</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>LocalEagerInstantiationScope</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>LocalEagerInstantiationScope</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>S</name><argument_list>(<argument>S</argument>)</argument_list></macro> <block>{
<expr><call><name><name>SavedPendingLocalImplicitInstantiations</name><operator>.</operator><name>swap</name></name><argument_list>(
<argument><expr><name><name>S</name><operator>.</operator><name>PendingLocalImplicitInstantiations</name></name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>void</name> <macro><name>perform</name><argument_list>()</argument_list></macro> <block>{ <expr><call><name><name>S</name><operator>.</operator><name>PerformPendingInstantiations</name></name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>; }</block>

<operator>~</operator><macro><name>LocalEagerInstantiationScope</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>PendingLocalImplicitInstantiations</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"there shouldn't be any pending local implicit instantiations"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name><name>SavedPendingLocalImplicitInstantiations</name><operator>.</operator><name>swap</name></name><argument_list>(
<argument><expr><name><name>S</name><operator>.</operator><name>PendingLocalImplicitInstantiations</name></name></expr></argument>)</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>Sema</name> <operator>&amp;</operator><name>S</name></expr>;</expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>deque</name><argument_list type="generic">&lt;<argument><expr><name>PendingImplicitInstantiation</name></expr></argument>&gt;</argument_list></name>
<name>SavedPendingLocalImplicitInstantiations</name></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


<decl_stmt><decl><type><name>class</name></type> <name>ExtParameterInfoBuilder</name> <block>{<block_content>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>FunctionProtoType</name><operator>::</operator><name>ExtParameterInfo</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>Infos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasInteresting</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>


<decl_stmt><decl><type><name>void</name></type> <name>set</name><argument_list>(<argument><expr><name>unsigned</name> <name>index</name></expr></argument>, <argument><expr><name>FunctionProtoType</name><operator>::</operator><name>ExtParameterInfo</name> <name>info</name></expr></argument>)</argument_list> <block>{<block_content>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>Infos</name><operator>.</operator><name>size</name></name><argument_list>()</argument_list></call> <operator>&lt;=</operator> <name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Infos</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>Infos</name><operator>.</operator><name>push_back</name></name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HasInteresting</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>HasInteresting</name> <operator>=</operator> <operator>(</operator><name>info</name> <operator>!=</operator> <name>FunctionProtoType</name><operator>::</operator><call><name>ExtParameterInfo</name><argument_list>()</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></decl></decl_stmt>



<expr_stmt><expr><specifier>const</specifier> <name>FunctionProtoType</name><operator>::</operator><name>ExtParameterInfo</name> <operator>*</operator>
<macro><name>getPointerOrNull</name><argument_list>(<argument>unsigned numParams</argument>)</argument_list></macro> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HasInteresting</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><name>nullptr</name></expr>;</return></block_content></block></if></if_stmt>
<call><name><name>Infos</name><operator>.</operator><name>resize</name></name><argument_list>(<argument><expr><name>numParams</name></expr></argument>)</argument_list></call></block></expr>;</expr_stmt>
<return>return <expr><call><name><name>Infos</name><operator>.</operator><name>data</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></decl></decl_stmt>
};

<function_decl><type><name>void</name></type> <name>PerformPendingInstantiations</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>LocalOnly</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>SubstType</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>T</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>Entity</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowDeducedTST</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>SubstType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>Entity</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>SubstType</name><parameter_list>(<parameter><decl><type><name>TypeLoc</name></type> <name>TL</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>Entity</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>SubstFunctionDeclType</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>T</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>DeclarationName</name></type> <name>Entity</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ThisContext</name></decl></parameter>,
<parameter><decl><type><name>Qualifiers</name></type> <name>ThisTypeQuals</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>SubstExceptionSpec</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Proto</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>Args</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>bool</name></type> <name>SubstExceptionSpec</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>FunctionProtoType</name><operator>::</operator><name>ExceptionSpecInfo</name> <operator>&amp;</operator><name>ESI</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>ExceptionStorage</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <operator>&amp;</operator><name>Args</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>SubstParmVarDecl</name><parameter_list>(<parameter><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>indexAdjustment</name></decl></parameter>,
<parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>NumExpansions</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ExpectParameterPack</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>bool</name></type> <name>SubstParmTypes</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Params</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>FunctionProtoType</name><operator>::</operator><name>ExtParameterInfo</name> <operator>*</operator><name>ExtParamInfos</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <operator>&amp;</operator><name>TemplateArgs</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>&gt;</argument_list></name> <operator>&amp;</operator><name>ParamTypes</name></expr></argument>,
<argument><expr><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ParmVarDecl</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <operator>*</operator><name>OutParams</name></expr></argument>,
<argument><expr><name>ExtParameterInfoBuilder</name> <operator>&amp;</operator><name>ParamInfos</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>ExprResult</name></type> <name>SubstExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>














<function_decl><type><name>bool</name></type> <name>SubstExprs</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Exprs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsCall</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Outputs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>SubstStmt</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type>
<name>SubstTemplateParams</name><parameter_list>(<parameter><decl><type><name>TemplateParameterList</name> <modifier>*</modifier></type><name>Params</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>Owner</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type>
<name>SubstTemplateArguments</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgumentLoc</name></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>Outputs</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>SubstDecl</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>Owner</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>SubstSpaceshipAsEqualEqual</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Spaceship</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>SubstInitializer</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>CXXDirectInit</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type>
<name>SubstBaseSpecifiers</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Instantiation</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type>
<name>InstantiateClass</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Instantiation</name></decl></parameter>, <parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Complain</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>InstantiateEnum</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl></parameter>,
<parameter><decl><type><name>EnumDecl</name> <modifier>*</modifier></type><name>Instantiation</name></decl></parameter>, <parameter><decl><type><name>EnumDecl</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>InstantiateInClassInitializer</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl></parameter>, <parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Instantiation</name></decl></parameter>,
<parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>LateInstantiatedAttribute</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>Attr</name> <modifier>*</modifier></type><name>TmplAttr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>LocalInstantiationScope</name> <modifier>*</modifier></type><name>Scope</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>NewDecl</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>LateInstantiatedAttribute</name><argument_list>(<argument><expr><specifier>const</specifier> <name>Attr</name> <operator>*</operator><name>A</name></expr></argument>, <argument><expr><name>LocalInstantiationScope</name> <operator>*</operator><name>S</name></expr></argument>,
<argument><expr><name>Decl</name> <operator>*</operator><name>D</name></expr></argument>)</argument_list></call>
<operator>:</operator> <call><name>TmplAttr</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Scope</name><argument_list>(<argument><expr><name>S</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>NewDecl</name><argument_list>(<argument>D</argument>)</argument_list></macro>
<expr><block>{ }</block></expr></expr_stmt>
}</block>;</struct>
<typedef>typedef <type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>LateInstantiatedAttribute</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>&gt;</argument_list></name></type> <name>LateInstantiatedAttrVec</name>;</typedef>

<function_decl><type><name>void</name></type> <name>InstantiateAttrs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Inst</name></decl></parameter>,
<parameter><decl><type><name>LateInstantiatedAttrVec</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>LocalInstantiationScope</name> <modifier>*</modifier></type><name>OuterMostScope</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type>
<name>InstantiateAttrsForDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Decl</name> <modifier>*</modifier></type><name>Pattern</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Inst</name></decl></parameter>,
<parameter><decl><type><name>LateInstantiatedAttrVec</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>LocalInstantiationScope</name> <modifier>*</modifier></type><name>OuterMostScope</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>InstantiateDefaultCtorDefaultArgs</name><parameter_list>(<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Ctor</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>usesPartialOrExplicitSpecialization</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>ClassTemplateSpecializationDecl</name> <modifier>*</modifier></type><name>ClassTemplateSpec</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type>
<name>InstantiateClassTemplateSpecialization</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl></parameter>,
<parameter><decl><type><name>ClassTemplateSpecializationDecl</name> <modifier>*</modifier></type><name>ClassTemplateSpec</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Complain</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>InstantiateClassMembers</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl></parameter>,
<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>Instantiation</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>InstantiateClassTemplateSpecializationMembers</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl></parameter>,
<parameter><decl><type><name>ClassTemplateSpecializationDecl</name> <modifier>*</modifier></type><name>ClassTemplateSpec</name></decl></parameter>,
<parameter><decl><type><name>TemplateSpecializationKind</name></type> <name>TSK</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>NestedNameSpecifierLoc</name></type>
<name>SubstNestedNameSpecifierLoc</name><parameter_list>(<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>NNS</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclarationNameInfo</name></type>
<name>SubstDeclarationNameInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>NameInfo</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>TemplateName</name></type>
<name>SubstTemplateName</name><parameter_list>(<parameter><decl><type><name>NestedNameSpecifierLoc</name></type> <name>QualifierLoc</name></decl></parameter>, <parameter><decl><type><name>TemplateName</name></type> <name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>Subst</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentLoc</name> <modifier>*</modifier></type><name>Args</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumArgs</name></decl></parameter>,
<parameter><decl><type><name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>Result</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>InstantiateDefaultArgument</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CallLoc</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><name>ParmVarDecl</name> <modifier>*</modifier></type><name>Param</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>InstantiateExceptionSpec</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Function</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckInstantiatedFunctionTemplateConstraints</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name></type> <name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>ConstraintSatisfaction</name> <modifier>&amp;</modifier></type><name>Satisfaction</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>InstantiateFunctionDeclaration</name><parameter_list>(<parameter><decl><type><name>FunctionTemplateDecl</name> <modifier>*</modifier></type><name>FTD</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentList</name> <modifier>*</modifier></type><name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>InstantiateFunctionDefinition</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Function</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Recursive</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DefinitionRequired</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AtEndOfTU</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>VarTemplateSpecializationDecl</name> <modifier>*</modifier></type><name>BuildVarTemplateInstantiation</name><parameter_list>(
<parameter><decl><type><name>VarTemplateDecl</name> <modifier>*</modifier></type><name>VarTemplate</name></decl></parameter>, <parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>FromVar</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgList</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>TemplateArgumentListInfo</name> <modifier>&amp;</modifier></type><name>TemplateArgsInfo</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>TemplateArgument</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Converted</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl></parameter>,
<parameter><decl><type><name>LateInstantiatedAttrVec</name> <modifier>*</modifier></type><name>LateAttrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>LocalInstantiationScope</name> <modifier>*</modifier></type><name>StartingScope</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>VarTemplateSpecializationDecl</name> <modifier>*</modifier></type><name>CompleteVarTemplateSpecializationDecl</name><parameter_list>(
<parameter><decl><type><name>VarTemplateSpecializationDecl</name> <modifier>*</modifier></type><name>VarSpec</name></decl></parameter>, <parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>PatternDecl</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type>
<name>BuildVariableInstantiation</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>NewVar</name></decl></parameter>, <parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>OldVar</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>LateInstantiatedAttrVec</name> <modifier>*</modifier></type><name>LateAttrs</name></decl></parameter>,
<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>Owner</name></decl></parameter>,
<parameter><decl><type><name>LocalInstantiationScope</name> <modifier>*</modifier></type><name>StartingScope</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>InstantiatingVarTemplate</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>VarTemplateSpecializationDecl</name> <modifier>*</modifier></type><name>PrevVTSD</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>InstantiateVariableInitializer</name><parameter_list>(
<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Var</name></decl></parameter>, <parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>OldVar</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>InstantiateVariableDefinition</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PointOfInstantiation</name></decl></parameter>,
<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Var</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Recursive</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DefinitionRequired</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AtEndOfTU</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>InstantiateMemInitializers</name><parameter_list>(<parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>New</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>Tmpl</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FindInstantiatedDecl</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>FindingInstantiatedContext</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>FindInstantiatedContext</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>MultiLevelTemplateArgumentList</name> <modifier>&amp;</modifier></type><name>TemplateArgs</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>ObjCContainerKind</name> <block>{
<decl><name>OCK_None</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
<decl><name>OCK_Interface</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>OCK_Protocol</name></decl>,
<decl><name>OCK_Category</name></decl>,
<decl><name>OCK_ClassExtension</name></decl>,
<decl><name>OCK_Implementation</name></decl>,
<decl><name>OCK_CategoryImplementation</name></decl>
}</block>;</enum>
<expr_stmt><expr><name>ObjCContainerKind</name> <macro><name>getObjCContainerKind</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<function_decl><type><name>DeclResult</name></type> <name>actOnObjCTypeParam</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>ObjCTypeParamVariance</name></type> <name>variance</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>varianceLoc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>index</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>paramName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>paramLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>colonLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>typeBound</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ObjCTypeParamList</name> <modifier>*</modifier></type><name>actOnObjCTypeParamList</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>lAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>typeParams</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>rAngleLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>popObjCTypeParamList</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>ObjCTypeParamList</name> <modifier>*</modifier></type><name>typeParamList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnStartClassInterface</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>AtInterfaceLoc</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ClassName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ClassLoc</name></decl></parameter>, <parameter><decl><type><name>ObjCTypeParamList</name> <modifier>*</modifier></type><name>typeParamList</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>SuperName</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParsedType</name></expr></argument>&gt;</argument_list></name></type> <name>SuperTypeArgs</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>SuperTypeArgsRange</name></decl></parameter>,
<parameter><decl><type><name>Decl</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ProtoRefs</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumProtoRefs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceLocation</name> <modifier>*</modifier></type><name>ProtoLocs</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndProtoLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnSuperClassOfClassInterface</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AtInterfaceLoc</name></decl></parameter>,
<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>IDecl</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ClassName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ClassLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>SuperName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParsedType</name></expr></argument>&gt;</argument_list></name></type> <name>SuperTypeArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceRange</name></type> <name>SuperTypeArgsRange</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnTypedefedProtocols</name><parameter_list>(<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>ProtocolRefs</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>ProtocolLocs</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>SuperName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnCompatibilityAlias</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>AtCompatibilityAliasLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>AliasName</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>AliasLocation</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ClassName</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ClassLocation</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckForwardProtocolDeclarationForCircularDependency</name><parameter_list>(
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>PName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>PLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>PrevLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>ObjCList</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>PList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnStartProtocolInterface</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>AtProtoInterfaceLoc</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ProtocolName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtocolLoc</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ProtoRefNames</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumProtoRefs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SourceLocation</name> <modifier>*</modifier></type><name>ProtoLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndProtoLoc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnStartCategoryInterface</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>AtInterfaceLoc</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ClassName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ClassLoc</name></decl></parameter>, <parameter><decl><type><name>ObjCTypeParamList</name> <modifier>*</modifier></type><name>typeParamList</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>CategoryName</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>CategoryLoc</name></decl></parameter>,
<parameter><decl><type><name>Decl</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>ProtoRefs</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumProtoRefs</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>SourceLocation</name> <modifier>*</modifier></type><name>ProtoLocs</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndProtoLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnStartClassImplementation</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtClassImplLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ClassName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ClassLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>SuperClassname</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>SuperClassLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnStartCategoryImplementation</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtCatImplLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ClassName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ClassLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>CatName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CatLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>AttrList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ActOnFinishObjCImplementation</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ObjCImpDecl</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Decls</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ActOnForwardClassDeclaration</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier><modifier>*</modifier></type><name>IdentList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>*</modifier></type><name>IdentLocs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ObjCTypeParamList</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>TypeParamLists</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>NumElts</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclGroupPtrTy</name></type>
<name>ActOnForwardProtocolDeclaration</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>AtProtoclLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierLocPair</name></expr></argument>&gt;</argument_list></name></type> <name>IdentList</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>attrList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>FindProtocolDeclaration</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>WarnOnDeclarations</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ForObjCContainer</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierLocPair</name></expr></argument>&gt;</argument_list></name></type> <name>ProtocolId</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Protocols</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseTypeArgsAndProtocols</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ProtocolId</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtocolLoc</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>TypeArgId</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeArgLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>SelectProtocolFirst</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>actOnObjCTypeArgsOrProtocolQualifiers</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>baseType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>lAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>identifiers</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>identifierLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>rAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>typeArgsLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>ParsedType</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>typeArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>typeArgsRAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>protocolLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>protocols</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name> <modifier>&amp;</modifier></type><name>protocolRAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>warnOnIncompleteProtocols</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>TypeResult</name></type> <name>actOnObjCProtocolQualifierType</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>lAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>protocols</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>protocolLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>rAngleLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>TypeResult</name></type> <name>actOnObjCTypeArgsAndProtocolQualifiers</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>BaseType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeArgsLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ParsedType</name></expr></argument>&gt;</argument_list></name></type> <name>TypeArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeArgsRAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtocolLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Protocols</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>ProtocolLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtocolRAngleLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>BuildObjCTypeParamType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCTypeParamDecl</name> <modifier>*</modifier></type><name>Decl</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtocolLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Protocols</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>ProtocolLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtocolRAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>FailOnError</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>BuildObjCObjectType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeArgsLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>TypeSourceInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>TypeArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>TypeArgsRAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtocolLAngleLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>ObjCProtocolDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Protocols</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>ProtocolLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ProtocolRAngleLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>FailOnError</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>CheckObjCPropertyAttributes</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>PropertyPtrTy</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>Attributes</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>propertyInPrimaryClass</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>ProcessPropertyDecl</name><parameter_list>(<parameter><decl><type><name>ObjCPropertyDecl</name> <modifier>*</modifier></type><name>property</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>DiagnosePropertyMismatch</name><parameter_list>(<parameter><decl><type><name>ObjCPropertyDecl</name> <modifier>*</modifier></type><name>Property</name></decl></parameter>,
<parameter><decl><type><name>ObjCPropertyDecl</name> <modifier>*</modifier></type><name>SuperProperty</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>OverridingProtocolProperty</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseClassExtensionDupMethods</name><parameter_list>(<parameter><decl><type><name>ObjCCategoryDecl</name> <modifier>*</modifier></type><name>CAT</name></decl></parameter>,
<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>ID</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnAtEnd</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>AtEnd</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>allMethods</name> <init>= <expr><name>None</name></expr></init></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>DeclGroupPtrTy</name></expr></argument>&gt;</argument_list></name></type> <name>allTUVars</name> <init>= <expr><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnProperty</name><argument_list>(<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>AtLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>LParenLoc</name></expr></argument>,
<argument><expr><name>FieldDeclarator</name> <operator>&amp;</operator><name>FD</name></expr></argument>, <argument><expr><name>ObjCDeclSpec</name> <operator>&amp;</operator><name>ODS</name></expr></argument>,
<argument><expr><name>Selector</name> <name>GetterSel</name></expr></argument>, <argument><expr><name>Selector</name> <name>SetterSel</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>ObjCKeywordKind</name> <name>MethodImplKind</name></expr></argument>,
<argument><expr><name>DeclContext</name> <operator>*</operator><name>lexicalDC</name> <operator>=</operator> <name>nullptr</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnPropertyImplDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AtLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PropertyLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ImplKind</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>PropertyId</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>PropertyIvar</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PropertyIvarLoc</name></decl></parameter>,
<parameter><decl><type><name>ObjCPropertyQueryKind</name></type> <name>QueryKind</name></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>ObjCSpecialMethodKind</name> <block>{
<decl><name>OSMK_None</name></decl>,
<decl><name>OSMK_Alloc</name></decl>,
<decl><name>OSMK_New</name></decl>,
<decl><name>OSMK_Copy</name></decl>,
<decl><name>OSMK_RetainingInit</name></decl>,
<decl><name>OSMK_NonRetainingInit</name></decl>
}</block>;</enum>

<struct>struct <name>ObjCArgInfo</name> <block>{
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ParsedType</name></type> <name>Type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ObjCDeclSpec</name></type> <name>DeclSpec</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>ParsedAttributesView</name></type> <name>ArgAttrs</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ActOnMethodDeclaration</name><argument_list>(
<argument><expr><name>Scope</name> <operator>*</operator><name>S</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>BeginLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>EndLoc</name></expr></argument>,
<argument><expr><name>tok</name><operator>::</operator><name>TokenKind</name> <name>MethodType</name></expr></argument>, <argument><expr><name>ObjCDeclSpec</name> <operator>&amp;</operator><name>ReturnQT</name></expr></argument>, <argument><expr><name>ParsedType</name> <name>ReturnType</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name> <name>SelectorLocs</name></expr></argument>, <argument><expr><name>Selector</name> <name>Sel</name></expr></argument>,


<argument><expr><name>ObjCArgInfo</name> <operator>*</operator><name>ArgInfo</name></expr></argument>, <argument><expr><name>DeclaratorChunk</name><operator>::</operator><name>ParamInfo</name> <operator>*</operator><name>CParamInfo</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>CNumArgs</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>ParsedAttributesView</name> <operator>&amp;</operator><name>AttrList</name></expr></argument>, <argument><expr><name>tok</name><operator>::</operator><name>ObjCKeywordKind</name> <name>MethodImplKind</name></expr></argument>,
<argument><expr><name>bool</name> <name>isVariadic</name></expr></argument>, <argument><expr><name>bool</name> <name>MethodDefinition</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>LookupMethodInQualifiedType</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectPointerType</name> <modifier>*</modifier></type><name>OPT</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsInstance</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>LookupMethodInObjectType</name><parameter_list>(<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsInstance</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckARCMethodDecl</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>method</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>inferObjCARCLifetime</name><parameter_list>(<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>deduceOpenCLAddressSpace</name><parameter_list>(<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>decl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type>
<name>HandleExprPropertyRefExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjCObjectPointerType</name> <modifier>*</modifier></type><name>OPT</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BaseExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>DeclarationName</name></type> <name>MemberName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>MemberLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>SuperType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Super</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type>
<name>ActOnClassPropertyRefExpr</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>receiverName</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>propertyName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>receiverNameLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>propertyNameLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>tryCaptureObjCSelf</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>ObjCMessageKind</name> <block>{

<decl><name>ObjCSuperMessage</name></decl>,

<decl><name>ObjCInstanceMessage</name></decl>,


<decl><name>ObjCClassMessage</name></decl>
}</block>;</enum>

<function_decl><type><name>ObjCMessageKind</name></type> <name>getObjCMessageKind</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsSuper</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>HasTrailingDot</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name> <modifier>&amp;</modifier></type><name>ReceiverType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnSuperMessage</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>,
<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBracLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>SelectorLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBracLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildClassMessage</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>ReceiverTypeInfo</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ReceiverType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>,
<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBracLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>SelectorLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBracLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isImplicit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildClassMessageImplicit</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ReceiverType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isSuperReceiver</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnClassMessage</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>Receiver</name></decl></parameter>,
<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBracLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>SelectorLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBracLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildInstanceMessage</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Receiver</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ReceiverType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>,
<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBracLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>SelectorLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBracLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isImplicit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildInstanceMessageImplicit</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Receiver</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ReceiverType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnInstanceMessage</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Receiver</name></decl></parameter>,
<parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LBracLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>SelectorLocs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RBracLoc</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildObjCBridgedCast</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>ObjCBridgeCastKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>BridgeKeywordLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TSInfo</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnObjCBridgedCast</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>ObjCBridgeCastKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>BridgeKeywordLoc</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>Type</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckTollFreeBridgeCast</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>castType</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>castExpr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckObjCBridgeRelatedCast</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>castType</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>castExpr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckTollFreeBridgeStaticCast</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>castType</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>castExpr</name></decl></parameter>,
<parameter><decl><type><name>CastKind</name> <modifier>&amp;</modifier></type><name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>checkObjCBridgeRelatedComponents</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>DestType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>SrcType</name></decl></parameter>,
<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>RelatedClass</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>ClassMethod</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>InstanceMethod</name></decl></parameter>,
<parameter><decl><type><name>TypedefNameDecl</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>TDNDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>CfToNs</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckObjCBridgeRelatedConversions</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>DestType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>SrcType</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>SrcExpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckConversionToObjCLiteral</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>DstType</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>SrcExpr</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>checkInitMethod</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>method</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>receiverTypeIfCall</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>CheckObjCMethodOverride</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>NewMethod</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Overridden</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>ResultTypeCompatibilityKind</name> <block>{
<decl><name>RTC_Compatible</name></decl>,
<decl><name>RTC_Incompatible</name></decl>,
<decl><name>RTC_Unknown</name></decl>
}</block>;</enum>

<function_decl><type><name>void</name></type> <name>CheckObjCMethodDirectOverrides</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>method</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>overridden</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckObjCMethodOverrides</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>ObjCMethod</name></decl></parameter>,
<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>CurrentClass</name></decl></parameter>,
<parameter><decl><type><name>ResultTypeCompatibilityKind</name></type> <name>RTC</name></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>PragmaOptionsAlignKind</name> <block>{
<decl><name>POAK_Native</name></decl>,
<decl><name>POAK_Natural</name></decl>,
<decl><name>POAK_Packed</name></decl>,
<decl><name>POAK_Power</name></decl>,
<decl><name>POAK_Mac68k</name></decl>,
<decl><name>POAK_Reset</name></decl>
}</block>;</enum>


<function_decl><type><name>void</name></type> <name>ActOnPragmaClangSection</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLoc</name></decl></parameter>,
<parameter><decl><type><name>PragmaClangSectionAction</name></type> <name>Action</name></decl></parameter>,
<parameter><decl><type><name>PragmaClangSectionKind</name></type> <name>SecKind</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>SecName</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnPragmaOptionsAlign</name><parameter_list>(<parameter><decl><type><name>PragmaOptionsAlignKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnPragmaPack</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLoc</name></decl></parameter>, <parameter><decl><type><name>PragmaMsStackAction</name></type> <name>Action</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>SlotLabel</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Alignment</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>PragmaAlignPackDiagnoseKind</name> <block>{<block_content>
<expr_stmt><expr><name>NonDefaultStateAtInclude</name></expr><operator>,</operator>
<expr><name>ChangedStateAtExit</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<function_decl><type><name>void</name></type> <name>DiagnoseNonDefaultPragmaAlignPack</name><parameter_list>(<parameter><decl><type><name>PragmaAlignPackDiagnoseKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IncludeLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DiagnoseUnterminatedPragmaAlignPack</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnPragmaMSStruct</name><parameter_list>(<parameter><decl><type><name>PragmaMSStructKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ActOnPragmaMSComment</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CommentLoc</name></decl></parameter>, <parameter><decl><type><name>PragmaMSCommentKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Arg</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>void</name></type> <name>ActOnPragmaMSPointersToMembers</name><argument_list>(
<argument><expr><name>LangOptions</name><operator>::</operator><name>PragmaMSPointersToMembersKind</name> <name>Kind</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>PragmaLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>ActOnPragmaMSVtorDisp</name><parameter_list>(<parameter><decl><type><name>PragmaMsStackAction</name></type> <name>Action</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLoc</name></decl></parameter>,
<parameter><decl><type><name>MSVtorDispMode</name></type> <name>Value</name></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>PragmaSectionKind</name> <block>{
<decl><name>PSK_DataSeg</name></decl>,
<decl><name>PSK_BSSSeg</name></decl>,
<decl><name>PSK_ConstSeg</name></decl>,
<decl><name>PSK_CodeSeg</name></decl>,
}</block>;</enum>

<function_decl><type><name>bool</name></type> <name>UnifySection</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>SectionName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>SectionFlags</name></decl></parameter>,
<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>TheDecl</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>UnifySection</name><parameter_list>(<parameter><decl><type><name>StringRef</name></type> <name>SectionName</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>SectionFlags</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaSectionLocation</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>ActOnPragmaMSSeg</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>PragmaLocation</name></expr></argument>,
<argument><expr><name>PragmaMsStackAction</name> <name>Action</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>StackSlotLabel</name></expr></argument>,
<argument><expr><name>StringLiteral</name> <operator>*</operator><name>SegmentName</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>PragmaName</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>ActOnPragmaMSSection</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLocation</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>SectionFlags</name></decl></parameter>, <parameter><decl><type><name>StringLiteral</name> <modifier>*</modifier></type><name>SegmentName</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnPragmaMSInitSeg</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLocation</name></decl></parameter>,
<parameter><decl><type><name>StringLiteral</name> <modifier>*</modifier></type><name>SegmentName</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnPragmaDump</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnPragmaDetectMismatch</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>StringRef</name></type> <name>Name</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Value</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>bool</name></type> <name>isPreciseFPEnabled</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><operator>!</operator><call><name><name>CurFPFeatures</name><operator>.</operator><name>getAllowFPReassociate</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name><name>CurFPFeatures</name><operator>.</operator><name>getNoSignedZero</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name><name>CurFPFeatures</name><operator>.</operator><name>getAllowReciprocal</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name><name>CurFPFeatures</name><operator>.</operator><name>getAllowApproxFunc</name></name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function_decl><type><name>void</name></type> <name>ActOnPragmaFloatControl</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>PragmaMsStackAction</name></type> <name>Action</name></decl></parameter>,
<parameter><decl><type><name>PragmaFloatControlKind</name></type> <name>Value</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnPragmaUnused</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Token</name> <modifier>&amp;</modifier></type><name>Identifier</name></decl></parameter>,
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>curScope</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnPragmaVisibility</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name><modifier>*</modifier></type> <name>VisType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>DeclClonePragmaWeak</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DeclApplyPragmaWeak</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>ND</name></decl></parameter>, <parameter><decl><type><name>WeakInfo</name> <modifier>&amp;</modifier></type><name>W</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnPragmaWeakID</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name><modifier>*</modifier></type> <name>WeakName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>WeakNameLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ActOnPragmaRedefineExtname</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name><modifier>*</modifier></type> <name>WeakName</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name><modifier>*</modifier></type> <name>AliasName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>WeakNameLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AliasNameLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnPragmaWeakAlias</name><parameter_list>(<parameter><decl><type><name>IdentifierInfo</name><modifier>*</modifier></type> <name>WeakName</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name><modifier>*</modifier></type> <name>AliasName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>WeakNameLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>AliasNameLoc</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>void</name></type> <name>ActOnPragmaFPContract</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>LangOptions</name><operator>::</operator><name>FPModeKind</name> <name>FPC</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>ActOnPragmaFPReassociate</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsEnabled</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ActOnPragmaFEnvAccess</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsEnabled</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>ActOnPragmaFPExceptions</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>LangOptions</name><operator>::</operator><name>FPExceptionModeKind</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>setRoundingMode</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>RoundingMode</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>setExceptionMode</name><argument_list>(<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>LangOptions</name><operator>::</operator><name>FPExceptionModeKind</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>AddAlignmentAttributesForRecord</name><parameter_list>(<parameter><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddMsStructLayoutForRecord</name><parameter_list>(<parameter><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>PushNamespaceVisibilityAttr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VisibilityAttr</name> <modifier>*</modifier></type><name>Attr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddPushedVisibilityAttribute</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>PopPragmaVisibility</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsNamespaceEnd</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>FreeVisContext</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>AddCFAuditedAttribute</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>ActOnPragmaAttributeAttribute</name><argument_list>(<argument><expr><name>ParsedAttr</name> <operator>&amp;</operator><name>Attribute</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>PragmaLoc</name></expr></argument>,
<argument><expr><name>attr</name><operator>::</operator><name>ParsedSubjectMatchRuleSet</name> <name>Rules</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>ActOnPragmaAttributeEmptyPush</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Namespace</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnPragmaAttributePop</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLoc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Namespace</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddPragmaAttributes</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>DiagnoseUnterminatedPragmaAttribute</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnPragmaOptimize</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>On</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>PragmaLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<expr_stmt><expr><name>SourceLocation</name> <macro><name>getOptimizeOffPragmaLocation</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>OptimizeOffPragmaLocation</name></expr>;</return>
}</block></expr></expr_stmt>




<function_decl><type><name>void</name></type> <name>AddRangeBasedOptnone</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>AddOptnoneAttributeIfNoConflicts</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddAlignedAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsPackExpansion</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AddAlignedAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>T</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsPackExpansion</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddAssumeAlignedAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>OE</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddAllocAlignAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ParamExpr</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddAlignValueAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddAnnotationAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Annot</name></decl></parameter>, <parameter><decl><type><name><name>MutableArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>AddLaunchBoundsAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>MaxThreads</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>MinBlocks</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>AddModeAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Name</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>InInstantiation</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>AddParameterABIAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><name>ParameterABI</name></type> <name>ABI</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>RetainOwnershipKind</name> <block>{<block_content><expr><name>NS</name></expr><operator>,</operator> <expr><name>CF</name></expr><operator>,</operator> <expr><name>OS</name></expr></block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>
<function_decl><type><name>void</name></type> <name>AddXConsumedAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><name>RetainOwnershipKind</name></type> <name>K</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsTemplateInstantiation</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>addAMDGPUFlatWorkGroupSizeAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Min</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Max</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>addAMDGPUWavesPerEUAttr</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AttributeCommonInfo</name> <modifier>&amp;</modifier></type><name>CI</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Min</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Max</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>checkNSReturnsRetainedReturnType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>ActOnCoroutineBodyStart</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KwLoc</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>Keyword</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnCoawaitExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KwLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>ActOnCoyieldExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KwLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnCoreturnStmt</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KwLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildResolvedCoawaitExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KwLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsImplicit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildUnresolvedCoawaitExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KwLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>UnresolvedLookupExpr</name><modifier>*</modifier></type> <name>Lookup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>BuildCoyieldExpr</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KwLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>BuildCoreturnStmt</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KwLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsImplicit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>StmtResult</name></type> <name>BuildCoroutineBodyStmt</name><argument_list>(<argument><expr><name>CoroutineBodyStmt</name><operator>::</operator><name>CtorArgs</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>bool</name></type> <name>buildCoroutineParameterMoves</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>buildCoroutinePromise</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckCompletedCoroutineBody</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>Body</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ClassTemplateDecl</name> <modifier>*</modifier></type><name>lookupCoroutineTraits</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>KwLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>FuncLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>checkFinalSuspendNoThrow</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>FinalSuspend</name></decl></parameter>)</parameter_list>;</function_decl>




<label><name>private</name>:</label>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>VarDataSharingAttributesStack</name></decl>;</decl_stmt>

<struct>struct <name>DeclareTargetContextInfo</name> <block>{
<struct>struct <name>MapInfo</name> <block>{
<expr_stmt><expr><name>OMPDeclareTargetDeclAttr</name><operator>::</operator><name>MapTypeTy</name> <name>MT</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
}</block>;</struct>

<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>NamedDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>MapInfo</name></expr></argument>&gt;</argument_list></name> <name>ExplicitlyMapped</name></expr>;</expr_stmt>


<expr_stmt><expr><name>OMPDeclareTargetDeclAttr</name><operator>::</operator><name>DevTypeTy</name> <name>DT</name> <operator>=</operator> <name>OMPDeclareTargetDeclAttr</name><operator>::</operator><name>DT_Any</name></expr>;</expr_stmt>


<decl_stmt><decl><type><name>OpenMPDirectiveKind</name></type> <name>Kind</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>

<macro><name>DeclareTargetContextInfo</name><argument_list>(<argument>OpenMPDirectiveKind Kind</argument>, <argument>SourceLocation Loc</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Kind</name><argument_list>(<argument><expr><name>Kind</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Loc</name><argument_list>(<argument>Loc</argument>)</argument_list></macro> <expr><block>{}</block></expr></expr_stmt>
}</block>;</struct>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>DeclareTargetContextInfo</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>DeclareTargetNesting</name></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>InitDataSharingAttributesStack</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>DestroyDataSharingAttributesStack</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type>
<name>VerifyPositiveIntegerConstantInClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Op</name></decl></parameter>, <parameter><decl><type><name>OpenMPClauseKind</name></type> <name>CKind</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>StrictlyPositive</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>SuppressExprDiags</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>unsigned</name> <macro><name>getOpenMPNestingLevel</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<decl_stmt><decl><type><name>void</name></type> <name>adjustOpenMPTargetScopeIndex</name><argument_list>(<argument><expr><name>unsigned</name> <operator>&amp;</operator><name>FunctionScopesIndex</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>Level</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<decl_stmt><decl><type><name>int</name></type> <name>getNumberOfConstructScopes</name><argument_list>(<argument><expr><name>unsigned</name> <name>Level</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>pushOpenMPFunctionRegion</name><parameter_list>()</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>popOpenMPFunctionRegion</name><argument_list>(<argument><expr><specifier>const</specifier> <name>sema</name><operator>::</operator><name>FunctionScopeInfo</name> <operator>*</operator><name>OldFSI</name></expr></argument>)</argument_list></decl>;</decl_stmt>













<function_decl><type><name>bool</name></type> <name>checkTransformableLoopNest</name><parameter_list>(
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>NumLoops</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>OMPLoopBasedDirective</name><operator>::</operator><name>HelperExprs</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>LoopHelpers</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>Body</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name><name>PointerUnion</name><argument_list type="generic">&lt;<argument><expr><name>Stmt</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>Decl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<modifier>&amp;</modifier></type><name>OriginalInits</name></decl></parameter>)</parameter_list>;</function_decl>



<struct>struct <name>OMPDeclareVariantScope</name> <block>{

<decl_stmt><decl><type><name>OMPTraitInfo</name> <modifier>*</modifier></type><name>TI</name></decl>;</decl_stmt>


<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <name>NameSuffix</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>OMPDeclareVariantScope</name><argument_list>(<argument><expr><name>OMPTraitInfo</name> <operator>&amp;</operator><name>TI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>;</struct>


<function><type><name>OMPTraitInfo</name> <modifier>*</modifier></type><name>getOMPTraitInfoForSurroundingScope</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><ternary><condition><expr><call><name><name>OMPDeclareVariantScopes</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>nullptr</name></expr>
</then><else>: <expr><call><name><name>OMPDeclareVariantScopes</name><operator>.</operator><name>back</name></name><argument_list>()</argument_list></call><operator>.</operator><name>TI</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>OMPDeclareVariantScope</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>OMPDeclareVariantScopes</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>AssumptionAttr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>OMPAssumeScoped</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>AssumptionAttr</name> <modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>OMPAssumeGlobal</name></decl>;</decl_stmt>

<label><name>public</name>:</label>




<function_decl><type><name>void</name></type> <name>ActOnStartOfFunctionDefinitionInOpenMPDeclareVariantScope</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>MultiTemplateParamsArg</name></type> <name>TemplateParameterLists</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Bases</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>ActOnFinishedFunctionDefinitionInOpenMPDeclareVariantScope</name><parameter_list>(
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Bases</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnFinishedFunctionDefinitionInOpenMPAssumeScope</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>bool</name> <macro><name>isInOpenMPDeclareVariantScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name><name>OMPDeclareVariantScopes</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>





<function_decl><type><name>ExprResult</name></type> <name>ActOnOpenMPCall</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>Call</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>Scope</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>MultiExprArg</name></type> <name>ArgExprs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ExecConfig</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnOpenMPBeginDeclareVariant</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>OMPTraitInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnOpenMPEndDeclareVariant</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>areMultiversionVariantFunctionsCompatible</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>OldFD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>NewFD</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>NoProtoDiagID</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnosticAt</name> <modifier>&amp;</modifier></type><name>NoteCausedDiagIDAt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnosticAt</name> <modifier>&amp;</modifier></type><name>NoSupportDiagIDAt</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnosticAt</name> <modifier>&amp;</modifier></type><name>DiffDiagIDAt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>TemplatesSupported</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ConstexprSupported</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>CLinkageMayDiffer</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>tryCaptureOpenMPLambdas</name><parameter_list>(<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>V</name></decl></parameter>)</parameter_list>;</function_decl>






<decl_stmt><decl><type><name>bool</name></type> <name>isOpenMPCapturedByRef</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Level</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>OpenMPCaptureLevel</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<function_decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>isOpenMPCapturedDecl</name><parameter_list>(<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>CheckScopeInfo</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>StopAt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>getOpenMPCapturedExpr</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Capture</name></decl></parameter>, <parameter><decl><type><name>ExprValueKind</name></type> <name>VK</name></decl></parameter>,
<parameter><decl><type><name>ExprObjectKind</name></type> <name>OK</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>startOpenMPLoop</name><parameter_list>()</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>startOpenMPCXXRangeFor</name><parameter_list>()</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>OpenMPClauseKind</name></type> <name>isOpenMPPrivateDecl</name><argument_list>(<argument><expr><name>ValueDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Level</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>CapLevel</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>




<function_decl><type><name>void</name></type> <name>setOpenMPCaptureKind</name><parameter_list>(<parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ValueDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>Level</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>bool</name></type> <name>isOpenMPTargetCapturedDecl</name><argument_list>(<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Level</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>CaptureLevel</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>





<decl_stmt><decl><type><name>bool</name></type> <name>isOpenMPGlobalCapturedDecl</name><argument_list>(<argument><expr><name>ValueDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><name>unsigned</name> <name>Level</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>CaptureLevel</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<function_decl><type><name>ExprResult</name></type> <name>PerformOpenMPImplicitIntegerConversion</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Op</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>StartOpenMPDSABlock</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>K</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>DirName</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>StartOpenMPClause</name><parameter_list>(<parameter><decl><type><name>OpenMPClauseKind</name></type> <name>K</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EndOpenMPClause</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>EndOpenMPDSABlock</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>CurDirective</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>ActOnOpenMPLoopInitialization</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ForLoc</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>ActOnOpenMPIdExpression</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>ScopeSpec</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>Id</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ActOnOpenMPThreadprivateDirective</name><parameter_list>(
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPThreadPrivateDecl</name> <modifier>*</modifier></type><name>CheckOMPThreadPrivateDecl</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ActOnOpenMPAllocateDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>Owner</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnOpenMPAssumesDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>DKind</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>StringRef</name></expr></argument>&gt;</argument_list></name></type> <name>Assumptions</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>SkippedClauses</name></decl></parameter>)</parameter_list>;</function_decl>


<expr_stmt><expr><name>bool</name> <macro><name>isInOpenMPAssumeScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>OMPAssumeScoped</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<expr_stmt><expr><name>bool</name> <macro><name>hasGlobalOpenMPAssumes</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><operator>!</operator><call><name><name>OMPAssumeGlobal</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></expr></expr_stmt>


<function_decl><type><name>void</name></type> <name>ActOnOpenMPEndAssumesDirective</name><parameter_list>()</parameter_list>;</function_decl>


<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ActOnOpenMPRequiresDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>ClauseList</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPRequiresDecl</name> <modifier>*</modifier></type><name>CheckOMPRequiresDecl</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>ActOnOpenMPDeclareReductionType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>TyLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeResult</name></type> <name>ParsedType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ActOnOpenMPDeclareReductionDirectiveStart</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>QualType</name></expr></argument>, <argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type> <name>ReductionTypes</name></decl></parameter>,
<parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>PrevDeclInScope</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnOpenMPDeclareReductionCombinerStart</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnOpenMPDeclareReductionCombinerEnd</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Combiner</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>ActOnOpenMPDeclareReductionInitializerStart</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ActOnOpenMPDeclareReductionInitializerEnd</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Initializer</name></decl></parameter>,
<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>OmpPrivParm</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ActOnOpenMPDeclareReductionDirectiveEnd</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>DeclGroupPtrTy</name></type> <name>DeclReductions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsValid</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>TypeResult</name></type> <name>ActOnOpenMPDeclareMapperVarDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>ActOnOpenMPDeclareMapperType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>TyLoc</name></decl></parameter>,
<parameter><decl><type><name>TypeResult</name></type> <name>ParsedType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclGroupPtrTy</name></type> <name>ActOnOpenMPDeclareMapperDirective</name><parameter_list>(
<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>DeclContext</name> <modifier>*</modifier></type><name>DC</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>Name</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>MapperType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>DeclarationName</name></type> <name>VN</name></decl></parameter>, <parameter><decl><type><name>AccessSpecifier</name></type> <name>AS</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>MapperVarRef</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>PrevDeclInScope</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>ActOnOpenMPDeclareMapperDirectiveVarDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>MapperType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>DeclarationName</name></type> <name>VN</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>bool</name></type> <name>isOpenMPDeclareMapperVarDeclAllowed</name><argument_list>(<argument><expr><specifier>const</specifier> <name>VarDecl</name> <operator>*</operator><name>VD</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>
<expr_stmt><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator><macro><name>getOpenMPDeclareMapperVarName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function_decl><type><name>bool</name></type> <name>ActOnStartOpenMPDeclareTargetContext</name><parameter_list>(<parameter><decl><type><name>DeclareTargetContextInfo</name> <modifier>&amp;</modifier></type><name>DTCI</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>const</specifier> <name>DeclareTargetContextInfo</name></type> <name>ActOnOpenMPEndDeclareTargetDirective</name><parameter_list>()</parameter_list>;</function_decl>





<function_decl><type><name>void</name></type> <name>ActOnFinishedOpenMPDeclareTargetContext</name><parameter_list>(<parameter><decl><type><name>DeclareTargetContextInfo</name> <modifier>&amp;</modifier></type><name>DTCI</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>lookupOpenMPDeclareTargetName</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>ScopeSpec</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>Id</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name></type> <name>ActOnOpenMPDeclareTargetName</name><argument_list>(<argument><expr><name>NamedDecl</name> <operator>*</operator><name>ND</name></expr></argument>, <argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>,
<argument><expr><name>OMPDeclareTargetDeclAttr</name><operator>::</operator><name>MapTypeTy</name> <name>MT</name></expr></argument>,
<argument><expr><name>OMPDeclareTargetDeclAttr</name><operator>::</operator><name>DevTypeTy</name> <name>DT</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>void</name></type>
<name>checkDeclIsAllowedInOpenMPTarget</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>IdLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>finalizeOpenMPDelayedAnalysis</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Caller</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Callee</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><name>bool</name> <macro><name>isInOpenMPDeclareTargetContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><operator>!</operator><call><name><name>DeclareTargetNesting</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>bool</name> <macro><name>isInOpenMPTargetExecutionDirective</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>


<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>getOpenMPCaptureLevels</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>ActOnOpenMPRegionStart</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>DKind</name></decl></parameter>, <parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPCanonicalLoop</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>)</parameter_list>;</function_decl>







<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPRegionEnd</name><parameter_list>(<parameter><decl><type><name>StmtResult</name></type> <name>S</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPExecutableDirective</name><parameter_list>(
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>DirName</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>CancelRegion</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPParallelDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>using</name></type> <name>VarsWithInheritedDSAType</name> <init>=
<expr><name>llvm</name><operator>::</operator><name><name>SmallDenseMap</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>ValueDecl</name> <operator>*</operator></expr></argument>, <argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></expr></init></decl>;</decl_stmt>


<function_decl><type><name>StmtResult</name></type>
<name>ActOnOpenMPSimdDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTileDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPUnrollDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type>
<name>ActOnOpenMPForDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type>
<name>ActOnOpenMPForSimdDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPSectionsDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPSectionDirective</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPSingleDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPMasterDirective</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPCriticalDirective</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>DirName</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPParallelForDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPParallelForSimdDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPParallelMasterDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPParallelSectionsDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTaskDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTaskyieldDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPBarrierDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTaskwaitDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTaskgroupDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPFlushDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPDepobjDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPScanDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPOrderedDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPAtomicDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTargetDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTargetDataDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTargetEnterDataDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTargetExitDataDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTargetParallelDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTargetParallelForDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTeamsDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type>
<name>ActOnOpenMPCancellationPointDirective</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>CancelRegion</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPCancelDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>CancelRegion</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type>
<name>ActOnOpenMPTaskLoopDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTaskLoopSimdDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPMasterTaskLoopDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPMasterTaskLoopSimdDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPParallelMasterTaskLoopDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPParallelMasterTaskLoopSimdDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type>
<name>ActOnOpenMPDistributeDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTargetUpdateDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPDistributeParallelForDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPDistributeParallelForSimdDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPDistributeSimdDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTargetParallelForSimdDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type>
<name>ActOnOpenMPTargetSimdDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTeamsDistributeDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTeamsDistributeSimdDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTeamsDistributeParallelForSimdDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTeamsDistributeParallelForDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTargetTeamsDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTargetTeamsDistributeDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTargetTeamsDistributeParallelForDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTargetTeamsDistributeParallelForSimdDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPTargetTeamsDistributeSimdDirective</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>, <parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>VarsWithInheritedDSAType</name> <modifier>&amp;</modifier></type><name>VarsWithImplicitDSA</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPInteropDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPDispatchDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>StmtResult</name></type> <name>ActOnOpenMPMaskedDirective</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OMPClause</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Clauses</name></decl></parameter>,
<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>AStmt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckOpenMPLinearModifier</name><parameter_list>(<parameter><decl><type><name>OpenMPLinearClauseKind</name></type> <name>LinKind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LinLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckOpenMPLinearDecl</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ValueDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ELoc</name></decl></parameter>,
<parameter><decl><type><name>OpenMPLinearClauseKind</name></type> <name>LinKind</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsDeclareSimd</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>DeclGroupPtrTy</name></type> <name>ActOnOpenMPDeclareSimdDirective</name><argument_list>(
<argument><expr><name>DeclGroupPtrTy</name> <name>DG</name></expr></argument>, <argument><expr><name>OMPDeclareSimdDeclAttr</name><operator>::</operator><name>BranchStateTy</name> <name>BS</name></expr></argument>,
<argument><expr><name>Expr</name> <operator>*</operator><name>Simdlen</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Uniforms</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Aligneds</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Alignments</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Linears</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name> <name>LinModifiers</name></expr></argument>, <argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Steps</name></expr></argument>, <argument><expr><name>SourceRange</name> <name>SR</name></expr></argument>)</argument_list></decl>;</decl_stmt>










<function_decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name> <modifier>*</modifier></expr></argument>, <argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></type>
<name>checkOpenMPDeclareVariantFunction</name><parameter_list>(<parameter><decl><type><name>DeclGroupPtrTy</name></type> <name>DG</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>VariantRef</name></decl></parameter>,
<parameter><decl><type><name>OMPTraitInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>SR</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>void</name></type> <name>ActOnOpenMPDeclareVariantDirective</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>VariantRef</name></decl></parameter>,
<parameter><decl><type><name>OMPTraitInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>SR</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPSingleExprClause</name><parameter_list>(<parameter><decl><type><name>OpenMPClauseKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Expr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPAllocatorClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Allocator</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPIfClause</name><parameter_list>(<parameter><decl><type><name>OpenMPDirectiveKind</name></type> <name>NameModifier</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Condition</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>NameModifierLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPFinalClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Condition</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPNumThreadsClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NumThreads</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPSafelenClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Length</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPSimdlenClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Length</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPSizesClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>SizeExprs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPFullClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPPartialClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>FactorExpr</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPCollapseClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NumForLoops</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type>
<name>ActOnOpenMPOrderedClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NumForLoops</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPGrainsizeClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Size</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPNumTasksClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NumTasks</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPHintClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Hint</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPDetachClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Evt</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPSimpleClause</name><parameter_list>(<parameter><decl><type><name>OpenMPClauseKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Argument</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ArgumentLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPDefaultClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>DefaultKind</name> <name>Kind</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>KindLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>StartLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>LParenLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>EndLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPProcBindClause</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator>omp<operator>::</operator><name>ProcBindKind</name> <name>Kind</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>KindLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>StartLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>LParenLoc</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>EndLoc</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPOrderClause</name><parameter_list>(<parameter><decl><type><name>OpenMPOrderClauseKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KindLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPUpdateClause</name><parameter_list>(<parameter><decl><type><name>OpenMPDependClauseKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KindLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPSingleExprWithArgClause</name><parameter_list>(
<parameter><decl><type><name>OpenMPClauseKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>unsigned</name></expr></argument>&gt;</argument_list></name></type> <name>Arguments</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Expr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>ArgumentsLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>DelimLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPScheduleClause</name><parameter_list>(
<parameter><decl><type><name>OpenMPScheduleClauseModifier</name></type> <name>M1</name></decl></parameter>, <parameter><decl><type><name>OpenMPScheduleClauseModifier</name></type> <name>M2</name></decl></parameter>,
<parameter><decl><type><name>OpenMPScheduleClauseKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ChunkSize</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>M1Loc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>M2Loc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KindLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>CommaLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPClause</name><parameter_list>(<parameter><decl><type><name>OpenMPClauseKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPNowaitClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPUntiedClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPMergeableClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPReadClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPWriteClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPUpdateClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPCaptureClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPSeqCstClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPAcqRelClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPAcquireClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPReleaseClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPRelaxedClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPInitClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>InteropVar</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>PrefExprs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsTarget</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsTargetSync</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>VarLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPUseClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>InteropVar</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>VarLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPDestroyClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>InteropVar</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>VarLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPNovariantsClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Condition</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPNocontextClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Condition</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPFilterClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ThreadID</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPThreadsClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPSIMDClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPNogroupClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPUnifiedAddressClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPUnifiedSharedMemoryClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPReverseOffloadClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPDynamicAllocatorsClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPAtomicDefaultMemOrderClause</name><parameter_list>(
<parameter><decl><type><name>OpenMPAtomicDefaultMemOrderClauseKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KindLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPVarListClause</name><parameter_list>(
<parameter><decl><type><name>OpenMPClauseKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Vars</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>DepModOrTailExpr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPVarListLocTy</name> <modifier>&amp;</modifier></type><name>Locs</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>ReductionOrMapperIdScopeSpec</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>ReductionOrMapperId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ExtraModifier</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPMapModifierKind</name></expr></argument>&gt;</argument_list></name></type> <name>MapTypeModifiers</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>MapTypeModifiersLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsMapTypeImplicit</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ExtraModifierLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPMotionModifierKind</name></expr></argument>&gt;</argument_list></name></type> <name>MotionModifiers</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>MotionModifiersLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPInclusiveClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPExclusiveClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type>
<name>ActOnOpenMPAllocateClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Allocator</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPPrivateClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPFirstprivateClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPLastprivateClause</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><name>OpenMPLastprivateModifier</name></type> <name>LPKind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LPKindLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPSharedClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPReductionClause</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><name>OpenMPReductionClauseModifier</name></type> <name>Modifier</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ModifierLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>ReductionIdScopeSpec</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>ReductionId</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>UnresolvedReductions</name> <init>= <expr><name>llvm</name><operator>::</operator><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPTaskReductionClause</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>ReductionIdScopeSpec</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>ReductionId</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>UnresolvedReductions</name> <init>= <expr><name>llvm</name><operator>::</operator><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPInReductionClause</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>ReductionIdScopeSpec</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>ReductionId</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>UnresolvedReductions</name> <init>= <expr><name>llvm</name><operator>::</operator><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type>
<name>ActOnOpenMPLinearClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Step</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>OpenMPLinearClauseKind</name></type> <name>LinKind</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LinLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPAlignedClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Alignment</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPCopyinClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPCopyprivateClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPFlushClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPDepobjClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Depobj</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type>
<name>ActOnOpenMPDependClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>DepModifier</name></decl></parameter>, <parameter><decl><type><name>OpenMPDependClauseKind</name></type> <name>DepKind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>DepLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPDeviceClause</name><parameter_list>(<parameter><decl><type><name>OpenMPDeviceClauseModifier</name></type> <name>Modifier</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Device</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ModifierLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type>
<name>ActOnOpenMPMapClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPMapModifierKind</name></expr></argument>&gt;</argument_list></name></type> <name>MapTypeModifiers</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>MapTypeModifiersLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>MapperIdScopeSpec</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>MapperId</name></decl></parameter>,
<parameter><decl><type><name>OpenMPMapClauseKind</name></type> <name>MapType</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsMapTypeImplicit</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>MapLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OMPVarListLocTy</name> <modifier>&amp;</modifier></type><name>Locs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>UnresolvedMappers</name> <init>= <expr><name>llvm</name><operator>::</operator><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPNumTeamsClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>NumTeams</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPThreadLimitClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ThreadLimit</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPPriorityClause</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Priority</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPDistScheduleClause</name><parameter_list>(
<parameter><decl><type><name>OpenMPDistScheduleClauseKind</name></type> <name>Kind</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>ChunkSize</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>KindLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CommaLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPDefaultmapClause</name><parameter_list>(
<parameter><decl><type><name>OpenMPDefaultmapClauseModifier</name></type> <name>M</name></decl></parameter>, <parameter><decl><type><name>OpenMPDefaultmapClauseKind</name></type> <name>Kind</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>MLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>KindLoc</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type>
<name>ActOnOpenMPToClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPMotionModifierKind</name></expr></argument>&gt;</argument_list></name></type> <name>MotionModifiers</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>MotionModifiersLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>MapperIdScopeSpec</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>MapperId</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OMPVarListLocTy</name> <modifier>&amp;</modifier></type><name>Locs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>UnresolvedMappers</name> <init>= <expr><name>llvm</name><operator>::</operator><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type>
<name>ActOnOpenMPFromClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>OpenMPMotionModifierKind</name></expr></argument>&gt;</argument_list></name></type> <name>MotionModifiers</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>MotionModifiersLoc</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>MapperIdScopeSpec</name></decl></parameter>,
<parameter><decl><type><name>DeclarationNameInfo</name> <modifier>&amp;</modifier></type><name>MapperId</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OMPVarListLocTy</name> <modifier>&amp;</modifier></type><name>Locs</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>UnresolvedMappers</name> <init>= <expr><name>llvm</name><operator>::</operator><name>None</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPUseDevicePtrClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPVarListLocTy</name> <modifier>&amp;</modifier></type><name>Locs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPUseDeviceAddrClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPVarListLocTy</name> <modifier>&amp;</modifier></type><name>Locs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPIsDevicePtrClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>OMPVarListLocTy</name> <modifier>&amp;</modifier></type><name>Locs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPNontemporalClause</name><parameter_list>(<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>VarList</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<struct>struct <name>UsesAllocatorsData</name> <block>{

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Allocator</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>AllocatorTraits</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl>, <decl><type ref="prev"/><name>RParenLoc</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPUsesAllocatorClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>UsesAllocatorsData</name></expr></argument>&gt;</argument_list></name></type> <name>Data</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>OMPClause</name> <modifier>*</modifier></type><name>ActOnOpenMPAffinityClause</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>StartLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ColonLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>EndLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Modifier</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Locators</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>CheckedConversionKind</name> <block>{

<decl><name>CCK_ImplicitConversion</name></decl>,

<decl><name>CCK_CStyleCast</name></decl>,

<decl><name>CCK_FunctionalCast</name></decl>,

<decl><name>CCK_OtherCast</name></decl>,

<decl><name>CCK_ForBuiltinOverloadedOp</name></decl>
}</block>;</enum>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isCast</name><parameter_list>(<parameter><decl><type><name>CheckedConversionKind</name></type> <name>CCK</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><name>CCK</name> <operator>==</operator> <name>CCK_CStyleCast</name> <operator>||</operator> <name>CCK</name> <operator>==</operator> <name>CCK_FunctionalCast</name> <operator>||</operator>
<name>CCK</name> <operator>==</operator> <name>CCK_OtherCast</name></expr>;</return>
</block_content>}</block></function>




<function_decl><type><name>ExprResult</name></type>
<name>ImpCastExprToType</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>, <parameter><decl><type><name>CastKind</name></type> <name>CK</name></decl></parameter>,
<parameter><decl><type><name>ExprValueKind</name></type> <name>VK</name> <init>= <expr><name>VK_PRValue</name></expr></init></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXCastPath</name> <modifier>*</modifier></type><name>BasePath</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>CheckedConversionKind</name></type> <name>CCK</name> <init>= <expr><name>CCK_ImplicitConversion</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><specifier>static</specifier> <name>CastKind</name></type> <name>ScalarTypeToBooleanCastKind</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ScalarTy</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>IgnoredValueConversions</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>UsualUnaryConversions</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>CallExprUnaryConversions</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>DefaultFunctionArrayConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>DefaultFunctionArrayLvalueConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>DefaultLvalueConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>DefaultArgumentPromotion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>ExprResult</name></type> <name>TemporaryMaterializationConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>VariadicCallType</name> <block>{
<decl><name>VariadicFunction</name></decl>,
<decl><name>VariadicBlock</name></decl>,
<decl><name>VariadicMethod</name></decl>,
<decl><name>VariadicConstructor</name></decl>,
<decl><name>VariadicDoesNotApply</name></decl>
}</block>;</enum>

<function_decl><type><name>VariadicCallType</name></type> <name>getVariadicCallType</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FDecl</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Proto</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Fn</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>VarArgKind</name> <block>{
<decl><name>VAK_Valid</name></decl>,
<decl><name>VAK_ValidInCXX11</name></decl>,
<decl><name>VAK_Undefined</name></decl>,
<decl><name>VAK_MSVCUndefined</name></decl>,
<decl><name>VAK_Invalid</name></decl>
}</block>;</enum>


<function_decl><type><name>VarArgKind</name></type> <name>isValidVarArgType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>QualType</name> <modifier>&amp;</modifier></type><name>Ty</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>checkVariadicArgument</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>VariadicCallType</name></type> <name>CT</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>checkAndRewriteMustTailAttr</name><parameter_list>(<parameter><decl><type><name>Stmt</name> <modifier>*</modifier></type><name>St</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Attr</name> <modifier>&amp;</modifier></type><name>MTA</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>


<function_decl><type><name>bool</name></type> <name>checkMustTailAttr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Stmt</name> <modifier>*</modifier></type><name>St</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Attr</name> <modifier>&amp;</modifier></type><name>MTA</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>

<function_decl><type><name>bool</name></type> <name>hasCStrMethod</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>GatherArgumentsForCall</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>CallLoc</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FDecl</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Proto</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>FirstParam</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>AllArgs</name></decl></parameter>,
<parameter><decl><type><name>VariadicCallType</name></type> <name>CallType</name> <init>= <expr><name>VariadicDoesNotApply</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowExplicit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsListInitialization</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>DefaultVariadicArgumentPromotion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>VariadicCallType</name></type> <name>CT</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FDecl</name></decl></parameter>)</parameter_list>;</function_decl>


<enum>enum <name>ArithConvKind</name> <block>{

<decl><name>ACK_Arithmetic</name></decl>,

<decl><name>ACK_BitwiseOp</name></decl>,

<decl><name>ACK_Comparison</name></decl>,

<decl><name>ACK_Conditional</name></decl>,

<decl><name>ACK_CompAssign</name></decl>,
}</block>;</enum>






<function_decl><type><name>QualType</name></type> <name>UsualArithmeticConversions</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>ArithConvKind</name></type> <name>ACK</name></decl></parameter>)</parameter_list>;</function_decl>






<enum>enum <name>AssignConvertType</name> <block>{

<decl><name>Compatible</name></decl>,



<decl><name>PointerToInt</name></decl>,



<decl><name>IntToPointer</name></decl>,



<decl><name>FunctionVoidPointer</name></decl>,



<decl><name>IncompatiblePointer</name></decl>,




<decl><name>IncompatibleFunctionPointer</name></decl>,





<decl><name>IncompatiblePointerSign</name></decl>,



<decl><name>CompatiblePointerDiscardsQualifiers</name></decl>,




<decl><name>IncompatiblePointerDiscardsQualifiers</name></decl>,





<decl><name>IncompatibleNestedPointerAddressSpaceMismatch</name></decl>,





<decl><name>IncompatibleNestedPointerQualifiers</name></decl>,



<decl><name>IncompatibleVectors</name></decl>,



<decl><name>IntToBlockPointer</name></decl>,



<decl><name>IncompatibleBlockPointer</name></decl>,




<decl><name>IncompatibleObjCQualifiedId</name></decl>,



<decl><name>IncompatibleObjCWeakRef</name></decl>,



<decl><name>Incompatible</name></decl>
}</block>;</enum>




<function_decl><type><name>bool</name></type> <name>DiagnoseAssignmentResult</name><parameter_list>(<parameter><decl><type><name>AssignConvertType</name></type> <name>ConvTy</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>DstType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>SrcType</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SrcExpr</name></decl></parameter>, <parameter><decl><type><name>AssignmentAction</name></type> <name>Action</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>Complained</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>bool</name></type> <name>IsValueInFlagEnum</name><argument_list>(<argument><expr><specifier>const</specifier> <name>EnumDecl</name> <operator>*</operator><name>ED</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>llvm</name><operator>::</operator><name>APInt</name> <operator>&amp;</operator><name>Val</name></expr></argument>,
<argument><expr><name>bool</name> <name>AllowMask</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>



<function_decl><type><name>void</name></type> <name>DiagnoseAssignmentEnum</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>DstType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>SrcType</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SrcExpr</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>AssignConvertType</name></type> <name>CheckAssignmentConstraints</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>LHSType</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>RHSType</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>AssignConvertType</name></type> <name>CheckAssignmentConstraints</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>LHSType</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>CastKind</name> <modifier>&amp;</modifier></type><name>Kind</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ConvertRHS</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>















<function_decl><type><name>AssignConvertType</name></type> <name>CheckSingleAssignmentConstraints</name><parameter_list>(
<parameter><decl><type><name>QualType</name></type> <name>LHSType</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DiagnoseCFAudited</name> <init>= <expr><name>false</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ConvertRHS</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>AssignConvertType</name></type> <name>CheckTransparentUnionArgumentConstraints</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>ArgType</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>IsStringLiteralToNonConstPointerConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckExceptionSpecCompatibility</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>PerformImplicitConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><name>AssignmentAction</name></type> <name>Action</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowExplicit</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>PerformImplicitConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ImplicitConversionSequence</name><modifier>&amp;</modifier></type> <name>ICS</name></decl></parameter>,
<parameter><decl><type><name>AssignmentAction</name></type> <name>Action</name></decl></parameter>,
<parameter><decl><type><name>CheckedConversionKind</name></type> <name>CCK</name>
<init>= <expr><name>CCK_ImplicitConversion</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>PerformImplicitConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>From</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>StandardConversionSequence</name><modifier>&amp;</modifier></type> <name>SCS</name></decl></parameter>,
<parameter><decl><type><name>AssignmentAction</name></type> <name>Action</name></decl></parameter>,
<parameter><decl><type><name>CheckedConversionKind</name></type> <name>CCK</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>PerformQualificationConversion</name><parameter_list>(
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>, <parameter><decl><type><name>ExprValueKind</name></type> <name>VK</name> <init>= <expr><name>VK_PRValue</name></expr></init></decl></parameter>,
<parameter><decl><type><name>CheckedConversionKind</name></type> <name>CCK</name> <init>= <expr><name>CCK_ImplicitConversion</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>QualType</name></type> <name>InvalidOperands</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>InvalidLogicalVectorOperands</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckPointerToMemberOperands</name><parameter_list>(
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>, <parameter><decl><type><name>ExprValueKind</name> <modifier>&amp;</modifier></type><name>VK</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isIndirect</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckMultiplyDivideOperands</name><parameter_list>(
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsCompAssign</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsDivide</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckRemainderOperands</name><parameter_list>(
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsCompAssign</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckAdditionOperands</name><parameter_list>(
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name></decl></parameter>, <parameter><decl><type><name>QualType</name><modifier>*</modifier></type> <name>CompLHSTy</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckSubtractionOperands</name><parameter_list>(
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>QualType</name><modifier>*</modifier></type> <name>CompLHSTy</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckShiftOperands</name><parameter_list>(
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsCompAssign</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckPtrComparisonWithNullChar</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>NullE</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckCompareOperands</name><parameter_list>(
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckBitwiseOperands</name><parameter_list>(
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckLogicalOperands</name><parameter_list>(
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>QualType</name></type> <name>CheckAssignmentOperands</name><parameter_list>(
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHSExpr</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>CompoundType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>checkPseudoObjectIncDec</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>UnaryOperatorKind</name></type> <name>Opcode</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Op</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>checkPseudoObjectAssignment</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opcode</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>checkPseudoObjectRValue</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Expr</name> <modifier>*</modifier></type><name>recreateSyntacticForm</name><parameter_list>(<parameter><decl><type><name>PseudoObjectExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>QualType</name></type> <name>CheckConditionalOperands</name><parameter_list>(
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>Cond</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>ExprValueKind</name> <modifier>&amp;</modifier></type><name>VK</name></decl></parameter>, <parameter><decl><type><name>ExprObjectKind</name> <modifier>&amp;</modifier></type><name>OK</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>QuestionLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CXXCheckConditionalOperands</name><parameter_list>(
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>cond</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>rhs</name></decl></parameter>,
<parameter><decl><type><name>ExprValueKind</name> <modifier>&amp;</modifier></type><name>VK</name></decl></parameter>, <parameter><decl><type><name>ExprObjectKind</name> <modifier>&amp;</modifier></type><name>OK</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>questionLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckVectorConditionalTypes</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>Cond</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>QuestionLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>FindCompositePointerType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>E1</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>E2</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ConvertArgs</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>QualType</name></type> <name>FindCompositePointerType</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>E1</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>E2</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ConvertArgs</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E1Tmp</name> <init>= <expr><call><name><name>E1</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>E2Tmp</name> <init>= <expr><call><name><name>E2</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>QualType</name></type> <name>Composite</name> <init>=
<expr><call><name>FindCompositePointerType</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><name>E1Tmp</name></expr></argument>, <argument><expr><name>E2Tmp</name></expr></argument>, <argument><expr><name>ConvertArgs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>E1</name> <operator>=</operator> <name>E1Tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>E2</name> <operator>=</operator> <name>E2Tmp</name></expr>;</expr_stmt>
<return>return <expr><name>Composite</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>QualType</name></type> <name>FindCompositeObjCPointerType</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>QuestionLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>DiagnoseConditionalForNull</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHSExpr</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHSExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>QuestionLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>DiagnoseAlwaysNonNullPointer</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>Expr</name><operator>::</operator><name>NullPointerConstantKind</name> <name>NullType</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsEqual</name></expr></argument>, <argument><expr><name>SourceRange</name> <name>Range</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<function_decl><type><name>QualType</name></type> <name>CheckVectorOperands</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsCompAssign</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowBothBool</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>AllowBoolConversion</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>GetSignedVectorType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>V</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckVectorCompareOperands</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckVectorLogicalOperands</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>QualType</name></type> <name>CheckMatrixElementwiseOperands</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsCompAssign</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>CheckMatrixMultiplyOperands</name><parameter_list>(<parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name> <modifier>&amp;</modifier></type><name>RHS</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsCompAssign</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>isValidSveBitcast</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>srcType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>destType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>areMatrixTypesOfTheSameDimension</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>srcTy</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>destTy</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>areVectorTypesSameSize</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>srcType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>destType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>areLaxCompatibleVectorTypes</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>srcType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>destType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isLaxVectorConversion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>srcType</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>destType</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>bool</name></type> <name>CheckForConstantInitializer</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>t</name></decl></parameter>)</parameter_list>;</function_decl>






<enum>enum <name>ReferenceCompareResult</name> <block>{


<decl><name>Ref_Incompatible</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,



<decl><name>Ref_Related</name></decl>,

<decl><name>Ref_Compatible</name></decl>
}</block>;</enum>


<struct>struct <name>ReferenceConversionsScope</name> <block>{



<enum>enum <name>ReferenceConversions</name> <block>{
<decl><name>Qualification</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,
<decl><name>NestedQualification</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,
<decl><name>Function</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>,
<decl><name>DerivedToBase</name> <init>= <expr><literal type="number">0x8</literal></expr></init></decl>,
<decl><name>ObjC</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>,
<decl><name>ObjCLifetime</name> <init>= <expr><literal type="number">0x20</literal></expr></init></decl>,

<decl><name>LLVM_MARK_AS_BITMASK_ENUM</name><argument_list>(<argument><expr><name>ObjCLifetime</name></expr></argument>)</argument_list></decl>
}</block>;</enum>
}</block>;</struct>
<decl_stmt><decl><type><name>using</name></type> <name>ReferenceConversions</name> <init>= <expr><name>ReferenceConversionsScope</name><operator>::</operator><name>ReferenceConversions</name></expr></init></decl>;</decl_stmt>

<function_decl><type><name>ReferenceCompareResult</name></type>
<name>CompareReferenceRelationship</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T1</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T2</name></decl></parameter>,
<parameter><decl><type><name>ReferenceConversions</name> <modifier>*</modifier></type><name>Conv</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>checkUnknownAnyCast</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>TypeRange</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>CastType</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CastExpr</name></decl></parameter>, <parameter><decl><type><name>CastKind</name> <modifier>&amp;</modifier></type><name>CastKind</name></decl></parameter>,
<parameter><decl><type><name>ExprValueKind</name> <modifier>&amp;</modifier></type><name>VK</name></decl></parameter>, <parameter><decl><type><name>CXXCastPath</name> <modifier>&amp;</modifier></type><name>Path</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>forceUnknownAnyToType</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ToType</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>checkUnknownAnyArg</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>callLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>paramType</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>CheckMatrixCast</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>DestTy</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>SrcTy</name></decl></parameter>,
<parameter><decl><type><name>CastKind</name> <modifier>&amp;</modifier></type><name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>CheckVectorCast</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>VectorTy</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Ty</name></decl></parameter>,
<parameter><decl><type><name>CastKind</name> <modifier>&amp;</modifier></type><name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExprResult</name></type> <name>prepareVectorSplat</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>VectorTy</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SplattedExpr</name></decl></parameter>)</parameter_list>;</function_decl>






<function_decl><type><name>ExprResult</name></type> <name>CheckExtVectorCast</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>R</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>DestTy</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CastExpr</name></decl></parameter>,
<parameter><decl><type><name>CastKind</name> <modifier>&amp;</modifier></type><name>Kind</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>BuildCXXFunctionalCastExpr</name><parameter_list>(<parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>LParenLoc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CastExpr</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>ARCConversionResult</name> <block>{ <decl><name>ACR_okay</name></decl>, <decl><name>ACR_unbridged</name></decl>, <decl><name>ACR_error</name></decl> }</block>;</enum>



<function_decl><type><name>ARCConversionResult</name></type> <name>CheckObjCConversion</name><parameter_list>(<parameter><decl><type><name>SourceRange</name></type> <name>castRange</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>castType</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier><modifier>&amp;</modifier></type><name>op</name></decl></parameter>,
<parameter><decl><type><name>CheckedConversionKind</name></type> <name>CCK</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Diagnose</name> <init>= <expr><name>true</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DiagnoseCFAudited</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><name>BinaryOperatorKind</name></type> <name>Opc</name> <init>= <expr><name>BO_PtrMemD</name></expr></init></decl></parameter>
)</parameter_list>;</function_decl>

<function_decl><type><name>Expr</name> <modifier>*</modifier></type><name>stripARCUnbridgedCast</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>diagnoseARCUnbridgedCast</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckObjCARCUnavailableWeakConversion</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>castType</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>ExprType</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>checkRetainCycles</name><parameter_list>(<parameter><decl><type><name>ObjCMessageExpr</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>checkRetainCycles</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>receiver</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>argument</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>checkRetainCycles</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>Var</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>checkUnsafeAssigns</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>LHS</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>checkUnsafeExprAssigns</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>bool</name></type> <name>CheckMessageArgumentTypes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Receiver</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ReceiverType</name></decl></parameter>,
<parameter><decl><type><name>MultiExprArg</name></type> <name>Args</name></decl></parameter>, <parameter><decl><type><name>Selector</name></type> <name>Sel</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>SourceLocation</name></expr></argument>&gt;</argument_list></name></type> <name>SelectorLocs</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isClassMessage</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isSuperMessage</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>lbrac</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>rbrac</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>RecRange</name></decl></parameter>,
<parameter><decl><type><name>QualType</name> <modifier>&amp;</modifier></type><name>ReturnType</name></decl></parameter>, <parameter><decl><type><name>ExprValueKind</name> <modifier>&amp;</modifier></type><name>VK</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>QualType</name></type> <name>getMessageSendResultType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>Receiver</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ReceiverType</name></decl></parameter>,
<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isClassMessage</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isSuperMessage</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>EmitRelatedResultTypeNote</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>EmitRelatedResultTypeNoteForReturn</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>destType</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>class</name></type> <name>ConditionResult</name> <block>{<block_content>
<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ConditionVar</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FullExprArg</name></type> <name>Condition</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Invalid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasKnownValue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>KnownValue</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>Sema</name></decl>;</decl_stmt>
<macro><name>ConditionResult</name><argument_list>(<argument>Sema &amp;S</argument>, <argument>Decl *ConditionVar</argument>, <argument>FullExprArg Condition</argument>,
<argument>bool IsConstexpr</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>ConditionVar</name><argument_list>(<argument><expr><name>ConditionVar</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Condition</name><argument_list>(<argument><expr><name>Condition</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Invalid</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>HasKnownValue</name><argument_list>(<argument><expr><name>IsConstexpr</name> <operator>&amp;&amp;</operator> <call><name><name>Condition</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><call><name><name>Condition</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call><operator>-&gt;</operator><call><name>isValueDependent</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>KnownValue</name><argument_list>(<argument>HasKnownValue &amp;&amp;
!!Condition.get()-&gt;EvaluateKnownConstInt(S.Context)</argument>)</argument_list></macro> <expr><block>{}</block>
<name>explicit</name> <macro><name>ConditionResult</name><argument_list>(<argument>bool Invalid</argument>)</argument_list></macro>
<operator>:</operator> <call><name>ConditionVar</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Condition</name><argument_list>(<argument><expr><name>nullptr</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>Invalid</name><argument_list>(<argument><expr><name>Invalid</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<expr><call><name>HasKnownValue</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>KnownValue</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{}</block>

<name>public</name><operator>:</operator>
<call><name>ConditionResult</name><argument_list>()</argument_list></call> <operator>:</operator> <macro><name>ConditionResult</name><argument_list>(<argument>false</argument>)</argument_list></macro> <block>{}</block>
<name>bool</name> <macro><name>isInvalid</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>Invalid</name></expr>;</return> }</block></expr></expr_stmt>
<expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name> <operator>*</operator></expr></argument>, <argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <macro><name>get</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>std</name><operator>::</operator><call><name>make_pair</name><argument_list>(<argument><expr><call><name><name>cast_or_null</name><argument_list type="generic">&lt;<argument><expr><name>VarDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>ConditionVar</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>Condition</name><operator>.</operator><name>get</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>
<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name> <macro><name>getKnownValue</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>HasKnownValue</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>None</name></expr>;</return></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>KnownValue</name></expr>;</return>
</block_content>}</block></decl></decl_stmt>
};
<function><type><specifier>static</specifier> <name>ConditionResult</name></type> <name>ConditionError</name><parameter_list>()</parameter_list> <block>{<block_content> <return>return <expr><call><name>ConditionResult</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>ConditionKind</name> <block>{<block_content>
<expr_stmt><expr><name>Boolean</name></expr><operator>,</operator>
<expr><name>ConstexprIf</name></expr><operator>,</operator>
<expr><name>Switch</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<function_decl><type><name>ConditionResult</name></type> <name>ActOnCondition</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>SubExpr</name></decl></parameter>, <parameter><decl><type><name>ConditionKind</name></type> <name>CK</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ConditionResult</name></type> <name>ActOnConditionVariable</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ConditionVar</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StmtLoc</name></decl></parameter>,
<parameter><decl><type><name>ConditionKind</name></type> <name>CK</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>DeclResult</name></type> <name>ActOnCXXConditionDeclaration</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>CheckConditionVariable</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>ConditionVar</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>StmtLoc</name></decl></parameter>,
<parameter><decl><type><name>ConditionKind</name></type> <name>CK</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>CheckSwitchCondition</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>SwitchLoc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Cond</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>ExprResult</name></type> <name>CheckBooleanCondition</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsConstexpr</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>ExplicitSpecifier</name></type> <name>ActOnExplicitBoolSpecifier</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>tryResolveExplicitSpecifier</name><parameter_list>(<parameter><decl><type><name>ExplicitSpecifier</name> <modifier>&amp;</modifier></type><name>ExplicitSpec</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DiagnoseAssignmentAsCondition</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>DiagnoseEqualityWithExtraParens</name><parameter_list>(<parameter><decl><type><name>ParenExpr</name> <modifier>*</modifier></type><name>ParenE</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>CheckCXXBooleanCondition</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>CondExpr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsConstexpr</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>void</name></type> <name>ConvertIntegerToTypeWarnOnOverflow</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <operator>&amp;</operator><name>OldVal</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>NewWidth</name></expr></argument>, <argument><expr><name>bool</name> <name>NewSign</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>unsigned</name> <name>DiagID</name></expr></argument>)</argument_list></decl>;</decl_stmt>




<function_decl><type><name>bool</name></type> <name>CheckObjCDeclScope</name><parameter_list>(<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>class</name></type> <name>VerifyICEDiagnoser</name> <block>{<block_content>
<label><name>public</name>:</label>
<decl_stmt><decl><type><name>bool</name></type> <name>Suppress</name></decl>;</decl_stmt>

<macro><name>VerifyICEDiagnoser</name><argument_list>(<argument>bool Suppress = false</argument>)</argument_list></macro> : <macro><name>Suppress</name><argument_list>(<argument>Suppress</argument>)</argument_list></macro> <block>{<block_content> </block_content>}</block>

<function_decl><type><name>virtual</name> <name>SemaDiagnosticBuilder</name></type>
<name>diagnoseNotICEType</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>T</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>virtual</name> <name>SemaDiagnosticBuilder</name></type> <name>diagnoseNotICE</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list> <init>= <expr><literal type="number">0</literal></expr></init>;</function_decl>
<function_decl><type><name>virtual</name> <name>SemaDiagnosticBuilder</name></type> <name>diagnoseFold</name><parameter_list>(<parameter><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>
<expr_stmt><expr><name>virtual</name> <operator>~</operator><macro><name>VerifyICEDiagnoser</name><argument_list>()</argument_list></macro> <block>{}</block></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>

<enum>enum <name>AllowFoldKind</name> <block>{
<decl><name>NoFold</name></decl>,
<decl><name>AllowFold</name></decl>,
}</block>;</enum>




<decl_stmt><decl><type><name>ExprResult</name></type> <name>VerifyIntegerConstantExpression</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <operator>*</operator><name>Result</name></expr></argument>,
<argument><expr><name>VerifyICEDiagnoser</name> <operator>&amp;</operator><name>Diagnoser</name></expr></argument>,
<argument><expr><name>AllowFoldKind</name> <name>CanFold</name> <operator>=</operator> <name>NoFold</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>VerifyIntegerConstantExpression</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>, <argument><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <operator>*</operator><name>Result</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>DiagID</name></expr></argument>,
<argument><expr><name>AllowFoldKind</name> <name>CanFold</name> <operator>=</operator> <name>NoFold</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>VerifyIntegerConstantExpression</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <operator>*</operator><name>Result</name> <operator>=</operator> <name>nullptr</name></expr></argument>,
<argument><expr><name>AllowFoldKind</name> <name>CanFold</name> <operator>=</operator> <name>NoFold</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function><type><name>ExprResult</name></type> <name>VerifyIntegerConstantExpression</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>,
<parameter><decl><type><name>AllowFoldKind</name></type> <name>CanFold</name> <init>= <expr><name>NoFold</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>VerifyIntegerConstantExpression</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>nullptr</name></expr></argument>, <argument><expr><name>CanFold</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function_decl><type><name>ExprResult</name></type> <name>VerifyBitField</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>FieldLoc</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>FieldName</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>FieldTy</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsMsStruct</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>BitWidth</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>ZeroWidth</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>unsigned</name></type> <name>ForceCUDAHostDeviceDepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>



<function_decl><type><name>void</name></type> <name>PushForceCUDAHostDevice</name><parameter_list>()</parameter_list>;</function_decl>




<function_decl><type><name>bool</name></type> <name>PopForceCUDAHostDevice</name><parameter_list>()</parameter_list>;</function_decl>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name><name>CanonicalDeclPtr</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>std</name><operator>::</operator><name><name>vector</name><argument_list type="generic">&lt;<argument><expr><name>PartialDiagnosticAt</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>DeviceDeferredDiags</name></expr>;</expr_stmt>



<struct>struct <name>FunctionDeclAndLoc</name> <block>{
<decl_stmt><decl><type><name><name>CanonicalDeclPtr</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name></type> <name>FD</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl>;</decl_stmt>
}</block>;</struct>




<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseSet</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDeclAndLoc</name></expr></argument>&gt;</argument_list></name> <name>LocsWithCUDACallDiags</name></expr>;</expr_stmt>






<expr_stmt><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt; <argument><expr><name><name>CanonicalDeclPtr</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>,
<argument><expr><name>FunctionDeclAndLoc</name></expr></argument>&gt;</argument_list></name>
<name>DeviceKnownEmittedFns</name></expr>;</expr_stmt>


















<function_decl><type><name>SemaDiagnosticBuilder</name></type> <name>CUDADiagIfDeviceCode</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>





<function_decl><type><name>SemaDiagnosticBuilder</name></type> <name>CUDADiagIfHostCode</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>
















<function_decl><type><name>SemaDiagnosticBuilder</name></type>
<name>diagIfOpenMPDeviceCode</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>














<function_decl><type><name>SemaDiagnosticBuilder</name></type> <name>diagIfOpenMPHostCode</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>SemaDiagnosticBuilder</name></type> <name>targetDiag</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function><type><name>SemaDiagnosticBuilder</name></type> <name>targetDiag</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>PartialDiagnostic</name> <modifier>&amp;</modifier></type><name>PD</name></decl></parameter>,
<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>targetDiag</name><argument_list>(<argument><expr><name>Loc</name></expr></argument>, <argument><expr><call><name><name>PD</name><operator>.</operator><name>getDiagID</name></name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>FD</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <name>PD</name></expr>;</return>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>checkDeviceDecl</name><parameter_list>(<parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>CUDAFunctionTarget</name> <block>{
<decl><name>CFT_Device</name></decl>,
<decl><name>CFT_Global</name></decl>,
<decl><name>CFT_Host</name></decl>,
<decl><name>CFT_HostDevice</name></decl>,
<decl><name>CFT_InvalidTarget</name></decl>
}</block>;</enum>






<function_decl><type><name>CUDAFunctionTarget</name></type> <name>IdentifyCUDATarget</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IgnoreImplicitHDAttr</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>CUDAFunctionTarget</name></type> <name>IdentifyCUDATarget</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParsedAttributesView</name> <modifier>&amp;</modifier></type><name>Attrs</name></decl></parameter>)</parameter_list>;</function_decl>

<enum>enum <name>CUDAVariableTarget</name> <block>{
<decl><name>CVT_Device</name></decl>,
<decl><name>CVT_Host</name></decl>,
<decl><name>CVT_Both</name></decl>,
<decl><name>CVT_Unified</name></decl>,
}</block>;</enum>

<function_decl><type><name>CUDAVariableTarget</name></type> <name>IdentifyCUDATarget</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VarDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>CUDAFunctionTarget</name></type> <name>CurrentCUDATarget</name><parameter_list>()</parameter_list> <block>{<block_content>
<return>return <expr><call><name>IdentifyCUDATarget</name><argument_list>(<argument><expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>CurContext</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isCUDAImplicitHostDeviceFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<enum>enum <name>CUDAFunctionPreference</name> <block>{
<decl><name>CFP_Never</name></decl>,
<decl><name>CFP_WrongSide</name></decl>,


<decl><name>CFP_HostDevice</name></decl>,
<decl><name>CFP_SameSide</name></decl>,

<decl><name>CFP_Native</name></decl>,
}</block>;</enum>








<function_decl><type><name>CUDAFunctionPreference</name></type> <name>IdentifyCUDAPreference</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Caller</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Callee</name></decl></parameter>)</parameter_list>;</function_decl>






<function><type><name>bool</name></type> <name>IsAllowedCUDACall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Caller</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Callee</name></decl></parameter>)</parameter_list> <block>{<block_content>
<return>return <expr><call><name>IdentifyCUDAPreference</name><argument_list>(<argument><expr><name>Caller</name></expr></argument>, <argument><expr><name>Callee</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CFP_Never</name></expr>;</return>
</block_content>}</block></function>



<function_decl><type><name>void</name></type> <name>maybeAddCUDAHostDeviceAttrs</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>MaybeAddCUDAConstantAttr</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>














<function_decl><type><name>bool</name></type> <name>CheckCUDACall</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Callee</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>void</name></type> <name>CUDACheckLambdaCapture</name><argument_list>(<argument><expr><name>CXXMethodDecl</name> <operator>*</operator><name>D</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>sema</name><operator>::</operator><name>Capture</name> <operator>&amp;</operator><name>Capture</name></expr></argument>)</argument_list></decl>;</decl_stmt>






<function_decl><type><name>void</name></type> <name>CUDASetLambdaAttrs</name><parameter_list>(<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>)</parameter_list>;</function_decl>




<function_decl><type><name>void</name></type> <name>EraseUnwantedCUDAMatches</name><parameter_list>(
<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Caller</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><name>DeclAccessPair</name></expr></argument>, <argument><expr><name>FunctionDecl</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Matches</name></decl></parameter>)</parameter_list>;</function_decl>












<function_decl><type><name>bool</name></type> <name>inferCUDATargetForImplicitSpecialMember</name><parameter_list>(<parameter><decl><type><name>CXXRecordDecl</name> <modifier>*</modifier></type><name>ClassDecl</name></decl></parameter>,
<parameter><decl><type><name>CXXSpecialMember</name></type> <name>CSM</name></decl></parameter>,
<parameter><decl><type><name>CXXMethodDecl</name> <modifier>*</modifier></type><name>MemberDecl</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>ConstRHS</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>Diagnose</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>bool</name></type> <name>isEmptyCudaConstructor</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>CXXConstructorDecl</name> <modifier>*</modifier></type><name>CD</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>isEmptyCudaDestructor</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>CXXDestructorDecl</name> <modifier>*</modifier></type><name>CD</name></decl></parameter>)</parameter_list>;</function_decl>









<function_decl><type><name>void</name></type> <name>checkAllowedCUDAInitializer</name><parameter_list>(<parameter><decl><type><name>VarDecl</name> <modifier>*</modifier></type><name>VD</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>checkCUDATargetOverload</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>NewFD</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>LookupResult</name> <modifier>&amp;</modifier></type><name>Previous</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>inheritCUDATargetAttrs</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionTemplateDecl</name> <modifier>&amp;</modifier></type><name>TD</name></decl></parameter>)</parameter_list>;</function_decl>




<expr_stmt><expr><name>std</name><operator>::</operator><name>string</name> <macro><name>getCudaConfigureFuncName</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>




<enum>enum <name>ParserCompletionContext</name> <block>{

<decl><name>PCC_Namespace</name></decl>,

<decl><name>PCC_Class</name></decl>,


<decl><name>PCC_ObjCInterface</name></decl>,


<decl><name>PCC_ObjCImplementation</name></decl>,


<decl><name>PCC_ObjCInstanceVariableList</name></decl>,


<decl><name>PCC_Template</name></decl>,


<decl><name>PCC_MemberTemplate</name></decl>,

<decl><name>PCC_Expression</name></decl>,


<decl><name>PCC_Statement</name></decl>,


<decl><name>PCC_ForInit</name></decl>,


<decl><name>PCC_Condition</name></decl>,



<decl><name>PCC_RecoveryInFunction</name></decl>,

<decl><name>PCC_Type</name></decl>,


<decl><name>PCC_ParenthesizedExpression</name></decl>,


<decl><name>PCC_LocalDeclarationSpecifiers</name></decl>
}</block>;</enum>

<function_decl><type><name>void</name></type> <name>CodeCompleteModuleImport</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>ImportLoc</name></decl></parameter>, <parameter><decl><type><name>ModuleIdPath</name></type> <name>Path</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteOrdinaryName</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>ParserCompletionContext</name></type> <name>CompletionContext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteDeclSpec</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowNonIdentifiers</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowNestedNameSpecifiers</name></decl></parameter>)</parameter_list>;</function_decl>

<struct_decl>struct <name>CodeCompleteExpressionData</name>;</struct_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteExpression</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CodeCompleteExpressionData</name> <modifier>&amp;</modifier></type><name>Data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteExpression</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>PreferredType</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsParenthesized</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteMemberReferenceExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Base</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>OtherOpBase</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpLoc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsArrow</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsBaseExprStatement</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>PreferredType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompletePostfixExpression</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>ExprResult</name></type> <name>LHS</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>PreferredType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteTag</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>TagSpec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteTypeQualifiers</name><parameter_list>(<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteFunctionQualifiers</name><parameter_list>(<parameter><decl><type><name>DeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>, <parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>VirtSpecifiers</name> <modifier>*</modifier></type><name>VS</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteBracketDeclarator</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteCase</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>








<function_decl><type><name>QualType</name></type> <name>ProduceCallSignatureHelp</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Fn</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpenParLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>ProduceConstructorSignatureHelp</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpenParLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>QualType</name></type> <name>ProduceCtorInitMemberSignatureHelp</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>ConstructorDecl</name></decl></parameter>,
<parameter><decl><type><name>CXXScopeSpec</name></type> <name>SS</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>TemplateTypeTy</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>ArgExprs</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>II</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>OpenParLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteInitializer</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>



<decl_stmt><decl><type><name>void</name></type> <name>CodeCompleteDesignator</name><argument_list>(<argument><expr><specifier>const</specifier> <name>QualType</name> <name>BaseType</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>InitExprs</name></expr></argument>,
<argument><expr><specifier>const</specifier> <name>Designation</name> <operator>&amp;</operator><name>D</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>CodeCompleteAfterIf</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsBracedThen</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CodeCompleteQualifiedId</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>CXXScopeSpec</name> <modifier>&amp;</modifier></type><name>SS</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>EnteringContext</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsUsingDeclaration</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>BaseType</name></decl></parameter>,
<parameter><decl><type><name>QualType</name></type> <name>PreferredType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteUsing</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteUsingDirective</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteNamespaceDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteNamespaceAliasDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteOperatorName</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteConstructorInitializer</name><parameter_list>(
<parameter><decl><type><name>Decl</name> <modifier>*</modifier></type><name>Constructor</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>CXXCtorInitializer</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Initializers</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CodeCompleteLambdaIntroducer</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>LambdaIntroducer</name> <modifier>&amp;</modifier></type><name>Intro</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AfterAmpersand</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteAfterFunctionEquals</name><parameter_list>(<parameter><decl><type><name>Declarator</name> <modifier>&amp;</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CodeCompleteObjCAtDirective</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCAtVisibility</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCAtStatement</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCAtExpression</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCPropertyFlags</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>ObjCDeclSpec</name> <modifier>&amp;</modifier></type><name>ODS</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCPropertyGetter</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCPropertySetter</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCPassingType</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>ObjCDeclSpec</name> <modifier>&amp;</modifier></type><name>DS</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsParameter</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCMessageReceiver</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCSuperMessage</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>SuperLoc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>SelIdents</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AtArgumentExpression</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCClassMessage</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>ParsedType</name></type> <name>Receiver</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>SelIdents</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AtArgumentExpression</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsSuper</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCInstanceMessage</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Receiver</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>SelIdents</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AtArgumentExpression</name></decl></parameter>,
<parameter><decl><type><name>ObjCInterfaceDecl</name> <modifier>*</modifier></type><name>Super</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCForCollection</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>DeclGroupPtrTy</name></type> <name>IterationVar</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCSelector</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>SelIdents</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCProtocolReferences</name><parameter_list>(
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierLocPair</name></expr></argument>&gt;</argument_list></name></type> <name>Protocols</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCProtocolDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCInterfaceDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCSuperclass</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ClassName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ClassNameLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCImplementationDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCInterfaceCategory</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ClassName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ClassNameLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCImplementationCategory</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>ClassName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ClassNameLoc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCPropertyDefinition</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCPropertySynthesizeIvar</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>PropertyName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCMethodDecl</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name><name>Optional</name><argument_list type="generic">&lt;<argument><expr><name>bool</name></expr></argument>&gt;</argument_list></name></type> <name>IsInstanceMethod</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ReturnType</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCMethodDeclSelector</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsInstanceMethod</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AtParameterName</name></decl></parameter>,
<parameter><decl><type><name>ParsedType</name></type> <name>ReturnType</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>IdentifierInfo</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>SelIdents</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteObjCClassPropertyRefExpr</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>, <parameter><decl><type><name>IdentifierInfo</name> <modifier>&amp;</modifier></type><name>ClassName</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ClassNameLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsBaseExprStatement</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompletePreprocessorDirective</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>InConditional</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteInPreprocessorConditionalExclusion</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompletePreprocessorMacroName</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>IsDefinition</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompletePreprocessorExpression</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompletePreprocessorMacroArgument</name><parameter_list>(<parameter><decl><type><name>Scope</name> <modifier>*</modifier></type><name>S</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Macro</name></decl></parameter>,
<parameter><decl><type><name>MacroInfo</name> <modifier>*</modifier></type><name>MacroInfo</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Argument</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>void</name></type> <name>CodeCompleteIncludedFile</name><argument_list>(<argument><expr><name>llvm</name><operator>::</operator><name>StringRef</name> <name>Dir</name></expr></argument>, <argument><expr><name>bool</name> <name>IsAngled</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> <name>CodeCompleteNaturalLanguage</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CodeCompleteAvailabilityPlatformName</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>GatherGlobalCodeCompletions</name><parameter_list>(<parameter><decl><type><name>CodeCompletionAllocator</name> <modifier>&amp;</modifier></type><name>Allocator</name></decl></parameter>,
<parameter><decl><type><name>CodeCompletionTUInfo</name> <modifier>&amp;</modifier></type><name>CCTUInfo</name></decl></parameter>,
<parameter><decl><type><name><name>SmallVectorImpl</name><argument_list type="generic">&lt;<argument><expr><name>CodeCompletionResult</name></expr></argument>&gt;</argument_list></name> <modifier>&amp;</modifier></type><name>Results</name></decl></parameter>)</parameter_list>;</function_decl>





<label><name>public</name>:</label>
<decl_stmt><decl><type><name>SourceLocation</name></type> <name>getLocationOfStringLiteralByte</name><argument_list>(<argument><expr><specifier>const</specifier> <name>StringLiteral</name> <operator>*</operator><name>SL</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>ByteNo</name></expr></argument>)</argument_list> const</decl>;</decl_stmt>

<label><name>private</name>:</label>
<function_decl><type><name>void</name></type> <name>CheckArrayAccess</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>BaseExpr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>IndexExpr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>ArraySubscriptExpr</name> <modifier>*</modifier></type><name>ASE</name><init>=<expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowOnePastEnd</name><init>=<expr><name>true</name></expr></init></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IndexNegated</name><init>=<expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckArrayAccess</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>


<struct>struct <name>FormatStringInfo</name> <block>{
<decl_stmt><decl><type><name>unsigned</name></type> <name>FormatIdx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>FirstDataArg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>HasVAListArg</name></decl>;</decl_stmt>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>getFormatStringInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FormatAttr</name> <modifier>*</modifier></type><name>Format</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>IsCXXMember</name></decl></parameter>,
<parameter><decl><type><name>FormatStringInfo</name> <modifier>*</modifier></type><name>FSI</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckFunctionCall</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FDecl</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Proto</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckObjCMethodCall</name><parameter_list>(<parameter><decl><type><name>ObjCMethodDecl</name> <modifier>*</modifier></type><name>Method</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>loc</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckPointerCall</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>NDecl</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Proto</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckOtherCall</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Proto</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckConstructorCall</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FDecl</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ThisType</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Proto</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckArgAlignment</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FDecl</name></decl></parameter>,
<parameter><decl><type><name>StringRef</name></type> <name>ParamName</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ArgTy</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>ParamTy</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>checkCall</name><parameter_list>(<parameter><decl><type><name>NamedDecl</name> <modifier>*</modifier></type><name>FDecl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionProtoType</name> <modifier>*</modifier></type><name>Proto</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>ThisArg</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>Args</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsMemberFunction</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>SourceRange</name></type> <name>Range</name></decl></parameter>,
<parameter><decl><type><name>VariadicCallType</name></type> <name>CallType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckObjCString</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>CheckOSLogFormatStringArg</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>ExprResult</name></type> <name>CheckBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FDecl</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckTSBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>,
<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>checkFortifiedBuiltinMemoryFunction</name><parameter_list>(<parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckARMBuiltinExclusiveCall</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>MaxWidth</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckNeonBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>,
<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckMVEBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckSVEBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckCDEBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>,
<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckARMCoprocessorImmediate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>CoprocArg</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>WantCDE</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckARMBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>,
<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckAArch64BuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>,
<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckBPFBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckHexagonBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckHexagonBuiltinArgument</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckMipsBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>,
<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckMipsBuiltinCpu</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>,
<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckMipsBuiltinArgument</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckSystemZBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckX86BuiltinRoundingOrSAE</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckX86BuiltinGatherScatterScale</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckX86BuiltinTileArguments</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckX86BuiltinTileArgumentsRange</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>ArgNums</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckX86BuiltinTileDuplicate</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>, <parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>ArgNums</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckX86BuiltinTileRangeAndDuplicate</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>,
<parameter><decl><type><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><name>int</name></expr></argument>&gt;</argument_list></name></type> <name>ArgNums</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckX86BuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>,
<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckPPCBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>,
<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckAMDGCNBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckRISCVLMUL</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ArgNum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>CheckRISCVBuiltinFunctionCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetInfo</name> <modifier>&amp;</modifier></type><name>TI</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>,
<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>SemaBuiltinVAStart</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinVAStartARMMicrosoft</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>Call</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinUnorderedCompare</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinFPClassification</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>NumArgs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinComplex</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinVSX</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinOSLogFormat</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaValueIsRunOfOnes</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ArgNum</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>

<function_decl><type><name>ExprResult</name></type> <name>SemaBuiltinShuffleVector</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>SemaConvertVectorExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>TypeSourceInfo</name> <modifier>*</modifier></type><name>TInfo</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>BuiltinLoc</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>RParenLoc</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinPrefetch</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinAllocaWithAlign</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinArithmeticFence</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinAssume</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinAssumeAligned</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinLongjmp</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinSetjmp</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>SemaBuiltinAtomicOverloaded</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>TheCallResult</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>SemaBuiltinNontemporalOverloaded</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>TheCallResult</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>ExprResult</name></type> <name>SemaAtomicOpsOverloaded</name><argument_list>(<argument><expr><name>ExprResult</name> <name>TheCallResult</name></expr></argument>,
<argument><expr><name>AtomicExpr</name><operator>::</operator><name>AtomicOp</name> <name>Op</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>ExprResult</name></type> <name>SemaBuiltinOperatorNewDeleteOverloaded</name><parameter_list>(<parameter><decl><type><name>ExprResult</name></type> <name>TheCallResult</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsDelete</name></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>bool</name></type> <name>SemaBuiltinConstantArg</name><argument_list>(<argument><expr><name>CallExpr</name> <operator>*</operator><name>TheCall</name></expr></argument>, <argument><expr><name>int</name> <name>ArgNum</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>APSInt</name> <operator>&amp;</operator><name>Result</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinConstantArgRange</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ArgNum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>Low</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>High</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>RangeIsError</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinConstantArgMultiple</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ArgNum</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>Multiple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinConstantArgPower2</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ArgNum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinConstantArgShiftedByte</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ArgNum</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>ArgBits</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinConstantArgShiftedByteOrXXFF</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ArgNum</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>ArgBits</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinARMSpecialReg</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>ArgNum</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>ExpectedFieldNum</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>AllowName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinARMMemoryTaggingCall</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>BuiltinID</name></decl></parameter>, <parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>SemaBuiltinPPCMMACall</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>TypeDesc</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>CheckPPCMMAType</name><parameter_list>(<parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>TypeLoc</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>ExprResult</name></type> <name>SemaBuiltinMatrixTranspose</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name></type> <name>CallResult</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>SemaBuiltinMatrixColumnMajorLoad</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name></type> <name>CallResult</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>ExprResult</name></type> <name>SemaBuiltinMatrixColumnMajorStore</name><parameter_list>(<parameter><decl><type><name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>,
<parameter><decl><type><name>ExprResult</name></type> <name>CallResult</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<enum>enum <name>FormatStringType</name> <block>{
<decl><name>FST_Scanf</name></decl>,
<decl><name>FST_Printf</name></decl>,
<decl><name>FST_NSString</name></decl>,
<decl><name>FST_Strftime</name></decl>,
<decl><name>FST_Strfmon</name></decl>,
<decl><name>FST_Kprintf</name></decl>,
<decl><name>FST_FreeBSDKPrintf</name></decl>,
<decl><name>FST_OSTrace</name></decl>,
<decl><name>FST_OSLog</name></decl>,
<decl><name>FST_Unknown</name></decl>
}</block>;</enum>
<function_decl><type><specifier>static</specifier> <name>FormatStringType</name></type> <name>GetFormatStringType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FormatAttr</name> <modifier>*</modifier></type><name>Format</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>bool</name></type> <name>FormatStringHasSArg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>StringLiteral</name> <modifier>*</modifier></type><name>FExpr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>GetFormatNSStringIdx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FormatAttr</name> <modifier>*</modifier></type><name>Format</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>&amp;</modifier></type><name>Idx</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>bool</name></type> <name>CheckFormatArguments</name><argument_list>(<argument><expr><specifier>const</specifier> <name>FormatAttr</name> <operator>*</operator><name>Format</name></expr></argument>,
<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>bool</name> <name>IsCXXMember</name></expr></argument>,
<argument><expr><name>VariadicCallType</name> <name>CallType</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>SourceRange</name> <name>Range</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>SmallBitVector</name> <operator>&amp;</operator><name>CheckedVarArgs</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>CheckFormatArguments</name><argument_list>(<argument><expr><name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <operator>*</operator></expr></argument>&gt;</argument_list></name> <name>Args</name></expr></argument>,
<argument><expr><name>bool</name> <name>HasVAListArg</name></expr></argument>, <argument><expr><name>unsigned</name> <name>format_idx</name></expr></argument>,
<argument><expr><name>unsigned</name> <name>firstDataArg</name></expr></argument>, <argument><expr><name>FormatStringType</name> <name>Type</name></expr></argument>,
<argument><expr><name>VariadicCallType</name> <name>CallType</name></expr></argument>,
<argument><expr><name>SourceLocation</name> <name>Loc</name></expr></argument>, <argument><expr><name>SourceRange</name> <name>range</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name>SmallBitVector</name> <operator>&amp;</operator><name>CheckedVarArgs</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><name>void</name></type> <name>CheckAbsoluteValueFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>Call</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckMaxUnsignedZero</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>Call</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FDecl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckMemaccessArguments</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>Call</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>BId</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>FnName</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckStrlcpycatArguments</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>Call</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>FnName</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckStrncatArguments</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>Call</name></decl></parameter>,
<parameter><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>FnName</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckFreeArguments</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckReturnValExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RetValExp</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>lhsType</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>ReturnLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>isObjCMethod</name> <init>= <expr><name>false</name></expr></init></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>AttrVec</name> <modifier>*</modifier></type><name>Attrs</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>FD</name> <init>= <expr><name>nullptr</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>
<function_decl><type><name>void</name></type> <name>CheckFloatComparison</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>LHS</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>RHS</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>private</name>:</label>
<function_decl><type><name>void</name></type> <name>CheckImplicitConversions</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>CC</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckBoolLikeConversion</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>CC</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckForIntOverflow</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>CheckUnsequencedOperations</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>CheckCompletedExpr</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>CheckLoc</name> <init>= <expr><call><name>SourceLocation</name><argument_list>()</argument_list></call></expr></init></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>IsConstexpr</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckBitFieldInitialization</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>InitLoc</name></decl></parameter>, <parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Field</name></decl></parameter>,
<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>Init</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>void</name></type> <name>CheckShadowInheritedFields</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SourceLocation</name> <modifier>&amp;</modifier></type><name>Loc</name></decl></parameter>,
<parameter><decl><type><name>DeclarationName</name></type> <name>FieldName</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name>CXXRecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DeclIsField</name> <init>= <expr><name>true</name></expr></init></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>CheckBreakContinueBinding</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>CheckObjCCircularContainer</name><parameter_list>(<parameter><decl><type><name>ObjCMessageExpr</name> <modifier>*</modifier></type><name>Message</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>CheckTCBEnforcement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallExpr</name> <modifier>*</modifier></type><name>TheCall</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionDecl</name> <modifier>*</modifier></type><name>Callee</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>AnalyzeDeleteExprMismatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CXXDeleteExpr</name> <modifier>*</modifier></type><name>DE</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>AnalyzeDeleteExprMismatch</name><parameter_list>(<parameter><decl><type><name>FieldDecl</name> <modifier>*</modifier></type><name>Field</name></decl></parameter>, <parameter><decl><type><name>SourceLocation</name></type> <name>DeleteLoc</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>DeleteWasArrayForm</name></decl></parameter>)</parameter_list>;</function_decl>
<label><name>public</name>:</label>

<function_decl><type><name>void</name></type> <name>RegisterTypeTagForDatatype</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>ArgumentKind</name></decl></parameter>,
<parameter><decl><type><name>uint64_t</name></type> <name>MagicValue</name></decl></parameter>, <parameter><decl><type><name>QualType</name></type> <name>Type</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>LayoutCompatible</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>MustBeNull</name></decl></parameter>)</parameter_list>;</function_decl>

<struct>struct <name>TypeTagData</name> <block>{
<macro><name>TypeTagData</name><argument_list>()</argument_list></macro> <block>{<block_content/>}</block>

<macro><name>TypeTagData</name><argument_list>(<argument>QualType Type</argument>, <argument>bool LayoutCompatible</argument>, <argument>bool MustBeNull</argument>)</argument_list></macro> :
<expr_stmt><expr><call><name>Type</name><argument_list>(<argument><expr><name>Type</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>LayoutCompatible</name><argument_list>(<argument><expr><name>LayoutCompatible</name></expr></argument>)</argument_list></call></expr><operator>,</operator>
<macro><name>MustBeNull</name><argument_list>(<argument>MustBeNull</argument>)</argument_list></macro>
<expr><block>{}</block>

<name>QualType</name> <name>Type</name></expr>;</expr_stmt>



<decl_stmt><decl><type><name>unsigned</name></type> <name>LayoutCompatible</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>MustBeNull</name> <range>: <expr><literal type="number">1</literal></expr></range></decl>;</decl_stmt>
}</block>;</struct>



<typedef>typedef <expr_stmt><expr><name>std</name><operator>::</operator><name><name>pair</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>IdentifierInfo</name> <operator>*</operator></expr></argument>, <argument><expr><name>uint64_t</name></expr></argument>&gt;</argument_list></name> <name>TypeTagMagicValue</name></expr>;</expr_stmt></typedef>

<label><name>private</name>:</label>

<expr_stmt><expr><name>std</name><operator>::</operator><name><name>unique_ptr</name><argument_list type="generic">&lt;<argument><expr><name>llvm</name><operator>::</operator><name><name>DenseMap</name><argument_list type="generic">&lt;<argument><expr><name>TypeTagMagicValue</name></expr></argument>, <argument><expr><name>TypeTagData</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name>
<name>TypeTagForDatatypeMagicValues</name></expr>;</expr_stmt>



<function_decl><type><name>void</name></type> <name>CheckArgumentWithTypeTag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArgumentWithTypeTagAttr</name> <modifier>*</modifier></type><name>Attr</name></decl></parameter>,
<parameter><decl><type><specifier>const</specifier> <name><name>ArrayRef</name><argument_list type="generic">&lt;<argument><expr><specifier>const</specifier> <name>Expr</name> <modifier>*</modifier></expr></argument>&gt;</argument_list></name></type> <name>ExprArgs</name></decl></parameter>,
<parameter><decl><type><name>SourceLocation</name></type> <name>CallSiteLoc</name></decl></parameter>)</parameter_list>;</function_decl>



<function_decl><type><name>void</name></type> <name>CheckAddressOfPackedMember</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>Scope</name> <modifier>*</modifier></type><name>CurScope</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mutable</name> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident_super</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mutable</name> <name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident___float128</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__Nonnull</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__Nullable</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__Nullable_result</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident__Null_unspecified</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>Ident_NSError</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>





<expr_stmt><expr><name>sema</name><operator>::</operator><name>SemaPPCallbacks</name> <operator>*</operator><name>SemaPPCallbackHandler</name></expr>;</expr_stmt>

<label><name>protected</name>:</label>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>Parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>InitializationSequence</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTDeclReader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>friend</name> <name>class</name></type> <name>ASTWriter</name></decl>;</decl_stmt>

<label><name>public</name>:</label>

<function_decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>getNullabilityKeyword</name><parameter_list>(<parameter><decl><type><name>NullabilityKind</name></type> <name>nullability</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>CFError</name> <init>= <expr><name>nullptr</name></expr></init></decl>;</decl_stmt>
<function_decl><type><name>bool</name></type> <name>isCFError</name><parameter_list>(<parameter><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>D</name></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><name>IdentifierInfo</name> <modifier>*</modifier></type><name>getNSErrorIdent</name><parameter_list>()</parameter_list>;</function_decl>









<expr_stmt><expr><name>Scope</name> <operator>*</operator><macro><name>getCurScope</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{ <return>return <expr><name>CurScope</name></expr>;</return> }</block></expr></expr_stmt>

<expr_stmt><expr><name>void</name> <macro><name>incrementMSManglingNumber</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><call><name><name>CurScope</name><operator>-&gt;</operator><name>incrementMSManglingNumber</name></name><argument_list>()</argument_list></call></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><name>IdentifierInfo</name> <operator>*</operator><macro><name>getSuperIdentifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>
<expr_stmt><expr><name>IdentifierInfo</name> <operator>*</operator><macro><name>getFloat128Identifier</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>Decl</name> <operator>*</operator><macro><name>getObjCDeclContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier></expr>;</expr_stmt>

<expr_stmt><expr><name>DeclContext</name> <operator>*</operator><macro><name>getCurLexicalContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<return>return <expr><name>OriginalLexicalContext</name> <operator>?</operator> <name>OriginalLexicalContext</name> <operator>:</operator> <name>CurContext</name></expr>;</return>
}</block></expr></expr_stmt>

<expr_stmt><expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><macro><name>getCurObjCLexicalContext</name><argument_list>()</argument_list></macro> <specifier>const</specifier> <block>{
<expr><specifier>const</specifier> <name>DeclContext</name> <operator>*</operator><name>DC</name> <operator>=</operator> <call><name>getCurLexicalContext</name><argument_list>()</argument_list></call></expr>;

<if_stmt><if>if <condition>(<decl><type><specifier>const</specifier> <name>ObjCCategoryDecl</name> <modifier>*</modifier></type><name>CatD</name> <init>= <expr><call><name><name>dyn_cast</name><argument_list type="generic">&lt;<argument><expr><name>ObjCCategoryDecl</name></expr></argument>&gt;</argument_list></name><argument_list>(<argument><expr><name>DC</name></expr></argument>)</argument_list></call></expr></init></decl>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>DC</name> <operator>=</operator> <call><name><name>CatD</name><operator>-&gt;</operator><name>getClassInterface</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block></expr></expr_stmt>
<return>return <expr><name>DC</name></expr>;</return>
}






unsigned <macro><name>getTemplateDepth</name><argument_list>(<argument>Scope *S</argument>)</argument_list></macro> <decl_stmt><decl><type><specifier>const</specifier></type></decl>;</decl_stmt>



<function><type><specifier>static</specifier> <name>bool</name></type> <name>TooManyArguments</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>NumParams</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>NumArgs</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>PartialOverloading</name> <init>= <expr><name>false</name></expr></init></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>NumArgs</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>PartialOverloading</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NumArgs</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>NumParams</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>NumArgs</name> <operator>&gt;</operator> <name>NumParams</name></expr>;</return>
</block_content>}</block></function>



<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CXXRecordDecl</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>DelayedDllExportClasses</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>CXXMethodDecl</name><modifier>*</modifier></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>DelayedDllExportMemberFunctions</name></decl>;</decl_stmt>

<label><name>private</name>:</label>
<decl_stmt><decl><type><name>int</name></type> <name>ParsingClassDepth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>class</name></type> <name>SavePendingParsedClassStateRAII</name> <block>{<block_content>
<label><name>public</name>:</label>
<expr_stmt><expr><call><name>SavePendingParsedClassStateRAII</name><argument_list>(<argument><expr><name>Sema</name> <operator>&amp;</operator><name>S</name></expr></argument>)</argument_list></call> <operator>:</operator> <macro><name>S</name><argument_list>(<argument>S</argument>)</argument_list></macro> <block>{ <expr><call><name>swapSavedState</name><argument_list>()</argument_list></call></expr>; }</block>

<operator>~</operator><macro><name>SavePendingParsedClassStateRAII</name><argument_list>()</argument_list></macro> <block>{
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>DelayedOverridingExceptionSpecChecks</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"there shouldn't be any pending delayed exception spec checks"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>assert</name><argument_list>(<argument><expr><call><name><name>S</name><operator>.</operator><name>DelayedEquivalentExceptionSpecChecks</name><operator>.</operator><name>empty</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<literal type="string">"there shouldn't be any pending delayed exception spec checks"</literal></expr></argument>)</argument_list></call></expr>;
<expr><call><name>swapSavedState</name><argument_list>()</argument_list></call></expr>;
}</block>

<name>private</name><operator>:</operator>
<name>Sema</name> <operator>&amp;</operator><name>S</name></expr>;</expr_stmt>
<macro><name>decltype</name><argument_list>(<argument>DelayedOverridingExceptionSpecChecks</argument>)</argument_list></macro>
<expr_stmt><expr><name>SavedOverridingExceptionSpecChecks</name></expr>;</expr_stmt>
<macro><name>decltype</name><argument_list>(<argument>DelayedEquivalentExceptionSpecChecks</argument>)</argument_list></macro>
<expr_stmt><expr><name>SavedEquivalentExceptionSpecChecks</name></expr>;</expr_stmt>

<function><type><name>void</name></type> <name>swapSavedState</name><parameter_list>()</parameter_list> <block>{<block_content>
<expr_stmt><expr><call><name><name>SavedOverridingExceptionSpecChecks</name><operator>.</operator><name>swap</name></name><argument_list>(
<argument><expr><name><name>S</name><operator>.</operator><name>DelayedOverridingExceptionSpecChecks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>SavedEquivalentExceptionSpecChecks</name><operator>.</operator><name>swap</name></name><argument_list>(
<argument><expr><name><name>S</name><operator>.</operator><name>DelayedEquivalentExceptionSpecChecks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>



<struct>struct <name>MisalignedMember</name> <block>{
<decl_stmt><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>MD</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CharUnits</name></type> <name>Alignment</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MisalignedMember</name><argument_list>()</argument_list></call> <operator>:</operator> <call><name>E</name><argument_list>()</argument_list></call></expr><operator>,</operator> <expr><call><name>RD</name><argument_list>()</argument_list></call></expr><operator>,</operator> <expr><call><name>MD</name><argument_list>()</argument_list></call></expr><operator>,</operator> <macro><name>Alignment</name><argument_list>()</argument_list></macro> <expr><block>{}</block>
<macro><name>MisalignedMember</name><argument_list>(<argument>Expr *E</argument>, <argument>RecordDecl *RD</argument>, <argument>ValueDecl *MD</argument>,
<argument>CharUnits Alignment</argument>)</argument_list></macro>
<operator>:</operator> <call><name>E</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>RD</name><argument_list>(<argument><expr><name>RD</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <expr><call><name>MD</name><argument_list>(<argument><expr><name>MD</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Alignment</name><argument_list>(<argument>Alignment</argument>)</argument_list></macro> <expr><block>{}</block>
<name>explicit</name> <call><name>MisalignedMember</name><argument_list>(<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>)</argument_list></call>
<operator>:</operator> <macro><name>MisalignedMember</name><argument_list>(<argument>E</argument>, <argument>nullptr</argument>, <argument>nullptr</argument>, <argument>CharUnits()</argument>)</argument_list></macro> <block>{}</block>

<name>bool</name> <name>operator</name><operator>==</operator><operator>(</operator><specifier>const</specifier> <name>MisalignedMember</name> <operator>&amp;</operator><name>m</name><operator>)</operator> <block>{ <return>return <expr><name><name>this</name><operator>-&gt;</operator><name>E</name></name> <operator>==</operator> <name><name>m</name><operator>.</operator><name>E</name></name></expr>;</return> }</block></expr></expr_stmt>
}</block>;</struct>


<decl_stmt><decl><type><name><name>SmallVector</name><argument_list type="generic">&lt;<argument><expr><name>MisalignedMember</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>&gt;</argument_list></name></type> <name>MisalignedMembers</name></decl>;</decl_stmt>


<function_decl><type><name>void</name></type> <name>AddPotentialMisalignedMembers</name><parameter_list>(<parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>, <parameter><decl><type><name>RecordDecl</name> <modifier>*</modifier></type><name>RD</name></decl></parameter>, <parameter><decl><type><name>ValueDecl</name> <modifier>*</modifier></type><name>MD</name></decl></parameter>,
<parameter><decl><type><name>CharUnits</name></type> <name>Alignment</name></decl></parameter>)</parameter_list>;</function_decl>

<label><name>public</name>:</label>



<function_decl><type><name>void</name></type> <name>DiagnoseMisalignedMembers</name><parameter_list>()</parameter_list>;</function_decl>






<function_decl><type><name>void</name></type> <name>DiscardMisalignedMemberAddress</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Type</name> <modifier>*</modifier></type><name>T</name></decl></parameter>, <parameter><decl><type><name>Expr</name> <modifier>*</modifier></type><name>E</name></decl></parameter>)</parameter_list>;</function_decl>




<decl_stmt><decl><type><name>void</name></type> <name>RefersToMemberWithReducedAlignment</name><argument_list>(
<argument><expr><name>Expr</name> <operator>*</operator><name>E</name></expr></argument>,
<argument><expr><name>llvm</name><operator>::</operator><name><name>function_ref</name><argument_list type="generic">&lt;<argument><expr><name>void</name><operator>(</operator><name>Expr</name> <operator>*</operator>, <name>RecordDecl</name> <operator>*</operator>, <name>FieldDecl</name> <operator>*</operator>, <name>CharUnits</name><operator>)</operator></expr></argument>&gt;</argument_list></name>
<name>Action</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<decl_stmt><decl><type><name><name>enum</name> <name>class</name></name></type> <name>CallingConventionIgnoredReason</name> <block>{<block_content>
<expr_stmt><expr><name>ForThisTarget</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator>
<expr><name>VariadicFunction</name></expr><operator>,</operator>
<expr><name>ConstructorDestructor</name></expr><operator>,</operator>
<expr><name>BuiltinFunction</name></expr></expr_stmt>
</block_content>}</block></decl></decl_stmt><empty_stmt>;</empty_stmt>


















<function_decl><type><name>SemaDiagnosticBuilder</name></type> <name>SYCLDiagIfDeviceCode</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>,
<parameter><decl><type><name>unsigned</name></type> <name>DiagID</name></decl></parameter>)</parameter_list>;</function_decl>














<function_decl><type><name>bool</name></type> <name>checkSYCLDeviceFunction</name><parameter_list>(<parameter><decl><type><name>SourceLocation</name></type> <name>Loc</name></decl></parameter>, <parameter><decl><type><name>FunctionDecl</name> <modifier>*</modifier></type><name>Callee</name></decl></parameter>)</parameter_list>;</function_decl>
};


<decl_stmt><decl><type><name>class</name></type> <name>EnterExpressionEvaluationContext</name> <block>{<block_content>
<decl_stmt><decl><type><name>Sema</name> <modifier>&amp;</modifier></type><name>Actions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>Entered</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<label><name>public</name>:</label>
<macro><name>EnterExpressionEvaluationContext</name><argument_list>(
<argument>Sema &amp;Actions</argument>, <argument>Sema::ExpressionEvaluationContext NewContext</argument>,
<argument>Decl *LambdaContextDecl = nullptr</argument>,
<argument>Sema::ExpressionEvaluationContextRecord::ExpressionKind ExprContext =
Sema::ExpressionEvaluationContextRecord::EK_Other</argument>,
<argument>bool ShouldEnter = true</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Actions</name><argument_list>(<argument><expr><name>Actions</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Entered</name><argument_list>(<argument>ShouldEnter</argument>)</argument_list></macro> <expr><block>{
<if_stmt><if>if <condition>(<expr><name>Entered</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Actions</name><operator>.</operator><name>PushExpressionEvaluationContext</name></name><argument_list>(<argument><expr><name>NewContext</name></expr></argument>, <argument><expr><name>LambdaContextDecl</name></expr></argument>,
<argument><expr><name>ExprContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block></expr></expr_stmt>
<macro><name>EnterExpressionEvaluationContext</name><argument_list>(
<argument>Sema &amp;Actions</argument>, <argument>Sema::ExpressionEvaluationContext NewContext</argument>,
<argument>Sema::ReuseLambdaContextDecl_t</argument>,
<argument>Sema::ExpressionEvaluationContextRecord::ExpressionKind ExprContext =
Sema::ExpressionEvaluationContextRecord::EK_Other</argument>)</argument_list></macro>
: <macro><name>Actions</name><argument_list>(<argument>Actions</argument>)</argument_list></macro> <block>{<block_content>
<expr_stmt><expr><call><name><name>Actions</name><operator>.</operator><name>PushExpressionEvaluationContext</name></name><argument_list>(
<argument><expr><name>NewContext</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>ReuseLambdaContextDecl</name></expr></argument>, <argument><expr><name>ExprContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>

<enum>enum <name>InitListTag</name> <block>{ <decl><name>InitList</name></decl> }</block>;</enum>
<macro><name>EnterExpressionEvaluationContext</name><argument_list>(<argument>Sema &amp;Actions</argument>, <argument>InitListTag</argument>,
<argument>bool ShouldEnter = true</argument>)</argument_list></macro>
: <expr_stmt><expr><call><name>Actions</name><argument_list>(<argument><expr><name>Actions</name></expr></argument>)</argument_list></call></expr><operator>,</operator> <macro><name>Entered</name><argument_list>(<argument>false</argument>)</argument_list></macro> <expr><block>{




<if_stmt><if>if <condition>(<expr><name>ShouldEnter</name> <operator>&amp;&amp;</operator> <call><name><name>Actions</name><operator>.</operator><name>isUnevaluatedContext</name></name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
<call><name><name>Actions</name><operator>.</operator><name>getLangOpts</name></name><argument_list>()</argument_list></call><operator>.</operator><name>CPlusPlus11</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name><name>Actions</name><operator>.</operator><name>PushExpressionEvaluationContext</name></name><argument_list>(
<argument><expr><name>Sema</name><operator>::</operator><name>ExpressionEvaluationContext</name><operator>::</operator><name>UnevaluatedList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Entered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<expr_stmt/>}</block_content>
}

~EnterExpressionEvaluationContext(</block></if></if_stmt>) <block>{
<if_stmt><if>if <condition>(<expr><name>Entered</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>Actions</name><operator>.</operator><name>PopExpressionEvaluationContext</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
}</block>
}</block></expr></expr_stmt><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><name>DeductionFailureInfo</name></type>
<name>MakeDeductionFailureInfo</name><argument_list>(<argument><expr><name>ASTContext</name> <operator>&amp;</operator><name>Context</name></expr></argument>, <argument><expr><name>Sema</name><operator>::</operator><name>TemplateDeductionResult</name> <name>TDK</name></expr></argument>,
<argument><expr><name>sema</name><operator>::</operator><name>TemplateDeductionInfo</name> <operator>&amp;</operator><name>Info</name></expr></argument>)</argument_list></decl>;</decl_stmt>



<struct>struct <name>LateParsedTemplate</name> <block>{
<decl_stmt><decl><type><name>CachedTokens</name></type> <name>Toks</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Decl</name> <modifier>*</modifier></type><name>D</name></decl>;</decl_stmt>
}</block>;</struct>

<expr_stmt><expr><name><name>template</name> <argument_list type="generic">&lt;&gt;</argument_list></name>
<name>void</name> <name>Sema</name><operator>::</operator><name><name>PragmaStack</name><argument_list type="generic">&lt;<argument><expr><name>Sema</name><operator>::</operator><name>AlignPackInfo</name></expr></argument>&gt;</argument_list></name><operator>::</operator><macro><name>Act</name><argument_list>(<argument>SourceLocation PragmaLocation</argument>,
<argument>PragmaMsStackAction Action</argument>,
<argument>llvm::StringRef StackSlotLabel</argument>,
<argument>AlignPackInfo Value</argument>)</argument_list></macro></expr>;</expr_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>namespace</name></type> <name>llvm</name> <block>{<block_content>


<macro><name>template</name></macro> <expr_stmt><expr><operator>&lt;</operator><operator>&gt;</operator> struct <name><name>DenseMapInfo</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>Sema</name><operator>::</operator><name>FunctionDeclAndLoc</name></expr></argument>&gt;</argument_list></name> <block>{
<expr><name>using</name> <name>FunctionDeclAndLoc</name> <operator>=</operator> <name>clang</name><operator>::</operator><name>Sema</name><operator>::</operator><name>FunctionDeclAndLoc</name></expr>;
<expr><name>using</name> <name>FDBaseInfo</name> <operator>=</operator> <name><name>DenseMapInfo</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name><name>CanonicalDeclPtr</name><argument_list type="generic">&lt;<argument><expr><name>clang</name><operator>::</operator><name>FunctionDecl</name></expr></argument>&gt;</argument_list></name></expr></argument>&gt;</argument_list></name></expr>;

<expr><specifier>static</specifier> <name>FunctionDeclAndLoc</name> <macro><name>getEmptyKey</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><block>{<expr><name>FDBaseInfo</name><operator>::</operator><call><name>getEmptyKey</name><argument_list>()</argument_list></call></expr>, <expr><name>clang</name><operator>::</operator><macro><name>SourceLocation</name><argument_list>()</argument_list></macro></expr>}</block></expr>;</return>
}</block>

<specifier>static</specifier> <name>FunctionDeclAndLoc</name> <macro><name>getTombstoneKey</name><argument_list>()</argument_list></macro> <block>{
<return>return <expr><block>{<expr><name>FDBaseInfo</name><operator>::</operator><call><name>getTombstoneKey</name><argument_list>()</argument_list></call></expr>, <expr><name>clang</name><operator>::</operator><macro><name>SourceLocation</name><argument_list>()</argument_list></macro></expr>}</block></expr>;</return>
}</block>

<specifier>static</specifier> <name>unsigned</name> <macro><name>getHashValue</name><argument_list>(<argument>const FunctionDeclAndLoc &amp;FDL</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>hash_combine</name><argument_list>(<argument><expr><name>FDBaseInfo</name><operator>::</operator><call><name>getHashValue</name><argument_list>(<argument><expr><name><name>FDL</name><operator>.</operator><name>FD</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name><name>FDL</name><operator>.</operator><name>Loc</name><operator>.</operator><name>getHashValue</name></name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<specifier>static</specifier> <name>bool</name> <macro><name>isEqual</name><argument_list>(<argument>const FunctionDeclAndLoc &amp;LHS</argument>,
<argument>const FunctionDeclAndLoc &amp;RHS</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>LHS</name><operator>.</operator><name>FD</name></name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>FD</name></name> <operator>&amp;&amp;</operator> <name><name>LHS</name><operator>.</operator><name>Loc</name></name> <operator>==</operator> <name><name>RHS</name><operator>.</operator><name>Loc</name></name></expr>;</return>
}</block>
}</expr>;
}</block></expr></expr_stmt></block_content></block></decl></decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
